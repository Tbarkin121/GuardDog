
LegDay.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000ece0  080001e0  080001e0  000101e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000b774  0800eec0  0800eec0  0001eec0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801a634  0801a634  0003150c  2**0
                  CONTENTS
  4 .ARM          00000008  0801a634  0801a634  0002a634  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801a63c  0801a63c  0003150c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801a63c  0801a63c  0002a63c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801a640  0801a640  0002a640  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000150c  20000000  0801a644  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001cd8  20001520  0801bb50  00031520  2**5
                  ALLOC
 10 ._user_heap_stack 00001000  200031f8  0801bb50  000331f8  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0003150c  2**0
                  CONTENTS, READONLY
 12 .comment      00000093  00000000  00000000  0003153c  2**0
                  CONTENTS, READONLY
 13 .debug_line   000510c9  00000000  00000000  000315cf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 00000071  00000000  00000000  00082698  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   0004e4ab  00000000  00000000  00082709  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000a3a0  00000000  00000000  000d0bb4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00002040  00000000  00000000  000daf58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0014a147  00000000  00000000  000dcf98  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000036be  00000000  00000000  002270df  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 0001da9e  00000000  00000000  0022a79d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  000398a5  00000000  00000000  0024823b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_frame  0000674c  00000000  00000000  00281ae0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	; (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	; (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	; (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20001520 	.word	0x20001520
 80001fc:	00000000 	.word	0x00000000
 8000200:	0800eea8 	.word	0x0800eea8

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	; (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	; (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	; (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	20001524 	.word	0x20001524
 800021c:	0800eea8 	.word	0x0800eea8

08000220 <memchr>:
 8000220:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000224:	2a10      	cmp	r2, #16
 8000226:	db2b      	blt.n	8000280 <memchr+0x60>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	d008      	beq.n	8000240 <memchr+0x20>
 800022e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000232:	3a01      	subs	r2, #1
 8000234:	428b      	cmp	r3, r1
 8000236:	d02d      	beq.n	8000294 <memchr+0x74>
 8000238:	f010 0f07 	tst.w	r0, #7
 800023c:	b342      	cbz	r2, 8000290 <memchr+0x70>
 800023e:	d1f6      	bne.n	800022e <memchr+0xe>
 8000240:	b4f0      	push	{r4, r5, r6, r7}
 8000242:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000246:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800024a:	f022 0407 	bic.w	r4, r2, #7
 800024e:	f07f 0700 	mvns.w	r7, #0
 8000252:	2300      	movs	r3, #0
 8000254:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000258:	3c08      	subs	r4, #8
 800025a:	ea85 0501 	eor.w	r5, r5, r1
 800025e:	ea86 0601 	eor.w	r6, r6, r1
 8000262:	fa85 f547 	uadd8	r5, r5, r7
 8000266:	faa3 f587 	sel	r5, r3, r7
 800026a:	fa86 f647 	uadd8	r6, r6, r7
 800026e:	faa5 f687 	sel	r6, r5, r7
 8000272:	b98e      	cbnz	r6, 8000298 <memchr+0x78>
 8000274:	d1ee      	bne.n	8000254 <memchr+0x34>
 8000276:	bcf0      	pop	{r4, r5, r6, r7}
 8000278:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800027c:	f002 0207 	and.w	r2, r2, #7
 8000280:	b132      	cbz	r2, 8000290 <memchr+0x70>
 8000282:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000286:	3a01      	subs	r2, #1
 8000288:	ea83 0301 	eor.w	r3, r3, r1
 800028c:	b113      	cbz	r3, 8000294 <memchr+0x74>
 800028e:	d1f8      	bne.n	8000282 <memchr+0x62>
 8000290:	2000      	movs	r0, #0
 8000292:	4770      	bx	lr
 8000294:	3801      	subs	r0, #1
 8000296:	4770      	bx	lr
 8000298:	2d00      	cmp	r5, #0
 800029a:	bf06      	itte	eq
 800029c:	4635      	moveq	r5, r6
 800029e:	3803      	subeq	r0, #3
 80002a0:	3807      	subne	r0, #7
 80002a2:	f015 0f01 	tst.w	r5, #1
 80002a6:	d107      	bne.n	80002b8 <memchr+0x98>
 80002a8:	3001      	adds	r0, #1
 80002aa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002ae:	bf02      	ittt	eq
 80002b0:	3001      	addeq	r0, #1
 80002b2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002b6:	3001      	addeq	r0, #1
 80002b8:	bcf0      	pop	{r4, r5, r6, r7}
 80002ba:	3801      	subs	r0, #1
 80002bc:	4770      	bx	lr
 80002be:	bf00      	nop

080002c0 <__aeabi_drsub>:
 80002c0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002c4:	e002      	b.n	80002cc <__adddf3>
 80002c6:	bf00      	nop

080002c8 <__aeabi_dsub>:
 80002c8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002cc <__adddf3>:
 80002cc:	b530      	push	{r4, r5, lr}
 80002ce:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002d2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002d6:	ea94 0f05 	teq	r4, r5
 80002da:	bf08      	it	eq
 80002dc:	ea90 0f02 	teqeq	r0, r2
 80002e0:	bf1f      	itttt	ne
 80002e2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002e6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ea:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ee:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002f2:	f000 80e2 	beq.w	80004ba <__adddf3+0x1ee>
 80002f6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002fa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002fe:	bfb8      	it	lt
 8000300:	426d      	neglt	r5, r5
 8000302:	dd0c      	ble.n	800031e <__adddf3+0x52>
 8000304:	442c      	add	r4, r5
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	ea82 0000 	eor.w	r0, r2, r0
 8000312:	ea83 0101 	eor.w	r1, r3, r1
 8000316:	ea80 0202 	eor.w	r2, r0, r2
 800031a:	ea81 0303 	eor.w	r3, r1, r3
 800031e:	2d36      	cmp	r5, #54	; 0x36
 8000320:	bf88      	it	hi
 8000322:	bd30      	pophi	{r4, r5, pc}
 8000324:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000328:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800032c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000330:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000334:	d002      	beq.n	800033c <__adddf3+0x70>
 8000336:	4240      	negs	r0, r0
 8000338:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800033c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000340:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000344:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000348:	d002      	beq.n	8000350 <__adddf3+0x84>
 800034a:	4252      	negs	r2, r2
 800034c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000350:	ea94 0f05 	teq	r4, r5
 8000354:	f000 80a7 	beq.w	80004a6 <__adddf3+0x1da>
 8000358:	f1a4 0401 	sub.w	r4, r4, #1
 800035c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000360:	db0d      	blt.n	800037e <__adddf3+0xb2>
 8000362:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000366:	fa22 f205 	lsr.w	r2, r2, r5
 800036a:	1880      	adds	r0, r0, r2
 800036c:	f141 0100 	adc.w	r1, r1, #0
 8000370:	fa03 f20e 	lsl.w	r2, r3, lr
 8000374:	1880      	adds	r0, r0, r2
 8000376:	fa43 f305 	asr.w	r3, r3, r5
 800037a:	4159      	adcs	r1, r3
 800037c:	e00e      	b.n	800039c <__adddf3+0xd0>
 800037e:	f1a5 0520 	sub.w	r5, r5, #32
 8000382:	f10e 0e20 	add.w	lr, lr, #32
 8000386:	2a01      	cmp	r2, #1
 8000388:	fa03 fc0e 	lsl.w	ip, r3, lr
 800038c:	bf28      	it	cs
 800038e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000392:	fa43 f305 	asr.w	r3, r3, r5
 8000396:	18c0      	adds	r0, r0, r3
 8000398:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800039c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003a0:	d507      	bpl.n	80003b2 <__adddf3+0xe6>
 80003a2:	f04f 0e00 	mov.w	lr, #0
 80003a6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003aa:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003ae:	eb6e 0101 	sbc.w	r1, lr, r1
 80003b2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003b6:	d31b      	bcc.n	80003f0 <__adddf3+0x124>
 80003b8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003bc:	d30c      	bcc.n	80003d8 <__adddf3+0x10c>
 80003be:	0849      	lsrs	r1, r1, #1
 80003c0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003c4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003c8:	f104 0401 	add.w	r4, r4, #1
 80003cc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003d0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003d4:	f080 809a 	bcs.w	800050c <__adddf3+0x240>
 80003d8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003dc:	bf08      	it	eq
 80003de:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003e2:	f150 0000 	adcs.w	r0, r0, #0
 80003e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ea:	ea41 0105 	orr.w	r1, r1, r5
 80003ee:	bd30      	pop	{r4, r5, pc}
 80003f0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003f4:	4140      	adcs	r0, r0
 80003f6:	eb41 0101 	adc.w	r1, r1, r1
 80003fa:	3c01      	subs	r4, #1
 80003fc:	bf28      	it	cs
 80003fe:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000402:	d2e9      	bcs.n	80003d8 <__adddf3+0x10c>
 8000404:	f091 0f00 	teq	r1, #0
 8000408:	bf04      	itt	eq
 800040a:	4601      	moveq	r1, r0
 800040c:	2000      	moveq	r0, #0
 800040e:	fab1 f381 	clz	r3, r1
 8000412:	bf08      	it	eq
 8000414:	3320      	addeq	r3, #32
 8000416:	f1a3 030b 	sub.w	r3, r3, #11
 800041a:	f1b3 0220 	subs.w	r2, r3, #32
 800041e:	da0c      	bge.n	800043a <__adddf3+0x16e>
 8000420:	320c      	adds	r2, #12
 8000422:	dd08      	ble.n	8000436 <__adddf3+0x16a>
 8000424:	f102 0c14 	add.w	ip, r2, #20
 8000428:	f1c2 020c 	rsb	r2, r2, #12
 800042c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000430:	fa21 f102 	lsr.w	r1, r1, r2
 8000434:	e00c      	b.n	8000450 <__adddf3+0x184>
 8000436:	f102 0214 	add.w	r2, r2, #20
 800043a:	bfd8      	it	le
 800043c:	f1c2 0c20 	rsble	ip, r2, #32
 8000440:	fa01 f102 	lsl.w	r1, r1, r2
 8000444:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000448:	bfdc      	itt	le
 800044a:	ea41 010c 	orrle.w	r1, r1, ip
 800044e:	4090      	lslle	r0, r2
 8000450:	1ae4      	subs	r4, r4, r3
 8000452:	bfa2      	ittt	ge
 8000454:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000458:	4329      	orrge	r1, r5
 800045a:	bd30      	popge	{r4, r5, pc}
 800045c:	ea6f 0404 	mvn.w	r4, r4
 8000460:	3c1f      	subs	r4, #31
 8000462:	da1c      	bge.n	800049e <__adddf3+0x1d2>
 8000464:	340c      	adds	r4, #12
 8000466:	dc0e      	bgt.n	8000486 <__adddf3+0x1ba>
 8000468:	f104 0414 	add.w	r4, r4, #20
 800046c:	f1c4 0220 	rsb	r2, r4, #32
 8000470:	fa20 f004 	lsr.w	r0, r0, r4
 8000474:	fa01 f302 	lsl.w	r3, r1, r2
 8000478:	ea40 0003 	orr.w	r0, r0, r3
 800047c:	fa21 f304 	lsr.w	r3, r1, r4
 8000480:	ea45 0103 	orr.w	r1, r5, r3
 8000484:	bd30      	pop	{r4, r5, pc}
 8000486:	f1c4 040c 	rsb	r4, r4, #12
 800048a:	f1c4 0220 	rsb	r2, r4, #32
 800048e:	fa20 f002 	lsr.w	r0, r0, r2
 8000492:	fa01 f304 	lsl.w	r3, r1, r4
 8000496:	ea40 0003 	orr.w	r0, r0, r3
 800049a:	4629      	mov	r1, r5
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	fa21 f004 	lsr.w	r0, r1, r4
 80004a2:	4629      	mov	r1, r5
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	f094 0f00 	teq	r4, #0
 80004aa:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004ae:	bf06      	itte	eq
 80004b0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004b4:	3401      	addeq	r4, #1
 80004b6:	3d01      	subne	r5, #1
 80004b8:	e74e      	b.n	8000358 <__adddf3+0x8c>
 80004ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004be:	bf18      	it	ne
 80004c0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004c4:	d029      	beq.n	800051a <__adddf3+0x24e>
 80004c6:	ea94 0f05 	teq	r4, r5
 80004ca:	bf08      	it	eq
 80004cc:	ea90 0f02 	teqeq	r0, r2
 80004d0:	d005      	beq.n	80004de <__adddf3+0x212>
 80004d2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004d6:	bf04      	itt	eq
 80004d8:	4619      	moveq	r1, r3
 80004da:	4610      	moveq	r0, r2
 80004dc:	bd30      	pop	{r4, r5, pc}
 80004de:	ea91 0f03 	teq	r1, r3
 80004e2:	bf1e      	ittt	ne
 80004e4:	2100      	movne	r1, #0
 80004e6:	2000      	movne	r0, #0
 80004e8:	bd30      	popne	{r4, r5, pc}
 80004ea:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ee:	d105      	bne.n	80004fc <__adddf3+0x230>
 80004f0:	0040      	lsls	r0, r0, #1
 80004f2:	4149      	adcs	r1, r1
 80004f4:	bf28      	it	cs
 80004f6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004fa:	bd30      	pop	{r4, r5, pc}
 80004fc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000500:	bf3c      	itt	cc
 8000502:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000506:	bd30      	popcc	{r4, r5, pc}
 8000508:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800050c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000510:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000514:	f04f 0000 	mov.w	r0, #0
 8000518:	bd30      	pop	{r4, r5, pc}
 800051a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800051e:	bf1a      	itte	ne
 8000520:	4619      	movne	r1, r3
 8000522:	4610      	movne	r0, r2
 8000524:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000528:	bf1c      	itt	ne
 800052a:	460b      	movne	r3, r1
 800052c:	4602      	movne	r2, r0
 800052e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000532:	bf06      	itte	eq
 8000534:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000538:	ea91 0f03 	teqeq	r1, r3
 800053c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000540:	bd30      	pop	{r4, r5, pc}
 8000542:	bf00      	nop

08000544 <__aeabi_ui2d>:
 8000544:	f090 0f00 	teq	r0, #0
 8000548:	bf04      	itt	eq
 800054a:	2100      	moveq	r1, #0
 800054c:	4770      	bxeq	lr
 800054e:	b530      	push	{r4, r5, lr}
 8000550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000558:	f04f 0500 	mov.w	r5, #0
 800055c:	f04f 0100 	mov.w	r1, #0
 8000560:	e750      	b.n	8000404 <__adddf3+0x138>
 8000562:	bf00      	nop

08000564 <__aeabi_i2d>:
 8000564:	f090 0f00 	teq	r0, #0
 8000568:	bf04      	itt	eq
 800056a:	2100      	moveq	r1, #0
 800056c:	4770      	bxeq	lr
 800056e:	b530      	push	{r4, r5, lr}
 8000570:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000574:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000578:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800057c:	bf48      	it	mi
 800057e:	4240      	negmi	r0, r0
 8000580:	f04f 0100 	mov.w	r1, #0
 8000584:	e73e      	b.n	8000404 <__adddf3+0x138>
 8000586:	bf00      	nop

08000588 <__aeabi_f2d>:
 8000588:	0042      	lsls	r2, r0, #1
 800058a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800058e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000592:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000596:	bf1f      	itttt	ne
 8000598:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005a4:	4770      	bxne	lr
 80005a6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005aa:	bf08      	it	eq
 80005ac:	4770      	bxeq	lr
 80005ae:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005b2:	bf04      	itt	eq
 80005b4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005b8:	4770      	bxeq	lr
 80005ba:	b530      	push	{r4, r5, lr}
 80005bc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005c0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005c4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005c8:	e71c      	b.n	8000404 <__adddf3+0x138>
 80005ca:	bf00      	nop

080005cc <__aeabi_ul2d>:
 80005cc:	ea50 0201 	orrs.w	r2, r0, r1
 80005d0:	bf08      	it	eq
 80005d2:	4770      	bxeq	lr
 80005d4:	b530      	push	{r4, r5, lr}
 80005d6:	f04f 0500 	mov.w	r5, #0
 80005da:	e00a      	b.n	80005f2 <__aeabi_l2d+0x16>

080005dc <__aeabi_l2d>:
 80005dc:	ea50 0201 	orrs.w	r2, r0, r1
 80005e0:	bf08      	it	eq
 80005e2:	4770      	bxeq	lr
 80005e4:	b530      	push	{r4, r5, lr}
 80005e6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005ea:	d502      	bpl.n	80005f2 <__aeabi_l2d+0x16>
 80005ec:	4240      	negs	r0, r0
 80005ee:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005f2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005f6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005fa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005fe:	f43f aed8 	beq.w	80003b2 <__adddf3+0xe6>
 8000602:	f04f 0203 	mov.w	r2, #3
 8000606:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800060a:	bf18      	it	ne
 800060c:	3203      	addne	r2, #3
 800060e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000612:	bf18      	it	ne
 8000614:	3203      	addne	r2, #3
 8000616:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800061a:	f1c2 0320 	rsb	r3, r2, #32
 800061e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000622:	fa20 f002 	lsr.w	r0, r0, r2
 8000626:	fa01 fe03 	lsl.w	lr, r1, r3
 800062a:	ea40 000e 	orr.w	r0, r0, lr
 800062e:	fa21 f102 	lsr.w	r1, r1, r2
 8000632:	4414      	add	r4, r2
 8000634:	e6bd      	b.n	80003b2 <__adddf3+0xe6>
 8000636:	bf00      	nop

08000638 <__aeabi_dmul>:
 8000638:	b570      	push	{r4, r5, r6, lr}
 800063a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800063e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000642:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000646:	bf1d      	ittte	ne
 8000648:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800064c:	ea94 0f0c 	teqne	r4, ip
 8000650:	ea95 0f0c 	teqne	r5, ip
 8000654:	f000 f8de 	bleq	8000814 <__aeabi_dmul+0x1dc>
 8000658:	442c      	add	r4, r5
 800065a:	ea81 0603 	eor.w	r6, r1, r3
 800065e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000662:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000666:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800066a:	bf18      	it	ne
 800066c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000670:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000674:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000678:	d038      	beq.n	80006ec <__aeabi_dmul+0xb4>
 800067a:	fba0 ce02 	umull	ip, lr, r0, r2
 800067e:	f04f 0500 	mov.w	r5, #0
 8000682:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000686:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800068a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800068e:	f04f 0600 	mov.w	r6, #0
 8000692:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000696:	f09c 0f00 	teq	ip, #0
 800069a:	bf18      	it	ne
 800069c:	f04e 0e01 	orrne.w	lr, lr, #1
 80006a0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006a4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006a8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006ac:	d204      	bcs.n	80006b8 <__aeabi_dmul+0x80>
 80006ae:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006b2:	416d      	adcs	r5, r5
 80006b4:	eb46 0606 	adc.w	r6, r6, r6
 80006b8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006bc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006c0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006c4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006c8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006cc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006d0:	bf88      	it	hi
 80006d2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006d6:	d81e      	bhi.n	8000716 <__aeabi_dmul+0xde>
 80006d8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006dc:	bf08      	it	eq
 80006de:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006e2:	f150 0000 	adcs.w	r0, r0, #0
 80006e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006f0:	ea46 0101 	orr.w	r1, r6, r1
 80006f4:	ea40 0002 	orr.w	r0, r0, r2
 80006f8:	ea81 0103 	eor.w	r1, r1, r3
 80006fc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000700:	bfc2      	ittt	gt
 8000702:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000706:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800070a:	bd70      	popgt	{r4, r5, r6, pc}
 800070c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000710:	f04f 0e00 	mov.w	lr, #0
 8000714:	3c01      	subs	r4, #1
 8000716:	f300 80ab 	bgt.w	8000870 <__aeabi_dmul+0x238>
 800071a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800071e:	bfde      	ittt	le
 8000720:	2000      	movle	r0, #0
 8000722:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000726:	bd70      	pople	{r4, r5, r6, pc}
 8000728:	f1c4 0400 	rsb	r4, r4, #0
 800072c:	3c20      	subs	r4, #32
 800072e:	da35      	bge.n	800079c <__aeabi_dmul+0x164>
 8000730:	340c      	adds	r4, #12
 8000732:	dc1b      	bgt.n	800076c <__aeabi_dmul+0x134>
 8000734:	f104 0414 	add.w	r4, r4, #20
 8000738:	f1c4 0520 	rsb	r5, r4, #32
 800073c:	fa00 f305 	lsl.w	r3, r0, r5
 8000740:	fa20 f004 	lsr.w	r0, r0, r4
 8000744:	fa01 f205 	lsl.w	r2, r1, r5
 8000748:	ea40 0002 	orr.w	r0, r0, r2
 800074c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000750:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000754:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000758:	fa21 f604 	lsr.w	r6, r1, r4
 800075c:	eb42 0106 	adc.w	r1, r2, r6
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f1c4 040c 	rsb	r4, r4, #12
 8000770:	f1c4 0520 	rsb	r5, r4, #32
 8000774:	fa00 f304 	lsl.w	r3, r0, r4
 8000778:	fa20 f005 	lsr.w	r0, r0, r5
 800077c:	fa01 f204 	lsl.w	r2, r1, r4
 8000780:	ea40 0002 	orr.w	r0, r0, r2
 8000784:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800078c:	f141 0100 	adc.w	r1, r1, #0
 8000790:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000794:	bf08      	it	eq
 8000796:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800079a:	bd70      	pop	{r4, r5, r6, pc}
 800079c:	f1c4 0520 	rsb	r5, r4, #32
 80007a0:	fa00 f205 	lsl.w	r2, r0, r5
 80007a4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007a8:	fa20 f304 	lsr.w	r3, r0, r4
 80007ac:	fa01 f205 	lsl.w	r2, r1, r5
 80007b0:	ea43 0302 	orr.w	r3, r3, r2
 80007b4:	fa21 f004 	lsr.w	r0, r1, r4
 80007b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007bc:	fa21 f204 	lsr.w	r2, r1, r4
 80007c0:	ea20 0002 	bic.w	r0, r0, r2
 80007c4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007cc:	bf08      	it	eq
 80007ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007d2:	bd70      	pop	{r4, r5, r6, pc}
 80007d4:	f094 0f00 	teq	r4, #0
 80007d8:	d10f      	bne.n	80007fa <__aeabi_dmul+0x1c2>
 80007da:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007de:	0040      	lsls	r0, r0, #1
 80007e0:	eb41 0101 	adc.w	r1, r1, r1
 80007e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007e8:	bf08      	it	eq
 80007ea:	3c01      	subeq	r4, #1
 80007ec:	d0f7      	beq.n	80007de <__aeabi_dmul+0x1a6>
 80007ee:	ea41 0106 	orr.w	r1, r1, r6
 80007f2:	f095 0f00 	teq	r5, #0
 80007f6:	bf18      	it	ne
 80007f8:	4770      	bxne	lr
 80007fa:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007fe:	0052      	lsls	r2, r2, #1
 8000800:	eb43 0303 	adc.w	r3, r3, r3
 8000804:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000808:	bf08      	it	eq
 800080a:	3d01      	subeq	r5, #1
 800080c:	d0f7      	beq.n	80007fe <__aeabi_dmul+0x1c6>
 800080e:	ea43 0306 	orr.w	r3, r3, r6
 8000812:	4770      	bx	lr
 8000814:	ea94 0f0c 	teq	r4, ip
 8000818:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800081c:	bf18      	it	ne
 800081e:	ea95 0f0c 	teqne	r5, ip
 8000822:	d00c      	beq.n	800083e <__aeabi_dmul+0x206>
 8000824:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000828:	bf18      	it	ne
 800082a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800082e:	d1d1      	bne.n	80007d4 <__aeabi_dmul+0x19c>
 8000830:	ea81 0103 	eor.w	r1, r1, r3
 8000834:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000838:	f04f 0000 	mov.w	r0, #0
 800083c:	bd70      	pop	{r4, r5, r6, pc}
 800083e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000842:	bf06      	itte	eq
 8000844:	4610      	moveq	r0, r2
 8000846:	4619      	moveq	r1, r3
 8000848:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800084c:	d019      	beq.n	8000882 <__aeabi_dmul+0x24a>
 800084e:	ea94 0f0c 	teq	r4, ip
 8000852:	d102      	bne.n	800085a <__aeabi_dmul+0x222>
 8000854:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000858:	d113      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800085a:	ea95 0f0c 	teq	r5, ip
 800085e:	d105      	bne.n	800086c <__aeabi_dmul+0x234>
 8000860:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000864:	bf1c      	itt	ne
 8000866:	4610      	movne	r0, r2
 8000868:	4619      	movne	r1, r3
 800086a:	d10a      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800086c:	ea81 0103 	eor.w	r1, r1, r3
 8000870:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000874:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000878:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800087c:	f04f 0000 	mov.w	r0, #0
 8000880:	bd70      	pop	{r4, r5, r6, pc}
 8000882:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000886:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800088a:	bd70      	pop	{r4, r5, r6, pc}

0800088c <__aeabi_ddiv>:
 800088c:	b570      	push	{r4, r5, r6, lr}
 800088e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000892:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000896:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800089a:	bf1d      	ittte	ne
 800089c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008a0:	ea94 0f0c 	teqne	r4, ip
 80008a4:	ea95 0f0c 	teqne	r5, ip
 80008a8:	f000 f8a7 	bleq	80009fa <__aeabi_ddiv+0x16e>
 80008ac:	eba4 0405 	sub.w	r4, r4, r5
 80008b0:	ea81 0e03 	eor.w	lr, r1, r3
 80008b4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008bc:	f000 8088 	beq.w	80009d0 <__aeabi_ddiv+0x144>
 80008c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008c4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008c8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008cc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008d0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008d4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008d8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008dc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008e0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008e4:	429d      	cmp	r5, r3
 80008e6:	bf08      	it	eq
 80008e8:	4296      	cmpeq	r6, r2
 80008ea:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008ee:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008f2:	d202      	bcs.n	80008fa <__aeabi_ddiv+0x6e>
 80008f4:	085b      	lsrs	r3, r3, #1
 80008f6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fa:	1ab6      	subs	r6, r6, r2
 80008fc:	eb65 0503 	sbc.w	r5, r5, r3
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800090a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000950:	085b      	lsrs	r3, r3, #1
 8000952:	ea4f 0232 	mov.w	r2, r2, rrx
 8000956:	ebb6 0e02 	subs.w	lr, r6, r2
 800095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095e:	bf22      	ittt	cs
 8000960:	1ab6      	subcs	r6, r6, r2
 8000962:	4675      	movcs	r5, lr
 8000964:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000968:	ea55 0e06 	orrs.w	lr, r5, r6
 800096c:	d018      	beq.n	80009a0 <__aeabi_ddiv+0x114>
 800096e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000972:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000976:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800097a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800097e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000982:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000986:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800098a:	d1c0      	bne.n	800090e <__aeabi_ddiv+0x82>
 800098c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000990:	d10b      	bne.n	80009aa <__aeabi_ddiv+0x11e>
 8000992:	ea41 0100 	orr.w	r1, r1, r0
 8000996:	f04f 0000 	mov.w	r0, #0
 800099a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800099e:	e7b6      	b.n	800090e <__aeabi_ddiv+0x82>
 80009a0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a4:	bf04      	itt	eq
 80009a6:	4301      	orreq	r1, r0
 80009a8:	2000      	moveq	r0, #0
 80009aa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009ae:	bf88      	it	hi
 80009b0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009b4:	f63f aeaf 	bhi.w	8000716 <__aeabi_dmul+0xde>
 80009b8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009bc:	bf04      	itt	eq
 80009be:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009c2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009c6:	f150 0000 	adcs.w	r0, r0, #0
 80009ca:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	pop	{r4, r5, r6, pc}
 80009d0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009d4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009d8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009dc:	bfc2      	ittt	gt
 80009de:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009e6:	bd70      	popgt	{r4, r5, r6, pc}
 80009e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009ec:	f04f 0e00 	mov.w	lr, #0
 80009f0:	3c01      	subs	r4, #1
 80009f2:	e690      	b.n	8000716 <__aeabi_dmul+0xde>
 80009f4:	ea45 0e06 	orr.w	lr, r5, r6
 80009f8:	e68d      	b.n	8000716 <__aeabi_dmul+0xde>
 80009fa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009fe:	ea94 0f0c 	teq	r4, ip
 8000a02:	bf08      	it	eq
 8000a04:	ea95 0f0c 	teqeq	r5, ip
 8000a08:	f43f af3b 	beq.w	8000882 <__aeabi_dmul+0x24a>
 8000a0c:	ea94 0f0c 	teq	r4, ip
 8000a10:	d10a      	bne.n	8000a28 <__aeabi_ddiv+0x19c>
 8000a12:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a16:	f47f af34 	bne.w	8000882 <__aeabi_dmul+0x24a>
 8000a1a:	ea95 0f0c 	teq	r5, ip
 8000a1e:	f47f af25 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a22:	4610      	mov	r0, r2
 8000a24:	4619      	mov	r1, r3
 8000a26:	e72c      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a28:	ea95 0f0c 	teq	r5, ip
 8000a2c:	d106      	bne.n	8000a3c <__aeabi_ddiv+0x1b0>
 8000a2e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a32:	f43f aefd 	beq.w	8000830 <__aeabi_dmul+0x1f8>
 8000a36:	4610      	mov	r0, r2
 8000a38:	4619      	mov	r1, r3
 8000a3a:	e722      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a3c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a40:	bf18      	it	ne
 8000a42:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a46:	f47f aec5 	bne.w	80007d4 <__aeabi_dmul+0x19c>
 8000a4a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a4e:	f47f af0d 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a52:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a56:	f47f aeeb 	bne.w	8000830 <__aeabi_dmul+0x1f8>
 8000a5a:	e712      	b.n	8000882 <__aeabi_dmul+0x24a>

08000a5c <__aeabi_d2f>:
 8000a5c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a60:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a64:	bf24      	itt	cs
 8000a66:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a6a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a6e:	d90d      	bls.n	8000a8c <__aeabi_d2f+0x30>
 8000a70:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a74:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a78:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a7c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a80:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a84:	bf08      	it	eq
 8000a86:	f020 0001 	biceq.w	r0, r0, #1
 8000a8a:	4770      	bx	lr
 8000a8c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a90:	d121      	bne.n	8000ad6 <__aeabi_d2f+0x7a>
 8000a92:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a96:	bfbc      	itt	lt
 8000a98:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a9c:	4770      	bxlt	lr
 8000a9e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aa2:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000aa6:	f1c2 0218 	rsb	r2, r2, #24
 8000aaa:	f1c2 0c20 	rsb	ip, r2, #32
 8000aae:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ab2:	fa20 f002 	lsr.w	r0, r0, r2
 8000ab6:	bf18      	it	ne
 8000ab8:	f040 0001 	orrne.w	r0, r0, #1
 8000abc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ac0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ac4:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ac8:	ea40 000c 	orr.w	r0, r0, ip
 8000acc:	fa23 f302 	lsr.w	r3, r3, r2
 8000ad0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ad4:	e7cc      	b.n	8000a70 <__aeabi_d2f+0x14>
 8000ad6:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000ada:	d107      	bne.n	8000aec <__aeabi_d2f+0x90>
 8000adc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000ae0:	bf1e      	ittt	ne
 8000ae2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000ae6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000aea:	4770      	bxne	lr
 8000aec:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000af0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000af4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop

08000afc <__aeabi_uldivmod>:
 8000afc:	b953      	cbnz	r3, 8000b14 <__aeabi_uldivmod+0x18>
 8000afe:	b94a      	cbnz	r2, 8000b14 <__aeabi_uldivmod+0x18>
 8000b00:	2900      	cmp	r1, #0
 8000b02:	bf08      	it	eq
 8000b04:	2800      	cmpeq	r0, #0
 8000b06:	bf1c      	itt	ne
 8000b08:	f04f 31ff 	movne.w	r1, #4294967295
 8000b0c:	f04f 30ff 	movne.w	r0, #4294967295
 8000b10:	f000 b970 	b.w	8000df4 <__aeabi_idiv0>
 8000b14:	f1ad 0c08 	sub.w	ip, sp, #8
 8000b18:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000b1c:	f000 f806 	bl	8000b2c <__udivmoddi4>
 8000b20:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b24:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b28:	b004      	add	sp, #16
 8000b2a:	4770      	bx	lr

08000b2c <__udivmoddi4>:
 8000b2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000b30:	9e08      	ldr	r6, [sp, #32]
 8000b32:	460d      	mov	r5, r1
 8000b34:	4604      	mov	r4, r0
 8000b36:	460f      	mov	r7, r1
 8000b38:	2b00      	cmp	r3, #0
 8000b3a:	d14a      	bne.n	8000bd2 <__udivmoddi4+0xa6>
 8000b3c:	428a      	cmp	r2, r1
 8000b3e:	4694      	mov	ip, r2
 8000b40:	d965      	bls.n	8000c0e <__udivmoddi4+0xe2>
 8000b42:	fab2 f382 	clz	r3, r2
 8000b46:	b143      	cbz	r3, 8000b5a <__udivmoddi4+0x2e>
 8000b48:	fa02 fc03 	lsl.w	ip, r2, r3
 8000b4c:	f1c3 0220 	rsb	r2, r3, #32
 8000b50:	409f      	lsls	r7, r3
 8000b52:	fa20 f202 	lsr.w	r2, r0, r2
 8000b56:	4317      	orrs	r7, r2
 8000b58:	409c      	lsls	r4, r3
 8000b5a:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000b5e:	fa1f f58c 	uxth.w	r5, ip
 8000b62:	fbb7 f1fe 	udiv	r1, r7, lr
 8000b66:	0c22      	lsrs	r2, r4, #16
 8000b68:	fb0e 7711 	mls	r7, lr, r1, r7
 8000b6c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000b70:	fb01 f005 	mul.w	r0, r1, r5
 8000b74:	4290      	cmp	r0, r2
 8000b76:	d90a      	bls.n	8000b8e <__udivmoddi4+0x62>
 8000b78:	eb1c 0202 	adds.w	r2, ip, r2
 8000b7c:	f101 37ff 	add.w	r7, r1, #4294967295
 8000b80:	f080 811c 	bcs.w	8000dbc <__udivmoddi4+0x290>
 8000b84:	4290      	cmp	r0, r2
 8000b86:	f240 8119 	bls.w	8000dbc <__udivmoddi4+0x290>
 8000b8a:	3902      	subs	r1, #2
 8000b8c:	4462      	add	r2, ip
 8000b8e:	1a12      	subs	r2, r2, r0
 8000b90:	b2a4      	uxth	r4, r4
 8000b92:	fbb2 f0fe 	udiv	r0, r2, lr
 8000b96:	fb0e 2210 	mls	r2, lr, r0, r2
 8000b9a:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000b9e:	fb00 f505 	mul.w	r5, r0, r5
 8000ba2:	42a5      	cmp	r5, r4
 8000ba4:	d90a      	bls.n	8000bbc <__udivmoddi4+0x90>
 8000ba6:	eb1c 0404 	adds.w	r4, ip, r4
 8000baa:	f100 32ff 	add.w	r2, r0, #4294967295
 8000bae:	f080 8107 	bcs.w	8000dc0 <__udivmoddi4+0x294>
 8000bb2:	42a5      	cmp	r5, r4
 8000bb4:	f240 8104 	bls.w	8000dc0 <__udivmoddi4+0x294>
 8000bb8:	4464      	add	r4, ip
 8000bba:	3802      	subs	r0, #2
 8000bbc:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000bc0:	1b64      	subs	r4, r4, r5
 8000bc2:	2100      	movs	r1, #0
 8000bc4:	b11e      	cbz	r6, 8000bce <__udivmoddi4+0xa2>
 8000bc6:	40dc      	lsrs	r4, r3
 8000bc8:	2300      	movs	r3, #0
 8000bca:	e9c6 4300 	strd	r4, r3, [r6]
 8000bce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bd2:	428b      	cmp	r3, r1
 8000bd4:	d908      	bls.n	8000be8 <__udivmoddi4+0xbc>
 8000bd6:	2e00      	cmp	r6, #0
 8000bd8:	f000 80ed 	beq.w	8000db6 <__udivmoddi4+0x28a>
 8000bdc:	2100      	movs	r1, #0
 8000bde:	e9c6 0500 	strd	r0, r5, [r6]
 8000be2:	4608      	mov	r0, r1
 8000be4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000be8:	fab3 f183 	clz	r1, r3
 8000bec:	2900      	cmp	r1, #0
 8000bee:	d149      	bne.n	8000c84 <__udivmoddi4+0x158>
 8000bf0:	42ab      	cmp	r3, r5
 8000bf2:	d302      	bcc.n	8000bfa <__udivmoddi4+0xce>
 8000bf4:	4282      	cmp	r2, r0
 8000bf6:	f200 80f8 	bhi.w	8000dea <__udivmoddi4+0x2be>
 8000bfa:	1a84      	subs	r4, r0, r2
 8000bfc:	eb65 0203 	sbc.w	r2, r5, r3
 8000c00:	2001      	movs	r0, #1
 8000c02:	4617      	mov	r7, r2
 8000c04:	2e00      	cmp	r6, #0
 8000c06:	d0e2      	beq.n	8000bce <__udivmoddi4+0xa2>
 8000c08:	e9c6 4700 	strd	r4, r7, [r6]
 8000c0c:	e7df      	b.n	8000bce <__udivmoddi4+0xa2>
 8000c0e:	b902      	cbnz	r2, 8000c12 <__udivmoddi4+0xe6>
 8000c10:	deff      	udf	#255	; 0xff
 8000c12:	fab2 f382 	clz	r3, r2
 8000c16:	2b00      	cmp	r3, #0
 8000c18:	f040 8090 	bne.w	8000d3c <__udivmoddi4+0x210>
 8000c1c:	1a8a      	subs	r2, r1, r2
 8000c1e:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000c22:	fa1f fe8c 	uxth.w	lr, ip
 8000c26:	2101      	movs	r1, #1
 8000c28:	fbb2 f5f7 	udiv	r5, r2, r7
 8000c2c:	fb07 2015 	mls	r0, r7, r5, r2
 8000c30:	0c22      	lsrs	r2, r4, #16
 8000c32:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000c36:	fb0e f005 	mul.w	r0, lr, r5
 8000c3a:	4290      	cmp	r0, r2
 8000c3c:	d908      	bls.n	8000c50 <__udivmoddi4+0x124>
 8000c3e:	eb1c 0202 	adds.w	r2, ip, r2
 8000c42:	f105 38ff 	add.w	r8, r5, #4294967295
 8000c46:	d202      	bcs.n	8000c4e <__udivmoddi4+0x122>
 8000c48:	4290      	cmp	r0, r2
 8000c4a:	f200 80cb 	bhi.w	8000de4 <__udivmoddi4+0x2b8>
 8000c4e:	4645      	mov	r5, r8
 8000c50:	1a12      	subs	r2, r2, r0
 8000c52:	b2a4      	uxth	r4, r4
 8000c54:	fbb2 f0f7 	udiv	r0, r2, r7
 8000c58:	fb07 2210 	mls	r2, r7, r0, r2
 8000c5c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000c60:	fb0e fe00 	mul.w	lr, lr, r0
 8000c64:	45a6      	cmp	lr, r4
 8000c66:	d908      	bls.n	8000c7a <__udivmoddi4+0x14e>
 8000c68:	eb1c 0404 	adds.w	r4, ip, r4
 8000c6c:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c70:	d202      	bcs.n	8000c78 <__udivmoddi4+0x14c>
 8000c72:	45a6      	cmp	lr, r4
 8000c74:	f200 80bb 	bhi.w	8000dee <__udivmoddi4+0x2c2>
 8000c78:	4610      	mov	r0, r2
 8000c7a:	eba4 040e 	sub.w	r4, r4, lr
 8000c7e:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000c82:	e79f      	b.n	8000bc4 <__udivmoddi4+0x98>
 8000c84:	f1c1 0720 	rsb	r7, r1, #32
 8000c88:	408b      	lsls	r3, r1
 8000c8a:	fa22 fc07 	lsr.w	ip, r2, r7
 8000c8e:	ea4c 0c03 	orr.w	ip, ip, r3
 8000c92:	fa05 f401 	lsl.w	r4, r5, r1
 8000c96:	fa20 f307 	lsr.w	r3, r0, r7
 8000c9a:	40fd      	lsrs	r5, r7
 8000c9c:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000ca0:	4323      	orrs	r3, r4
 8000ca2:	fbb5 f8f9 	udiv	r8, r5, r9
 8000ca6:	fa1f fe8c 	uxth.w	lr, ip
 8000caa:	fb09 5518 	mls	r5, r9, r8, r5
 8000cae:	0c1c      	lsrs	r4, r3, #16
 8000cb0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000cb4:	fb08 f50e 	mul.w	r5, r8, lr
 8000cb8:	42a5      	cmp	r5, r4
 8000cba:	fa02 f201 	lsl.w	r2, r2, r1
 8000cbe:	fa00 f001 	lsl.w	r0, r0, r1
 8000cc2:	d90b      	bls.n	8000cdc <__udivmoddi4+0x1b0>
 8000cc4:	eb1c 0404 	adds.w	r4, ip, r4
 8000cc8:	f108 3aff 	add.w	sl, r8, #4294967295
 8000ccc:	f080 8088 	bcs.w	8000de0 <__udivmoddi4+0x2b4>
 8000cd0:	42a5      	cmp	r5, r4
 8000cd2:	f240 8085 	bls.w	8000de0 <__udivmoddi4+0x2b4>
 8000cd6:	f1a8 0802 	sub.w	r8, r8, #2
 8000cda:	4464      	add	r4, ip
 8000cdc:	1b64      	subs	r4, r4, r5
 8000cde:	b29d      	uxth	r5, r3
 8000ce0:	fbb4 f3f9 	udiv	r3, r4, r9
 8000ce4:	fb09 4413 	mls	r4, r9, r3, r4
 8000ce8:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000cec:	fb03 fe0e 	mul.w	lr, r3, lr
 8000cf0:	45a6      	cmp	lr, r4
 8000cf2:	d908      	bls.n	8000d06 <__udivmoddi4+0x1da>
 8000cf4:	eb1c 0404 	adds.w	r4, ip, r4
 8000cf8:	f103 35ff 	add.w	r5, r3, #4294967295
 8000cfc:	d26c      	bcs.n	8000dd8 <__udivmoddi4+0x2ac>
 8000cfe:	45a6      	cmp	lr, r4
 8000d00:	d96a      	bls.n	8000dd8 <__udivmoddi4+0x2ac>
 8000d02:	3b02      	subs	r3, #2
 8000d04:	4464      	add	r4, ip
 8000d06:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000d0a:	fba3 9502 	umull	r9, r5, r3, r2
 8000d0e:	eba4 040e 	sub.w	r4, r4, lr
 8000d12:	42ac      	cmp	r4, r5
 8000d14:	46c8      	mov	r8, r9
 8000d16:	46ae      	mov	lr, r5
 8000d18:	d356      	bcc.n	8000dc8 <__udivmoddi4+0x29c>
 8000d1a:	d053      	beq.n	8000dc4 <__udivmoddi4+0x298>
 8000d1c:	b156      	cbz	r6, 8000d34 <__udivmoddi4+0x208>
 8000d1e:	ebb0 0208 	subs.w	r2, r0, r8
 8000d22:	eb64 040e 	sbc.w	r4, r4, lr
 8000d26:	fa04 f707 	lsl.w	r7, r4, r7
 8000d2a:	40ca      	lsrs	r2, r1
 8000d2c:	40cc      	lsrs	r4, r1
 8000d2e:	4317      	orrs	r7, r2
 8000d30:	e9c6 7400 	strd	r7, r4, [r6]
 8000d34:	4618      	mov	r0, r3
 8000d36:	2100      	movs	r1, #0
 8000d38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d3c:	f1c3 0120 	rsb	r1, r3, #32
 8000d40:	fa02 fc03 	lsl.w	ip, r2, r3
 8000d44:	fa20 f201 	lsr.w	r2, r0, r1
 8000d48:	fa25 f101 	lsr.w	r1, r5, r1
 8000d4c:	409d      	lsls	r5, r3
 8000d4e:	432a      	orrs	r2, r5
 8000d50:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000d54:	fa1f fe8c 	uxth.w	lr, ip
 8000d58:	fbb1 f0f7 	udiv	r0, r1, r7
 8000d5c:	fb07 1510 	mls	r5, r7, r0, r1
 8000d60:	0c11      	lsrs	r1, r2, #16
 8000d62:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000d66:	fb00 f50e 	mul.w	r5, r0, lr
 8000d6a:	428d      	cmp	r5, r1
 8000d6c:	fa04 f403 	lsl.w	r4, r4, r3
 8000d70:	d908      	bls.n	8000d84 <__udivmoddi4+0x258>
 8000d72:	eb1c 0101 	adds.w	r1, ip, r1
 8000d76:	f100 38ff 	add.w	r8, r0, #4294967295
 8000d7a:	d22f      	bcs.n	8000ddc <__udivmoddi4+0x2b0>
 8000d7c:	428d      	cmp	r5, r1
 8000d7e:	d92d      	bls.n	8000ddc <__udivmoddi4+0x2b0>
 8000d80:	3802      	subs	r0, #2
 8000d82:	4461      	add	r1, ip
 8000d84:	1b49      	subs	r1, r1, r5
 8000d86:	b292      	uxth	r2, r2
 8000d88:	fbb1 f5f7 	udiv	r5, r1, r7
 8000d8c:	fb07 1115 	mls	r1, r7, r5, r1
 8000d90:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000d94:	fb05 f10e 	mul.w	r1, r5, lr
 8000d98:	4291      	cmp	r1, r2
 8000d9a:	d908      	bls.n	8000dae <__udivmoddi4+0x282>
 8000d9c:	eb1c 0202 	adds.w	r2, ip, r2
 8000da0:	f105 38ff 	add.w	r8, r5, #4294967295
 8000da4:	d216      	bcs.n	8000dd4 <__udivmoddi4+0x2a8>
 8000da6:	4291      	cmp	r1, r2
 8000da8:	d914      	bls.n	8000dd4 <__udivmoddi4+0x2a8>
 8000daa:	3d02      	subs	r5, #2
 8000dac:	4462      	add	r2, ip
 8000dae:	1a52      	subs	r2, r2, r1
 8000db0:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000db4:	e738      	b.n	8000c28 <__udivmoddi4+0xfc>
 8000db6:	4631      	mov	r1, r6
 8000db8:	4630      	mov	r0, r6
 8000dba:	e708      	b.n	8000bce <__udivmoddi4+0xa2>
 8000dbc:	4639      	mov	r1, r7
 8000dbe:	e6e6      	b.n	8000b8e <__udivmoddi4+0x62>
 8000dc0:	4610      	mov	r0, r2
 8000dc2:	e6fb      	b.n	8000bbc <__udivmoddi4+0x90>
 8000dc4:	4548      	cmp	r0, r9
 8000dc6:	d2a9      	bcs.n	8000d1c <__udivmoddi4+0x1f0>
 8000dc8:	ebb9 0802 	subs.w	r8, r9, r2
 8000dcc:	eb65 0e0c 	sbc.w	lr, r5, ip
 8000dd0:	3b01      	subs	r3, #1
 8000dd2:	e7a3      	b.n	8000d1c <__udivmoddi4+0x1f0>
 8000dd4:	4645      	mov	r5, r8
 8000dd6:	e7ea      	b.n	8000dae <__udivmoddi4+0x282>
 8000dd8:	462b      	mov	r3, r5
 8000dda:	e794      	b.n	8000d06 <__udivmoddi4+0x1da>
 8000ddc:	4640      	mov	r0, r8
 8000dde:	e7d1      	b.n	8000d84 <__udivmoddi4+0x258>
 8000de0:	46d0      	mov	r8, sl
 8000de2:	e77b      	b.n	8000cdc <__udivmoddi4+0x1b0>
 8000de4:	3d02      	subs	r5, #2
 8000de6:	4462      	add	r2, ip
 8000de8:	e732      	b.n	8000c50 <__udivmoddi4+0x124>
 8000dea:	4608      	mov	r0, r1
 8000dec:	e70a      	b.n	8000c04 <__udivmoddi4+0xd8>
 8000dee:	4464      	add	r4, ip
 8000df0:	3802      	subs	r0, #2
 8000df2:	e742      	b.n	8000c7a <__udivmoddi4+0x14e>

08000df4 <__aeabi_idiv0>:
 8000df4:	4770      	bx	lr
 8000df6:	bf00      	nop

08000df8 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000df8:	480d      	ldr	r0, [pc, #52]	; (8000e30 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000dfa:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000dfc:	480d      	ldr	r0, [pc, #52]	; (8000e34 <LoopForever+0x6>)
  ldr r1, =_edata
 8000dfe:	490e      	ldr	r1, [pc, #56]	; (8000e38 <LoopForever+0xa>)
  ldr r2, =_sidata
 8000e00:	4a0e      	ldr	r2, [pc, #56]	; (8000e3c <LoopForever+0xe>)
  movs r3, #0
 8000e02:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8000e04:	e002      	b.n	8000e0c <LoopCopyDataInit>

08000e06 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000e06:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000e08:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000e0a:	3304      	adds	r3, #4

08000e0c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000e0c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000e0e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000e10:	d3f9      	bcc.n	8000e06 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000e12:	4a0b      	ldr	r2, [pc, #44]	; (8000e40 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000e14:	4c0b      	ldr	r4, [pc, #44]	; (8000e44 <LoopForever+0x16>)
  movs r3, #0
 8000e16:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000e18:	e001      	b.n	8000e1e <LoopFillZerobss>

08000e1a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000e1a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000e1c:	3204      	adds	r2, #4

08000e1e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000e1e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000e20:	d3fb      	bcc.n	8000e1a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8000e22:	f004 fabf 	bl	80053a4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000e26:	f00c fcd5 	bl	800d7d4 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000e2a:	f000 fddd 	bl	80019e8 <main>

08000e2e <LoopForever>:

LoopForever:
    b LoopForever
 8000e2e:	e7fe      	b.n	8000e2e <LoopForever>
  ldr   r0, =_estack
 8000e30:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8000e34:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000e38:	2000150c 	.word	0x2000150c
  ldr r2, =_sidata
 8000e3c:	0801a644 	.word	0x0801a644
  ldr r2, =_sbss
 8000e40:	20001520 	.word	0x20001520
  ldr r4, =_ebss
 8000e44:	200031f8 	.word	0x200031f8

08000e48 <ADC3_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000e48:	e7fe      	b.n	8000e48 <ADC3_IRQHandler>
	...

08000e4c <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000e4c:	b510      	push	{r4, lr}

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 8000e4e:	2400      	movs	r4, #0
{
 8000e50:	b09a      	sub	sp, #104	; 0x68
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000e52:	223c      	movs	r2, #60	; 0x3c
 8000e54:	4621      	mov	r1, r4
 8000e56:	a80b      	add	r0, sp, #44	; 0x2c
  ADC_MultiModeTypeDef multimode = {0};
 8000e58:	e9cd 4400 	strd	r4, r4, [sp]
 8000e5c:	9402      	str	r4, [sp, #8]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000e5e:	f00c fc55 	bl	800d70c <memset>
  ADC_ChannelConfTypeDef sConfig = {0};
 8000e62:	2220      	movs	r2, #32
 8000e64:	4621      	mov	r1, r4
 8000e66:	a803      	add	r0, sp, #12
 8000e68:	f00c fc50 	bl	800d70c <memset>

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 8000e6c:	483d      	ldr	r0, [pc, #244]	; (8000f64 <MX_ADC1_Init+0x118>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
  hadc1.Init.GainCompensation = 0;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8000e6e:	2301      	movs	r3, #1
 8000e70:	6143      	str	r3, [r0, #20]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = 1;
 8000e72:	6203      	str	r3, [r0, #32]
  hadc1.Instance = ADC1;
 8000e74:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000e78:	6003      	str	r3, [r0, #0]
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000e7a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000e7e:	60c3      	str	r3, [r0, #12]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000e80:	8384      	strh	r4, [r0, #28]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000e82:	2304      	movs	r3, #4
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000e84:	e9c0 4401 	strd	r4, r4, [r0, #4]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000e88:	e9c0 440b 	strd	r4, r4, [r0, #44]	; 0x2c
  hadc1.Init.GainCompensation = 0;
 8000e8c:	6104      	str	r4, [r0, #16]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000e8e:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000e92:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000e96:	63c4      	str	r4, [r0, #60]	; 0x3c
  hadc1.Init.OversamplingMode = DISABLE;
 8000e98:	f880 4040 	strb.w	r4, [r0, #64]	; 0x40
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000e9c:	6183      	str	r3, [r0, #24]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000e9e:	f004 fadb 	bl	8005458 <HAL_ADC_Init>
 8000ea2:	2800      	cmp	r0, #0
 8000ea4:	d14a      	bne.n	8000f3c <MX_ADC1_Init+0xf0>
    Error_Handler();
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000ea6:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000ea8:	482e      	ldr	r0, [pc, #184]	; (8000f64 <MX_ADC1_Init+0x118>)
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000eaa:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000eac:	4669      	mov	r1, sp
 8000eae:	f005 f9a1 	bl	80061f4 <HAL_ADCEx_MultiModeConfigChannel>
 8000eb2:	2800      	cmp	r0, #0
 8000eb4:	d152      	bne.n	8000f5c <MX_ADC1_Init+0x110>
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_1;
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000eb6:	482c      	ldr	r0, [pc, #176]	; (8000f68 <MX_ADC1_Init+0x11c>)
 8000eb8:	2109      	movs	r1, #9
 8000eba:	e9cd 010b 	strd	r0, r1, [sp, #44]	; 0x2c
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_6CYCLES_5;
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000ebe:	2401      	movs	r4, #1
 8000ec0:	217f      	movs	r1, #127	; 0x7f
 8000ec2:	e9cd 410d 	strd	r4, r1, [sp, #52]	; 0x34
  sConfigInjected.InjectedOffsetNumber = ADC_OFFSET_NONE;
 8000ec6:	2104      	movs	r1, #4
 8000ec8:	910f      	str	r1, [sp, #60]	; 0x3c
  sConfigInjected.InjectedOffset = 0;
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000eca:	2103      	movs	r1, #3
  sConfigInjected.InjectedOffset = 0;
 8000ecc:	2300      	movs	r3, #0
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
  sConfigInjected.AutoInjectedConv = DISABLE;
  sConfigInjected.QueueInjectedContext = DISABLE;
  sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJEC_T1_TRGO;
 8000ece:	2280      	movs	r2, #128	; 0x80
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000ed0:	9113      	str	r1, [sp, #76]	; 0x4c
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
  sConfigInjected.InjecOversamplingMode = DISABLE;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ed2:	4824      	ldr	r0, [pc, #144]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedOffset = 0;
 8000ed4:	9310      	str	r3, [sp, #64]	; 0x40
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ed6:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
 8000ed8:	e9cd 2215 	strd	r2, r2, [sp, #84]	; 0x54
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8000edc:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
  sConfigInjected.QueueInjectedContext = DISABLE;
 8000ee0:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
  sConfigInjected.InjecOversamplingMode = DISABLE;
 8000ee4:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ee8:	f004 fe68 	bl	8005bbc <HAL_ADCEx_InjectedConfigChannel>
 8000eec:	2800      	cmp	r0, #0
 8000eee:	d132      	bne.n	8000f56 <MX_ADC1_Init+0x10a>
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_7;
 8000ef0:	4a1e      	ldr	r2, [pc, #120]	; (8000f6c <MX_ADC1_Init+0x120>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ef2:	481c      	ldr	r0, [pc, #112]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedChannel = ADC_CHANNEL_7;
 8000ef4:	920b      	str	r2, [sp, #44]	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000ef6:	f240 130f 	movw	r3, #271	; 0x10f
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000efa:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000efc:	930c      	str	r3, [sp, #48]	; 0x30
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000efe:	f004 fe5d 	bl	8005bbc <HAL_ADCEx_InjectedConfigChannel>
 8000f02:	bb28      	cbnz	r0, 8000f50 <MX_ADC1_Init+0x104>
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_6;
 8000f04:	4a1a      	ldr	r2, [pc, #104]	; (8000f70 <MX_ADC1_Init+0x124>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f06:	4817      	ldr	r0, [pc, #92]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000f08:	f240 2315 	movw	r3, #533	; 0x215
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f0c:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000f0e:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f12:	f004 fe53 	bl	8005bbc <HAL_ADCEx_InjectedConfigChannel>
 8000f16:	b9c0      	cbnz	r0, 8000f4a <MX_ADC1_Init+0xfe>
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_2;
 8000f18:	4a16      	ldr	r2, [pc, #88]	; (8000f74 <MX_ADC1_Init+0x128>)
 8000f1a:	9203      	str	r2, [sp, #12]
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000f1c:	227f      	movs	r2, #127	; 0x7f
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000f1e:	2304      	movs	r3, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000f20:	2406      	movs	r4, #6
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000f22:	9206      	str	r2, [sp, #24]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f24:	480f      	ldr	r0, [pc, #60]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfig.Offset = 0;
 8000f26:	2200      	movs	r2, #0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f28:	a903      	add	r1, sp, #12
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000f2a:	e9cd 4304 	strd	r4, r3, [sp, #16]
  sConfig.Offset = 0;
 8000f2e:	e9cd 3207 	strd	r3, r2, [sp, #28]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f32:	f004 fbb7 	bl	80056a4 <HAL_ADC_ConfigChannel>
 8000f36:	b920      	cbnz	r0, 8000f42 <MX_ADC1_Init+0xf6>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8000f38:	b01a      	add	sp, #104	; 0x68
 8000f3a:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000f3c:	f000 fe7c 	bl	8001c38 <Error_Handler>
 8000f40:	e7b1      	b.n	8000ea6 <MX_ADC1_Init+0x5a>
    Error_Handler();
 8000f42:	f000 fe79 	bl	8001c38 <Error_Handler>
}
 8000f46:	b01a      	add	sp, #104	; 0x68
 8000f48:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000f4a:	f000 fe75 	bl	8001c38 <Error_Handler>
 8000f4e:	e7e3      	b.n	8000f18 <MX_ADC1_Init+0xcc>
    Error_Handler();
 8000f50:	f000 fe72 	bl	8001c38 <Error_Handler>
 8000f54:	e7d6      	b.n	8000f04 <MX_ADC1_Init+0xb8>
    Error_Handler();
 8000f56:	f000 fe6f 	bl	8001c38 <Error_Handler>
 8000f5a:	e7c9      	b.n	8000ef0 <MX_ADC1_Init+0xa4>
    Error_Handler();
 8000f5c:	f000 fe6c 	bl	8001c38 <Error_Handler>
 8000f60:	e7a9      	b.n	8000eb6 <MX_ADC1_Init+0x6a>
 8000f62:	bf00      	nop
 8000f64:	2000153c 	.word	0x2000153c
 8000f68:	04300002 	.word	0x04300002
 8000f6c:	1d500080 	.word	0x1d500080
 8000f70:	19200040 	.word	0x19200040
 8000f74:	08600004 	.word	0x08600004

08000f78 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8000f78:	b5d0      	push	{r4, r6, r7, lr}
 8000f7a:	4604      	mov	r4, r0
 8000f7c:	b09e      	sub	sp, #120	; 0x78

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000f7e:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000f80:	2254      	movs	r2, #84	; 0x54
 8000f82:	a809      	add	r0, sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000f84:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8000f88:	e9cd 1106 	strd	r1, r1, [sp, #24]
 8000f8c:	9108      	str	r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000f8e:	f00c fbbd 	bl	800d70c <memset>
  if(adcHandle->Instance==ADC1)
 8000f92:	6823      	ldr	r3, [r4, #0]
 8000f94:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000f98:	d001      	beq.n	8000f9e <HAL_ADC_MspInit+0x26>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8000f9a:	b01e      	add	sp, #120	; 0x78
 8000f9c:	bdd0      	pop	{r4, r6, r7, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8000f9e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8000fa2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000fa6:	a809      	add	r0, sp, #36	; 0x24
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8000fa8:	9209      	str	r2, [sp, #36]	; 0x24
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8000faa:	931a      	str	r3, [sp, #104]	; 0x68
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000fac:	f006 f8a4 	bl	80070f8 <HAL_RCCEx_PeriphCLKConfig>
 8000fb0:	2800      	cmp	r0, #0
 8000fb2:	d12f      	bne.n	8001014 <HAL_ADC_MspInit+0x9c>
    __HAL_RCC_ADC12_CLK_ENABLE();
 8000fb4:	4b19      	ldr	r3, [pc, #100]	; (800101c <HAL_ADC_MspInit+0xa4>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000fb6:	481a      	ldr	r0, [pc, #104]	; (8001020 <HAL_ADC_MspInit+0xa8>)
    __HAL_RCC_ADC12_CLK_ENABLE();
 8000fb8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fba:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000fbe:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fc0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fc2:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8000fc6:	9201      	str	r2, [sp, #4]
 8000fc8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000fca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fcc:	f042 0204 	orr.w	r2, r2, #4
 8000fd0:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fd2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fd4:	f002 0204 	and.w	r2, r2, #4
 8000fd8:	9202      	str	r2, [sp, #8]
 8000fda:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000fdc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fde:	f042 0201 	orr.w	r2, r2, #1
 8000fe2:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fe4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fe6:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin;
 8000fea:	2603      	movs	r6, #3
 8000fec:	2703      	movs	r7, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000fee:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff0:	2400      	movs	r4, #0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ff2:	a904      	add	r1, sp, #16
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ff4:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff6:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin;
 8000ff8:	e9cd 6704 	strd	r6, r7, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ffc:	f005 fb4a 	bl	8006694 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001000:	a904      	add	r1, sp, #16
 8001002:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8001006:	e9cd 6704 	strd	r6, r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800100a:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800100c:	f005 fb42 	bl	8006694 <HAL_GPIO_Init>
}
 8001010:	b01e      	add	sp, #120	; 0x78
 8001012:	bdd0      	pop	{r4, r6, r7, pc}
      Error_Handler();
 8001014:	f000 fe10 	bl	8001c38 <Error_Handler>
 8001018:	e7cc      	b.n	8000fb4 <HAL_ADC_MspInit+0x3c>
 800101a:	bf00      	nop
 800101c:	40021000 	.word	0x40021000
 8001020:	48000800 	.word	0x48000800

08001024 <MX_X_CUBE_AI_Init>:
/* USER CODE END 2 */

/* Entry points --------------------------------------------------------------*/

void MX_X_CUBE_AI_Init(void)
{
 8001024:	b570      	push	{r4, r5, r6, lr}
  err = ai_network_create_and_init(&network, act_addr, NULL);
 8001026:	4c16      	ldr	r4, [pc, #88]	; (8001080 <MX_X_CUBE_AI_Init+0x5c>)
    /* USER CODE BEGIN 5 */
  printf("\r\nTEMPLATE - initialization\r\n");
 8001028:	4816      	ldr	r0, [pc, #88]	; (8001084 <MX_X_CUBE_AI_Init+0x60>)
 800102a:	f00c fa8f 	bl	800d54c <puts>
  err = ai_network_create_and_init(&network, act_addr, NULL);
 800102e:	4916      	ldr	r1, [pc, #88]	; (8001088 <MX_X_CUBE_AI_Init+0x64>)
 8001030:	2200      	movs	r2, #0
 8001032:	4620      	mov	r0, r4
 8001034:	f001 ffb4 	bl	8002fa0 <ai_network_create_and_init>
  if (err.type != AI_ERROR_NONE) {
 8001038:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
 800103c:	d118      	bne.n	8001070 <MX_X_CUBE_AI_Init+0x4c>
  ai_input = ai_network_inputs_get(network, NULL);
 800103e:	6820      	ldr	r0, [r4, #0]
 8001040:	4e12      	ldr	r6, [pc, #72]	; (800108c <MX_X_CUBE_AI_Init+0x68>)
 8001042:	4629      	mov	r1, r5
 8001044:	f001 fe3e 	bl	8002cc4 <ai_network_inputs_get>
  ai_output = ai_network_outputs_get(network, NULL);
 8001048:	4629      	mov	r1, r5
  ai_input = ai_network_inputs_get(network, NULL);
 800104a:	4603      	mov	r3, r0
  ai_output = ai_network_outputs_get(network, NULL);
 800104c:	6820      	ldr	r0, [r4, #0]
  ai_input = ai_network_inputs_get(network, NULL);
 800104e:	6033      	str	r3, [r6, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001050:	f001 fe44 	bl	8002cdc <ai_network_outputs_get>
	data_ins[idx] = ai_input[idx].data;
 8001054:	6831      	ldr	r1, [r6, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001056:	4c0e      	ldr	r4, [pc, #56]	; (8001090 <MX_X_CUBE_AI_Init+0x6c>)
	data_ins[idx] = ai_input[idx].data;
 8001058:	4a0e      	ldr	r2, [pc, #56]	; (8001094 <MX_X_CUBE_AI_Init+0x70>)
 800105a:	6849      	ldr	r1, [r1, #4]
	data_outs[idx] = ai_output[idx].data;
 800105c:	4b0e      	ldr	r3, [pc, #56]	; (8001098 <MX_X_CUBE_AI_Init+0x74>)
	data_ins[idx] = ai_input[idx].data;
 800105e:	6011      	str	r1, [r2, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001060:	6020      	str	r0, [r4, #0]
	data_outs[idx] = ai_output[idx].data;
 8001062:	6a01      	ldr	r1, [r0, #32]
 8001064:	6844      	ldr	r4, [r0, #4]
 8001066:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8001068:	609a      	str	r2, [r3, #8]
 800106a:	e9c3 4100 	strd	r4, r1, [r3]

  ai_boostrap(data_activations0);
    /* USER CODE END 5 */
}
 800106e:	bd70      	pop	{r4, r5, r6, pc}
    ai_log_err(err, "ai_network_create_and_init");
 8001070:	4603      	mov	r3, r0
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 8001072:	490a      	ldr	r1, [pc, #40]	; (800109c <MX_X_CUBE_AI_Init+0x78>)
 8001074:	480a      	ldr	r0, [pc, #40]	; (80010a0 <MX_X_CUBE_AI_Init+0x7c>)
 8001076:	0a1b      	lsrs	r3, r3, #8
 8001078:	462a      	mov	r2, r5
 800107a:	f00c fa01 	bl	800d480 <iprintf>
  do {} while (1);
 800107e:	e7fe      	b.n	800107e <MX_X_CUBE_AI_Init+0x5a>
 8001080:	200015c0 	.word	0x200015c0
 8001084:	0800eed0 	.word	0x0800eed0
 8001088:	20000000 	.word	0x20000000
 800108c:	200015a8 	.word	0x200015a8
 8001090:	200015ac 	.word	0x200015ac
 8001094:	200015b0 	.word	0x200015b0
 8001098:	200015b4 	.word	0x200015b4
 800109c:	0800eef0 	.word	0x0800eef0
 80010a0:	0800ef0c 	.word	0x0800ef0c

080010a4 <MX_X_CUBE_AI_Process>:

void MX_X_CUBE_AI_Process(void)
{
 80010a4:	b538      	push	{r3, r4, r5, lr}
    /* USER CODE BEGIN 6 */
  int res = -1;

  printf("TEMPLATE - run - main loop\r\n");

  if (network) {
 80010a6:	4c1b      	ldr	r4, [pc, #108]	; (8001114 <MX_X_CUBE_AI_Process+0x70>)
  printf("TEMPLATE - run - main loop\r\n");
 80010a8:	481b      	ldr	r0, [pc, #108]	; (8001118 <MX_X_CUBE_AI_Process+0x74>)
 80010aa:	f00c fa4f 	bl	800d54c <puts>
  if (network) {
 80010ae:	6823      	ldr	r3, [r4, #0]
 80010b0:	b1eb      	cbz	r3, 80010ee <MX_X_CUBE_AI_Process+0x4a>
  memcpy(data[0], in_data1, AI_NETWORK_IN_1_SIZE * sizeof(ai_float));
 80010b2:	4b1a      	ldr	r3, [pc, #104]	; (800111c <MX_X_CUBE_AI_Process+0x78>)
 80010b4:	4d1a      	ldr	r5, [pc, #104]	; (8001120 <MX_X_CUBE_AI_Process+0x7c>)
 80010b6:	cb07      	ldmia	r3!, {r0, r1, r2}
 80010b8:	682b      	ldr	r3, [r5, #0]
 80010ba:	6018      	str	r0, [r3, #0]
 80010bc:	6059      	str	r1, [r3, #4]
 80010be:	609a      	str	r2, [r3, #8]
  batch = ai_network_run(network, ai_input, ai_output);
 80010c0:	4818      	ldr	r0, [pc, #96]	; (8001124 <MX_X_CUBE_AI_Process+0x80>)
 80010c2:	4b19      	ldr	r3, [pc, #100]	; (8001128 <MX_X_CUBE_AI_Process+0x84>)
 80010c4:	6802      	ldr	r2, [r0, #0]
 80010c6:	6819      	ldr	r1, [r3, #0]
 80010c8:	6820      	ldr	r0, [r4, #0]
 80010ca:	f001 ffc3 	bl	8003054 <ai_network_run>
  if (batch != 1) {
 80010ce:	2801      	cmp	r0, #1
 80010d0:	d114      	bne.n	80010fc <MX_X_CUBE_AI_Process+0x58>
  memcpy(out_data1, data[0], AI_NETWORK_OUT_1_SIZE * sizeof(ai_float));
 80010d2:	4b16      	ldr	r3, [pc, #88]	; (800112c <MX_X_CUBE_AI_Process+0x88>)
 80010d4:	4916      	ldr	r1, [pc, #88]	; (8001130 <MX_X_CUBE_AI_Process+0x8c>)
 80010d6:	e9d3 0200 	ldrd	r0, r2, [r3]
 80010da:	6800      	ldr	r0, [r0, #0]
 80010dc:	6008      	str	r0, [r1, #0]
  memcpy(out_data2, data[1], AI_NETWORK_OUT_2_SIZE * sizeof(ai_float));
 80010de:	4915      	ldr	r1, [pc, #84]	; (8001134 <MX_X_CUBE_AI_Process+0x90>)
 80010e0:	6810      	ldr	r0, [r2, #0]
 80010e2:	689a      	ldr	r2, [r3, #8]
 80010e4:	6008      	str	r0, [r1, #0]
  memcpy(out_data3, data[2], AI_NETWORK_OUT_3_SIZE * sizeof(ai_float));
 80010e6:	4b14      	ldr	r3, [pc, #80]	; (8001138 <MX_X_CUBE_AI_Process+0x94>)
 80010e8:	6812      	ldr	r2, [r2, #0]
 80010ea:	601a      	str	r2, [r3, #0]
  if (res) {
    ai_error err = {AI_ERROR_INVALID_STATE, AI_ERROR_CODE_NETWORK};
    ai_log_err(err, "Process has FAILED");
  }
    /* USER CODE END 6 */
}
 80010ec:	bd38      	pop	{r3, r4, r5, pc}
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 80010ee:	4913      	ldr	r1, [pc, #76]	; (800113c <MX_X_CUBE_AI_Process+0x98>)
 80010f0:	4813      	ldr	r0, [pc, #76]	; (8001140 <MX_X_CUBE_AI_Process+0x9c>)
 80010f2:	2310      	movs	r3, #16
 80010f4:	2211      	movs	r2, #17
 80010f6:	f00c f9c3 	bl	800d480 <iprintf>
  do {} while (1);
 80010fa:	e7fe      	b.n	80010fa <MX_X_CUBE_AI_Process+0x56>
    ai_log_err(ai_network_get_error(network),
 80010fc:	6820      	ldr	r0, [r4, #0]
 80010fe:	f001 fddf 	bl	8002cc0 <ai_network_get_error>
 8001102:	4602      	mov	r2, r0
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 8001104:	0a13      	lsrs	r3, r2, #8
 8001106:	490f      	ldr	r1, [pc, #60]	; (8001144 <MX_X_CUBE_AI_Process+0xa0>)
 8001108:	480d      	ldr	r0, [pc, #52]	; (8001140 <MX_X_CUBE_AI_Process+0x9c>)
 800110a:	b2d2      	uxtb	r2, r2
 800110c:	f00c f9b8 	bl	800d480 <iprintf>
  do {} while (1);
 8001110:	e7fe      	b.n	8001110 <MX_X_CUBE_AI_Process+0x6c>
 8001112:	bf00      	nop
 8001114:	200015c0 	.word	0x200015c0
 8001118:	0800ef40 	.word	0x0800ef40
 800111c:	20001a70 	.word	0x20001a70
 8001120:	200015b0 	.word	0x200015b0
 8001124:	200015ac 	.word	0x200015ac
 8001128:	200015a8 	.word	0x200015a8
 800112c:	200015b4 	.word	0x200015b4
 8001130:	20001a7c 	.word	0x20001a7c
 8001134:	20001a80 	.word	0x20001a80
 8001138:	20001a84 	.word	0x20001a84
 800113c:	0800ef6c 	.word	0x0800ef6c
 8001140:	0800ef0c 	.word	0x0800ef0c
 8001144:	0800ef5c 	.word	0x0800ef5c

08001148 <ASPEP_start>:
  * @brief  Starts ASPEP communication by configuring UART.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_start(ASPEP_Handle_t *pHandle)
{
 8001148:	b570      	push	{r4, r5, r6, lr}
 800114a:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->fASPEP_HWInit(pHandle->HWIp);
 800114c:	6940      	ldr	r0, [r0, #20]
 800114e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001150:	4798      	blx	r3
    pHandle->ASPEP_State = ASPEP_IDLE;
 8001152:	2300      	movs	r3, #0
    pHandle->ASPEP_TL_State = WAITING_PACKET;
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/

    /* Configure UART to receive first packet*/
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8001154:	6d65      	ldr	r5, [r4, #84]	; 0x54
    pHandle->ASPEP_State = ASPEP_IDLE;
 8001156:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 800115a:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800115e:	6960      	ldr	r0, [r4, #20]
 8001160:	f104 011c 	add.w	r1, r4, #28
 8001164:	462b      	mov	r3, r5
 8001166:	2204      	movs	r2, #4
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001168:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800116c:	4718      	bx	r3
 800116e:	bf00      	nop

08001170 <ASPEP_sendBeacon>:
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  * @param  *capabilities Matched capabilities between controller and performer
  */
void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
{
 8001170:	b410      	push	{r4}
  {
#endif
    uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
    *packet = (BEACON
             | (((uint32_t)capabilities->version) << 4U)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 8001172:	780b      	ldrb	r3, [r1, #0]
             | (((uint32_t)capabilities->version) << 4U)
 8001174:	790a      	ldrb	r2, [r1, #4]
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 8001176:	f891 c002 	ldrb.w	ip, [r1, #2]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 800117a:	4c1e      	ldr	r4, [pc, #120]	; (80011f4 <ASPEP_sendBeacon+0x84>)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 800117c:	01db      	lsls	r3, r3, #7
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 800117e:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
 8001182:	784a      	ldrb	r2, [r1, #1]
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 8001184:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001188:	78ca      	ldrb	r2, [r1, #3]
 800118a:	ea43 338c 	orr.w	r3, r3, ip, lsl #14
 800118e:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001192:	b2da      	uxtb	r2, r3
 8001194:	f042 0205 	orr.w	r2, r2, #5
  header &= 0x0fffffffU;
 8001198:	f023 4170 	bic.w	r1, r3, #4026531840	; 0xf0000000
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800119c:	5ca2      	ldrb	r2, [r4, r2]
 800119e:	ea82 2211 	eor.w	r2, r2, r1, lsr #8
 80011a2:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80011a4:	5ca2      	ldrb	r2, [r4, r2]
 80011a6:	ea82 4211 	eor.w	r2, r2, r1, lsr #16
 80011aa:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80011ac:	5ca2      	ldrb	r2, [r4, r2]
 80011ae:	4c12      	ldr	r4, [pc, #72]	; (80011f8 <ASPEP_sendBeacon+0x88>)
 80011b0:	ea82 6211 	eor.w	r2, r2, r1, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 80011b4:	5ca2      	ldrb	r2, [r4, r2]
 80011b6:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80011ba:	f043 0305 	orr.w	r3, r3, #5
 80011be:	6203      	str	r3, [r0, #32]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011c0:	b672      	cpsid	i
  {
#endif
    /* Insert CRC header in the packet to send */
    ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
    __disable_irq(); /*TODO: Disable High frequency task is enough */
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 80011c2:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80011c4:	b14b      	cbz	r3, 80011da <ASPEP_sendBeacon+0x6a>
  __ASM volatile ("cpsie i" : : : "memory");
 80011c6:	b662      	cpsie	i
          pHandle->syncBuffer.length = bufferLength;
        }
      }
      else if(ASPEP_CTRL == dataType)
      {
        if (pHandle->ctrlBuffer.state != available)
 80011c8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80011cc:	b913      	cbnz	r3, 80011d4 <ASPEP_sendBeacon+0x64>
        {
          result = ASPEP_BUFFER_ERROR;
        }
        else
        {
          pHandle->ctrlBuffer.state = pending;
 80011ce:	2302      	movs	r3, #2
 80011d0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 80011d4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80011d8:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 80011da:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 80011de:	2303      	movs	r3, #3
 80011e0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80011e4:	6481      	str	r1, [r0, #72]	; 0x48
 80011e6:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80011e8:	2204      	movs	r2, #4
 80011ea:	6d83      	ldr	r3, [r0, #88]	; 0x58
}
 80011ec:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80011f0:	6940      	ldr	r0, [r0, #20]
 80011f2:	4718      	bx	r3
 80011f4:	0800ef90 	.word	0x0800ef90
 80011f8:	0800ef80 	.word	0x0800ef80

080011fc <ASPEP_sendPing>:
{
 80011fc:	b430      	push	{r4, r5}
                   | (uint32_t)((uint32_t)cBit << 5U)
 80011fe:	014b      	lsls	r3, r1, #5
    uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 8001200:	f890 c060 	ldrb.w	ip, [r0, #96]	; 0x60
    uint8_t ipID = pHandle->liid & 0xFU;
 8001204:	f890 4063 	ldrb.w	r4, [r0, #99]	; 0x63
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001208:	4d1d      	ldr	r5, [pc, #116]	; (8001280 <ASPEP_sendPing+0x84>)
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800120a:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800120e:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
                   | (uint32_t)((uint32_t)Nbit << 6U)
 8001212:	f00c 0101 	and.w	r1, ip, #1
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8001216:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 800121a:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
                   | (uint32_t)((uint32_t)ipID << 8U)
 800121e:	f004 040f 	and.w	r4, r4, #15
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8001222:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001226:	b2d3      	uxtb	r3, r2
 8001228:	4c16      	ldr	r4, [pc, #88]	; (8001284 <ASPEP_sendPing+0x88>)
 800122a:	f043 0306 	orr.w	r3, r3, #6
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800122e:	f042 0106 	orr.w	r1, r2, #6
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001232:	5ce3      	ldrb	r3, [r4, r3]
 8001234:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 8001238:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 800123a:	5ce3      	ldrb	r3, [r4, r3]
 800123c:	ea83 4312 	eor.w	r3, r3, r2, lsr #16
 8001240:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001242:	5ce3      	ldrb	r3, [r4, r3]
 8001244:	ea83 6312 	eor.w	r3, r3, r2, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 8001248:	5ceb      	ldrb	r3, [r5, r3]
 800124a:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800124e:	6203      	str	r3, [r0, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 8001250:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001252:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001254:	b143      	cbz	r3, 8001268 <ASPEP_sendPing+0x6c>
  __ASM volatile ("cpsie i" : : : "memory");
 8001256:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8001258:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800125c:	b913      	cbnz	r3, 8001264 <ASPEP_sendPing+0x68>
          pHandle->ctrlBuffer.state = pending;
 800125e:	2302      	movs	r3, #2
 8001260:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 8001264:	bc30      	pop	{r4, r5}
 8001266:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8001268:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 800126c:	2303      	movs	r3, #3
 800126e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8001272:	6481      	str	r1, [r0, #72]	; 0x48
 8001274:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 8001276:	2204      	movs	r2, #4
 8001278:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800127a:	6940      	ldr	r0, [r0, #20]
}
 800127c:	bc30      	pop	{r4, r5}
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 800127e:	4718      	bx	r3
 8001280:	0800ef80 	.word	0x0800ef80
 8001284:	0800ef90 	.word	0x0800ef90

08001288 <ASPEP_getBuffer>:
    if (MCTL_SYNC == syncAsync)
 8001288:	2a0a      	cmp	r2, #10
{
 800128a:	b410      	push	{r4}
 800128c:	4603      	mov	r3, r0
    if (MCTL_SYNC == syncAsync)
 800128e:	d00b      	beq.n	80012a8 <ASPEP_getBuffer+0x20>
      if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 8001290:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
 8001294:	2a01      	cmp	r2, #1
 8001296:	d921      	bls.n	80012dc <ASPEP_getBuffer+0x54>
 8001298:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 800129c:	2a01      	cmp	r2, #1
 800129e:	d911      	bls.n	80012c4 <ASPEP_getBuffer+0x3c>
        result = false;
 80012a0:	2000      	movs	r0, #0
}
 80012a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012a6:	4770      	bx	lr
      if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 80012a8:	f890 202e 	ldrb.w	r2, [r0, #46]	; 0x2e
 80012ac:	2a01      	cmp	r2, #1
 80012ae:	d8f7      	bhi.n	80012a0 <ASPEP_getBuffer+0x18>
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80012b0:	6a82      	ldr	r2, [r0, #40]	; 0x28
        pHandle->syncBuffer.state = writeLock;
 80012b2:	2401      	movs	r4, #1
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80012b4:	3204      	adds	r2, #4
 80012b6:	600a      	str	r2, [r1, #0]
        pHandle->syncBuffer.state = writeLock;
 80012b8:	f883 402e 	strb.w	r4, [r3, #46]	; 0x2e
  bool result = true;
 80012bc:	4620      	mov	r0, r4
}
 80012be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012c2:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012c4:	6b82      	ldr	r2, [r0, #56]	; 0x38
          pHandle->asyncBufferB.state = writeLock;
 80012c6:	2001      	movs	r0, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80012c8:	f103 0438 	add.w	r4, r3, #56	; 0x38
          pHandle->asyncBufferB.state = writeLock;
 80012cc:	f883 003e 	strb.w	r0, [r3, #62]	; 0x3e
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012d0:	3204      	adds	r2, #4
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80012d2:	641c      	str	r4, [r3, #64]	; 0x40
}
 80012d4:	f85d 4b04 	ldr.w	r4, [sp], #4
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012d8:	600a      	str	r2, [r1, #0]
}
 80012da:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012dc:	6b02      	ldr	r2, [r0, #48]	; 0x30
          pHandle->asyncBufferA.state = writeLock;
 80012de:	2001      	movs	r0, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80012e0:	f103 0430 	add.w	r4, r3, #48	; 0x30
          pHandle->asyncBufferA.state = writeLock;
 80012e4:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012e8:	3204      	adds	r2, #4
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80012ea:	641c      	str	r4, [r3, #64]	; 0x40
}
 80012ec:	f85d 4b04 	ldr.w	r4, [sp], #4
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012f0:	600a      	str	r2, [r1, #0]
}
 80012f2:	4770      	bx	lr

080012f4 <ASPEP_sendPacket>:
{
 80012f4:	4684      	mov	ip, r0
    if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 80012f6:	f890 0064 	ldrb.w	r0, [r0, #100]	; 0x64
 80012fa:	2802      	cmp	r0, #2
 80012fc:	d001      	beq.n	8001302 <ASPEP_sendPacket+0xe>
      result = ASPEP_NOT_CONNECTED;
 80012fe:	2002      	movs	r0, #2
 8001300:	4770      	bx	lr
      tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 8001302:	ea43 1002 	orr.w	r0, r3, r2, lsl #4
      *header = tmpHeader;
 8001306:	f841 0c04 	str.w	r0, [r1, #-4]
      if (1U == pHandle->Capabilities.DATA_CRC)
 800130a:	f89c 006c 	ldrb.w	r0, [ip, #108]	; 0x6c
 800130e:	2801      	cmp	r0, #1
 8001310:	d104      	bne.n	800131c <ASPEP_sendPacket+0x28>
        packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 8001312:	f64f 60ca 	movw	r0, #65226	; 0xfeca
 8001316:	5288      	strh	r0, [r1, r2]
        txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 8001318:	3202      	adds	r2, #2
 800131a:	b292      	uxth	r2, r2
      if (MCTL_SYNC == syncAsync)
 800131c:	2b0a      	cmp	r3, #10
 800131e:	d105      	bne.n	800132c <ASPEP_sendPacket+0x38>
        if (pSupHandle->MCP_PacketAvailable)
 8001320:	f89c 0010 	ldrb.w	r0, [ip, #16]
 8001324:	b378      	cbz	r0, 8001386 <ASPEP_sendPacket+0x92>
          pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 8001326:	2000      	movs	r0, #0
 8001328:	f88c 0010 	strb.w	r0, [ip, #16]
  uint32_t header = *headerPtr;
 800132c:	f851 0c04 	ldr.w	r0, [r1, #-4]
{
 8001330:	b570      	push	{r4, r5, r6, lr}
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001332:	4d35      	ldr	r5, [pc, #212]	; (8001408 <ASPEP_sendPacket+0x114>)
 8001334:	b2c4      	uxtb	r4, r0
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 8001336:	3204      	adds	r2, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001338:	5d2e      	ldrb	r6, [r5, r4]
 800133a:	f3c0 2407 	ubfx	r4, r0, #8, #8
 800133e:	4074      	eors	r4, r6
      header--; /* Header ues 4*8 bits on top of txBuffer*/
 8001340:	f1a1 0e04 	sub.w	lr, r1, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001344:	5d2e      	ldrb	r6, [r5, r4]
 8001346:	f3c0 4407 	ubfx	r4, r0, #16, #8
 800134a:	4074      	eors	r4, r6
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 800134c:	b292      	uxth	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800134e:	5d2c      	ldrb	r4, [r5, r4]
 8001350:	f3c0 6503 	ubfx	r5, r0, #24, #4
 8001354:	406c      	eors	r4, r5
 8001356:	4d2d      	ldr	r5, [pc, #180]	; (800140c <ASPEP_sendPacket+0x118>)
  *headerPtr |= (uint32_t)crc << 28;
 8001358:	5d2c      	ldrb	r4, [r5, r4]
 800135a:	ea40 7004 	orr.w	r0, r0, r4, lsl #28
 800135e:	f841 0c04 	str.w	r0, [r1, #-4]
  __ASM volatile ("cpsid i" : : : "memory");
 8001362:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001364:	f8dc 1048 	ldr.w	r1, [ip, #72]	; 0x48
 8001368:	b1e9      	cbz	r1, 80013a6 <ASPEP_sendPacket+0xb2>
  __ASM volatile ("cpsie i" : : : "memory");
 800136a:	b662      	cpsie	i
      if (MCTL_ASYNC == dataType)
 800136c:	2b09      	cmp	r3, #9
 800136e:	d00c      	beq.n	800138a <ASPEP_sendPacket+0x96>
      else if (MCTL_SYNC == dataType)
 8001370:	2b0a      	cmp	r3, #10
 8001372:	d031      	beq.n	80013d8 <ASPEP_sendPacket+0xe4>
      else if(ASPEP_CTRL == dataType)
 8001374:	2b00      	cmp	r3, #0
 8001376:	d135      	bne.n	80013e4 <ASPEP_sendPacket+0xf0>
        if (pHandle->ctrlBuffer.state != available)
 8001378:	f89c 0024 	ldrb.w	r0, [ip, #36]	; 0x24
 800137c:	bb80      	cbnz	r0, 80013e0 <ASPEP_sendPacket+0xec>
          pHandle->ctrlBuffer.state = pending;
 800137e:	2302      	movs	r3, #2
 8001380:	f88c 3024 	strb.w	r3, [ip, #36]	; 0x24
}
 8001384:	bd70      	pop	{r4, r5, r6, pc}
          result = MCTL_SYNC_NOT_EXPECTED;
 8001386:	2001      	movs	r0, #1
}
 8001388:	4770      	bx	lr
        if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 800138a:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 800138e:	6819      	ldr	r1, [r3, #0]
          result = ASPEP_BUFFER_ERROR;
 8001390:	458e      	cmp	lr, r1
 8001392:	bf14      	ite	ne
 8001394:	2003      	movne	r0, #3
 8001396:	2000      	moveq	r0, #0
        if (NULL == pHandle->asyncNextBuffer)
 8001398:	f8dc 1044 	ldr.w	r1, [ip, #68]	; 0x44
 800139c:	b381      	cbz	r1, 8001400 <ASPEP_sendPacket+0x10c>
        pHandle->lastRequestedAsyncBuff->state = pending;
 800139e:	2102      	movs	r1, #2
 80013a0:	7199      	strb	r1, [r3, #6]
        pHandle->lastRequestedAsyncBuff->length = bufferLength;
 80013a2:	809a      	strh	r2, [r3, #4]
}
 80013a4:	bd70      	pop	{r4, r5, r6, pc}
      if (MCTL_ASYNC == dataType)
 80013a6:	2b09      	cmp	r3, #9
 80013a8:	d025      	beq.n	80013f6 <ASPEP_sendPacket+0x102>
      else if (MCTL_SYNC == dataType)
 80013aa:	2b0a      	cmp	r3, #10
        pHandle->syncBuffer.state = readLock;
 80013ac:	f04f 0303 	mov.w	r3, #3
 80013b0:	bf0b      	itete	eq
 80013b2:	f88c 302e 	strbeq.w	r3, [ip, #46]	; 0x2e
        pHandle->ctrlBuffer.state = readLock;
 80013b6:	f88c 3024 	strbne.w	r3, [ip, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 80013ba:	f10c 0328 	addeq.w	r3, ip, #40	; 0x28
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80013be:	f10c 0320 	addne.w	r3, ip, #32
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80013c2:	f8cc 3048 	str.w	r3, [ip, #72]	; 0x48
 80013c6:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80013c8:	f8dc 3058 	ldr.w	r3, [ip, #88]	; 0x58
 80013cc:	f8dc 0014 	ldr.w	r0, [ip, #20]
 80013d0:	4671      	mov	r1, lr
 80013d2:	4798      	blx	r3
 80013d4:	2000      	movs	r0, #0
}
 80013d6:	bd70      	pop	{r4, r5, r6, pc}
        if (pHandle -> syncBuffer.state != writeLock)
 80013d8:	f89c 302e 	ldrb.w	r3, [ip, #46]	; 0x2e
 80013dc:	2b01      	cmp	r3, #1
 80013de:	d003      	beq.n	80013e8 <ASPEP_sendPacket+0xf4>
          result = ASPEP_BUFFER_ERROR;
 80013e0:	2003      	movs	r0, #3
}
 80013e2:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t result = ASPEP_OK;
 80013e4:	2000      	movs	r0, #0
}
 80013e6:	bd70      	pop	{r4, r5, r6, pc}
          pHandle->syncBuffer.state = pending;
 80013e8:	2302      	movs	r3, #2
 80013ea:	f88c 302e 	strb.w	r3, [ip, #46]	; 0x2e
          pHandle->syncBuffer.length = bufferLength;
 80013ee:	f8ac 202c 	strh.w	r2, [ip, #44]	; 0x2c
  uint8_t result = ASPEP_OK;
 80013f2:	2000      	movs	r0, #0
}
 80013f4:	bd70      	pop	{r4, r5, r6, pc}
        pHandle->lastRequestedAsyncBuff->state = readLock;
 80013f6:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 80013fa:	2103      	movs	r1, #3
 80013fc:	7199      	strb	r1, [r3, #6]
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80013fe:	e7e0      	b.n	80013c2 <ASPEP_sendPacket+0xce>
          pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 8001400:	f8cc 3044 	str.w	r3, [ip, #68]	; 0x44
 8001404:	e7cb      	b.n	800139e <ASPEP_sendPacket+0xaa>
 8001406:	bf00      	nop
 8001408:	0800ef90 	.word	0x0800ef90
 800140c:	0800ef80 	.word	0x0800ef80

08001410 <ASPEP_HWDataTransmittedIT>:
  * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
{
 8001410:	b510      	push	{r4, lr}
  }
  else
  {
#endif
    /* First free previous readLock buffer */
    if (pHandle->ctrlBuffer.state == readLock)
 8001412:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001416:	2b03      	cmp	r3, #3
{
 8001418:	4604      	mov	r4, r0
    if (pHandle->ctrlBuffer.state == readLock)
 800141a:	d013      	beq.n	8001444 <ASPEP_HWDataTransmittedIT+0x34>
      pHandle->ctrlBuffer.state = available;
    }
    else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
    {
      MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
      tempBuff->state = available;
 800141c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800141e:	2100      	movs	r1, #0
 8001420:	7191      	strb	r1, [r2, #6]
    }
    if (pHandle->syncBuffer.state == pending)
 8001422:	f890 202e 	ldrb.w	r2, [r0, #46]	; 0x2e
 8001426:	2a02      	cmp	r2, #2
 8001428:	d013      	beq.n	8001452 <ASPEP_HWDataTransmittedIT+0x42>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
      pHandle->syncBuffer.state = readLock;
    }
    /* Second prepare transfer of pending buffer */
    else if (pHandle->ctrlBuffer.state == pending)
 800142a:	2b02      	cmp	r3, #2
 800142c:	d11d      	bne.n	800146a <ASPEP_HWDataTransmittedIT+0x5a>
    {
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 800142e:	f100 0120 	add.w	r1, r0, #32
      pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8001432:	6d83      	ldr	r3, [r0, #88]	; 0x58
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 8001434:	6481      	str	r1, [r0, #72]	; 0x48
      pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8001436:	2204      	movs	r2, #4
 8001438:	6940      	ldr	r0, [r0, #20]
 800143a:	4798      	blx	r3
      pHandle->ctrlBuffer.state = readLock;
 800143c:	2303      	movs	r3, #3
 800143e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      __enable_irq();
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001442:	bd10      	pop	{r4, pc}
    if (pHandle->syncBuffer.state == pending)
 8001444:	f890 302e 	ldrb.w	r3, [r0, #46]	; 0x2e
      pHandle->ctrlBuffer.state = available;
 8001448:	2200      	movs	r2, #0
    if (pHandle->syncBuffer.state == pending)
 800144a:	2b02      	cmp	r3, #2
      pHandle->ctrlBuffer.state = available;
 800144c:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    if (pHandle->syncBuffer.state == pending)
 8001450:	d10b      	bne.n	800146a <ASPEP_HWDataTransmittedIT+0x5a>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8001452:	f104 0028 	add.w	r0, r4, #40	; 0x28
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8001456:	6da3      	ldr	r3, [r4, #88]	; 0x58
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8001458:	64a0      	str	r0, [r4, #72]	; 0x48
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 800145a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800145c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800145e:	6960      	ldr	r0, [r4, #20]
 8001460:	4798      	blx	r3
      pHandle->syncBuffer.state = readLock;
 8001462:	2303      	movs	r3, #3
 8001464:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
}
 8001468:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800146a:	b672      	cpsid	i
      if (pHandle->asyncNextBuffer != NULL)
 800146c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800146e:	b1cb      	cbz	r3, 80014a4 <ASPEP_HWDataTransmittedIT+0x94>
        pHandle->asyncNextBuffer->state = readLock;
 8001470:	2203      	movs	r2, #3
        pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 8001472:	64a3      	str	r3, [r4, #72]	; 0x48
        pHandle->asyncNextBuffer->state = readLock;
 8001474:	719a      	strb	r2, [r3, #6]
        pHandle->fASPEP_send(pHandle ->HWIp, pHandle->asyncNextBuffer->buffer, pHandle->asyncNextBuffer->length);
 8001476:	6819      	ldr	r1, [r3, #0]
 8001478:	889a      	ldrh	r2, [r3, #4]
 800147a:	6960      	ldr	r0, [r4, #20]
 800147c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800147e:	4798      	blx	r3
        if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 8001480:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 8001484:	2b02      	cmp	r3, #2
 8001486:	d007      	beq.n	8001498 <ASPEP_HWDataTransmittedIT+0x88>
 8001488:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 800148c:	2b02      	cmp	r3, #2
 800148e:	d003      	beq.n	8001498 <ASPEP_HWDataTransmittedIT+0x88>
          pHandle->asyncNextBuffer = NULL;
 8001490:	2300      	movs	r3, #0
 8001492:	6463      	str	r3, [r4, #68]	; 0x44
  __ASM volatile ("cpsie i" : : : "memory");
 8001494:	b662      	cpsie	i
}
 8001496:	bd10      	pop	{r4, pc}
          uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 8001498:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800149a:	0063      	lsls	r3, r4, #1
 800149c:	3368      	adds	r3, #104	; 0x68
 800149e:	1a9b      	subs	r3, r3, r2
          pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 80014a0:	6463      	str	r3, [r4, #68]	; 0x44
        {
 80014a2:	e7f7      	b.n	8001494 <ASPEP_HWDataTransmittedIT+0x84>
        pHandle->lockBuffer = NULL;
 80014a4:	64a3      	str	r3, [r4, #72]	; 0x48
 80014a6:	e7f5      	b.n	8001494 <ASPEP_HWDataTransmittedIT+0x84>

080014a8 <ASPEP_RXframeProcess>:
    uint16_t packetNumber;
#if VALID_CRC_DATA
    bool validCRCData = true;
#endif
    *packetLength = 0;
    if (pHandle->NewPacketAvailable)
 80014a8:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 80014ac:	69c2      	ldr	r2, [r0, #28]
{
 80014ae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    *packetLength = 0;
 80014b2:	2500      	movs	r5, #0
{
 80014b4:	4604      	mov	r4, r0
    *packetLength = 0;
 80014b6:	800d      	strh	r5, [r1, #0]
    if (pHandle->NewPacketAvailable)
 80014b8:	b193      	cbz	r3, 80014e0 <ASPEP_RXframeProcess+0x38>
    {
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
      switch (pHandle->ASPEP_State)
 80014ba:	f890 6064 	ldrb.w	r6, [r0, #100]	; 0x64
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 80014be:	f880 5061 	strb.w	r5, [r0, #97]	; 0x61
      switch (pHandle->ASPEP_State)
 80014c2:	2e01      	cmp	r6, #1
 80014c4:	d054      	beq.n	8001570 <ASPEP_RXframeProcess+0xc8>
 80014c6:	2e02      	cmp	r6, #2
 80014c8:	d03e      	beq.n	8001548 <ASPEP_RXframeProcess+0xa0>
 80014ca:	2e00      	cmp	r6, #0
 80014cc:	d033      	beq.n	8001536 <ASPEP_RXframeProcess+0x8e>

        default:
          break;
      }
      /* The valid received packet is now safely consumes, we are ready to receive a new packet */
      pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 80014ce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80014d0:	6960      	ldr	r0, [r4, #20]
 80014d2:	2204      	movs	r2, #4
 80014d4:	f104 011c 	add.w	r1, r4, #28
 80014d8:	4798      	blx	r3
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
  return (result);
}
 80014da:	4628      	mov	r0, r5
 80014dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if (pHandle->badPacketFlag > ASPEP_OK)
 80014e0:	f890 5062 	ldrb.w	r5, [r0, #98]	; 0x62
 80014e4:	2d00      	cmp	r5, #0
 80014e6:	d0f8      	beq.n	80014da <ASPEP_RXframeProcess+0x32>
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 80014e8:	042b      	lsls	r3, r5, #16
 80014ea:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80014ee:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80014f2:	489b      	ldr	r0, [pc, #620]	; (8001760 <ASPEP_RXframeProcess+0x2b8>)
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80014f4:	4d9b      	ldr	r5, [pc, #620]	; (8001764 <ASPEP_RXframeProcess+0x2bc>)
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80014f6:	f082 0209 	eor.w	r2, r2, #9
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80014fa:	5c81      	ldrb	r1, [r0, r2]
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 80014fc:	f043 020f 	orr.w	r2, r3, #15
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001500:	ea81 4313 	eor.w	r3, r1, r3, lsr #16
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001504:	5cc3      	ldrb	r3, [r0, r3]
  *headerPtr |= (uint32_t)crc << 28;
 8001506:	5ceb      	ldrb	r3, [r5, r3]
 8001508:	ea42 7303 	orr.w	r3, r2, r3, lsl #28
 800150c:	6223      	str	r3, [r4, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800150e:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001510:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001512:	2b00      	cmp	r3, #0
 8001514:	d03a      	beq.n	800158c <ASPEP_RXframeProcess+0xe4>
  __ASM volatile ("cpsie i" : : : "memory");
 8001516:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8001518:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800151c:	b913      	cbnz	r3, 8001524 <ASPEP_RXframeProcess+0x7c>
          pHandle->ctrlBuffer.state = pending;
 800151e:	2302      	movs	r3, #2
 8001520:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      pHandle->badPacketFlag = ASPEP_OK;
 8001524:	2500      	movs	r5, #0
      pHandle->fASPEP_HWSync(pHandle->HWIp);
 8001526:	6960      	ldr	r0, [r4, #20]
 8001528:	6d23      	ldr	r3, [r4, #80]	; 0x50
      pHandle->badPacketFlag = ASPEP_OK;
 800152a:	f884 5062 	strb.w	r5, [r4, #98]	; 0x62
      pHandle->fASPEP_HWSync(pHandle->HWIp);
 800152e:	4798      	blx	r3
}
 8001530:	4628      	mov	r0, r5
 8001532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if (BEACON == pHandle->rxPacketType)
 8001536:	6e81      	ldr	r1, [r0, #104]	; 0x68
 8001538:	2905      	cmp	r1, #5
 800153a:	f000 809e 	beq.w	800167a <ASPEP_RXframeProcess+0x1d2>
          else if (PING == pHandle->rxPacketType)
 800153e:	2906      	cmp	r1, #6
 8001540:	f000 80e3 	beq.w	800170a <ASPEP_RXframeProcess+0x262>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001544:	4635      	mov	r5, r6
 8001546:	e7c2      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
          if (BEACON == pHandle->rxPacketType)
 8001548:	6e86      	ldr	r6, [r0, #104]	; 0x68
 800154a:	2e05      	cmp	r6, #5
 800154c:	d060      	beq.n	8001610 <ASPEP_RXframeProcess+0x168>
          else if (PING == pHandle->rxPacketType)
 800154e:	2e06      	cmp	r6, #6
 8001550:	f000 80e2 	beq.w	8001718 <ASPEP_RXframeProcess+0x270>
          else if (DATA_PACKET == pHandle->rxPacketType)
 8001554:	2e09      	cmp	r6, #9
 8001556:	d1ba      	bne.n	80014ce <ASPEP_RXframeProcess+0x26>
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001558:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
              *packetLength = pHandle->rxLength;
 800155c:	f8b0 205c 	ldrh.w	r2, [r0, #92]	; 0x5c
              result = pHandle->rxBuffer;
 8001560:	69a5      	ldr	r5, [r4, #24]
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001562:	3301      	adds	r3, #1
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 8001564:	2001      	movs	r0, #1
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001566:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 800156a:	7420      	strb	r0, [r4, #16]
              *packetLength = pHandle->rxLength;
 800156c:	800a      	strh	r2, [r1, #0]
              result = pHandle->rxBuffer;
 800156e:	e7ae      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
          if (BEACON == pHandle->rxPacketType)
 8001570:	6e81      	ldr	r1, [r0, #104]	; 0x68
 8001572:	2905      	cmp	r1, #5
 8001574:	d016      	beq.n	80015a4 <ASPEP_RXframeProcess+0xfc>
          else if (PING == pHandle->rxPacketType)
 8001576:	2906      	cmp	r1, #6
 8001578:	d1a9      	bne.n	80014ce <ASPEP_RXframeProcess+0x26>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 800157a:	f3c2 320f 	ubfx	r2, r2, #12, #16
 800157e:	4631      	mov	r1, r6
 8001580:	f7ff fe3c 	bl	80011fc <ASPEP_sendPing>
            pHandle->ASPEP_State = ASPEP_CONNECTED;
 8001584:	2302      	movs	r3, #2
 8001586:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800158a:	e7a0      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 800158c:	f104 0120 	add.w	r1, r4, #32
        pHandle->ctrlBuffer.state = readLock;
 8001590:	2303      	movs	r3, #3
 8001592:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8001596:	64a1      	str	r1, [r4, #72]	; 0x48
 8001598:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 800159a:	2204      	movs	r2, #4
 800159c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800159e:	6960      	ldr	r0, [r4, #20]
 80015a0:	4798      	blx	r3
  return (result);
 80015a2:	e7bf      	b.n	8001524 <ASPEP_RXframeProcess+0x7c>
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80015a4:	7f03      	ldrb	r3, [r0, #28]
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80015a6:	7f40      	ldrb	r0, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80015a8:	f894 106d 	ldrb.w	r1, [r4, #109]	; 0x6d
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015ac:	f894 606c 	ldrb.w	r6, [r4, #108]	; 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015b0:	f894 706e 	ldrb.w	r7, [r4, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015b4:	f894 e06f 	ldrb.w	lr, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80015b8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80015bc:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80015be:	4281      	cmp	r1, r0
 80015c0:	bf28      	it	cs
 80015c2:	4601      	movcs	r1, r0
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015c4:	42b3      	cmp	r3, r6
 80015c6:	469c      	mov	ip, r3
 80015c8:	bf28      	it	cs
 80015ca:	46b4      	movcs	ip, r6
 80015cc:	f36c 0507 	bfi	r5, ip, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 80015d0:	f3c2 3c86 	ubfx	ip, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80015d4:	f3c2 5846 	ubfx	r8, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015d8:	45bc      	cmp	ip, r7
 80015da:	46e1      	mov	r9, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015dc:	f361 250f 	bfi	r5, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015e0:	bf28      	it	cs
 80015e2:	46b9      	movcs	r9, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015e4:	45f0      	cmp	r8, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015e6:	f369 4517 	bfi	r5, r9, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015ea:	46c1      	mov	r9, r8
 80015ec:	bf28      	it	cs
 80015ee:	46f1      	movcs	r9, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015f0:	f369 651f 	bfi	r5, r9, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80015f4:	42b3      	cmp	r3, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015f6:	66e5      	str	r5, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80015f8:	f240 8093 	bls.w	8001722 <ASPEP_RXframeProcess+0x27a>
              pHandle->ASPEP_State = ASPEP_IDLE;
 80015fc:	2300      	movs	r3, #0
 80015fe:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8001602:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 8001606:	4620      	mov	r0, r4
 8001608:	f7ff fdb2 	bl	8001170 <ASPEP_sendBeacon>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 800160c:	2500      	movs	r5, #0
 800160e:	e75e      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8001610:	7f46      	ldrb	r6, [r0, #29]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001612:	f890 c06c 	ldrb.w	ip, [r0, #108]	; 0x6c
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001616:	7f03      	ldrb	r3, [r0, #28]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8001618:	f890 006d 	ldrb.w	r0, [r0, #109]	; 0x6d
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 800161c:	f894 e06e 	ldrb.w	lr, [r4, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001620:	f894 806f 	ldrb.w	r8, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8001624:	f006 063f 	and.w	r6, r6, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001628:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 800162a:	42b0      	cmp	r0, r6
 800162c:	bf28      	it	cs
 800162e:	4630      	movcs	r0, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001630:	4563      	cmp	r3, ip
 8001632:	461f      	mov	r7, r3
 8001634:	4629      	mov	r1, r5
 8001636:	bf28      	it	cs
 8001638:	4667      	movcs	r7, ip
 800163a:	f367 0107 	bfi	r1, r7, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 800163e:	f3c2 3786 	ubfx	r7, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8001642:	f3c2 5946 	ubfx	r9, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8001646:	4577      	cmp	r7, lr
 8001648:	46ba      	mov	sl, r7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800164a:	f360 210f 	bfi	r1, r0, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 800164e:	bf28      	it	cs
 8001650:	46f2      	movcs	sl, lr
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001652:	45c1      	cmp	r9, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001654:	f36a 4117 	bfi	r1, sl, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001658:	46ca      	mov	sl, r9
 800165a:	bf28      	it	cs
 800165c:	46c2      	movcs	sl, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800165e:	f36a 611f 	bfi	r1, sl, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8001662:	4563      	cmp	r3, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001664:	66e1      	str	r1, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8001666:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 800166a:	d96b      	bls.n	8001744 <ASPEP_RXframeProcess+0x29c>
 800166c:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8001670:	4620      	mov	r0, r4
 8001672:	f7ff fd7d 	bl	8001170 <ASPEP_sendBeacon>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001676:	2500      	movs	r5, #0
 8001678:	e729      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800167a:	7f45      	ldrb	r5, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 800167c:	f890 106d 	ldrb.w	r1, [r0, #109]	; 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001680:	7f03      	ldrb	r3, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001682:	f890 e06c 	ldrb.w	lr, [r0, #108]	; 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8001686:	f890 706e 	ldrb.w	r7, [r0, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 800168a:	f894 906f 	ldrb.w	r9, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800168e:	f005 053f 	and.w	r5, r5, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001692:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8001694:	42a9      	cmp	r1, r5
 8001696:	bf28      	it	cs
 8001698:	4629      	movcs	r1, r5
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800169a:	4573      	cmp	r3, lr
 800169c:	4618      	mov	r0, r3
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 800169e:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016a2:	bf28      	it	cs
 80016a4:	4670      	movcs	r0, lr
 80016a6:	f360 0607 	bfi	r6, r0, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80016aa:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80016ae:	45b8      	cmp	r8, r7
 80016b0:	4640      	mov	r0, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016b2:	f361 260f 	bfi	r6, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80016b6:	bf28      	it	cs
 80016b8:	4638      	movcs	r0, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80016ba:	45ca      	cmp	sl, r9
 80016bc:	46d4      	mov	ip, sl
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016be:	f360 4617 	bfi	r6, r0, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80016c2:	bf28      	it	cs
 80016c4:	46cc      	movcs	ip, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016c6:	f36c 661f 	bfi	r6, ip, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80016ca:	4573      	cmp	r3, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016cc:	66e6      	str	r6, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80016ce:	d898      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 80016d0:	428d      	cmp	r5, r1
 80016d2:	d896      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 80016d4:	45b8      	cmp	r8, r7
 80016d6:	d894      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 80016d8:	45ca      	cmp	sl, r9
 80016da:	d892      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 80016dc:	f3c2 1302 	ubfx	r3, r2, #4, #3
 80016e0:	f894 2070 	ldrb.w	r2, [r4, #112]	; 0x70
 80016e4:	429a      	cmp	r2, r3
 80016e6:	d18c      	bne.n	8001602 <ASPEP_RXframeProcess+0x15a>
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016e8:	1c4b      	adds	r3, r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016ea:	1c42      	adds	r2, r0, #1
 80016ec:	b2d2      	uxtb	r2, r2
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016ee:	b2db      	uxtb	r3, r3
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016f0:	0152      	lsls	r2, r2, #5
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 80016f2:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016f6:	015b      	lsls	r3, r3, #5
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 80016f8:	2101      	movs	r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016fa:	81a2      	strh	r2, [r4, #12]
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 80016fc:	f8a4 c00e 	strh.w	ip, [r4, #14]
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8001700:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8001704:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
 8001708:	e77b      	b.n	8001602 <ASPEP_RXframeProcess+0x15a>
            ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 800170a:	f3c2 320f 	ubfx	r2, r2, #12, #16
 800170e:	4631      	mov	r1, r6
 8001710:	f7ff fd74 	bl	80011fc <ASPEP_sendPing>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001714:	4635      	mov	r5, r6
 8001716:	e6da      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 8001718:	7f42      	ldrb	r2, [r0, #29]
 800171a:	2101      	movs	r1, #1
 800171c:	f7ff fd6e 	bl	80011fc <ASPEP_sendPing>
 8001720:	e6d5      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8001722:	4288      	cmp	r0, r1
 8001724:	f63f af6a 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8001728:	45bc      	cmp	ip, r7
 800172a:	f63f af67 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 800172e:	45f0      	cmp	r8, lr
 8001730:	f63f af64 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8001734:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
 8001738:	f3c2 1302 	ubfx	r3, r2, #4, #3
 800173c:	4299      	cmp	r1, r3
 800173e:	f47f af5d 	bne.w	80015fc <ASPEP_RXframeProcess+0x154>
 8001742:	e75e      	b.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8001744:	4286      	cmp	r6, r0
 8001746:	d891      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8001748:	4577      	cmp	r7, lr
 800174a:	d88f      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 800174c:	45c1      	cmp	r9, r8
 800174e:	d88d      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8001750:	f894 5070 	ldrb.w	r5, [r4, #112]	; 0x70
 8001754:	f3c2 1302 	ubfx	r3, r2, #4, #3
              pHandle->ASPEP_State = ASPEP_IDLE;
 8001758:	1aeb      	subs	r3, r5, r3
 800175a:	425d      	negs	r5, r3
 800175c:	415d      	adcs	r5, r3
 800175e:	e785      	b.n	800166c <ASPEP_RXframeProcess+0x1c4>
 8001760:	0800ef90 	.word	0x0800ef90
 8001764:	0800ef80 	.word	0x0800ef80

08001768 <ASPEP_HWDataReceivedIT>:
  * If the packet received contains an error in the header, the HW IP will be re-synchronised first, and DMA will be configured after.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataReceivedIT(ASPEP_Handle_t *pHandle)
{
 8001768:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    switch (pHandle->ASPEP_TL_State)
 800176a:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
{
 800176e:	4604      	mov	r4, r0
    switch (pHandle->ASPEP_TL_State)
 8001770:	b13b      	cbz	r3, 8001782 <ASPEP_HWDataReceivedIT+0x1a>
 8001772:	2b01      	cmp	r3, #1
 8001774:	d104      	bne.n	8001780 <ASPEP_HWDataReceivedIT+0x18>
        break;
      }

      case WAITING_PAYLOAD:
      {
        pHandle->ASPEP_TL_State = WAITING_PACKET;
 8001776:	2200      	movs	r2, #0
 8001778:	f880 2065 	strb.w	r2, [r0, #101]	; 0x65
        /* Payload received, */
        pHandle->NewPacketAvailable = true;
 800177c:	f880 3061 	strb.w	r3, [r0, #97]	; 0x61
        break;
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001780:	bd10      	pop	{r4, pc}
        if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-11.3
 8001782:	69c1      	ldr	r1, [r0, #28]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001784:	4a1e      	ldr	r2, [pc, #120]	; (8001800 <ASPEP_HWDataReceivedIT+0x98>)
 8001786:	b2cb      	uxtb	r3, r1
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001788:	5cd3      	ldrb	r3, [r2, r3]
 800178a:	ea83 2311 	eor.w	r3, r3, r1, lsr #8
 800178e:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001790:	5cd3      	ldrb	r3, [r2, r3]
 8001792:	ea83 4311 	eor.w	r3, r3, r1, lsr #16
 8001796:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 8001798:	5cd3      	ldrb	r3, [r2, r3]
 800179a:	ea83 6311 	eor.w	r3, r3, r1, lsr #24
        if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-11.3
 800179e:	5cd3      	ldrb	r3, [r2, r3]
 80017a0:	b95b      	cbnz	r3, 80017ba <ASPEP_HWDataReceivedIT+0x52>
          pHandle->rxPacketType = (ASPEP_packetType)(((uint32_t)pHandle->rxHeader[0]) & ID_MASK);
 80017a2:	7f03      	ldrb	r3, [r0, #28]
 80017a4:	f003 030f 	and.w	r3, r3, #15
 80017a8:	2b06      	cmp	r3, #6
 80017aa:	6683      	str	r3, [r0, #104]	; 0x68
          switch (pHandle->rxPacketType)
 80017ac:	d809      	bhi.n	80017c2 <ASPEP_HWDataReceivedIT+0x5a>
 80017ae:	2b04      	cmp	r3, #4
 80017b0:	d81e      	bhi.n	80017f0 <ASPEP_HWDataReceivedIT+0x88>
              pHandle->badPacketFlag = ASPEP_BAD_PACKET_TYPE;
 80017b2:	2301      	movs	r3, #1
 80017b4:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
}
 80017b8:	bd10      	pop	{r4, pc}
          pHandle->badPacketFlag = ASPEP_BAD_CRC_HEADER;
 80017ba:	2304      	movs	r3, #4
 80017bc:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
}
 80017c0:	bd10      	pop	{r4, pc}
 80017c2:	2b09      	cmp	r3, #9
 80017c4:	d1f5      	bne.n	80017b2 <ASPEP_HWDataReceivedIT+0x4a>
              pHandle->rxLength = (uint16_t)((*((uint16_t *)pHandle->rxHeader) & 0x1FFF0U) >> (uint16_t)4);
 80017c6:	8b83      	ldrh	r3, [r0, #28]
 80017c8:	091b      	lsrs	r3, r3, #4
 80017ca:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
              if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 80017ce:	b17b      	cbz	r3, 80017f0 <ASPEP_HWDataReceivedIT+0x88>
              else if (pHandle->rxLength <= pHandle->maxRXPayload)
 80017d0:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80017d4:	429a      	cmp	r2, r3
 80017d6:	d30f      	bcc.n	80017f8 <ASPEP_HWDataReceivedIT+0x90>
                pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxBuffer,  /* need to read + 2 bytes CRC*/
 80017d8:	f890 206c 	ldrb.w	r2, [r0, #108]	; 0x6c
 80017dc:	6981      	ldr	r1, [r0, #24]
 80017de:	6940      	ldr	r0, [r0, #20]
 80017e0:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 80017e4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80017e6:	4798      	blx	r3
                pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 80017e8:	2301      	movs	r3, #1
 80017ea:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
}
 80017ee:	bd10      	pop	{r4, pc}
              pHandle->NewPacketAvailable = true;
 80017f0:	2301      	movs	r3, #1
 80017f2:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
}
 80017f6:	bd10      	pop	{r4, pc}
                pHandle->badPacketFlag = ASPEP_BAD_PACKET_SIZE;
 80017f8:	2302      	movs	r3, #2
 80017fa:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
}
 80017fe:	bd10      	pop	{r4, pc}
 8001800:	0800ef90 	.word	0x0800ef90

08001804 <ASPEP_HWDMAReset>:
  * @brief  Resets DMA after debugger has stopped the MCU.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDMAReset(ASPEP_Handle_t *pHandle)
{
 8001804:	4601      	mov	r1, r0
  {
#endif
    /* We must reset the RX state machine to be sure to not be in Waiting packet state */
    /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
    /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
    pHandle->ASPEP_TL_State = WAITING_PACKET;
 8001806:	2200      	movs	r2, #0
 8001808:	f880 2065 	strb.w	r2, [r0, #101]	; 0x65
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800180c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800180e:	6940      	ldr	r0, [r0, #20]
 8001810:	2204      	movs	r2, #4
 8001812:	311c      	adds	r1, #28
 8001814:	4718      	bx	r3
 8001816:	bf00      	nop

08001818 <MX_CORDIC_Init>:
  /* USER CODE END CORDIC_Init 0 */

  /* USER CODE BEGIN CORDIC_Init 1 */

  /* USER CODE END CORDIC_Init 1 */
  hcordic.Instance = CORDIC;
 8001818:	4805      	ldr	r0, [pc, #20]	; (8001830 <MX_CORDIC_Init+0x18>)
{
 800181a:	b508      	push	{r3, lr}
  hcordic.Instance = CORDIC;
 800181c:	4b05      	ldr	r3, [pc, #20]	; (8001834 <MX_CORDIC_Init+0x1c>)
 800181e:	6003      	str	r3, [r0, #0]
  if (HAL_CORDIC_Init(&hcordic) != HAL_OK)
 8001820:	f004 fd98 	bl	8006354 <HAL_CORDIC_Init>
 8001824:	b900      	cbnz	r0, 8001828 <MX_CORDIC_Init+0x10>
  }
  /* USER CODE BEGIN CORDIC_Init 2 */

  /* USER CODE END CORDIC_Init 2 */

}
 8001826:	bd08      	pop	{r3, pc}
 8001828:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 800182c:	f000 ba04 	b.w	8001c38 <Error_Handler>
 8001830:	200019f8 	.word	0x200019f8
 8001834:	40020c00 	.word	0x40020c00

08001838 <HAL_CORDIC_MspInit>:

void HAL_CORDIC_MspInit(CORDIC_HandleTypeDef* cordicHandle)
{

  if(cordicHandle->Instance==CORDIC)
 8001838:	4b0a      	ldr	r3, [pc, #40]	; (8001864 <HAL_CORDIC_MspInit+0x2c>)
 800183a:	6802      	ldr	r2, [r0, #0]
 800183c:	429a      	cmp	r2, r3
 800183e:	d000      	beq.n	8001842 <HAL_CORDIC_MspInit+0xa>
 8001840:	4770      	bx	lr
  {
  /* USER CODE BEGIN CORDIC_MspInit 0 */

  /* USER CODE END CORDIC_MspInit 0 */
    /* CORDIC clock enable */
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8001842:	f8d3 2448 	ldr.w	r2, [r3, #1096]	; 0x448
 8001846:	f042 0208 	orr.w	r2, r2, #8
 800184a:	f8c3 2448 	str.w	r2, [r3, #1096]	; 0x448
 800184e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
{
 8001852:	b082      	sub	sp, #8
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8001854:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001856:	f003 0308 	and.w	r3, r3, #8
 800185a:	9301      	str	r3, [sp, #4]
 800185c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CORDIC_MspInit 1 */

  /* USER CODE END CORDIC_MspInit 1 */
  }
}
 800185e:	b002      	add	sp, #8
 8001860:	4770      	bx	lr
 8001862:	bf00      	nop
 8001864:	40020c00 	.word	0x40020c00

08001868 <MX_CRC_Init>:
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 8001868:	4808      	ldr	r0, [pc, #32]	; (800188c <MX_CRC_Init+0x24>)
 800186a:	4909      	ldr	r1, [pc, #36]	; (8001890 <MX_CRC_Init+0x28>)
{
 800186c:	b508      	push	{r3, lr}
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800186e:	2300      	movs	r3, #0
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 8001870:	2201      	movs	r2, #1
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 8001872:	8083      	strh	r3, [r0, #4]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8001874:	e9c0 3305 	strd	r3, r3, [r0, #20]
  hcrc.Instance = CRC;
 8001878:	6001      	str	r1, [r0, #0]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 800187a:	6202      	str	r2, [r0, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800187c:	f004 fe02 	bl	8006484 <HAL_CRC_Init>
 8001880:	b900      	cbnz	r0, 8001884 <MX_CRC_Init+0x1c>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 8001882:	bd08      	pop	{r3, pc}
 8001884:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8001888:	f000 b9d6 	b.w	8001c38 <Error_Handler>
 800188c:	20001a20 	.word	0x20001a20
 8001890:	40023000 	.word	0x40023000

08001894 <HAL_CRC_MspInit>:

void HAL_CRC_MspInit(CRC_HandleTypeDef* crcHandle)
{

  if(crcHandle->Instance==CRC)
 8001894:	4b09      	ldr	r3, [pc, #36]	; (80018bc <HAL_CRC_MspInit+0x28>)
 8001896:	6802      	ldr	r2, [r0, #0]
 8001898:	429a      	cmp	r2, r3
 800189a:	d000      	beq.n	800189e <HAL_CRC_MspInit+0xa>
 800189c:	4770      	bx	lr
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* CRC clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 800189e:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
{
 80018a2:	b082      	sub	sp, #8
    __HAL_RCC_CRC_CLK_ENABLE();
 80018a4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018a6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80018aa:	649a      	str	r2, [r3, #72]	; 0x48
 80018ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80018ae:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80018b2:	9301      	str	r3, [sp, #4]
 80018b4:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }
}
 80018b6:	b002      	add	sp, #8
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop
 80018bc:	40023000 	.word	0x40023000

080018c0 <MX_DMA_Init>:
  */
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 80018c0:	4b0a      	ldr	r3, [pc, #40]	; (80018ec <MX_DMA_Init+0x2c>)
 80018c2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018c4:	f042 0204 	orr.w	r2, r2, #4
 80018c8:	649a      	str	r2, [r3, #72]	; 0x48
 80018ca:	6c9a      	ldr	r2, [r3, #72]	; 0x48
{
 80018cc:	b082      	sub	sp, #8
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 80018ce:	f002 0204 	and.w	r2, r2, #4
 80018d2:	9200      	str	r2, [sp, #0]
 80018d4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80018d6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018d8:	f042 0201 	orr.w	r2, r2, #1
 80018dc:	649a      	str	r2, [r3, #72]	; 0x48
 80018de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80018e0:	f003 0301 	and.w	r3, r3, #1
 80018e4:	9301      	str	r3, [sp, #4]
 80018e6:	9b01      	ldr	r3, [sp, #4]

}
 80018e8:	b002      	add	sp, #8
 80018ea:	4770      	bx	lr
 80018ec:	40021000 	.word	0x40021000

080018f0 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80018f0:	b500      	push	{lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018f2:	2200      	movs	r2, #0
{
 80018f4:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018f6:	e9cd 2206 	strd	r2, r2, [sp, #24]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80018fa:	4b1b      	ldr	r3, [pc, #108]	; (8001968 <MX_GPIO_Init+0x78>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018fc:	9208      	str	r2, [sp, #32]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80018fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = Start_Stop_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8001900:	481a      	ldr	r0, [pc, #104]	; (800196c <MX_GPIO_Init+0x7c>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001902:	f042 0204 	orr.w	r2, r2, #4
 8001906:	64da      	str	r2, [r3, #76]	; 0x4c
 8001908:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800190a:	f002 0204 	and.w	r2, r2, #4
 800190e:	9200      	str	r2, [sp, #0]
 8001910:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001912:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001914:	f042 0220 	orr.w	r2, r2, #32
 8001918:	64da      	str	r2, [r3, #76]	; 0x4c
 800191a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800191c:	f002 0220 	and.w	r2, r2, #32
 8001920:	9201      	str	r2, [sp, #4]
 8001922:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001924:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001926:	f042 0201 	orr.w	r2, r2, #1
 800192a:	64da      	str	r2, [r3, #76]	; 0x4c
 800192c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800192e:	f002 0201 	and.w	r2, r2, #1
 8001932:	9202      	str	r2, [sp, #8]
 8001934:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001936:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001938:	f042 0202 	orr.w	r2, r2, #2
 800193c:	64da      	str	r2, [r3, #76]	; 0x4c
 800193e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 8001940:	ed9f 7b07 	vldr	d7, [pc, #28]	; 8001960 <MX_GPIO_Init+0x70>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001944:	f003 0302 	and.w	r3, r3, #2
 8001948:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 800194a:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 800194c:	ed8d 7b04 	vstr	d7, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001950:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8001952:	f004 fe9f 	bl	8006694 <HAL_GPIO_Init>

}
 8001956:	b00b      	add	sp, #44	; 0x2c
 8001958:	f85d fb04 	ldr.w	pc, [sp], #4
 800195c:	f3af 8000 	nop.w
 8001960:	00002000 	.word	0x00002000
 8001964:	00210000 	.word	0x00210000
 8001968:	40021000 	.word	0x40021000
 800196c:	48000800 	.word	0x48000800

08001970 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001970:	b510      	push	{r4, lr}
 8001972:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001974:	2238      	movs	r2, #56	; 0x38
 8001976:	2100      	movs	r1, #0
 8001978:	a806      	add	r0, sp, #24
 800197a:	f00b fec7 	bl	800d70c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800197e:	2000      	movs	r0, #0
 8001980:	e9cd 0001 	strd	r0, r0, [sp, #4]
 8001984:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8001988:	9005      	str	r0, [sp, #20]

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 800198a:	f004 ff7d 	bl	8006888 <HAL_PWREx_ControlVoltageScaling>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800198e:	2001      	movs	r0, #1
 8001990:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8001994:	2206      	movs	r2, #6
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001996:	e9cd 0106 	strd	r0, r1, [sp, #24]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800199a:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800199c:	2403      	movs	r4, #3
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 800199e:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 80019a0:	2155      	movs	r1, #85	; 0x55
 80019a2:	2208      	movs	r2, #8
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019a4:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80019a6:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 80019aa:	e9cd 1210 	strd	r1, r2, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80019ae:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019b2:	f004 ffe7 	bl	8006984 <HAL_RCC_OscConfig>
 80019b6:	b108      	cbz	r0, 80019bc <SystemClock_Config+0x4c>
  __ASM volatile ("cpsid i" : : : "memory");
 80019b8:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80019ba:	e7fe      	b.n	80019ba <SystemClock_Config+0x4a>
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019bc:	2104      	movs	r1, #4
 80019be:	4603      	mov	r3, r0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80019c0:	220f      	movs	r2, #15
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019c2:	eb0d 0001 	add.w	r0, sp, r1
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80019c6:	e9cd 2401 	strd	r2, r4, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80019ca:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80019ce:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019d0:	f005 fa5c 	bl	8006e8c <HAL_RCC_ClockConfig>
 80019d4:	b108      	cbz	r0, 80019da <SystemClock_Config+0x6a>
 80019d6:	b672      	cpsid	i
  while (1)
 80019d8:	e7fe      	b.n	80019d8 <SystemClock_Config+0x68>
  HAL_RCC_EnableCSS();
 80019da:	f005 fb85 	bl	80070e8 <HAL_RCC_EnableCSS>
}
 80019de:	b014      	add	sp, #80	; 0x50
 80019e0:	bd10      	pop	{r4, pc}
 80019e2:	bf00      	nop
 80019e4:	0000      	movs	r0, r0
	...

080019e8 <main>:
{
 80019e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  data_flag=0;
 80019ec:	4d82      	ldr	r5, [pc, #520]	; (8001bf8 <main+0x210>)
 80019ee:	f8df 8238 	ldr.w	r8, [pc, #568]	; 8001c28 <main+0x240>
 80019f2:	4f82      	ldr	r7, [pc, #520]	; (8001bfc <main+0x214>)
 80019f4:	f8df b234 	ldr.w	fp, [pc, #564]	; 8001c2c <main+0x244>
 80019f8:	f8df a234 	ldr.w	sl, [pc, #564]	; 8001c30 <main+0x248>
      HAL_TIM_Base_Start(&htim3);
 80019fc:	f8df 9234 	ldr.w	r9, [pc, #564]	; 8001c34 <main+0x24c>
{
 8001a00:	ed2d 8b02 	vpush	{d8}
  data_flag=0;
 8001a04:	2400      	movs	r4, #0
 8001a06:	702c      	strb	r4, [r5, #0]
  HAL_Init();
 8001a08:	f003 fcfc 	bl	8005404 <HAL_Init>
  SystemClock_Config();
 8001a0c:	f7ff ffb0 	bl	8001970 <SystemClock_Config>
  MX_GPIO_Init();
 8001a10:	f7ff ff6e 	bl	80018f0 <MX_GPIO_Init>
  MX_DMA_Init();
 8001a14:	f7ff ff54 	bl	80018c0 <MX_DMA_Init>
  MX_ADC1_Init();
 8001a18:	f7ff fa18 	bl	8000e4c <MX_ADC1_Init>
  MX_CORDIC_Init();
 8001a1c:	f7ff fefc 	bl	8001818 <MX_CORDIC_Init>
  MX_TIM1_Init();
 8001a20:	f003 faba 	bl	8004f98 <MX_TIM1_Init>
  MX_TIM2_Init();
 8001a24:	f003 f93a 	bl	8004c9c <MX_TIM2_Init>
  MX_USART2_UART_Init();
 8001a28:	f003 fb70 	bl	800510c <MX_USART2_UART_Init>
  MX_MotorControl_Init();
 8001a2c:	f001 f92a 	bl	8002c84 <MX_MotorControl_Init>
  MX_CRC_Init();
 8001a30:	f7ff ff1a 	bl	8001868 <MX_CRC_Init>
  MX_TIM3_Init();
 8001a34:	f003 f968 	bl	8004d08 <MX_TIM3_Init>
  MX_TIM5_Init();
 8001a38:	f003 f9a2 	bl	8004d80 <MX_TIM5_Init>
  MX_X_CUBE_AI_Init();
 8001a3c:	f7ff faf2 	bl	8001024 <MX_X_CUBE_AI_Init>
  HAL_NVIC_SetPriority(USART2_IRQn, 3, 1);
 8001a40:	2103      	movs	r1, #3
 8001a42:	2201      	movs	r2, #1
 8001a44:	2026      	movs	r0, #38	; 0x26
 8001a46:	f004 fcb1 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001a4a:	2026      	movs	r0, #38	; 0x26
 8001a4c:	f004 fcec 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 8001a50:	4622      	mov	r2, r4
 8001a52:	2103      	movs	r1, #3
 8001a54:	200b      	movs	r0, #11
 8001a56:	f004 fca9 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8001a5a:	200b      	movs	r0, #11
 8001a5c:	f004 fce4 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_BRK_TIM15_IRQn, 4, 1);
 8001a60:	2201      	movs	r2, #1
 8001a62:	2104      	movs	r1, #4
 8001a64:	2018      	movs	r0, #24
 8001a66:	f004 fca1 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_BRK_TIM15_IRQn);
 8001a6a:	2018      	movs	r0, #24
 8001a6c:	f004 fcdc 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 0, 0);
 8001a70:	4622      	mov	r2, r4
 8001a72:	4621      	mov	r1, r4
 8001a74:	2019      	movs	r0, #25
 8001a76:	f004 fc99 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 8001a7a:	2019      	movs	r0, #25
 8001a7c:	f004 fcd4 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(ADC1_2_IRQn, 2, 0);
 8001a80:	4622      	mov	r2, r4
 8001a82:	2102      	movs	r1, #2
 8001a84:	2012      	movs	r0, #18
 8001a86:	f004 fc91 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 8001a8a:	2012      	movs	r0, #18
 8001a8c:	f004 fccc 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);
 8001a90:	4622      	mov	r2, r4
 8001a92:	2103      	movs	r1, #3
 8001a94:	201c      	movs	r0, #28
 8001a96:	f004 fc89 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8001a9a:	201c      	movs	r0, #28
 8001a9c:	f004 fcc4 	bl	8006428 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 3, 0);
 8001aa0:	4622      	mov	r2, r4
 8001aa2:	2103      	movs	r1, #3
 8001aa4:	2028      	movs	r0, #40	; 0x28
 8001aa6:	f004 fc81 	bl	80063ac <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8001aaa:	2028      	movs	r0, #40	; 0x28
 8001aac:	f004 fcbc 	bl	8006428 <HAL_NVIC_EnableIRQ>
  MC_StartMotor1();
 8001ab0:	f000 f8c4 	bl	8001c3c <MC_StartMotor1>
  MC_ProgramTorqueRampMotor1_F(0.0, 0);
 8001ab4:	4620      	mov	r0, r4
 8001ab6:	ed9f 0a52 	vldr	s0, [pc, #328]	; 8001c00 <main+0x218>
      float enc_mec_angle = (float)ENCODER_M1._Super.hMecAngle/65536*2*M_PI;
 8001aba:	eddf 8a52 	vldr	s17, [pc, #328]	; 8001c04 <main+0x21c>
 8001abe:	4c52      	ldr	r4, [pc, #328]	; (8001c08 <main+0x220>)
  MC_ProgramTorqueRampMotor1_F(0.0, 0);
 8001ac0:	f000 f8c8 	bl	8001c54 <MC_ProgramTorqueRampMotor1_F>
  HAL_TIM_Base_Start_IT(&htim5);
 8001ac4:	4851      	ldr	r0, [pc, #324]	; (8001c0c <main+0x224>)
 8001ac6:	f005 fe6b 	bl	80077a0 <HAL_TIM_Base_Start_IT>
    if(data_flag)
 8001aca:	782b      	ldrb	r3, [r5, #0]
 8001acc:	2b00      	cmp	r3, #0
 8001ace:	d0fc      	beq.n	8001aca <main+0xe2>
      TIM3->CNT = 0;
 8001ad0:	4b4f      	ldr	r3, [pc, #316]	; (8001c10 <main+0x228>)
 8001ad2:	2600      	movs	r6, #0
 8001ad4:	625e      	str	r6, [r3, #36]	; 0x24
      HAL_TIM_Base_Start(&htim3);
 8001ad6:	4648      	mov	r0, r9
 8001ad8:	f005 fe12 	bl	8007700 <HAL_TIM_Base_Start>
      float enc_mec_angle = (float)ENCODER_M1._Super.hMecAngle/65536*2*M_PI;
 8001adc:	4b4d      	ldr	r3, [pc, #308]	; (8001c14 <main+0x22c>)
 8001ade:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8001ae2:	ee07 3a90 	vmov	s15, r3
 8001ae6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001aea:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8001aee:	ee17 0a90 	vmov	r0, s15
 8001af2:	f7fe fd49 	bl	8000588 <__aeabi_f2d>
 8001af6:	a33a      	add	r3, pc, #232	; (adr r3, 8001be0 <main+0x1f8>)
 8001af8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001afc:	f7fe fd9c 	bl	8000638 <__aeabi_dmul>
 8001b00:	f7fe ffac 	bl	8000a5c <__aeabi_d2f>
    float offset_angle = angle + M_PI;
 8001b04:	f7fe fd40 	bl	8000588 <__aeabi_f2d>
 8001b08:	a335      	add	r3, pc, #212	; (adr r3, 8001be0 <main+0x1f8>)
 8001b0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001b0e:	f7fe fbdd 	bl	80002cc <__adddf3>
 8001b12:	f7fe ffa3 	bl	8000a5c <__aeabi_d2f>
    *sin_component = sinf(offset_angle);
 8001b16:	ee00 0a10 	vmov	s0, r0
    float offset_angle = angle + M_PI;
 8001b1a:	ee08 0a10 	vmov	s16, r0
    *sin_component = sinf(offset_angle);
 8001b1e:	f00c fb63 	bl	800e1e8 <sinf>
 8001b22:	eef0 7a40 	vmov.f32	s15, s0
    *cos_component = cosf(offset_angle);
 8001b26:	eeb0 0a48 	vmov.f32	s0, s16
    *sin_component = sinf(offset_angle);
 8001b2a:	edc8 7a00 	vstr	s15, [r8]
    *cos_component = cosf(offset_angle);
 8001b2e:	f00c fb0f 	bl	800e150 <cosf>
 8001b32:	ed87 0a00 	vstr	s0, [r7]
      vel_scaled = scale_vel(MC_GetAverageMecSpeedMotor1_F());
 8001b36:	f000 f895 	bl	8001c64 <MC_GetAverageMecSpeedMotor1_F>
 8001b3a:	ee10 0a10 	vmov	r0, s0
    return rpm * (2 * M_PI / 60) / VEL_SCALE;
 8001b3e:	f7fe fd23 	bl	8000588 <__aeabi_f2d>
 8001b42:	a329      	add	r3, pc, #164	; (adr r3, 8001be8 <main+0x200>)
 8001b44:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001b48:	f7fe fd76 	bl	8000638 <__aeabi_dmul>
 8001b4c:	f7fe ff86 	bl	8000a5c <__aeabi_d2f>
      in_data1[2] = vel_scaled; // Velocity
 8001b50:	4a31      	ldr	r2, [pc, #196]	; (8001c18 <main+0x230>)
      in_data1[0] = sin_encode; // Sin Encoding
 8001b52:	f8d8 3000 	ldr.w	r3, [r8]
 8001b56:	6013      	str	r3, [r2, #0]
      in_data1[1] = cos_encode; // Cosine Encoding
 8001b58:	683b      	ldr	r3, [r7, #0]
      in_data1[2] = vel_scaled; // Velocity
 8001b5a:	6090      	str	r0, [r2, #8]
      in_data1[1] = cos_encode; // Cosine Encoding
 8001b5c:	6053      	str	r3, [r2, #4]
      vel_scaled = scale_vel(MC_GetAverageMecSpeedMotor1_F());
 8001b5e:	f8cb 0000 	str.w	r0, [fp]
      MX_X_CUBE_AI_Process();
 8001b62:	f7ff fa9f 	bl	80010a4 <MX_X_CUBE_AI_Process>
      action = clip(out_data1[0], -1.0, 1.0) * MAX_EFFORT/TORQUE_K; //Result is in Amps
 8001b66:	edda 7a00 	vldr	s15, [sl]
 8001b6a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8001b6e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b76:	bf88      	it	hi
 8001b78:	eef0 7a47 	vmovhi.f32	s15, s14
 8001b7c:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8001b80:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001b84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001b88:	bfb4      	ite	lt
 8001b8a:	ee17 0a10 	vmovlt	r0, s14
 8001b8e:	ee17 0a90 	vmovge	r0, s15
 8001b92:	f7fe fcf9 	bl	8000588 <__aeabi_f2d>
 8001b96:	a316      	add	r3, pc, #88	; (adr r3, 8001bf0 <main+0x208>)
 8001b98:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001b9c:	f7fe fd4c 	bl	8000638 <__aeabi_dmul>
 8001ba0:	f7fe ff5c 	bl	8000a5c <__aeabi_d2f>
 8001ba4:	4b1d      	ldr	r3, [pc, #116]	; (8001c1c <main+0x234>)
 8001ba6:	ee00 0a10 	vmov	s0, r0
 8001baa:	6018      	str	r0, [r3, #0]
      MC_ProgramTorqueRampMotor1_F(action, 0);
 8001bac:	4630      	mov	r0, r6
 8001bae:	f000 f851 	bl	8001c54 <MC_ProgramTorqueRampMotor1_F>
      HAL_TIM_Base_Stop(&htim3);
 8001bb2:	4648      	mov	r0, r9
 8001bb4:	f005 fde0 	bl	8007778 <HAL_TIM_Base_Stop>
      data.floatValue[0] = out_data1[0]; // Value
 8001bb8:	f8da 3000 	ldr.w	r3, [sl]
 8001bbc:	6023      	str	r3, [r4, #0]
      data.floatValue[1] = out_data2[0]; // Mu
 8001bbe:	4b18      	ldr	r3, [pc, #96]	; (8001c20 <main+0x238>)
      data_flag = 0;
 8001bc0:	702e      	strb	r6, [r5, #0]
      data.floatValue[1] = out_data2[0]; // Mu
 8001bc2:	681b      	ldr	r3, [r3, #0]
 8001bc4:	6063      	str	r3, [r4, #4]
      data.floatValue[2] = out_data3[0]; // STD
 8001bc6:	4b17      	ldr	r3, [pc, #92]	; (8001c24 <main+0x23c>)
 8001bc8:	681b      	ldr	r3, [r3, #0]
 8001bca:	60a3      	str	r3, [r4, #8]
      data.floatValue[5] = sin_encode;
 8001bcc:	f8d8 3000 	ldr.w	r3, [r8]
 8001bd0:	6163      	str	r3, [r4, #20]
      data.floatValue[6] = cos_encode;
 8001bd2:	683b      	ldr	r3, [r7, #0]
 8001bd4:	61a3      	str	r3, [r4, #24]
      data.floatValue[7] = vel_scaled;
 8001bd6:	f8db 3000 	ldr.w	r3, [fp]
 8001bda:	61e3      	str	r3, [r4, #28]
      data_flag = 0;
 8001bdc:	e775      	b.n	8001aca <main+0xe2>
 8001bde:	bf00      	nop
 8001be0:	54442d18 	.word	0x54442d18
 8001be4:	400921fb 	.word	0x400921fb
 8001be8:	c2c98978 	.word	0xc2c98978
 8001bec:	3f757254 	.word	0x3f757254
 8001bf0:	651fe2d9 	.word	0x651fe2d9
 8001bf4:	4008e939 	.word	0x4008e939
 8001bf8:	20001a6c 	.word	0x20001a6c
 8001bfc:	20001a48 	.word	0x20001a48
 8001c00:	00000000 	.word	0x00000000
 8001c04:	38000000 	.word	0x38000000
 8001c08:	20001a4c 	.word	0x20001a4c
 8001c0c:	20002f08 	.word	0x20002f08
 8001c10:	40000400 	.word	0x40000400
 8001c14:	20000024 	.word	0x20000024
 8001c18:	20001a70 	.word	0x20001a70
 8001c1c:	20001a44 	.word	0x20001a44
 8001c20:	20001a80 	.word	0x20001a80
 8001c24:	20001a84 	.word	0x20001a84
 8001c28:	20001a88 	.word	0x20001a88
 8001c2c:	20001a8c 	.word	0x20001a8c
 8001c30:	20001a7c 	.word	0x20001a7c
 8001c34:	20002ebc 	.word	0x20002ebc

08001c38 <Error_Handler>:
 8001c38:	b672      	cpsid	i
  while (1)
 8001c3a:	e7fe      	b.n	8001c3a <Error_Handler+0x2>

08001c3c <MC_StartMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StartMotor1(void)
{
  return (MCI_StartMotor(pMCI[M1]));
 8001c3c:	4b01      	ldr	r3, [pc, #4]	; (8001c44 <MC_StartMotor1+0x8>)
 8001c3e:	6818      	ldr	r0, [r3, #0]
 8001c40:	f000 b8ae 	b.w	8001da0 <MCI_StartMotor>
 8001c44:	20002c88 	.word	0x20002c88

08001c48 <MC_StopMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StopMotor1(void)
{
  return (MCI_StopMotor(pMCI[M1]));
 8001c48:	4b01      	ldr	r3, [pc, #4]	; (8001c50 <MC_StopMotor1+0x8>)
 8001c4a:	6818      	ldr	r0, [r3, #0]
 8001c4c:	f000 b8d8 	b.w	8001e00 <MCI_StopMotor>
 8001c50:	20002c88 	.word	0x20002c88

08001c54 <MC_ProgramTorqueRampMotor1_F>:
  *         is possible to set 0 to perform an instantaneous change in the torque
  *         value.
  */
__weak void MC_ProgramTorqueRampMotor1_F(float_t FinalTorque, uint16_t hDurationms)
{
  MCI_ExecTorqueRamp_F(pMCI[M1], FinalTorque, hDurationms);
 8001c54:	4b02      	ldr	r3, [pc, #8]	; (8001c60 <MC_ProgramTorqueRampMotor1_F+0xc>)
{
 8001c56:	4601      	mov	r1, r0
  MCI_ExecTorqueRamp_F(pMCI[M1], FinalTorque, hDurationms);
 8001c58:	6818      	ldr	r0, [r3, #0]
 8001c5a:	f000 b839 	b.w	8001cd0 <MCI_ExecTorqueRamp_F>
 8001c5e:	bf00      	nop
 8001c60:	20002c88 	.word	0x20002c88

08001c64 <MC_GetAverageMecSpeedMotor1_F>:
/**
 * @brief Returns the last computed average mechanical rotor speed for Motor 1, expressed in rpm.
 */
__weak float_t MC_GetAverageMecSpeedMotor1_F(void)
{
  return (MCI_GetAvrgMecSpeed_F(pMCI[M1]));
 8001c64:	4b01      	ldr	r3, [pc, #4]	; (8001c6c <MC_GetAverageMecSpeedMotor1_F+0x8>)
 8001c66:	6818      	ldr	r0, [r3, #0]
 8001c68:	f000 b91c 	b.w	8001ea4 <MCI_GetAvrgMecSpeed_F>
 8001c6c:	20002c88 	.word	0x20002c88

08001c70 <MC_GetSTMStateMotor1>:
/**
 * @brief returns the current state of Motor 1 state machine
 */
__weak MCI_State_t MC_GetSTMStateMotor1(void)
{
  return (MCI_GetSTMState(pMCI[M1]));
 8001c70:	4b01      	ldr	r3, [pc, #4]	; (8001c78 <MC_GetSTMStateMotor1+0x8>)
 8001c72:	6818      	ldr	r0, [r3, #0]
 8001c74:	f000 b88e 	b.w	8001d94 <MCI_GetSTMState>
 8001c78:	20002c88 	.word	0x20002c88

08001c7c <MC_ProfilerCommand>:
 * @brief Not implemented MC_Profiler function.
 *  */ //cstat !MISRAC2012-Rule-2.7 !RED-unused-param  !MISRAC2012-Rule-2.7  !MISRAC2012-Rule-8.13
__weak uint8_t MC_ProfilerCommand(uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, uint16_t *txLength, uint8_t *txBuffer)
{
  return (MCP_CMD_UNKNOWN);
}
 8001c7c:	2002      	movs	r0, #2
 8001c7e:	4770      	bx	lr

08001c80 <MC_APP_BootHook>:
   */

/* USER CODE BEGIN BootHook */

/* USER CODE END BootHook */
}
 8001c80:	4770      	bx	lr
 8001c82:	bf00      	nop

08001c84 <MC_APP_PostMediumFrequencyHook_M1>:
 8001c84:	4770      	bx	lr
 8001c86:	bf00      	nop

08001c88 <MCI_Init>:
  *         (only present if position control is enabled)
  * @param  pPWMHandle pointer to the PWM & current feedback component to be used by the MCI.
  */
__weak void MCI_Init(MCI_Handle_t *pHandle, SpeednTorqCtrl_Handle_t *pSTC, pFOCVars_t pFOCVars,
                     PWMC_Handle_t *pPWMHandle )
{
 8001c88:	b410      	push	{r4}
    pHandle->pSTC = pSTC;
    pHandle->pFOCVars = pFOCVars;
    pHandle->pPWM = pPWMHandle;

    /* Buffer related initialization */
    pHandle->lastCommand = MCI_NOCOMMANDSYET;
 8001c8a:	2400      	movs	r4, #0
    pHandle->hFinalTorque = 0;
    pHandle->hDurationms = 0;
    pHandle->CommandState = MCI_BUFFER_EMPTY;
    pHandle->DirectCommand = MCI_NO_COMMAND;
    pHandle->State = IDLE;
    pHandle->CurrentFaults = MC_NO_FAULTS;
 8001c8c:	e9c0 4407 	strd	r4, r4, [r0, #28]
    pHandle->lastCommand = MCI_NOCOMMANDSYET;
 8001c90:	7304      	strb	r4, [r0, #12]
    pHandle->hFinalSpeed = 0;
 8001c92:	f8c0 400e 	str.w	r4, [r0, #14]
    pHandle->CommandState = MCI_BUFFER_EMPTY;
 8001c96:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    pHandle->pFOCVars = pFOCVars;
 8001c9a:	e9c0 1200 	strd	r1, r2, [r0]
    pHandle->PastFaults = MC_NO_FAULTS;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001c9e:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->pPWM = pPWMHandle;
 8001ca2:	6083      	str	r3, [r0, #8]
}
 8001ca4:	4770      	bx	lr
 8001ca6:	bf00      	nop

08001ca8 <MCI_ExecSpeedRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 8001ca8:	f04f 0c01 	mov.w	ip, #1
    pHandle->hFinalSpeed = hFinalSpeed;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cac:	f240 3301 	movw	r3, #769	; 0x301
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 8001cb0:	f880 c00c 	strb.w	ip, [r0, #12]
    pHandle->hFinalSpeed = hFinalSpeed;
 8001cb4:	81c1      	strh	r1, [r0, #14]
    pHandle->hDurationms = hDurationms;
 8001cb6:	8382      	strh	r2, [r0, #28]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cb8:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_SPEED_MODE;

#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cba:	4770      	bx	lr

08001cbc <MCI_ExecTorqueRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 8001cbc:	f04f 0c02 	mov.w	ip, #2
    pHandle->hFinalTorque = hFinalTorque;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cc0:	f240 4301 	movw	r3, #1025	; 0x401
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 8001cc4:	f880 c00c 	strb.w	ip, [r0, #12]
    pHandle->hFinalTorque = hFinalTorque;
 8001cc8:	8201      	strh	r1, [r0, #16]
    pHandle->hDurationms = hDurationms;
 8001cca:	8382      	strh	r2, [r0, #28]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001ccc:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cce:	4770      	bx	lr

08001cd0 <MCI_ExecTorqueRamp_F>:
    /* Nothing to do */
  }
  else
  {
#endif
    int16_t hFinalTorque = (int16_t)(FinalTorque * (int16_t)CURRENT_CONV_FACTOR);
 8001cd0:	eddf 7a06 	vldr	s15, [pc, #24]	; 8001cec <MCI_ExecTorqueRamp_F+0x1c>
 8001cd4:	ee20 0a27 	vmul.f32	s0, s0, s15
{
 8001cd8:	b508      	push	{r3, lr}
    int16_t hFinalTorque = (int16_t)(FinalTorque * (int16_t)CURRENT_CONV_FACTOR);
 8001cda:	eebd 0ac0 	vcvt.s32.f32	s0, s0
{
 8001cde:	460a      	mov	r2, r1
    MCI_ExecTorqueRamp(pHandle, hFinalTorque, hDurationms);
 8001ce0:	ee10 3a10 	vmov	r3, s0
 8001ce4:	b219      	sxth	r1, r3
 8001ce6:	f7ff ffe9 	bl	8001cbc <MCI_ExecTorqueRamp>
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cea:	bd08      	pop	{r3, pc}
 8001cec:	452dc000 	.word	0x452dc000

08001cf0 <MCI_SetCurrentReferences>:
  * function.

  @sa MCI_SetCurrentReferences_F
  */
__weak void MCI_SetCurrentReferences(MCI_Handle_t *pHandle, qd_t Iqdref)
{
 8001cf0:	b082      	sub	sp, #8
  }
  else
  {
#endif

    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001cf2:	2203      	movs	r2, #3
    pHandle->Iqdref.q = Iqdref.q;
    pHandle->Iqdref.d = Iqdref.d;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cf4:	f240 4301 	movw	r3, #1025	; 0x401
    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001cf8:	7302      	strb	r2, [r0, #12]
    pHandle->Iqdref.q = Iqdref.q;
 8001cfa:	f8c0 1012 	str.w	r1, [r0, #18]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cfe:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001d00:	b002      	add	sp, #8
 8001d02:	4770      	bx	lr

08001d04 <MCI_FaultProcessing>:
  }
  else
  {
#endif
    /* Set current errors */
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001d04:	8c03      	ldrh	r3, [r0, #32]
    pHandle->PastFaults |= hSetErrors;
 8001d06:	f8b0 c022 	ldrh.w	ip, [r0, #34]	; 0x22
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001d0a:	430b      	orrs	r3, r1
 8001d0c:	ea23 0302 	bic.w	r3, r3, r2
    pHandle->PastFaults |= hSetErrors;
 8001d10:	ea41 010c 	orr.w	r1, r1, ip
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001d14:	8403      	strh	r3, [r0, #32]
    pHandle->PastFaults |= hSetErrors;
 8001d16:	8441      	strh	r1, [r0, #34]	; 0x22
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001d18:	4770      	bx	lr
 8001d1a:	bf00      	nop

08001d1c <MCI_ExecBufferedCommands>:
    /* Nothing to do */
  }
  else
  {
#endif
    if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 8001d1c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001d20:	2b01      	cmp	r3, #1
 8001d22:	d000      	beq.n	8001d26 <MCI_ExecBufferedCommands+0xa>
 8001d24:	4770      	bx	lr
{
 8001d26:	b510      	push	{r4, lr}
    {
      bool commandHasBeenExecuted = false;
      switch (pHandle->lastCommand)
 8001d28:	7b02      	ldrb	r2, [r0, #12]
 8001d2a:	2a02      	cmp	r2, #2
 8001d2c:	4604      	mov	r4, r0
 8001d2e:	d007      	beq.n	8001d40 <MCI_ExecBufferedCommands+0x24>
 8001d30:	2a03      	cmp	r2, #3
 8001d32:	d028      	beq.n	8001d86 <MCI_ExecBufferedCommands+0x6a>
 8001d34:	2a01      	cmp	r2, #1
 8001d36:	d017      	beq.n	8001d68 <MCI_ExecBufferedCommands+0x4c>
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
      }
      else
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 8001d38:	2303      	movs	r3, #3
 8001d3a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      }
    }
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001d3e:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001d40:	6843      	ldr	r3, [r0, #4]
 8001d42:	2200      	movs	r2, #0
 8001d44:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 8001d48:	6800      	ldr	r0, [r0, #0]
 8001d4a:	2104      	movs	r1, #4
 8001d4c:	f008 fb64 	bl	800a418 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDurationms);
 8001d50:	8ba2      	ldrh	r2, [r4, #28]
 8001d52:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
 8001d56:	6820      	ldr	r0, [r4, #0]
 8001d58:	f008 fb62 	bl	800a420 <STC_ExecRamp>
      if (commandHasBeenExecuted)
 8001d5c:	2800      	cmp	r0, #0
 8001d5e:	d0eb      	beq.n	8001d38 <MCI_ExecBufferedCommands+0x1c>
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
 8001d60:	2302      	movs	r3, #2
 8001d62:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8001d66:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001d68:	6843      	ldr	r3, [r0, #4]
 8001d6a:	2200      	movs	r2, #0
 8001d6c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 8001d70:	6800      	ldr	r0, [r0, #0]
 8001d72:	2103      	movs	r1, #3
 8001d74:	f008 fb50 	bl	800a418 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDurationms);
 8001d78:	8ba2      	ldrh	r2, [r4, #28]
 8001d7a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8001d7e:	6820      	ldr	r0, [r4, #0]
 8001d80:	f008 fb4e 	bl	800a420 <STC_ExecRamp>
          break;
 8001d84:	e7ea      	b.n	8001d5c <MCI_ExecBufferedCommands+0x40>
          pHandle->pFOCVars->bDriveInput = EXTERNAL;
 8001d86:	6842      	ldr	r2, [r0, #4]
 8001d88:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
          pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 8001d8c:	f8d0 3012 	ldr.w	r3, [r0, #18]
 8001d90:	6113      	str	r3, [r2, #16]
      if (commandHasBeenExecuted)
 8001d92:	e7e5      	b.n	8001d60 <MCI_ExecBufferedCommands+0x44>

08001d94 <MCI_GetSTMState>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
#else
  return (pHandle->State);
#endif
}
 8001d94:	7fc0      	ldrb	r0, [r0, #31]
 8001d96:	4770      	bx	lr

08001d98 <MCI_GetOccurredFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
#else
  return ((uint16_t)pHandle->PastFaults);
#endif
}
 8001d98:	8c40      	ldrh	r0, [r0, #34]	; 0x22
 8001d9a:	4770      	bx	lr

08001d9c <MCI_GetCurrentFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
#else
  return ((uint16_t)pHandle->CurrentFaults);
#endif
}
 8001d9c:	8c00      	ldrh	r0, [r0, #32]
 8001d9e:	4770      	bx	lr

08001da0 <MCI_StartMotor>:
{
 8001da0:	b510      	push	{r4, lr}
 8001da2:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001da4:	f7ff fff6 	bl	8001d94 <MCI_GetSTMState>
 8001da8:	b108      	cbz	r0, 8001dae <MCI_StartMotor+0xe>
  bool retVal = false;
 8001daa:	2000      	movs	r0, #0
}
 8001dac:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dae:	4620      	mov	r0, r4
 8001db0:	f7ff fff2 	bl	8001d98 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001db4:	2800      	cmp	r0, #0
 8001db6:	d1f8      	bne.n	8001daa <MCI_StartMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001db8:	4620      	mov	r0, r4
 8001dba:	f7ff ffef 	bl	8001d9c <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dbe:	2800      	cmp	r0, #0
 8001dc0:	d1f3      	bne.n	8001daa <MCI_StartMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 8001dc2:	2001      	movs	r0, #1
 8001dc4:	77a0      	strb	r0, [r4, #30]
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001dc6:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
}
 8001dca:	bd10      	pop	{r4, pc}

08001dcc <MCI_StartWithPolarizationMotor>:
{
 8001dcc:	b510      	push	{r4, lr}
 8001dce:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001dd0:	f7ff ffe0 	bl	8001d94 <MCI_GetSTMState>
 8001dd4:	b108      	cbz	r0, 8001dda <MCI_StartWithPolarizationMotor+0xe>
  bool retVal = true;
 8001dd6:	2001      	movs	r0, #1
}
 8001dd8:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dda:	4620      	mov	r0, r4
 8001ddc:	f7ff ffdc 	bl	8001d98 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001de0:	2800      	cmp	r0, #0
 8001de2:	d1f8      	bne.n	8001dd6 <MCI_StartWithPolarizationMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001de4:	4620      	mov	r0, r4
 8001de6:	f7ff ffd9 	bl	8001d9c <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dea:	2800      	cmp	r0, #0
 8001dec:	d1f3      	bne.n	8001dd6 <MCI_StartWithPolarizationMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 8001dee:	2201      	movs	r2, #1
      pHandle->pPWM->offsetCalibStatus = false;
 8001df0:	68a1      	ldr	r1, [r4, #8]
      pHandle->DirectCommand = MCI_START;
 8001df2:	77a2      	strb	r2, [r4, #30]
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001df4:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      pHandle->pPWM->offsetCalibStatus = false;
 8001df8:	f881 0081 	strb.w	r0, [r1, #129]	; 0x81
}
 8001dfc:	bd10      	pop	{r4, pc}
 8001dfe:	bf00      	nop

08001e00 <MCI_StopMotor>:
{
 8001e00:	b538      	push	{r3, r4, r5, lr}
 8001e02:	4605      	mov	r5, r0
    State = MCI_GetSTMState(pHandle);
 8001e04:	f7ff ffc6 	bl	8001d94 <MCI_GetSTMState>
    if ((IDLE == State) || (ICLWAIT == State))
 8001e08:	b150      	cbz	r0, 8001e20 <MCI_StopMotor+0x20>
 8001e0a:	f1b0 040c 	subs.w	r4, r0, #12
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001e0e:	4628      	mov	r0, r5
    if ((IDLE == State) || (ICLWAIT == State))
 8001e10:	bf18      	it	ne
 8001e12:	2401      	movne	r4, #1
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001e14:	f7ff ffc0 	bl	8001d98 <MCI_GetOccurredFaults>
 8001e18:	b140      	cbz	r0, 8001e2c <MCI_StopMotor+0x2c>
  bool retVal = false;
 8001e1a:	2400      	movs	r4, #0
}
 8001e1c:	4620      	mov	r0, r4
 8001e1e:	bd38      	pop	{r3, r4, r5, pc}
      status = false;
 8001e20:	4604      	mov	r4, r0
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001e22:	4628      	mov	r0, r5
 8001e24:	f7ff ffb8 	bl	8001d98 <MCI_GetOccurredFaults>
 8001e28:	2800      	cmp	r0, #0
 8001e2a:	d1f6      	bne.n	8001e1a <MCI_StopMotor+0x1a>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 8001e2c:	4628      	mov	r0, r5
 8001e2e:	f7ff ffb5 	bl	8001d9c <MCI_GetCurrentFaults>
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001e32:	2800      	cmp	r0, #0
 8001e34:	d1f1      	bne.n	8001e1a <MCI_StopMotor+0x1a>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 8001e36:	2c00      	cmp	r4, #0
 8001e38:	d0ef      	beq.n	8001e1a <MCI_StopMotor+0x1a>
      pHandle->DirectCommand = MCI_STOP;
 8001e3a:	2305      	movs	r3, #5
 8001e3c:	77ab      	strb	r3, [r5, #30]
      retVal = true;
 8001e3e:	e7ed      	b.n	8001e1c <MCI_StopMotor+0x1c>

08001e40 <MCI_FaultAcknowledged>:
{
 8001e40:	b510      	push	{r4, lr}
 8001e42:	4604      	mov	r4, r0
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001e44:	f7ff ffa6 	bl	8001d94 <MCI_GetSTMState>
 8001e48:	280b      	cmp	r0, #11
 8001e4a:	d001      	beq.n	8001e50 <MCI_FaultAcknowledged+0x10>
  bool reVal = false;
 8001e4c:	2000      	movs	r0, #0
}
 8001e4e:	bd10      	pop	{r4, pc}
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001e50:	4620      	mov	r0, r4
 8001e52:	f7ff ffa3 	bl	8001d9c <MCI_GetCurrentFaults>
 8001e56:	2800      	cmp	r0, #0
 8001e58:	d1f8      	bne.n	8001e4c <MCI_FaultAcknowledged+0xc>
      pHandle->DirectCommand = MCI_ACK_FAULTS;
 8001e5a:	2302      	movs	r3, #2
 8001e5c:	77a3      	strb	r3, [r4, #30]
      pHandle->PastFaults = MC_NO_FAULTS;
 8001e5e:	8460      	strh	r0, [r4, #34]	; 0x22
      reVal = true;
 8001e60:	2001      	movs	r0, #1
}
 8001e62:	bd10      	pop	{r4, pc}

08001e64 <MCI_GetFaultState>:
    LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
  }
  else
  {
#endif
    LocalFaultState = (uint32_t)(pHandle->PastFaults);
 8001e64:	8c43      	ldrh	r3, [r0, #34]	; 0x22
    LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 8001e66:	8c00      	ldrh	r0, [r0, #32]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (LocalFaultState);
}
 8001e68:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001e6c:	4770      	bx	lr
 8001e6e:	bf00      	nop

08001e70 <MCI_GetControlMode>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
#else
  return (pHandle->LastModalitySetByUser);
#endif
}
 8001e70:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
 8001e74:	4770      	bx	lr
 8001e76:	bf00      	nop

08001e78 <MCI_GetLastRampFinalSpeed>:
  }
  return (retVal);
#else
  return (pHandle->hFinalSpeed);
#endif
}
 8001e78:	f9b0 000e 	ldrsh.w	r0, [r0, #14]
 8001e7c:	4770      	bx	lr
 8001e7e:	bf00      	nop

08001e80 <MCI_GetLastRampFinalTorque>:
  }
  return (retVal);
#else
  return (pHandle->hFinalTorque);
#endif
}
 8001e80:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
 8001e84:	4770      	bx	lr
 8001e86:	bf00      	nop

08001e88 <MCI_GetLastRampFinalDuration>:
  }
  return (retVal);
#else
  return (pHandle->hDurationms);
#endif
}
 8001e88:	8b80      	ldrh	r0, [r0, #28]
 8001e8a:	4770      	bx	lr

08001e8c <MCI_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    STC_StopRamp(pHandle->pSTC);
 8001e8c:	6800      	ldr	r0, [r0, #0]
 8001e8e:	f008 bb0b 	b.w	800a4a8 <STC_StopRamp>
 8001e92:	bf00      	nop

08001e94 <MCI_GetAvrgMecSpeedUnit>:
  *         the unit defined by #SPEED_UNIT and related to the sensor actually
  *         used by FOC algorithm
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak int16_t MCI_GetAvrgMecSpeedUnit(MCI_Handle_t *pHandle)
{
 8001e94:	b508      	push	{r3, lr}
    temp_speed = 0;
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 8001e96:	6800      	ldr	r0, [r0, #0]
 8001e98:	f008 faac 	bl	800a3f4 <STC_GetSpeedSensor>
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (temp_speed);
}
 8001e9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 8001ea0:	f008 ba50 	b.w	800a344 <SPD_GetAvrgMecSpeedUnit>

08001ea4 <MCI_GetAvrgMecSpeed_F>:
  * @brief  Returns the last computed average mechanical speed, expressed in rpm
  *         and related to the sensor actually used by FOC algorithm.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak float_t MCI_GetAvrgMecSpeed_F(MCI_Handle_t *pHandle)
{
 8001ea4:	b508      	push	{r3, lr}
    returnAvrgSpeed = 0.0f;
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 8001ea6:	6800      	ldr	r0, [r0, #0]
 8001ea8:	f008 faa4 	bl	800a3f4 <STC_GetSpeedSensor>
    returnAvrgSpeed = (((float_t)SPD_GetAvrgMecSpeedUnit(SpeedSensor) * (float_t)U_RPM) / (float_t)SPEED_UNIT);
 8001eac:	f008 fa4a 	bl	800a344 <SPD_GetAvrgMecSpeedUnit>
 8001eb0:	ee07 0a90 	vmov	s15, r0
 8001eb4:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8001eb8:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (returnAvrgSpeed);
}
 8001ebc:	ee20 0a27 	vmul.f32	s0, s0, s15
 8001ec0:	bd08      	pop	{r3, pc}
 8001ec2:	bf00      	nop

08001ec4 <MCI_GetMecSpeedRefUnit>:
__weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
#else
  return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 8001ec4:	6800      	ldr	r0, [r0, #0]
 8001ec6:	f008 ba9f 	b.w	800a408 <STC_GetMecSpeedRefUnit>
 8001eca:	bf00      	nop

08001ecc <MCI_GetIab>:
  {
    tempVal = pHandle->pFOCVars->Iab;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iab);
 8001ecc:	6842      	ldr	r2, [r0, #4]
 8001ece:	6810      	ldr	r0, [r2, #0]
 8001ed0:	2300      	movs	r3, #0
 8001ed2:	b282      	uxth	r2, r0
 8001ed4:	f362 030f 	bfi	r3, r2, #0, #16
 8001ed8:	0c00      	lsrs	r0, r0, #16
 8001eda:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001ede:	b082      	sub	sp, #8
#endif
}
 8001ee0:	4618      	mov	r0, r3
 8001ee2:	b002      	add	sp, #8
 8001ee4:	4770      	bx	lr
 8001ee6:	bf00      	nop

08001ee8 <MCI_GetIalphabeta>:
  {
    tempVal = pHandle->pFOCVars->Ialphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Ialphabeta);
 8001ee8:	6842      	ldr	r2, [r0, #4]
 8001eea:	6850      	ldr	r0, [r2, #4]
 8001eec:	2300      	movs	r3, #0
 8001eee:	b282      	uxth	r2, r0
 8001ef0:	f362 030f 	bfi	r3, r2, #0, #16
 8001ef4:	0c00      	lsrs	r0, r0, #16
 8001ef6:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001efa:	b082      	sub	sp, #8
#endif
}
 8001efc:	4618      	mov	r0, r3
 8001efe:	b002      	add	sp, #8
 8001f00:	4770      	bx	lr
 8001f02:	bf00      	nop

08001f04 <MCI_GetIqd>:
  {
    tempVal = pHandle->pFOCVars->Iqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqd);
 8001f04:	6842      	ldr	r2, [r0, #4]
 8001f06:	68d0      	ldr	r0, [r2, #12]
 8001f08:	2300      	movs	r3, #0
 8001f0a:	b282      	uxth	r2, r0
 8001f0c:	f362 030f 	bfi	r3, r2, #0, #16
 8001f10:	0c00      	lsrs	r0, r0, #16
 8001f12:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f16:	b082      	sub	sp, #8
#endif
}
 8001f18:	4618      	mov	r0, r3
 8001f1a:	b002      	add	sp, #8
 8001f1c:	4770      	bx	lr
 8001f1e:	bf00      	nop

08001f20 <MCI_GetIqdref>:
  {
    tempVal = pHandle->pFOCVars->Iqdref;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqdref);
 8001f20:	6842      	ldr	r2, [r0, #4]
 8001f22:	6910      	ldr	r0, [r2, #16]
 8001f24:	2300      	movs	r3, #0
 8001f26:	b282      	uxth	r2, r0
 8001f28:	f362 030f 	bfi	r3, r2, #0, #16
 8001f2c:	0c00      	lsrs	r0, r0, #16
 8001f2e:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f32:	b082      	sub	sp, #8
#endif
}
 8001f34:	4618      	mov	r0, r3
 8001f36:	b002      	add	sp, #8
 8001f38:	4770      	bx	lr
 8001f3a:	bf00      	nop

08001f3c <MCI_GetVqd>:
  {
    tempVal = pHandle->pFOCVars->Vqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Vqd);
 8001f3c:	6842      	ldr	r2, [r0, #4]
 8001f3e:	f8d2 0016 	ldr.w	r0, [r2, #22]
 8001f42:	2300      	movs	r3, #0
 8001f44:	b282      	uxth	r2, r0
 8001f46:	f362 030f 	bfi	r3, r2, #0, #16
 8001f4a:	0c00      	lsrs	r0, r0, #16
 8001f4c:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f50:	b082      	sub	sp, #8
#endif
}
 8001f52:	4618      	mov	r0, r3
 8001f54:	b002      	add	sp, #8
 8001f56:	4770      	bx	lr

08001f58 <MCI_GetValphabeta>:
  {
    tempVal = pHandle->pFOCVars->Valphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Valphabeta);
 8001f58:	6842      	ldr	r2, [r0, #4]
 8001f5a:	f8d2 001a 	ldr.w	r0, [r2, #26]
 8001f5e:	2300      	movs	r3, #0
 8001f60:	b282      	uxth	r2, r0
 8001f62:	f362 030f 	bfi	r3, r2, #0, #16
 8001f66:	0c00      	lsrs	r0, r0, #16
 8001f68:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f6c:	b082      	sub	sp, #8
#endif
}
 8001f6e:	4618      	mov	r0, r3
 8001f70:	b002      	add	sp, #8
 8001f72:	4770      	bx	lr

08001f74 <MCI_GetTeref>:
__weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
#else
  return (pHandle->pFOCVars->hTeref);
 8001f74:	6843      	ldr	r3, [r0, #4]
#endif
}
 8001f76:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
 8001f7a:	4770      	bx	lr

08001f7c <MCI_Clear_Iqdref>:
/**
  * @brief  It re-initializes Iqdref variables with their default values.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
{
 8001f7c:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 8001f7e:	e9d0 0400 	ldrd	r0, r4, [r0]
 8001f82:	f008 fac3 	bl	800a50c <STC_GetDefaultIqdref>
 8001f86:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8001f8a:	8220      	strh	r0, [r4, #16]
 8001f8c:	8263      	strh	r3, [r4, #18]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001f8e:	bd10      	pop	{r4, pc}

08001f90 <MCM_Clarke>:
  /* qIalpha = qIas*/
  Output.alpha = Input.a;

  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);

  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 8001f90:	f644 11e6 	movw	r1, #18918	; 0x49e6
 8001f94:	b203      	sxth	r3, r0
  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);
 8001f96:	fb13 f201 	smulbb	r2, r3, r1
{
 8001f9a:	f3c0 400f 	ubfx	r0, r0, #16, #16
  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 8001f9e:	fb10 f001 	smulbb	r0, r0, r1
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
  /* WARNING: the below instruction is not MISRA compliant, user should verify
    that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    the compiler to perform the shift (instead of LSR logical shift right) */
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 8001fa2:	4252      	negs	r2, r2
 8001fa4:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
#else
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) / 32768;
#endif

  /* Check saturation of Ibeta */
  if (wbeta_tmp > INT16_MAX)
 8001fa8:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
{
 8001fac:	b084      	sub	sp, #16
  if (wbeta_tmp > INT16_MAX)
 8001fae:	da05      	bge.n	8001fbc <MCM_Clarke+0x2c>
 8001fb0:	13d1      	asrs	r1, r2, #15
  {
    hbeta_tmp = INT16_MAX;
  }
  else if (wbeta_tmp < (-32768))
 8001fb2:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 8001fb6:	da0c      	bge.n	8001fd2 <MCM_Clarke+0x42>
 8001fb8:	4a09      	ldr	r2, [pc, #36]	; (8001fe0 <MCM_Clarke+0x50>)
 8001fba:	e001      	b.n	8001fc0 <MCM_Clarke+0x30>
 8001fbc:	f647 72ff 	movw	r2, #32767	; 0x7fff
  else
  {
    /* Nothing to do */
  }

  return (Output);
 8001fc0:	b29b      	uxth	r3, r3
 8001fc2:	2000      	movs	r0, #0
 8001fc4:	f363 000f 	bfi	r0, r3, #0, #16
 8001fc8:	b293      	uxth	r3, r2
 8001fca:	f363 401f 	bfi	r0, r3, #16, #16
}
 8001fce:	b004      	add	sp, #16
 8001fd0:	4770      	bx	lr
    hbeta_tmp = ((int16_t)wbeta_tmp);
 8001fd2:	4803      	ldr	r0, [pc, #12]	; (8001fe0 <MCM_Clarke+0x50>)
 8001fd4:	b20a      	sxth	r2, r1
 8001fd6:	4282      	cmp	r2, r0
 8001fd8:	bfb8      	it	lt
 8001fda:	4602      	movlt	r2, r0
 8001fdc:	e7f0      	b.n	8001fc0 <MCM_Clarke+0x30>
 8001fde:	bf00      	nop
 8001fe0:	ffff8001 	.word	0xffff8001

08001fe4 <MCM_Trig_Functions>:
  } CosSin;
  //cstat +MISRAC2012-Rule-19.2
  /* Configure CORDIC */
  /* Misra  violation Rule 11.4 A�Conversion�should�not�be�performed�between�a�
   * pointer�to�object and an integer type */
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001fe4:	4b09      	ldr	r3, [pc, #36]	; (800200c <MCM_Trig_Functions+0x28>)
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed�between�a
   * pointer�to�object and an integer type */
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 8001fe6:	f100 40ff 	add.w	r0, r0, #2139095040	; 0x7f800000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001fea:	f04f 1260 	mov.w	r2, #6291552	; 0x600060
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 8001fee:	f500 00fe 	add.w	r0, r0, #8323072	; 0x7f0000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001ff2:	601a      	str	r2, [r3, #0]
  * @param  InData 0 .. 0xFFFFFFFF : 32-bit value to be provided as input data for CORDIC processing.
  * @retval None
  */
__STATIC_INLINE void LL_CORDIC_WriteData(CORDIC_TypeDef *CORDICx, uint32_t InData)
{
  WRITE_REG(CORDICx->WDATA, InData);
 8001ff4:	6058      	str	r0, [r3, #4]
  * @param  CORDICx CORDIC Instance
  * @retval 32-bit output data of CORDIC processing.
  */
__STATIC_INLINE uint32_t LL_CORDIC_ReadData(CORDIC_TypeDef *CORDICx)
{
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 8001ff6:	689b      	ldr	r3, [r3, #8]
  /* Read angle */
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed between�a
   * pointer�to object and an integer type */
  CosSin.CordicRdata = LL_CORDIC_ReadData(CORDIC);
  return (CosSin.Components); //cstat !UNION-type-punning
 8001ff8:	2000      	movs	r0, #0
 8001ffa:	b29a      	uxth	r2, r3
 8001ffc:	f362 000f 	bfi	r0, r2, #0, #16
 8002000:	0c1b      	lsrs	r3, r3, #16
{
 8002002:	b082      	sub	sp, #8
  return (CosSin.Components); //cstat !UNION-type-punning
 8002004:	f363 401f 	bfi	r0, r3, #16, #16
}
 8002008:	b002      	add	sp, #8
 800200a:	4770      	bx	lr
 800200c:	40020c00 	.word	0x40020c00

08002010 <MCM_Park>:
{
 8002010:	b530      	push	{r4, r5, lr}
 8002012:	b085      	sub	sp, #20
 8002014:	4604      	mov	r4, r0
 8002016:	4605      	mov	r5, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8002018:	4608      	mov	r0, r1
{
 800201a:	9401      	str	r4, [sp, #4]
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 800201c:	f7ff ffe2 	bl	8001fe4 <MCM_Trig_Functions>
 8002020:	b22d      	sxth	r5, r5
 8002022:	b201      	sxth	r1, r0
 8002024:	1424      	asrs	r4, r4, #16
 8002026:	1400      	asrs	r0, r0, #16
  q_tmp_1 = Input.alpha * ((int32_t )Local_Vector_Components.hCos);
 8002028:	fb05 f301 	mul.w	r3, r5, r1
  wqd_tmp = (q_tmp_1 - q_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800202c:	fb04 3310 	mls	r3, r4, r0, r3
  if (wqd_tmp > INT16_MAX)
 8002030:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002034:	da05      	bge.n	8002042 <MCM_Park+0x32>
 8002036:	13da      	asrs	r2, r3, #15
  else if (wqd_tmp < (-32768))
 8002038:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 800203c:	da22      	bge.n	8002084 <MCM_Park+0x74>
 800203e:	4a14      	ldr	r2, [pc, #80]	; (8002090 <MCM_Park+0x80>)
 8002040:	e001      	b.n	8002046 <MCM_Park+0x36>
 8002042:	f647 72ff 	movw	r2, #32767	; 0x7fff
  d_tmp_2 = Input.beta * ((int32_t )Local_Vector_Components.hCos);
 8002046:	fb01 f404 	mul.w	r4, r1, r4
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800204a:	fb05 4400 	mla	r4, r5, r0, r4
  if (wqd_tmp > INT16_MAX)
 800204e:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8002052:	ea4f 33e4 	mov.w	r3, r4, asr #15
  if (wqd_tmp > INT16_MAX)
 8002056:	da04      	bge.n	8002062 <MCM_Park+0x52>
  else if (wqd_tmp < (-32768))
 8002058:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 800205c:	da0c      	bge.n	8002078 <MCM_Park+0x68>
 800205e:	4b0c      	ldr	r3, [pc, #48]	; (8002090 <MCM_Park+0x80>)
 8002060:	e001      	b.n	8002066 <MCM_Park+0x56>
 8002062:	f647 73ff 	movw	r3, #32767	; 0x7fff
  return (Output);
 8002066:	b292      	uxth	r2, r2
 8002068:	2000      	movs	r0, #0
 800206a:	f362 000f 	bfi	r0, r2, #0, #16
 800206e:	b29b      	uxth	r3, r3
 8002070:	f363 401f 	bfi	r0, r3, #16, #16
}
 8002074:	b005      	add	sp, #20
 8002076:	bd30      	pop	{r4, r5, pc}
    hqd_tmp = ((int16_t)wqd_tmp);
 8002078:	4905      	ldr	r1, [pc, #20]	; (8002090 <MCM_Park+0x80>)
 800207a:	b21b      	sxth	r3, r3
 800207c:	428b      	cmp	r3, r1
 800207e:	bfb8      	it	lt
 8002080:	460b      	movlt	r3, r1
 8002082:	e7f0      	b.n	8002066 <MCM_Park+0x56>
    hqd_tmp = ((int16_t)wqd_tmp);
 8002084:	4b02      	ldr	r3, [pc, #8]	; (8002090 <MCM_Park+0x80>)
 8002086:	b212      	sxth	r2, r2
 8002088:	429a      	cmp	r2, r3
 800208a:	bfb8      	it	lt
 800208c:	461a      	movlt	r2, r3
 800208e:	e7da      	b.n	8002046 <MCM_Park+0x36>
 8002090:	ffff8001 	.word	0xffff8001

08002094 <MCM_Rev_Park>:
{
 8002094:	b530      	push	{r4, r5, lr}
 8002096:	b085      	sub	sp, #20
 8002098:	4604      	mov	r4, r0
 800209a:	4605      	mov	r5, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 800209c:	4608      	mov	r0, r1
{
 800209e:	9401      	str	r4, [sp, #4]
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 80020a0:	f7ff ffa0 	bl	8001fe4 <MCM_Trig_Functions>
 80020a4:	1424      	asrs	r4, r4, #16
 80020a6:	1402      	asrs	r2, r0, #16
 80020a8:	b22d      	sxth	r5, r5
 80020aa:	b200      	sxth	r0, r0
  alpha_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hSin);
 80020ac:	fb04 f302 	mul.w	r3, r4, r2
  Output.alpha = (int16_t)(((alpha_tmp1) + (alpha_tmp2)) >> 15);
 80020b0:	fb05 3300 	mla	r3, r5, r0, r3
  beta_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hCos);
 80020b4:	fb00 f404 	mul.w	r4, r0, r4
  Output.beta = (int16_t)((beta_tmp2 - beta_tmp1) >> 15);
 80020b8:	fb05 4412 	mls	r4, r5, r2, r4
  return (Output);
 80020bc:	f3c3 33cf 	ubfx	r3, r3, #15, #16
 80020c0:	2000      	movs	r0, #0
 80020c2:	f363 000f 	bfi	r0, r3, #0, #16
 80020c6:	f3c4 34cf 	ubfx	r4, r4, #15, #16
 80020ca:	f364 401f 	bfi	r0, r4, #16, #16
}
 80020ce:	b005      	add	sp, #20
 80020d0:	bd30      	pop	{r4, r5, pc}
 80020d2:	bf00      	nop

080020d4 <MCM_Sqrt>:
  */
__weak int32_t MCM_Sqrt(int32_t wInput)
{
  int32_t wtemprootnew;

  if (wInput > 0)
 80020d4:	2800      	cmp	r0, #0
 80020d6:	dd09      	ble.n	80020ec <MCM_Sqrt+0x18>
 80020d8:	b672      	cpsid	i
  {
    uint32_t retVal;
    /* Disable Irq as sqrt is used in MF and HF task */
    __disable_irq();
    /* Configure CORDIC */
    WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_SQRT);
 80020da:	4b05      	ldr	r3, [pc, #20]	; (80020f0 <MCM_Sqrt+0x1c>)
 80020dc:	f240 1269 	movw	r2, #361	; 0x169
 80020e0:	601a      	str	r2, [r3, #0]
  WRITE_REG(CORDICx->WDATA, InData);
 80020e2:	6058      	str	r0, [r3, #4]
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 80020e4:	6898      	ldr	r0, [r3, #8]
    LL_CORDIC_WriteData(CORDIC, ((uint32_t)wInput));
    /* Read sqrt and return */
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
    retVal = (LL_CORDIC_ReadData(CORDIC)) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 80020e6:	0bc0      	lsrs	r0, r0, #15
  __ASM volatile ("cpsie i" : : : "memory");
 80020e8:	b662      	cpsie	i
}
 80020ea:	4770      	bx	lr
    __enable_irq();

  }
  else
  {
    wtemprootnew = (int32_t)0;
 80020ec:	2000      	movs	r0, #0
  }

  return (wtemprootnew);
}
 80020ee:	4770      	bx	lr
 80020f0:	40020c00 	.word	0x40020c00

080020f4 <FOC_Clear>:
  ab_t NULL_ab = {((int16_t)0), ((int16_t)0)};
  qd_t NULL_qd = {((int16_t)0), ((int16_t)0)};
  alphabeta_t NULL_alphabeta = {((int16_t)0), ((int16_t)0)};

  FOCVars[bMotor].Iab = NULL_ab;
  FOCVars[bMotor].Ialphabeta = NULL_alphabeta;
 80020f4:	2226      	movs	r2, #38	; 0x26
{
 80020f6:	b538      	push	{r3, r4, r5, lr}
 80020f8:	fb00 f202 	mul.w	r2, r0, r2
 80020fc:	4b15      	ldr	r3, [pc, #84]	; (8002154 <FOC_Clear+0x60>)
  FOCVars[bMotor].Iab = NULL_ab;
 80020fe:	2400      	movs	r4, #0
 8002100:	509c      	str	r4, [r3, r2]
{
 8002102:	4605      	mov	r5, r0
 8002104:	f102 0108 	add.w	r1, r2, #8
 8002108:	1898      	adds	r0, r3, r2
 800210a:	3210      	adds	r2, #16
 800210c:	4419      	add	r1, r3
 800210e:	4413      	add	r3, r2
  FOCVars[bMotor].hTeref = (int16_t)0;
  FOCVars[bMotor].Vqd = NULL_qd;
  FOCVars[bMotor].Valphabeta = NULL_alphabeta;
  FOCVars[bMotor].hElAngle = (int16_t)0;

  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8002110:	4a11      	ldr	r2, [pc, #68]	; (8002158 <FOC_Clear+0x64>)
  FOCVars[bMotor].Iab = NULL_ab;
 8002112:	6044      	str	r4, [r0, #4]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8002114:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
  FOCVars[bMotor].Iqd = NULL_qd;
 8002118:	604c      	str	r4, [r1, #4]
 800211a:	608c      	str	r4, [r1, #8]
  FOCVars[bMotor].Vqd = NULL_qd;
 800211c:	f8c3 4006 	str.w	r4, [r3, #6]
 8002120:	f8c3 400a 	str.w	r4, [r3, #10]
 8002124:	f8c3 400e 	str.w	r4, [r3, #14]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 8002128:	4621      	mov	r1, r4
 800212a:	f007 f855 	bl	80091d8 <PID_SetIntegralTerm>
  PID_SetIntegralTerm(pPIDId[bMotor], ((int32_t)0));
 800212e:	4b0b      	ldr	r3, [pc, #44]	; (800215c <FOC_Clear+0x68>)
 8002130:	4621      	mov	r1, r4
 8002132:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8002136:	f007 f84f 	bl	80091d8 <PID_SetIntegralTerm>

  STC_Clear(pSTC[bMotor]);
 800213a:	4b09      	ldr	r3, [pc, #36]	; (8002160 <FOC_Clear+0x6c>)
 800213c:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8002140:	f008 f95a 	bl	800a3f8 <STC_Clear>

  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 8002144:	4b07      	ldr	r3, [pc, #28]	; (8002164 <FOC_Clear+0x70>)
 8002146:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]

  /* USER CODE BEGIN FOC_Clear 1 */

  /* USER CODE END FOC_Clear 1 */
}
 800214a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 800214e:	f001 b931 	b.w	80033b4 <PWMC_SwitchOffPWM>
 8002152:	bf00      	nop
 8002154:	20001ac4 	.word	0x20001ac4
 8002158:	200003d8 	.word	0x200003d8
 800215c:	200003d4 	.word	0x200003d4
 8002160:	200003dc 	.word	0x200003dc
 8002164:	20001af8 	.word	0x20001af8

08002168 <MCboot>:
  if (MC_NULL == pMCIList)
 8002168:	2800      	cmp	r0, #0
 800216a:	d073      	beq.n	8002254 <MCboot+0xec>
{
 800216c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bMCBootCompleted = (uint8_t )0;
 8002170:	f8df 9130 	ldr.w	r9, [pc, #304]	; 80022a4 <MCboot+0x13c>
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 8002174:	f8df b130 	ldr.w	fp, [pc, #304]	; 80022a8 <MCboot+0x140>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8002178:	4d37      	ldr	r5, [pc, #220]	; (8002258 <MCboot+0xf0>)
 800217a:	4e38      	ldr	r6, [pc, #224]	; (800225c <MCboot+0xf4>)
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 800217c:	4f38      	ldr	r7, [pc, #224]	; (8002260 <MCboot+0xf8>)
{
 800217e:	b083      	sub	sp, #12
    bMCBootCompleted = (uint8_t )0;
 8002180:	f04f 0800 	mov.w	r8, #0
 8002184:	4604      	mov	r4, r0
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 8002186:	4837      	ldr	r0, [pc, #220]	; (8002264 <MCboot+0xfc>)
 8002188:	f8cb 0000 	str.w	r0, [fp]
    bMCBootCompleted = (uint8_t )0;
 800218c:	f889 8000 	strb.w	r8, [r9]
    R3_1_Init(&PWM_Handle_M1);
 8002190:	f007 fbf8 	bl	8009984 <R3_1_Init>
    ASPEP_start(&aspepOverUartA);
 8002194:	4834      	ldr	r0, [pc, #208]	; (8002268 <MCboot+0x100>)
 8002196:	f7fe ffd7 	bl	8001148 <ASPEP_start>
    startTimers();
 800219a:	f007 f8cd 	bl	8009338 <startTimers>
    PID_HandleInit(&PIDSpeedHandle_M1);
 800219e:	4833      	ldr	r0, [pc, #204]	; (800226c <MCboot+0x104>)
 80021a0:	f007 f806 	bl	80091b0 <PID_HandleInit>
    ENC_Init (&ENCODER_M1);
 80021a4:	4832      	ldr	r0, [pc, #200]	; (8002270 <MCboot+0x108>)
 80021a6:	f006 fd19 	bl	8008bdc <ENC_Init>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 80021aa:	6829      	ldr	r1, [r5, #0]
 80021ac:	4b30      	ldr	r3, [pc, #192]	; (8002270 <MCboot+0x108>)
 80021ae:	4a31      	ldr	r2, [pc, #196]	; (8002274 <MCboot+0x10c>)
 80021b0:	4630      	mov	r0, r6
 80021b2:	f006 fcc7 	bl	8008b44 <EAC_Init>
    pEAC[M1] = &EncAlignCtrlM1;
 80021b6:	4b30      	ldr	r3, [pc, #192]	; (8002278 <MCboot+0x110>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 80021b8:	4a2d      	ldr	r2, [pc, #180]	; (8002270 <MCboot+0x108>)
 80021ba:	492c      	ldr	r1, [pc, #176]	; (800226c <MCboot+0x104>)
    pEAC[M1] = &EncAlignCtrlM1;
 80021bc:	601e      	str	r6, [r3, #0]
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 80021be:	6828      	ldr	r0, [r5, #0]
    RVBS_Init(&BusVoltageSensor_M1);
 80021c0:	4e2e      	ldr	r6, [pc, #184]	; (800227c <MCboot+0x114>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 80021c2:	f008 f8ff 	bl	800a3c4 <STC_Init>
    STO_PLL_Init (&STO_PLL_M1);
 80021c6:	482e      	ldr	r0, [pc, #184]	; (8002280 <MCboot+0x118>)
 80021c8:	f008 fba8 	bl	800a91c <STO_PLL_Init>
    VSS_Init(&VirtualSpeedSensorM1);
 80021cc:	4829      	ldr	r0, [pc, #164]	; (8002274 <MCboot+0x10c>)
 80021ce:	f008 fc21 	bl	800aa14 <VSS_Init>
    PID_HandleInit(&PIDIqHandle_M1);
 80021d2:	482c      	ldr	r0, [pc, #176]	; (8002284 <MCboot+0x11c>)
 80021d4:	f006 ffec 	bl	80091b0 <PID_HandleInit>
    PID_HandleInit(&PIDIdHandle_M1);
 80021d8:	482b      	ldr	r0, [pc, #172]	; (8002288 <MCboot+0x120>)
 80021da:	f006 ffe9 	bl	80091b0 <PID_HandleInit>
    (void)RCM_RegisterRegConv(&VbusRegConv_M1);
 80021de:	482b      	ldr	r0, [pc, #172]	; (800228c <MCboot+0x124>)
 80021e0:	f002 f988 	bl	80044f4 <RCM_RegisterRegConv>
    RVBS_Init(&BusVoltageSensor_M1);
 80021e4:	4630      	mov	r0, r6
 80021e6:	f008 f847 	bl	800a278 <RVBS_Init>
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 80021ea:	4b29      	ldr	r3, [pc, #164]	; (8002290 <MCboot+0x128>)
    NTC_Init(&TempSensor_M1);
 80021ec:	4829      	ldr	r0, [pc, #164]	; (8002294 <MCboot+0x12c>)
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 80021ee:	681b      	ldr	r3, [r3, #0]
 80021f0:	60de      	str	r6, [r3, #12]
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 80021f2:	4e29      	ldr	r6, [pc, #164]	; (8002298 <MCboot+0x130>)
 80021f4:	609e      	str	r6, [r3, #8]
    NTC_Init(&TempSensor_M1);
 80021f6:	f006 ffbd 	bl	8009174 <NTC_Init>
    REMNG_Init(pREMNG[M1]);
 80021fa:	4828      	ldr	r0, [pc, #160]	; (800229c <MCboot+0x134>)
 80021fc:	f008 f896 	bl	800a32c <REMNG_Init>
    FOCVars[M1].bDriveInput = EXTERNAL;
 8002200:	f04f 0a01 	mov.w	sl, #1
    FOC_Clear(M1);
 8002204:	4640      	mov	r0, r8
 8002206:	f7ff ff75 	bl	80020f4 <FOC_Clear>
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 800220a:	6828      	ldr	r0, [r5, #0]
    FOCVars[M1].bDriveInput = EXTERNAL;
 800220c:	f886 a024 	strb.w	sl, [r6, #36]	; 0x24
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 8002210:	f008 f97c 	bl	800a50c <STC_GetDefaultIqdref>
 8002214:	6130      	str	r0, [r6, #16]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8002216:	6828      	ldr	r0, [r5, #0]
 8002218:	f008 f978 	bl	800a50c <STC_GetDefaultIqdref>
 800221c:	f3c0 400f 	ubfx	r0, r0, #16, #16
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 8002220:	6829      	ldr	r1, [r5, #0]
 8002222:	f8db 3000 	ldr.w	r3, [fp]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 8002226:	82b0      	strh	r0, [r6, #20]
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 8002228:	4632      	mov	r2, r6
 800222a:	4638      	mov	r0, r7
 800222c:	f7ff fd2c 	bl	8001c88 <MCI_Init>
   Mci[M1].pScale = &scaleParams_M1;
 8002230:	4b1b      	ldr	r3, [pc, #108]	; (80022a0 <MCboot+0x138>)
    MCI_ExecSpeedRamp(&Mci[M1],
 8002232:	6828      	ldr	r0, [r5, #0]
   Mci[M1].pScale = &scaleParams_M1;
 8002234:	61bb      	str	r3, [r7, #24]
    MCI_ExecSpeedRamp(&Mci[M1],
 8002236:	f008 f965 	bl	800a504 <STC_GetMecSpeedRefUnitDefault>
 800223a:	4642      	mov	r2, r8
 800223c:	4601      	mov	r1, r0
 800223e:	4638      	mov	r0, r7
 8002240:	f7ff fd32 	bl	8001ca8 <MCI_ExecSpeedRamp>
    pMCIList[M1] = &Mci[M1];
 8002244:	6027      	str	r7, [r4, #0]
    MC_APP_BootHook();
 8002246:	f7ff fd1b 	bl	8001c80 <MC_APP_BootHook>
    bMCBootCompleted = 1U;
 800224a:	f889 a000 	strb.w	sl, [r9]
}
 800224e:	b003      	add	sp, #12
 8002250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002254:	4770      	bx	lr
 8002256:	bf00      	nop
 8002258:	200003dc 	.word	0x200003dc
 800225c:	200000a4 	.word	0x200000a4
 8002260:	20001a90 	.word	0x20001a90
 8002264:	20000154 	.word	0x20000154
 8002268:	20000450 	.word	0x20000450
 800226c:	20000118 	.word	0x20000118
 8002270:	20000024 	.word	0x20000024
 8002274:	20000398 	.word	0x20000398
 8002278:	20001af4 	.word	0x20001af4
 800227c:	20000004 	.word	0x20000004
 8002280:	20000210 	.word	0x20000210
 8002284:	200000ec 	.word	0x200000ec
 8002288:	200000c0 	.word	0x200000c0
 800228c:	20000388 	.word	0x20000388
 8002290:	200003d0 	.word	0x200003d0
 8002294:	2000036c 	.word	0x2000036c
 8002298:	20001ac4 	.word	0x20001ac4
 800229c:	200001f8 	.word	0x200001f8
 80022a0:	200003f0 	.word	0x200003f0
 80022a4:	20001aea 	.word	0x20001aea
 80022a8:	20001af8 	.word	0x20001af8

080022ac <FOC_InitAdditionalMethods>:
    {
  /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */

  /* USER CODE END FOC_InitAdditionalMethods 0 */
    }
}
 80022ac:	4770      	bx	lr
 80022ae:	bf00      	nop

080022b0 <FOC_CalcCurrRef>:
  *         MTPA algorithm(s). It must be called with the periodicity specified
  *         in oTSC parameters.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_CalcCurrRef(uint8_t bMotor)
{
 80022b0:	b510      	push	{r4, lr}

  /* USER CODE BEGIN FOC_CalcCurrRef 0 */

  /* USER CODE END FOC_CalcCurrRef 0 */
  if (INTERNAL == FOCVars[bMotor].bDriveInput)
 80022b2:	4c08      	ldr	r4, [pc, #32]	; (80022d4 <FOC_CalcCurrRef+0x24>)
 80022b4:	2326      	movs	r3, #38	; 0x26
 80022b6:	fb03 4400 	mla	r4, r3, r0, r4
 80022ba:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80022be:	b103      	cbz	r3, 80022c2 <FOC_CalcCurrRef+0x12>
    /* Nothing to do */
  }
  /* USER CODE BEGIN FOC_CalcCurrRef 1 */

  /* USER CODE END FOC_CalcCurrRef 1 */
}
 80022c0:	bd10      	pop	{r4, pc}
    FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
 80022c2:	4b05      	ldr	r3, [pc, #20]	; (80022d8 <FOC_CalcCurrRef+0x28>)
 80022c4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80022c8:	f008 f8f2 	bl	800a4b0 <STC_CalcTorqueReference>
 80022cc:	83e0      	strh	r0, [r4, #30]
    FOCVars[bMotor].Iqdref.q = FOCVars[bMotor].hTeref;
 80022ce:	8220      	strh	r0, [r4, #16]
}
 80022d0:	bd10      	pop	{r4, pc}
 80022d2:	bf00      	nop
 80022d4:	20001ac4 	.word	0x20001ac4
 80022d8:	200003dc 	.word	0x200003dc

080022dc <TSK_SetChargeBootCapDelayM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount)
{
   hBootCapDelayCounterM1 = hTickCount;
 80022dc:	4b01      	ldr	r3, [pc, #4]	; (80022e4 <TSK_SetChargeBootCapDelayM1+0x8>)
 80022de:	8018      	strh	r0, [r3, #0]
}
 80022e0:	4770      	bx	lr
 80022e2:	bf00      	nop
 80022e4:	20001aec 	.word	0x20001aec

080022e8 <TSK_ChargeBootCapDelayHasElapsedM1>:
  * @retval bool true if time has elapsed, false otherwise.
  */
__weak bool TSK_ChargeBootCapDelayHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hBootCapDelayCounterM1)
 80022e8:	4b03      	ldr	r3, [pc, #12]	; (80022f8 <TSK_ChargeBootCapDelayHasElapsedM1+0x10>)
 80022ea:	8818      	ldrh	r0, [r3, #0]
 80022ec:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 80022ee:	fab0 f080 	clz	r0, r0
 80022f2:	0940      	lsrs	r0, r0, #5
 80022f4:	4770      	bx	lr
 80022f6:	bf00      	nop
 80022f8:	20001aec 	.word	0x20001aec

080022fc <TSK_SetStopPermanencyTimeM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount)
{
  hStopPermanencyCounterM1 = hTickCount;
 80022fc:	4b01      	ldr	r3, [pc, #4]	; (8002304 <TSK_SetStopPermanencyTimeM1+0x8>)
 80022fe:	8018      	strh	r0, [r3, #0]
}
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
 8002304:	20001af0 	.word	0x20001af0

08002308 <TSK_StopPermanencyTimeHasElapsedM1>:
  * @retval bool true if time is elapsed, false otherwise.
  */
__weak bool TSK_StopPermanencyTimeHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hStopPermanencyCounterM1)
 8002308:	4b03      	ldr	r3, [pc, #12]	; (8002318 <TSK_StopPermanencyTimeHasElapsedM1+0x10>)
 800230a:	8818      	ldrh	r0, [r3, #0]
 800230c:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 800230e:	fab0 f080 	clz	r0, r0
 8002312:	0940      	lsrs	r0, r0, #5
 8002314:	4770      	bx	lr
 8002316:	bf00      	nop
 8002318:	20001af0 	.word	0x20001af0

0800231c <TSK_MediumFrequencyTaskM1>:
{
 800231c:	b570      	push	{r4, r5, r6, lr}
 800231e:	b082      	sub	sp, #8
  int16_t wAux = 0;
 8002320:	2300      	movs	r3, #0
  (void)STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 8002322:	f10d 0106 	add.w	r1, sp, #6
 8002326:	48a1      	ldr	r0, [pc, #644]	; (80025ac <TSK_MediumFrequencyTaskM1+0x290>)
  PQD_CalcElMotorPower(pMPM[M1]);
 8002328:	4da1      	ldr	r5, [pc, #644]	; (80025b0 <TSK_MediumFrequencyTaskM1+0x294>)
  int16_t wAux = 0;
 800232a:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 800232e:	4ca1      	ldr	r4, [pc, #644]	; (80025b4 <TSK_MediumFrequencyTaskM1+0x298>)
  (void)STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 8002330:	f008 f9f4 	bl	800a71c <STO_PLL_CalcAvrgMecSpeedUnit>
  (void)ENC_CalcAvrgMecSpeedUnit(&ENCODER_M1, &wAux);
 8002334:	f10d 0106 	add.w	r1, sp, #6
 8002338:	489f      	ldr	r0, [pc, #636]	; (80025b8 <TSK_MediumFrequencyTaskM1+0x29c>)
 800233a:	f006 fcb3 	bl	8008ca4 <ENC_CalcAvrgMecSpeedUnit>
  PQD_CalcElMotorPower(pMPM[M1]);
 800233e:	6828      	ldr	r0, [r5, #0]
 8002340:	f006 ffc0 	bl	80092c4 <PQD_CalcElMotorPower>
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 8002344:	4620      	mov	r0, r4
 8002346:	f7ff fd29 	bl	8001d9c <MCI_GetCurrentFaults>
 800234a:	b118      	cbz	r0, 8002354 <TSK_MediumFrequencyTaskM1+0x38>
    Mci[M1].State = FAULT_NOW;
 800234c:	230a      	movs	r3, #10
 800234e:	77e3      	strb	r3, [r4, #31]
}
 8002350:	b002      	add	sp, #8
 8002352:	bd70      	pop	{r4, r5, r6, pc}
    if (MCI_GetOccurredFaults(&Mci[M1]) == MC_NO_FAULTS)
 8002354:	4620      	mov	r0, r4
 8002356:	f7ff fd1f 	bl	8001d98 <MCI_GetOccurredFaults>
 800235a:	bb78      	cbnz	r0, 80023bc <TSK_MediumFrequencyTaskM1+0xa0>
      switch (Mci[M1].State)
 800235c:	7fe3      	ldrb	r3, [r4, #31]
 800235e:	2b14      	cmp	r3, #20
 8002360:	d8f6      	bhi.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
 8002362:	a201      	add	r2, pc, #4	; (adr r2, 8002368 <TSK_MediumFrequencyTaskM1+0x4c>)
 8002364:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002368:	0800250d 	.word	0x0800250d
 800236c:	08002351 	.word	0x08002351
 8002370:	080024bb 	.word	0x080024bb
 8002374:	08002351 	.word	0x08002351
 8002378:	08002351 	.word	0x08002351
 800237c:	08002351 	.word	0x08002351
 8002380:	080024a7 	.word	0x080024a7
 8002384:	08002351 	.word	0x08002351
 8002388:	0800249b 	.word	0x0800249b
 800238c:	08002351 	.word	0x08002351
 8002390:	080023bd 	.word	0x080023bd
 8002394:	0800248d 	.word	0x0800248d
 8002398:	08002351 	.word	0x08002351
 800239c:	08002351 	.word	0x08002351
 80023a0:	08002351 	.word	0x08002351
 80023a4:	08002351 	.word	0x08002351
 80023a8:	08002435 	.word	0x08002435
 80023ac:	08002403 	.word	0x08002403
 80023b0:	08002351 	.word	0x08002351
 80023b4:	08002351 	.word	0x08002351
 80023b8:	080023c5 	.word	0x080023c5
      Mci[M1].State = FAULT_OVER;
 80023bc:	230b      	movs	r3, #11
 80023be:	77e3      	strb	r3, [r4, #31]
}
 80023c0:	b002      	add	sp, #8
 80023c2:	bd70      	pop	{r4, r5, r6, pc}
          if (MCI_STOP == Mci[M1].DirectCommand)
 80023c4:	7fa3      	ldrb	r3, [r4, #30]
 80023c6:	2b05      	cmp	r3, #5
 80023c8:	f000 80b0 	beq.w	800252c <TSK_MediumFrequencyTaskM1+0x210>
            if (TSK_StopPermanencyTimeHasElapsedM1())
 80023cc:	f7ff ff9c 	bl	8002308 <TSK_StopPermanencyTimeHasElapsedM1>
 80023d0:	2800      	cmp	r0, #0
 80023d2:	d0bd      	beq.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
              ENC_Clear(&ENCODER_M1);
 80023d4:	4878      	ldr	r0, [pc, #480]	; (80025b8 <TSK_MediumFrequencyTaskM1+0x29c>)
 80023d6:	f006 fc3d 	bl	8008c54 <ENC_Clear>
              R3_1_SwitchOnPWM(pwmcHandle[M1]);
 80023da:	4b78      	ldr	r3, [pc, #480]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
 80023dc:	6818      	ldr	r0, [r3, #0]
 80023de:	f007 f92b 	bl	8009638 <R3_1_SwitchOnPWM>
              FOC_InitAdditionalMethods(M1);
 80023e2:	2000      	movs	r0, #0
 80023e4:	f7ff ff62 	bl	80022ac <FOC_InitAdditionalMethods>
              STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 80023e8:	4b75      	ldr	r3, [pc, #468]	; (80025c0 <TSK_MediumFrequencyTaskM1+0x2a4>)
 80023ea:	6818      	ldr	r0, [r3, #0]
 80023ec:	f008 f89c 	bl	800a528 <STC_ForceSpeedReferenceToCurrentSpeed>
              MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 80023f0:	4870      	ldr	r0, [pc, #448]	; (80025b4 <TSK_MediumFrequencyTaskM1+0x298>)
 80023f2:	f7ff fc93 	bl	8001d1c <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 80023f6:	2000      	movs	r0, #0
 80023f8:	f7ff ff5a 	bl	80022b0 <FOC_CalcCurrRef>
              Mci[M1].State = RUN;
 80023fc:	2306      	movs	r3, #6
 80023fe:	77e3      	strb	r3, [r4, #31]
 8002400:	e7a6      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8002402:	7fa3      	ldrb	r3, [r4, #30]
 8002404:	2b05      	cmp	r3, #5
 8002406:	f000 8091 	beq.w	800252c <TSK_MediumFrequencyTaskM1+0x210>
            if (PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC))
 800240a:	4e6c      	ldr	r6, [pc, #432]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
 800240c:	2101      	movs	r1, #1
 800240e:	6830      	ldr	r0, [r6, #0]
 8002410:	f000 ffd4 	bl	80033bc <PWMC_CurrentReadingCalibr>
 8002414:	2800      	cmp	r0, #0
 8002416:	d09b      	beq.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
              if (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand)
 8002418:	7fa3      	ldrb	r3, [r4, #30]
 800241a:	2b03      	cmp	r3, #3
 800241c:	f000 80a6 	beq.w	800256c <TSK_MediumFrequencyTaskM1+0x250>
                R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8002420:	6830      	ldr	r0, [r6, #0]
 8002422:	2100      	movs	r1, #0
 8002424:	f007 fa10 	bl	8009848 <R3_1_TurnOnLowSides>
                TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 8002428:	2014      	movs	r0, #20
 800242a:	f7ff ff57 	bl	80022dc <TSK_SetChargeBootCapDelayM1>
                Mci[M1].State = CHARGE_BOOT_CAP;
 800242e:	2310      	movs	r3, #16
 8002430:	77e3      	strb	r3, [r4, #31]
 8002432:	e78d      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8002434:	7fa3      	ldrb	r3, [r4, #30]
 8002436:	2b05      	cmp	r3, #5
 8002438:	d078      	beq.n	800252c <TSK_MediumFrequencyTaskM1+0x210>
            if (TSK_ChargeBootCapDelayHasElapsedM1())
 800243a:	f7ff ff55 	bl	80022e8 <TSK_ChargeBootCapDelayHasElapsedM1>
 800243e:	2800      	cmp	r0, #0
 8002440:	d086      	beq.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8002442:	4d5e      	ldr	r5, [pc, #376]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8002444:	4e5e      	ldr	r6, [pc, #376]	; (80025c0 <TSK_MediumFrequencyTaskM1+0x2a4>)
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8002446:	6828      	ldr	r0, [r5, #0]
 8002448:	f007 f942 	bl	80096d0 <R3_1_SwitchOffPWM>
              FOCVars[M1].bDriveInput = EXTERNAL;
 800244c:	4b5d      	ldr	r3, [pc, #372]	; (80025c4 <TSK_MediumFrequencyTaskM1+0x2a8>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 800244e:	495e      	ldr	r1, [pc, #376]	; (80025c8 <TSK_MediumFrequencyTaskM1+0x2ac>)
 8002450:	6830      	ldr	r0, [r6, #0]
              FOCVars[M1].bDriveInput = EXTERNAL;
 8002452:	2201      	movs	r2, #1
 8002454:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8002458:	f007 ffca 	bl	800a3f0 <STC_SetSpeedSensor>
              ENC_Clear(&ENCODER_M1);
 800245c:	4856      	ldr	r0, [pc, #344]	; (80025b8 <TSK_MediumFrequencyTaskM1+0x29c>)
 800245e:	f006 fbf9 	bl	8008c54 <ENC_Clear>
              STO_PLL_Clear(&STO_PLL_M1);
 8002462:	4852      	ldr	r0, [pc, #328]	; (80025ac <TSK_MediumFrequencyTaskM1+0x290>)
 8002464:	f008 fa34 	bl	800a8d0 <STO_PLL_Clear>
              FOC_Clear( M1 );
 8002468:	2000      	movs	r0, #0
 800246a:	f7ff fe43 	bl	80020f4 <FOC_Clear>
              if (EAC_IsAligned(&EncAlignCtrlM1) == false)
 800246e:	4857      	ldr	r0, [pc, #348]	; (80025cc <TSK_MediumFrequencyTaskM1+0x2b0>)
 8002470:	f006 fbb0 	bl	8008bd4 <EAC_IsAligned>
 8002474:	2800      	cmp	r0, #0
 8002476:	f040 8082 	bne.w	800257e <TSK_MediumFrequencyTaskM1+0x262>
                EAC_StartAlignment(&EncAlignCtrlM1);
 800247a:	4854      	ldr	r0, [pc, #336]	; (80025cc <TSK_MediumFrequencyTaskM1+0x2b0>)
 800247c:	f006 fb6a 	bl	8008b54 <EAC_StartAlignment>
                Mci[M1].State = ALIGNMENT;
 8002480:	2302      	movs	r3, #2
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 8002482:	6828      	ldr	r0, [r5, #0]
                Mci[M1].State = ALIGNMENT;
 8002484:	77e3      	strb	r3, [r4, #31]
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 8002486:	f000 ff97 	bl	80033b8 <PWMC_SwitchOnPWM>
 800248a:	e761      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_ACK_FAULTS == Mci[M1].DirectCommand)
 800248c:	7fa3      	ldrb	r3, [r4, #30]
 800248e:	2b02      	cmp	r3, #2
 8002490:	f47f af5e 	bne.w	8002350 <TSK_MediumFrequencyTaskM1+0x34>
            Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8002494:	2300      	movs	r3, #0
 8002496:	83e3      	strh	r3, [r4, #30]
 8002498:	e75a      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if (TSK_StopPermanencyTimeHasElapsedM1())
 800249a:	f7ff ff35 	bl	8002308 <TSK_StopPermanencyTimeHasElapsedM1>
 800249e:	2800      	cmp	r0, #0
 80024a0:	f43f af56 	beq.w	8002350 <TSK_MediumFrequencyTaskM1+0x34>
 80024a4:	e7f6      	b.n	8002494 <TSK_MediumFrequencyTaskM1+0x178>
          if (MCI_STOP == Mci[M1].DirectCommand)
 80024a6:	7fa3      	ldrb	r3, [r4, #30]
 80024a8:	2b05      	cmp	r3, #5
 80024aa:	d03f      	beq.n	800252c <TSK_MediumFrequencyTaskM1+0x210>
            MCI_ExecBufferedCommands(&Mci[M1]);
 80024ac:	4841      	ldr	r0, [pc, #260]	; (80025b4 <TSK_MediumFrequencyTaskM1+0x298>)
 80024ae:	f7ff fc35 	bl	8001d1c <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 80024b2:	2000      	movs	r0, #0
 80024b4:	f7ff fefc 	bl	80022b0 <FOC_CalcCurrRef>
 80024b8:	e74a      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 80024ba:	7fa3      	ldrb	r3, [r4, #30]
 80024bc:	2b05      	cmp	r3, #5
 80024be:	d035      	beq.n	800252c <TSK_MediumFrequencyTaskM1+0x210>
            bool isAligned = EAC_IsAligned(&EncAlignCtrlM1);
 80024c0:	4842      	ldr	r0, [pc, #264]	; (80025cc <TSK_MediumFrequencyTaskM1+0x2b0>)
 80024c2:	f006 fb87 	bl	8008bd4 <EAC_IsAligned>
 80024c6:	4605      	mov	r5, r0
            bool EACDone = EAC_Exec(&EncAlignCtrlM1);
 80024c8:	4840      	ldr	r0, [pc, #256]	; (80025cc <TSK_MediumFrequencyTaskM1+0x2b0>)
 80024ca:	f006 fb6b 	bl	8008ba4 <EAC_Exec>
 80024ce:	4606      	mov	r6, r0
            if ((isAligned == false)  && (EACDone == false))
 80024d0:	b90d      	cbnz	r5, 80024d6 <TSK_MediumFrequencyTaskM1+0x1ba>
 80024d2:	2800      	cmp	r0, #0
 80024d4:	d042      	beq.n	800255c <TSK_MediumFrequencyTaskM1+0x240>
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 80024d6:	4d39      	ldr	r5, [pc, #228]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 80024d8:	4e39      	ldr	r6, [pc, #228]	; (80025c0 <TSK_MediumFrequencyTaskM1+0x2a4>)
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 80024da:	6828      	ldr	r0, [r5, #0]
 80024dc:	f007 f8f8 	bl	80096d0 <R3_1_SwitchOffPWM>
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 80024e0:	6830      	ldr	r0, [r6, #0]
 80024e2:	2103      	movs	r1, #3
 80024e4:	f007 ff98 	bl	800a418 <STC_SetControlMode>
              STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 80024e8:	4933      	ldr	r1, [pc, #204]	; (80025b8 <TSK_MediumFrequencyTaskM1+0x29c>)
 80024ea:	6830      	ldr	r0, [r6, #0]
 80024ec:	f007 ff80 	bl	800a3f0 <STC_SetSpeedSensor>
              FOC_Clear(M1);
 80024f0:	2000      	movs	r0, #0
 80024f2:	f7ff fdff 	bl	80020f4 <FOC_Clear>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 80024f6:	6828      	ldr	r0, [r5, #0]
 80024f8:	2100      	movs	r1, #0
 80024fa:	f007 f9a5 	bl	8009848 <R3_1_TurnOnLowSides>
              TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 80024fe:	f44f 7048 	mov.w	r0, #800	; 0x320
 8002502:	f7ff fefb 	bl	80022fc <TSK_SetStopPermanencyTimeM1>
              Mci[M1].State = WAIT_STOP_MOTOR;
 8002506:	2314      	movs	r3, #20
 8002508:	77e3      	strb	r3, [r4, #31]
 800250a:	e721      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
          if ((MCI_START == Mci[M1].DirectCommand) || (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand))
 800250c:	7fa3      	ldrb	r3, [r4, #30]
 800250e:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8002512:	2b01      	cmp	r3, #1
 8002514:	f47f af1c 	bne.w	8002350 <TSK_MediumFrequencyTaskM1+0x34>
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 8002518:	4d28      	ldr	r5, [pc, #160]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
 800251a:	6828      	ldr	r0, [r5, #0]
 800251c:	f890 1081 	ldrb.w	r1, [r0, #129]	; 0x81
 8002520:	b9a9      	cbnz	r1, 800254e <TSK_MediumFrequencyTaskM1+0x232>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_START);
 8002522:	f000 ff4b 	bl	80033bc <PWMC_CurrentReadingCalibr>
              Mci[M1].State = OFFSET_CALIB;
 8002526:	2311      	movs	r3, #17
 8002528:	77e3      	strb	r3, [r4, #31]
 800252a:	e711      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 800252c:	4b23      	ldr	r3, [pc, #140]	; (80025bc <TSK_MediumFrequencyTaskM1+0x2a0>)
 800252e:	6818      	ldr	r0, [r3, #0]
 8002530:	f007 f8ce 	bl	80096d0 <R3_1_SwitchOffPWM>
  FOC_Clear(motor);
 8002534:	2000      	movs	r0, #0
 8002536:	f7ff fddd 	bl	80020f4 <FOC_Clear>
  PQD_Clear(pMPM[motor]);
 800253a:	6828      	ldr	r0, [r5, #0]
 800253c:	f006 fede 	bl	80092fc <PQD_Clear>
  TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 8002540:	f44f 7048 	mov.w	r0, #800	; 0x320
 8002544:	f7ff feda 	bl	80022fc <TSK_SetStopPermanencyTimeM1>
  Mci[motor].State = STOP;
 8002548:	2308      	movs	r3, #8
 800254a:	77e3      	strb	r3, [r4, #31]
}
 800254c:	e700      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 800254e:	4619      	mov	r1, r3
              pwmcHandle[M1]->OffCalibrWaitTimeCounter = 1u;
 8002550:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 8002554:	f000 ff32 	bl	80033bc <PWMC_CurrentReadingCalibr>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8002558:	6828      	ldr	r0, [r5, #0]
 800255a:	e762      	b.n	8002422 <TSK_MediumFrequencyTaskM1+0x106>
              IqdRef.d = STC_CalcTorqueReference(pSTC[M1]);
 800255c:	4b18      	ldr	r3, [pc, #96]	; (80025c0 <TSK_MediumFrequencyTaskM1+0x2a4>)
 800255e:	6818      	ldr	r0, [r3, #0]
 8002560:	f007 ffa6 	bl	800a4b0 <STC_CalcTorqueReference>
              FOCVars[M1].Iqdref = IqdRef;
 8002564:	4b17      	ldr	r3, [pc, #92]	; (80025c4 <TSK_MediumFrequencyTaskM1+0x2a8>)
 8002566:	821e      	strh	r6, [r3, #16]
 8002568:	8258      	strh	r0, [r3, #18]
            {
 800256a:	e6f1      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
                FOC_Clear(M1);
 800256c:	2000      	movs	r0, #0
 800256e:	f7ff fdc1 	bl	80020f4 <FOC_Clear>
                PQD_Clear(pMPM[M1]);
 8002572:	6828      	ldr	r0, [r5, #0]
 8002574:	f006 fec2 	bl	80092fc <PQD_Clear>
                Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8002578:	2300      	movs	r3, #0
 800257a:	83e3      	strh	r3, [r4, #30]
 800257c:	e6e8      	b.n	8002350 <TSK_MediumFrequencyTaskM1+0x34>
                STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 800257e:	6830      	ldr	r0, [r6, #0]
 8002580:	2103      	movs	r1, #3
 8002582:	f007 ff49 	bl	800a418 <STC_SetControlMode>
                STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 8002586:	490c      	ldr	r1, [pc, #48]	; (80025b8 <TSK_MediumFrequencyTaskM1+0x29c>)
 8002588:	6830      	ldr	r0, [r6, #0]
 800258a:	f007 ff31 	bl	800a3f0 <STC_SetSpeedSensor>
                FOC_InitAdditionalMethods(M1);
 800258e:	2000      	movs	r0, #0
 8002590:	f7ff fe8c 	bl	80022ac <FOC_InitAdditionalMethods>
                FOC_CalcCurrRef(M1);
 8002594:	2000      	movs	r0, #0
 8002596:	f7ff fe8b 	bl	80022b0 <FOC_CalcCurrRef>
                STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 800259a:	6830      	ldr	r0, [r6, #0]
 800259c:	f007 ffc4 	bl	800a528 <STC_ForceSpeedReferenceToCurrentSpeed>
                MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 80025a0:	4804      	ldr	r0, [pc, #16]	; (80025b4 <TSK_MediumFrequencyTaskM1+0x298>)
 80025a2:	f7ff fbbb 	bl	8001d1c <MCI_ExecBufferedCommands>
 80025a6:	2306      	movs	r3, #6
 80025a8:	e76b      	b.n	8002482 <TSK_MediumFrequencyTaskM1+0x166>
 80025aa:	bf00      	nop
 80025ac:	20000210 	.word	0x20000210
 80025b0:	200003d0 	.word	0x200003d0
 80025b4:	20001a90 	.word	0x20001a90
 80025b8:	20000024 	.word	0x20000024
 80025bc:	20001af8 	.word	0x20001af8
 80025c0:	200003dc 	.word	0x200003dc
 80025c4:	20001ac4 	.word	0x20001ac4
 80025c8:	20000398 	.word	0x20000398
 80025cc:	200000a4 	.word	0x200000a4

080025d0 <MC_Scheduler>:
  if (((uint8_t)1) == bMCBootCompleted)
 80025d0:	4b1d      	ldr	r3, [pc, #116]	; (8002648 <MC_Scheduler+0x78>)
 80025d2:	781b      	ldrb	r3, [r3, #0]
 80025d4:	2b01      	cmp	r3, #1
 80025d6:	d000      	beq.n	80025da <MC_Scheduler+0xa>
 80025d8:	4770      	bx	lr
{
 80025da:	b570      	push	{r4, r5, r6, lr}
    if(hMFTaskCounterM1 > 0u)
 80025dc:	4c1b      	ldr	r4, [pc, #108]	; (800264c <MC_Scheduler+0x7c>)
 80025de:	8823      	ldrh	r3, [r4, #0]
 80025e0:	b19b      	cbz	r3, 800260a <MC_Scheduler+0x3a>
      hMFTaskCounterM1--;
 80025e2:	3b01      	subs	r3, #1
 80025e4:	b29b      	uxth	r3, r3
    if(hBootCapDelayCounterM1 > 0U)
 80025e6:	4a1a      	ldr	r2, [pc, #104]	; (8002650 <MC_Scheduler+0x80>)
      hMFTaskCounterM1--;
 80025e8:	8023      	strh	r3, [r4, #0]
    if(hBootCapDelayCounterM1 > 0U)
 80025ea:	8813      	ldrh	r3, [r2, #0]
 80025ec:	b29b      	uxth	r3, r3
 80025ee:	b11b      	cbz	r3, 80025f8 <MC_Scheduler+0x28>
      hBootCapDelayCounterM1--;
 80025f0:	8813      	ldrh	r3, [r2, #0]
 80025f2:	3b01      	subs	r3, #1
 80025f4:	b29b      	uxth	r3, r3
 80025f6:	8013      	strh	r3, [r2, #0]
    if(hStopPermanencyCounterM1 > 0U)
 80025f8:	4a16      	ldr	r2, [pc, #88]	; (8002654 <MC_Scheduler+0x84>)
 80025fa:	8813      	ldrh	r3, [r2, #0]
 80025fc:	b29b      	uxth	r3, r3
 80025fe:	b11b      	cbz	r3, 8002608 <MC_Scheduler+0x38>
      hStopPermanencyCounterM1--;
 8002600:	8813      	ldrh	r3, [r2, #0]
 8002602:	3b01      	subs	r3, #1
 8002604:	b29b      	uxth	r3, r3
 8002606:	8013      	strh	r3, [r2, #0]
}
 8002608:	bd70      	pop	{r4, r5, r6, pc}
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 800260a:	4d13      	ldr	r5, [pc, #76]	; (8002658 <MC_Scheduler+0x88>)
      TSK_MediumFrequencyTaskM1();
 800260c:	f7ff fe86 	bl	800231c <TSK_MediumFrequencyTaskM1>
      MC_APP_PostMediumFrequencyHook_M1();
 8002610:	f7ff fb38 	bl	8001c84 <MC_APP_PostMediumFrequencyHook_M1>
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 8002614:	4629      	mov	r1, r5
 8002616:	f851 0b0c 	ldr.w	r0, [r1], #12
 800261a:	6883      	ldr	r3, [r0, #8]
 800261c:	4798      	blx	r3
 800261e:	6068      	str	r0, [r5, #4]
      if ( 0U == MCP_Over_UartA.rxBuffer)
 8002620:	b130      	cbz	r0, 8002630 <MC_Scheduler+0x60>
        if (0U == MCP_Over_UartA.pTransportLayer->fGetBuffer(MCP_Over_UartA.pTransportLayer,
 8002622:	4629      	mov	r1, r5
 8002624:	220a      	movs	r2, #10
 8002626:	f851 0b08 	ldr.w	r0, [r1], #8
 800262a:	6803      	ldr	r3, [r0, #0]
 800262c:	4798      	blx	r3
 800262e:	b908      	cbnz	r0, 8002634 <MC_Scheduler+0x64>
{
 8002630:	2301      	movs	r3, #1
 8002632:	e7d8      	b.n	80025e6 <MC_Scheduler+0x16>
          MCP_ReceivedPacket(&MCP_Over_UartA);
 8002634:	4628      	mov	r0, r5
 8002636:	f000 fa59 	bl	8002aec <MCP_ReceivedPacket>
          MCP_Over_UartA.pTransportLayer->fSendPacket(MCP_Over_UartA.pTransportLayer, MCP_Over_UartA.txBuffer,
 800263a:	6828      	ldr	r0, [r5, #0]
 800263c:	89ea      	ldrh	r2, [r5, #14]
 800263e:	6846      	ldr	r6, [r0, #4]
 8002640:	68a9      	ldr	r1, [r5, #8]
 8002642:	230a      	movs	r3, #10
 8002644:	47b0      	blx	r6
 8002646:	e7f3      	b.n	8002630 <MC_Scheduler+0x60>
 8002648:	20001aea 	.word	0x20001aea
 800264c:	20001aee 	.word	0x20001aee
 8002650:	20001aec 	.word	0x20001aec
 8002654:	20001af0 	.word	0x20001af0
 8002658:	2000042c 	.word	0x2000042c

0800265c <TSK_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t TSK_HighFrequencyTask(void)
{
 800265c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* USER CODE BEGIN HighFrequencyTask 0 */

  /* USER CODE END HighFrequencyTask 0 */

  Observer_Inputs_t STO_aux_Inputs; /* Only if sensorless aux */
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8002660:	4c3e      	ldr	r4, [pc, #248]	; (800275c <TSK_HighFrequencyTask+0x100>)
  int16_t hElAngle;
  uint16_t hCodeError;
  SpeednPosFdbk_Handle_t *speedHandle;
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
  hElAngle = SPD_GetElAngle(speedHandle);
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8002662:	4f3f      	ldr	r7, [pc, #252]	; (8002760 <TSK_HighFrequencyTask+0x104>)
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8002664:	f8d4 001a 	ldr.w	r0, [r4, #26]
{
 8002668:	b088      	sub	sp, #32
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 800266a:	9005      	str	r0, [sp, #20]
  (void)ENC_CalcAngle(&ENCODER_M1);   /* If not sensorless then 2nd parameter is MC_NULL */
 800266c:	483d      	ldr	r0, [pc, #244]	; (8002764 <TSK_HighFrequencyTask+0x108>)
 800266e:	f006 faff 	bl	8008c70 <ENC_CalcAngle>
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
 8002672:	4b3d      	ldr	r3, [pc, #244]	; (8002768 <TSK_HighFrequencyTask+0x10c>)
 8002674:	6818      	ldr	r0, [r3, #0]
 8002676:	f007 febd 	bl	800a3f4 <STC_GetSpeedSensor>
 800267a:	4680      	mov	r8, r0
  hElAngle = SPD_GetElAngle(speedHandle);
 800267c:	f007 fe5e 	bl	800a33c <SPD_GetElAngle>
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8002680:	a902      	add	r1, sp, #8
  hElAngle = SPD_GetElAngle(speedHandle);
 8002682:	4605      	mov	r5, r0
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8002684:	6838      	ldr	r0, [r7, #0]
 8002686:	f000 fd01 	bl	800308c <PWMC_GetPhaseCurrents>
  RCM_ReadOngoingConv();
 800268a:	f002 f989 	bl	80049a0 <RCM_ReadOngoingConv>
  RCM_ExecNextConv();
 800268e:	f002 f937 	bl	8004900 <RCM_ExecNextConv>
  Ialphabeta = MCM_Clarke(Iab);
 8002692:	9802      	ldr	r0, [sp, #8]
 8002694:	f7ff fc7c 	bl	8001f90 <MCM_Clarke>
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8002698:	4629      	mov	r1, r5
  Ialphabeta = MCM_Clarke(Iab);
 800269a:	9003      	str	r0, [sp, #12]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 800269c:	f7ff fcb8 	bl	8002010 <MCM_Park>
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 80026a0:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 80026a4:	9000      	str	r0, [sp, #0]
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 80026a6:	b203      	sxth	r3, r0
 80026a8:	1ac9      	subs	r1, r1, r3
 80026aa:	4b30      	ldr	r3, [pc, #192]	; (800276c <TSK_HighFrequencyTask+0x110>)
 80026ac:	6818      	ldr	r0, [r3, #0]
 80026ae:	f006 fdc5 	bl	800923c <PI_Controller>
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 80026b2:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 80026b6:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 80026ba:	1ac9      	subs	r1, r1, r3
 80026bc:	4b2c      	ldr	r3, [pc, #176]	; (8002770 <TSK_HighFrequencyTask+0x114>)
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 80026be:	4606      	mov	r6, r0
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 80026c0:	6818      	ldr	r0, [r3, #0]
 80026c2:	f006 fdbb 	bl	800923c <PI_Controller>
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 80026c6:	f8ad 6004 	strh.w	r6, [sp, #4]
 80026ca:	f8ad 0006 	strh.w	r0, [sp, #6]
 80026ce:	9901      	ldr	r1, [sp, #4]
 80026d0:	4828      	ldr	r0, [pc, #160]	; (8002774 <TSK_HighFrequencyTask+0x118>)
 80026d2:	f006 fa07 	bl	8008ae4 <Circle_Limitation>
 80026d6:	4606      	mov	r6, r0
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
 80026d8:	4640      	mov	r0, r8
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 80026da:	9601      	str	r6, [sp, #4]
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
 80026dc:	f007 fe36 	bl	800a34c <SPD_GetInstElSpeedDpp>
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 80026e0:	4629      	mov	r1, r5
 80026e2:	9801      	ldr	r0, [sp, #4]
 80026e4:	f7ff fcd6 	bl	8002094 <MCM_Rev_Park>
 80026e8:	4601      	mov	r1, r0
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026ea:	6838      	ldr	r0, [r7, #0]
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 80026ec:	9104      	str	r1, [sp, #16]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026ee:	f000 fccf 	bl	8003090 <PWMC_SetPhaseVoltage>

  FOCVars[M1].Vqd = Vqd;
  FOCVars[M1].Iab = Iab;
  FOCVars[M1].Ialphabeta = Ialphabeta;
 80026f2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026f6:	4601      	mov	r1, r0
  FOCVars[M1].Ialphabeta = Ialphabeta;
 80026f8:	e9c4 2300 	strd	r2, r3, [r4]
  FOCVars[M1].Iqd = Iqd;
  FOCVars[M1].Valphabeta = Valphabeta;
 80026fc:	9804      	ldr	r0, [sp, #16]
  FOCVars[M1].Iqd = Iqd;
 80026fe:	9a00      	ldr	r2, [sp, #0]
  FOCVars[M1].hElAngle = hElAngle;
 8002700:	8425      	strh	r5, [r4, #32]
  if(hFOCreturn == MC_DURATION)
 8002702:	2901      	cmp	r1, #1
  FOCVars[M1].Vqd = Vqd;
 8002704:	f8c4 6016 	str.w	r6, [r4, #22]
  FOCVars[M1].Iqd = Iqd;
 8002708:	60e2      	str	r2, [r4, #12]
  FOCVars[M1].Valphabeta = Valphabeta;
 800270a:	f8c4 001a 	str.w	r0, [r4, #26]
  if(hFOCreturn == MC_DURATION)
 800270e:	d019      	beq.n	8002744 <TSK_HighFrequencyTask+0xe8>
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 8002710:	4819      	ldr	r0, [pc, #100]	; (8002778 <TSK_HighFrequencyTask+0x11c>)
    STO_aux_Inputs.Ialfa_beta = FOCVars[M1].Ialphabeta; /* Only if sensorless */
 8002712:	9306      	str	r3, [sp, #24]
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 8002714:	f006 f9de 	bl	8008ad4 <VBS_GetAvBusVoltage_d>
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 8002718:	a905      	add	r1, sp, #20
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 800271a:	4603      	mov	r3, r0
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 800271c:	4817      	ldr	r0, [pc, #92]	; (800277c <TSK_HighFrequencyTask+0x120>)
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 800271e:	f8ad 301c 	strh.w	r3, [sp, #28]
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 8002722:	f007 ff09 	bl	800a538 <STO_PLL_CalcElAngle>
    STO_PLL_CalcAvrgElSpeedDpp (&STO_PLL_M1);
 8002726:	4815      	ldr	r0, [pc, #84]	; (800277c <TSK_HighFrequencyTask+0x120>)
 8002728:	f008 f8a0 	bl	800a86c <STO_PLL_CalcAvrgElSpeedDpp>
  GLOBAL_TIMESTAMP++;
 800272c:	4a14      	ldr	r2, [pc, #80]	; (8002780 <TSK_HighFrequencyTask+0x124>)
  if (0U == MCPA_UART_A.Mark)
 800272e:	4815      	ldr	r0, [pc, #84]	; (8002784 <TSK_HighFrequencyTask+0x128>)
  GLOBAL_TIMESTAMP++;
 8002730:	6813      	ldr	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 8002732:	f890 1029 	ldrb.w	r1, [r0, #41]	; 0x29
  GLOBAL_TIMESTAMP++;
 8002736:	3301      	adds	r3, #1
 8002738:	6013      	str	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 800273a:	b941      	cbnz	r1, 800274e <TSK_HighFrequencyTask+0xf2>
}
 800273c:	2000      	movs	r0, #0
 800273e:	b008      	add	sp, #32
 8002740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MCI_FaultProcessing(&Mci[M1], MC_DURATION, 0);
 8002744:	4810      	ldr	r0, [pc, #64]	; (8002788 <TSK_HighFrequencyTask+0x12c>)
 8002746:	2200      	movs	r2, #0
 8002748:	f7ff fadc 	bl	8001d04 <MCI_FaultProcessing>
 800274c:	e7ee      	b.n	800272c <TSK_HighFrequencyTask+0xd0>
    MCPA_dataLog (&MCPA_UART_A);
 800274e:	f006 fba5 	bl	8008e9c <MCPA_dataLog>
}
 8002752:	2000      	movs	r0, #0
 8002754:	b008      	add	sp, #32
 8002756:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800275a:	bf00      	nop
 800275c:	20001ac4 	.word	0x20001ac4
 8002760:	20001af8 	.word	0x20001af8
 8002764:	20000024 	.word	0x20000024
 8002768:	200003dc 	.word	0x200003dc
 800276c:	200003d8 	.word	0x200003d8
 8002770:	200003d4 	.word	0x200003d4
 8002774:	20000020 	.word	0x20000020
 8002778:	20000004 	.word	0x20000004
 800277c:	20000210 	.word	0x20000210
 8002780:	200030a8 	.word	0x200030a8
 8002784:	20000400 	.word	0x20000400
 8002788:	20001a90 	.word	0x20001a90

0800278c <TSK_SafetyTask_PWMOFF>:
  * @brief  Safety task implementation if  MC.M1_ON_OVER_VOLTAGE == TURN_OFF_PWM.
  * @param  bMotor Motor reference number defined
  *         \link Motors_reference_number here \endlink.
  */
__weak void TSK_SafetyTask_PWMOFF(uint8_t bMotor)
{
 800278c:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE END TSK_SafetyTask_PWMOFF 0 */
  uint16_t CodeReturn = MC_NO_ERROR;
  const uint16_t errMask[NBR_OF_MOTORS] = {VBUS_TEMP_ERR_MASK};
  /* Check for fault if FW protection is activated. It returns MC_OVER_TEMP or MC_NO_ERROR */
  CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[bMotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800278e:	4e21      	ldr	r6, [pc, #132]	; (8002814 <TSK_SafetyTask_PWMOFF+0x88>)
{
 8002790:	b082      	sub	sp, #8
 8002792:	4604      	mov	r4, r0
  CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[bMotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 8002794:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8002798:	f000 fe42 	bl	8003420 <PWMC_IsFaultOccurred>
 800279c:	4605      	mov	r5, r0
                                                    (for STM32F30x can return MC_OVER_VOLT in case of HW Overvoltage) */
  if (M1 == bMotor)
 800279e:	b354      	cbz	r4, 80027f6 <TSK_SafetyTask_PWMOFF+0x6a>
  }
  else
  {
    /* Nothing to do */
  }
  MCI_FaultProcessing(&Mci[bMotor], CodeReturn, ~CodeReturn); /* Process faults */
 80027a0:	481d      	ldr	r0, [pc, #116]	; (8002818 <TSK_SafetyTask_PWMOFF+0x8c>)
 80027a2:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80027a6:	43ea      	mvns	r2, r5
 80027a8:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 80027ac:	b292      	uxth	r2, r2
 80027ae:	4629      	mov	r1, r5
 80027b0:	9001      	str	r0, [sp, #4]
 80027b2:	f7ff faa7 	bl	8001d04 <MCI_FaultProcessing>

  if (MCI_GetFaultState(&Mci[bMotor]) != (uint32_t)MC_NO_FAULTS)
 80027b6:	9801      	ldr	r0, [sp, #4]
 80027b8:	f7ff fb54 	bl	8001e64 <MCI_GetFaultState>
 80027bc:	b1c8      	cbz	r0, 80027f2 <TSK_SafetyTask_PWMOFF+0x66>
  {
    /* Reset Encoder state */
    if (pEAC[bMotor] != MC_NULL)
 80027be:	4b17      	ldr	r3, [pc, #92]	; (800281c <TSK_SafetyTask_PWMOFF+0x90>)
 80027c0:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80027c4:	b110      	cbz	r0, 80027cc <TSK_SafetyTask_PWMOFF+0x40>
    {
      EAC_SetRestartState(pEAC[bMotor], false);
 80027c6:	2100      	movs	r1, #0
 80027c8:	f006 fa06 	bl	8008bd8 <EAC_SetRestartState>
    }
    else
    {
      /* Nothing to do */
    }
    PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80027cc:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80027d0:	f000 fdf0 	bl	80033b4 <PWMC_SwitchOffPWM>
    if (MCPA_UART_A.Mark != 0U)
 80027d4:	4812      	ldr	r0, [pc, #72]	; (8002820 <TSK_SafetyTask_PWMOFF+0x94>)
 80027d6:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 80027da:	b9c3      	cbnz	r3, 800280e <TSK_SafetyTask_PWMOFF+0x82>
    }
    else
    {
      /* Nothing to do */
    }
    FOC_Clear(bMotor);
 80027dc:	4620      	mov	r0, r4
 80027de:	f7ff fc89 	bl	80020f4 <FOC_Clear>
    PQD_Clear(pMPM[bMotor]); //cstat !MISRAC2012-Rule-11.3
 80027e2:	4b10      	ldr	r3, [pc, #64]	; (8002824 <TSK_SafetyTask_PWMOFF+0x98>)
 80027e4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    /* No errors */
  }
  /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 3 */

  /* USER CODE END TSK_SafetyTask_PWMOFF 3 */
}
 80027e8:	b002      	add	sp, #8
 80027ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    PQD_Clear(pMPM[bMotor]); //cstat !MISRAC2012-Rule-11.3
 80027ee:	f006 bd85 	b.w	80092fc <PQD_Clear>
}
 80027f2:	b002      	add	sp, #8
 80027f4:	bd70      	pop	{r4, r5, r6, pc}
    uint16_t rawValueM1 =  RCM_ExecRegularConv(&VbusRegConv_M1);
 80027f6:	480c      	ldr	r0, [pc, #48]	; (8002828 <TSK_SafetyTask_PWMOFF+0x9c>)
 80027f8:	f001 ff86 	bl	8004708 <RCM_ExecRegularConv>
 80027fc:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & RVBS_CalcAvVbus(&BusVoltageSensor_M1, rawValueM1);
 80027fe:	480b      	ldr	r0, [pc, #44]	; (800282c <TSK_SafetyTask_PWMOFF+0xa0>)
 8002800:	f007 fd66 	bl	800a2d0 <RVBS_CalcAvVbus>
 8002804:	f020 0008 	bic.w	r0, r0, #8
 8002808:	4328      	orrs	r0, r5
 800280a:	b285      	uxth	r5, r0
 800280c:	e7c8      	b.n	80027a0 <TSK_SafetyTask_PWMOFF+0x14>
      MCPA_flushDataLog (&MCPA_UART_A);
 800280e:	f006 fc09 	bl	8009024 <MCPA_flushDataLog>
 8002812:	e7e3      	b.n	80027dc <TSK_SafetyTask_PWMOFF+0x50>
 8002814:	20001af8 	.word	0x20001af8
 8002818:	20001a90 	.word	0x20001a90
 800281c:	20001af4 	.word	0x20001af4
 8002820:	20000400 	.word	0x20000400
 8002824:	200003d0 	.word	0x200003d0
 8002828:	20000388 	.word	0x20000388
 800282c:	20000004 	.word	0x20000004

08002830 <TSK_SafetyTask>:
{
 8002830:	b508      	push	{r3, lr}
  if (1U == bMCBootCompleted)
 8002832:	4b06      	ldr	r3, [pc, #24]	; (800284c <TSK_SafetyTask+0x1c>)
 8002834:	781b      	ldrb	r3, [r3, #0]
 8002836:	2b01      	cmp	r3, #1
 8002838:	d000      	beq.n	800283c <TSK_SafetyTask+0xc>
}
 800283a:	bd08      	pop	{r3, pc}
    TSK_SafetyTask_PWMOFF(M1);
 800283c:	2000      	movs	r0, #0
 800283e:	f7ff ffa5 	bl	800278c <TSK_SafetyTask_PWMOFF>
}
 8002842:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCM_ExecUserConv();
 8002846:	f002 b827 	b.w	8004898 <RCM_ExecUserConv>
 800284a:	bf00      	nop
 800284c:	20001aea 	.word	0x20001aea

08002850 <MC_RunMotorControlTasks>:
{
 8002850:	b508      	push	{r3, lr}
  if (0U == bMCBootCompleted)
 8002852:	4b04      	ldr	r3, [pc, #16]	; (8002864 <MC_RunMotorControlTasks+0x14>)
 8002854:	781b      	ldrb	r3, [r3, #0]
 8002856:	b903      	cbnz	r3, 800285a <MC_RunMotorControlTasks+0xa>
}
 8002858:	bd08      	pop	{r3, pc}
    MC_Scheduler();
 800285a:	f7ff feb9 	bl	80025d0 <MC_Scheduler>
    TSK_SafetyTask();
 800285e:	f7ff ffe7 	bl	8002830 <TSK_SafetyTask>
}
 8002862:	bd08      	pop	{r3, pc}
 8002864:	20001aea 	.word	0x20001aea

08002868 <TSK_HardwareFaultTask>:
  *
  *  This function is to be executed when a general hardware failure has been detected
  * by the microcontroller and is used to put the system in safety condition.
  */
__weak void TSK_HardwareFaultTask(void)
{
 8002868:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TSK_HardwareFaultTask 0 */

  /* USER CODE END TSK_HardwareFaultTask 0 */
  R3_1_SwitchOffPWM(pwmcHandle[M1]);
 800286a:	4b05      	ldr	r3, [pc, #20]	; (8002880 <TSK_HardwareFaultTask+0x18>)
 800286c:	6818      	ldr	r0, [r3, #0]
 800286e:	f006 ff2f 	bl	80096d0 <R3_1_SwitchOffPWM>
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);

  /* USER CODE BEGIN TSK_HardwareFaultTask 1 */

  /* USER CODE END TSK_HardwareFaultTask 1 */
}
 8002872:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);
 8002876:	4803      	ldr	r0, [pc, #12]	; (8002884 <TSK_HardwareFaultTask+0x1c>)
 8002878:	2200      	movs	r2, #0
 800287a:	2180      	movs	r1, #128	; 0x80
 800287c:	f7ff ba42 	b.w	8001d04 <MCI_FaultProcessing>
 8002880:	20001af8 	.word	0x20001af8
 8002884:	20001a90 	.word	0x20001a90

08002888 <UI_HandleStartStopButton_cb>:

__weak void UI_HandleStartStopButton_cb (void)
{
 8002888:	b508      	push	{r3, lr}
/* USER CODE BEGIN START_STOP_BTN */
  if (IDLE == MC_GetSTMStateMotor1())
 800288a:	f7ff f9f1 	bl	8001c70 <MC_GetSTMStateMotor1>
 800288e:	b918      	cbnz	r0, 8002898 <UI_HandleStartStopButton_cb+0x10>
  else
  {
    (void)MC_StopMotor1();
  }
/* USER CODE END START_STOP_BTN */
}
 8002890:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StartMotor1();
 8002894:	f7ff b9d2 	b.w	8001c3c <MC_StartMotor1>
}
 8002898:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StopMotor1();
 800289c:	f7ff b9d4 	b.w	8001c48 <MC_StopMotor1>

080028a0 <mc_lock_pins>:

 /**
  * @brief  Locks GPIO pins used for Motor Control to prevent accidental reconfiguration.
  */
__weak void mc_lock_pins (void)
{
 80028a0:	b4f0      	push	{r4, r5, r6, r7}
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  __IO uint32_t temp;
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028a2:	4b34      	ldr	r3, [pc, #208]	; (8002974 <mc_lock_pins+0xd4>)
 80028a4:	4934      	ldr	r1, [pc, #208]	; (8002978 <mc_lock_pins+0xd8>)
 80028a6:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028a8:	2402      	movs	r4, #2
 80028aa:	61dc      	str	r4, [r3, #28]
 80028ac:	b08c      	sub	sp, #48	; 0x30
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028ae:	61d9      	str	r1, [r3, #28]
  /* Read LCKR register. This read is mandatory to complete key lock sequence */
  temp = READ_REG(GPIOx->LCKR);
 80028b0:	69da      	ldr	r2, [r3, #28]
 80028b2:	920b      	str	r2, [sp, #44]	; 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028b4:	f04f 1001 	mov.w	r0, #65537	; 0x10001
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028b8:	2501      	movs	r5, #1
  (void) temp;
 80028ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028bc:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028be:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028c0:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028c2:	69db      	ldr	r3, [r3, #28]
 80028c4:	930a      	str	r3, [sp, #40]	; 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028c6:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
  (void) temp;
 80028ca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028cc:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028ce:	61dc      	str	r4, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028d0:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028d2:	69da      	ldr	r2, [r3, #28]
 80028d4:	9209      	str	r2, [sp, #36]	; 0x24
  (void) temp;
 80028d6:	9a09      	ldr	r2, [sp, #36]	; 0x24
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028d8:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028da:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028dc:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028de:	69da      	ldr	r2, [r3, #28]
 80028e0:	9208      	str	r2, [sp, #32]
  (void) temp;
 80028e2:	9a08      	ldr	r2, [sp, #32]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028e4:	f44f 4600 	mov.w	r6, #32768	; 0x8000
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028e8:	f44f 32c0 	mov.w	r2, #98304	; 0x18000
 80028ec:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028ee:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028f0:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028f2:	69de      	ldr	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028f4:	4a21      	ldr	r2, [pc, #132]	; (800297c <mc_lock_pins+0xdc>)
  temp = READ_REG(GPIOx->LCKR);
 80028f6:	9607      	str	r6, [sp, #28]
  (void) temp;
 80028f8:	9e07      	ldr	r6, [sp, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028fa:	4e21      	ldr	r6, [pc, #132]	; (8002980 <mc_lock_pins+0xe0>)
 80028fc:	61d6      	str	r6, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028fe:	2708      	movs	r7, #8
 8002900:	61d7      	str	r7, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002902:	61d6      	str	r6, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002904:	69d6      	ldr	r6, [r2, #28]
 8002906:	9606      	str	r6, [sp, #24]
  (void) temp;
 8002908:	9e06      	ldr	r6, [sp, #24]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800290a:	4e1e      	ldr	r6, [pc, #120]	; (8002984 <mc_lock_pins+0xe4>)
 800290c:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800290e:	f44f 7780 	mov.w	r7, #256	; 0x100
 8002912:	61df      	str	r7, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002914:	61de      	str	r6, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002916:	69de      	ldr	r6, [r3, #28]
 8002918:	9605      	str	r6, [sp, #20]
  (void) temp;
 800291a:	9e05      	ldr	r6, [sp, #20]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800291c:	f44f 7700 	mov.w	r7, #512	; 0x200
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002920:	f44f 3681 	mov.w	r6, #66048	; 0x10200
 8002924:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002926:	61df      	str	r7, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002928:	61de      	str	r6, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800292a:	69de      	ldr	r6, [r3, #28]
 800292c:	9604      	str	r6, [sp, #16]
  (void) temp;
 800292e:	9e04      	ldr	r6, [sp, #16]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002930:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002932:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002934:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002936:	69d0      	ldr	r0, [r2, #28]
 8002938:	9003      	str	r0, [sp, #12]
  (void) temp;
 800293a:	9d03      	ldr	r5, [sp, #12]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800293c:	f44f 3082 	mov.w	r0, #66560	; 0x10400
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002940:	f44f 6580 	mov.w	r5, #1024	; 0x400
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002944:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002946:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002948:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800294a:	69d8      	ldr	r0, [r3, #28]
 800294c:	9002      	str	r0, [sp, #8]
  (void) temp;
 800294e:	9802      	ldr	r0, [sp, #8]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002950:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002952:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002954:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002956:	69d1      	ldr	r1, [r2, #28]
 8002958:	9101      	str	r1, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800295a:	4a0b      	ldr	r2, [pc, #44]	; (8002988 <mc_lock_pins+0xe8>)
  (void) temp;
 800295c:	9801      	ldr	r0, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800295e:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002960:	2180      	movs	r1, #128	; 0x80
 8002962:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002964:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002966:	69db      	ldr	r3, [r3, #28]
 8002968:	9300      	str	r3, [sp, #0]
  (void) temp;
 800296a:	9b00      	ldr	r3, [sp, #0]
LL_GPIO_LockPin(M1_PWM_VH_GPIO_Port, M1_PWM_VH_Pin);
LL_GPIO_LockPin(M1_PWM_VL_GPIO_Port, M1_PWM_VL_Pin);
LL_GPIO_LockPin(M1_PWM_WH_GPIO_Port, M1_PWM_WH_Pin);
LL_GPIO_LockPin(M1_PWM_WL_GPIO_Port, M1_PWM_WL_Pin);
LL_GPIO_LockPin(M1_PWM_UL_GPIO_Port, M1_PWM_UL_Pin);
}
 800296c:	b00c      	add	sp, #48	; 0x30
 800296e:	bcf0      	pop	{r4, r5, r6, r7}
 8002970:	4770      	bx	lr
 8002972:	bf00      	nop
 8002974:	48000800 	.word	0x48000800
 8002978:	00010002 	.word	0x00010002
 800297c:	48000400 	.word	0x48000400
 8002980:	00010008 	.word	0x00010008
 8002984:	00010100 	.word	0x00010100
 8002988:	00010080 	.word	0x00010080

0800298c <RI_SetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_SetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 800298c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002990:	b087      	sub	sp, #28
    uint8_t accessResult;

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 8002992:	4b2f      	ldr	r3, [pc, #188]	; (8002a50 <RI_SetRegCommandParser+0xc4>)
 8002994:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8002998:	9304      	str	r3, [sp, #16]
 800299a:	4b2e      	ldr	r3, [pc, #184]	; (8002a54 <RI_SetRegCommandParser+0xc8>)
 800299c:	9305      	str	r3, [sp, #20]
    uint16_t size = 0U;
 800299e:	2600      	movs	r6, #0
    uint8_t * rxData = pHandle->rxBuffer;
 80029a0:	f8d0 e004 	ldr.w	lr, [r0, #4]
    int16_t rxLength = pHandle->rxLength;
 80029a4:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    uint16_t size = 0U;
 80029a8:	f8ad 600e 	strh.w	r6, [sp, #14]
{
 80029ac:	4607      	mov	r7, r0
    uint8_t number_of_item =0;
    pHandle->txLength = 0;
 80029ae:	81c6      	strh	r6, [r0, #14]
 80029b0:	eb08 0901 	add.w	r9, r8, r1
  uint8_t retVal = MCP_CMD_OK;
 80029b4:	46b2      	mov	sl, r6

    while (rxLength > 0)
    {
      number_of_item ++;
 80029b6:	3601      	adds	r6, #1
    while (rxLength > 0)
 80029b8:	2b00      	cmp	r3, #0
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 80029ba:	f1a3 0c02 	sub.w	ip, r3, #2
      number_of_item ++;
 80029be:	b2f6      	uxtb	r6, r6
    while (rxLength > 0)
 80029c0:	dd43      	ble.n	8002a4a <RI_SetRegCommandParser+0xbe>
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 80029c2:	fa0f f18c 	sxth.w	r1, ip
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 80029c6:	fa1f f48c 	uxth.w	r4, ip
      regID = *dataElementID & REG_MASK;
 80029ca:	f8be c000 	ldrh.w	ip, [lr]
      rxData = rxData+MCP_ID_SIZE; // Shift buffer to the next data
 80029ce:	f10e 0502 	add.w	r5, lr, #2
      if (motorID > NBR_OF_MOTORS)
 80029d2:	f01c 0f06 	tst.w	ip, #6
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 80029d6:	f10d 030e 	add.w	r3, sp, #14
 80029da:	462a      	mov	r2, r5
      regID = *dataElementID & REG_MASK;
 80029dc:	f02c 0007 	bic.w	r0, ip, #7
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 80029e0:	fa5f fe8c 	uxtb.w	lr, ip
      if (motorID > NBR_OF_MOTORS)
 80029e4:	d11e      	bne.n	8002a24 <RI_SetRegCommandParser+0x98>
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 80029e6:	9100      	str	r1, [sp, #0]
 80029e8:	f00e 0c07 	and.w	ip, lr, #7
 80029ec:	a906      	add	r1, sp, #24
 80029ee:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 80029f2:	f00e 0138 	and.w	r1, lr, #56	; 0x38
 80029f6:	f85c bc08 	ldr.w	fp, [ip, #-8]
 80029fa:	47d8      	blx	fp
        /* Prepare next data*/
        rxLength = (int16_t) (rxLength - size);
 80029fc:	f8bd e00e 	ldrh.w	lr, [sp, #14]
        rxData = rxData+size;
        /* If there is only one CMD in the buffer, we do not store the result */
        if ((1U == number_of_item) && (0 == rxLength))
 8002a00:	2e01      	cmp	r6, #1
        rxLength = (int16_t) (rxLength - size);
 8002a02:	eba4 0c0e 	sub.w	ip, r4, lr
 8002a06:	fa0f f38c 	sxth.w	r3, ip
        if ((1U == number_of_item) && (0 == rxLength))
 8002a0a:	d013      	beq.n	8002a34 <RI_SetRegCommandParser+0xa8>
        {
          retVal = accessResult;
        }
        else
        {/* Store the result for each access to be able to report failing access */
          if (txSyncFreeSpace !=0 )
 8002a0c:	45c1      	cmp	r9, r8
 8002a0e:	d00d      	beq.n	8002a2c <RI_SetRegCommandParser+0xa0>
          {
            *txData = accessResult;
 8002a10:	f808 0b01 	strb.w	r0, [r8], #1
            txData = txData+1;
            pHandle->txLength++;
 8002a14:	89fa      	ldrh	r2, [r7, #14]
 8002a16:	3201      	adds	r2, #1
        rxData = rxData+size;
 8002a18:	44ae      	add	lr, r5
            pHandle->txLength++;
 8002a1a:	81fa      	strh	r2, [r7, #14]
            txSyncFreeSpace--; /* decrement one by one no wraparound possible */
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8002a1c:	2800      	cmp	r0, #0
 8002a1e:	d0ca      	beq.n	80029b6 <RI_SetRegCommandParser+0x2a>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 8002a20:	2807      	cmp	r0, #7
 8002a22:	d10d      	bne.n	8002a40 <RI_SetRegCommandParser+0xb4>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8002a24:	2001      	movs	r0, #1
    }
  #ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 8002a26:	b007      	add	sp, #28
 8002a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8002a2c:	2008      	movs	r0, #8
}
 8002a2e:	b007      	add	sp, #28
 8002a30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((1U == number_of_item) && (0 == rxLength))
 8002a34:	2b00      	cmp	r3, #0
 8002a36:	d1e9      	bne.n	8002a0c <RI_SetRegCommandParser+0x80>
    if (MCP_CMD_OK == retVal)
 8002a38:	2800      	cmp	r0, #0
 8002a3a:	d1f4      	bne.n	8002a26 <RI_SetRegCommandParser+0x9a>
      pHandle->txLength = 0;
 8002a3c:	81f8      	strh	r0, [r7, #14]
 8002a3e:	e7f2      	b.n	8002a26 <RI_SetRegCommandParser+0x9a>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 8002a40:	280a      	cmp	r0, #10
 8002a42:	d0ef      	beq.n	8002a24 <RI_SetRegCommandParser+0x98>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 8002a44:	f04f 0a01 	mov.w	sl, #1
 8002a48:	e7b5      	b.n	80029b6 <RI_SetRegCommandParser+0x2a>
 8002a4a:	4650      	mov	r0, sl
 8002a4c:	e7f4      	b.n	8002a38 <RI_SetRegCommandParser+0xac>
 8002a4e:	bf00      	nop
 8002a50:	08003459 	.word	0x08003459
 8002a54:	08003555 	.word	0x08003555

08002a58 <RI_GetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_GetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8002a58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002a5c:	b086      	sub	sp, #24
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    uint16_t size = 0U;
 8002a5e:	2300      	movs	r3, #0
 8002a60:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
    pHandle->txLength = 0;
 8002a64:	81c3      	strh	r3, [r0, #14]
    uint16_t rxLength = pHandle->rxLength;
 8002a66:	f8b0 800c 	ldrh.w	r8, [r0, #12]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002a6a:	4b1e      	ldr	r3, [pc, #120]	; (8002ae4 <RI_GetRegCommandParser+0x8c>)
 8002a6c:	9304      	str	r3, [sp, #16]
 8002a6e:	4b1e      	ldr	r3, [pc, #120]	; (8002ae8 <RI_GetRegCommandParser+0x90>)
    uint8_t * rxData = pHandle->rxBuffer;
 8002a70:	f8d0 9004 	ldr.w	r9, [r0, #4]
    uint8_t * txData = pHandle->txBuffer;
 8002a74:	6886      	ldr	r6, [r0, #8]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002a76:	9305      	str	r3, [sp, #20]
    while (rxLength > 0U)
 8002a78:	f1b8 0f00 	cmp.w	r8, #0
 8002a7c:	d023      	beq.n	8002ac6 <RI_GetRegCommandParser+0x6e>
 8002a7e:	4607      	mov	r7, r0
 8002a80:	b20d      	sxth	r5, r1
    uint8_t * rxData = pHandle->rxBuffer;
 8002a82:	464c      	mov	r4, r9
    {
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength - MCP_ID_SIZE;
      rxData = rxData + MCP_ID_SIZE; // Shift buffer to the next MCP_ID

      regID = *dataElementID & REG_MASK;
 8002a84:	f834 cb02 	ldrh.w	ip, [r4], #2
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8002a88:	fa5f f18c 	uxtb.w	r1, ip
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a8c:	f001 0e07 	and.w	lr, r1, #7
 8002a90:	f10d 0a18 	add.w	sl, sp, #24
      if (motorID > NBR_OF_MOTORS)
 8002a94:	f01c 0f06 	tst.w	ip, #6
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a98:	4632      	mov	r2, r6
      regID = *dataElementID & REG_MASK;
 8002a9a:	f02c 0007 	bic.w	r0, ip, #7
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a9e:	f10d 030e 	add.w	r3, sp, #14
 8002aa2:	eb0a 0e8e 	add.w	lr, sl, lr, lsl #2
 8002aa6:	f001 0138 	and.w	r1, r1, #56	; 0x38
      if (motorID > NBR_OF_MOTORS)
 8002aaa:	d10c      	bne.n	8002ac6 <RI_GetRegCommandParser+0x6e>
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002aac:	9500      	str	r5, [sp, #0]
 8002aae:	f85e ac08 	ldr.w	sl, [lr, #-8]
 8002ab2:	47d0      	blx	sl
        if (retVal == MCP_CMD_OK )
 8002ab4:	eba8 0304 	sub.w	r3, r8, r4
    while (rxLength > 0U)
 8002ab8:	fa19 f383 	uxtah	r3, r9, r3
 8002abc:	b29b      	uxth	r3, r3
        if (retVal == MCP_CMD_OK )
 8002abe:	b130      	cbz	r0, 8002ace <RI_GetRegCommandParser+0x76>
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 8002ac0:	b006      	add	sp, #24
 8002ac2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  uint8_t retVal = MCP_CMD_NOK;
 8002ac6:	2001      	movs	r0, #1
}
 8002ac8:	b006      	add	sp, #24
 8002aca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          txData = txData+size;
 8002ace:	f8bd 100e 	ldrh.w	r1, [sp, #14]
          pHandle->txLength += size;
 8002ad2:	89fa      	ldrh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002ad4:	1a6d      	subs	r5, r5, r1
          pHandle->txLength += size;
 8002ad6:	440a      	add	r2, r1
          txData = txData+size;
 8002ad8:	440e      	add	r6, r1
          pHandle->txLength += size;
 8002ada:	81fa      	strh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002adc:	b22d      	sxth	r5, r5
    while (rxLength > 0U)
 8002ade:	2b00      	cmp	r3, #0
 8002ae0:	d1d0      	bne.n	8002a84 <RI_GetRegCommandParser+0x2c>
 8002ae2:	e7ed      	b.n	8002ac0 <RI_GetRegCommandParser+0x68>
 8002ae4:	08003aad 	.word	0x08003aad
 8002ae8:	08003be9 	.word	0x08003be9

08002aec <MCP_ReceivedPacket>:
  * @brief  Parses the header from the received packet and call the required function depending on the command sent by the controller device.
  *
  * @param  pHandle Handler of the current instance of the MCP component
  */
void MCP_ReceivedPacket(MCP_Handle_t *pHandle)
{
 8002aec:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* Nothing to do, txBuffer and txLength have not been modified */
  }
  else /* Length is 0, this is a request to send back the last packet */
  {
#endif
    packetHeader = (uint16_t *)pHandle->rxBuffer; //cstat !MISRAC2012-Rule-11.3
 8002aee:	6845      	ldr	r5, [r0, #4]
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002af0:	882b      	ldrh	r3, [r5, #0]

    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002af2:	f403 427f 	and.w	r2, r3, #65280	; 0xff00
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002af6:	f023 0c07 	bic.w	ip, r3, #7
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002afa:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
{
 8002afe:	b083      	sub	sp, #12
 8002b00:	4604      	mov	r4, r0
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002b02:	fa1f fc8c 	uxth.w	ip, ip
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002b06:	d051      	beq.n	8002bac <MCP_ReceivedPacket+0xc0>
    else
    {
      /* Nothing to do */
    }

    motorID = (uint8_t)((*packetHeader - 1U) & MOTOR_MASK);
 8002b08:	3b01      	subs	r3, #1
    MCI_Handle_t *pMCI = &Mci[motorID];
 8002b0a:	4f5c      	ldr	r7, [pc, #368]	; (8002c7c <MCP_ReceivedPacket+0x190>)
 8002b0c:	f003 0307 	and.w	r3, r3, #7
 8002b10:	eb03 0383 	add.w	r3, r3, r3, lsl #2

    /* Removing MCP Header from RxBuffer */
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002b14:	3502      	adds	r5, #2
    MCI_Handle_t *pMCI = &Mci[motorID];
 8002b16:	eb07 07c3 	add.w	r7, r7, r3, lsl #3

    /* Commands requiering payload response must be aware of space available for the payload */
    /* Last byte is reserved for MCP response*/
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b1a:	6823      	ldr	r3, [r4, #0]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002b1c:	6045      	str	r5, [r0, #4]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b1e:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b20:	899a      	ldrh	r2, [r3, #12]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b22:	3802      	subs	r0, #2
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b24:	3a01      	subs	r2, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b26:	b280      	uxth	r0, r0

    /* Initialization of the tx length, command which send back data has to increment the txLength
     * (case of Read register) */
    pHandle->txLength = 0U;
 8002b28:	2600      	movs	r6, #0

    switch (command)
 8002b2a:	f1bc 0f38 	cmp.w	ip, #56	; 0x38
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b2e:	b291      	uxth	r1, r2
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b30:	81a0      	strh	r0, [r4, #12]
    pHandle->txLength = 0U;
 8002b32:	81e6      	strh	r6, [r4, #14]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b34:	b212      	sxth	r2, r2
    switch (command)
 8002b36:	d82a      	bhi.n	8002b8e <MCP_ReceivedPacket+0xa2>
 8002b38:	f1bc 0f38 	cmp.w	ip, #56	; 0x38
 8002b3c:	d81e      	bhi.n	8002b7c <MCP_ReceivedPacket+0x90>
 8002b3e:	e8df f00c 	tbb	[pc, ip]
 8002b42:	1d63      	.short	0x1d63
 8002b44:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b48:	1d6b1d1d 	.word	0x1d6b1d1d
 8002b4c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b50:	1d701d1d 	.word	0x1d701d1d
 8002b54:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b58:	1d751d1d 	.word	0x1d751d1d
 8002b5c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b60:	1d4c1d1d 	.word	0x1d4c1d1d
 8002b64:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b68:	1d521d1d 	.word	0x1d521d1d
 8002b6c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b70:	1d471d1d 	.word	0x1d471d1d
 8002b74:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b78:	1d1d      	.short	0x1d1d
 8002b7a:	5d          	.byte	0x5d
 8002b7b:	00          	.byte	0x00
 8002b7c:	2300      	movs	r3, #0
 8002b7e:	2002      	movs	r0, #2
      {
        MCPResponse = MCP_CMD_UNKNOWN;
        break;
      }
    }
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002b80:	68a2      	ldr	r2, [r4, #8]
 8002b82:	54d0      	strb	r0, [r2, r3]
    pHandle->txLength++;
 8002b84:	89e3      	ldrh	r3, [r4, #14]
 8002b86:	3301      	adds	r3, #1
 8002b88:	81e3      	strh	r3, [r4, #14]
#ifdef NULL_PTR_CHECK_MCP
  }
#endif
}
 8002b8a:	b003      	add	sp, #12
 8002b8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (command)
 8002b8e:	f1bc 0f68 	cmp.w	ip, #104	; 0x68
 8002b92:	d05f      	beq.n	8002c54 <MCP_ReceivedPacket+0x168>
 8002b94:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
 8002b98:	d06d      	beq.n	8002c76 <MCP_ReceivedPacket+0x18a>
 8002b9a:	f1bc 0f48 	cmp.w	ip, #72	; 0x48
 8002b9e:	d1ed      	bne.n	8002b7c <MCP_ReceivedPacket+0x90>
        MCI_Clear_Iqdref(pMCI);
 8002ba0:	4638      	mov	r0, r7
 8002ba2:	f7ff f9eb 	bl	8001f7c <MCI_Clear_Iqdref>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002ba6:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002ba8:	4630      	mov	r0, r6
        break;
 8002baa:	e7e9      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002bac:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002bae:	6823      	ldr	r3, [r4, #0]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002bb0:	3802      	subs	r0, #2
      userCommand = ((uint8_t)(command & 0xF8U) >> 3U);
 8002bb2:	f3cc 0cc4 	ubfx	ip, ip, #3, #5
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002bb6:	899a      	ldrh	r2, [r3, #12]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002bb8:	b280      	uxth	r0, r0
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002bba:	3502      	adds	r5, #2
    pHandle->txLength = 0U;
 8002bbc:	2300      	movs	r3, #0
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002bbe:	f1bc 0f01 	cmp.w	ip, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002bc2:	81a0      	strh	r0, [r4, #12]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002bc4:	6065      	str	r5, [r4, #4]
    pHandle->txLength = 0U;
 8002bc6:	81e3      	strh	r3, [r4, #14]
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002bc8:	d935      	bls.n	8002c36 <MCP_ReceivedPacket+0x14a>
        MCPResponse = MCP_CMD_OK;
 8002bca:	2300      	movs	r3, #0
          MCPResponse = MCP_ERROR_CALLBACK_NOT_REGISTRED;
 8002bcc:	200d      	movs	r0, #13
 8002bce:	e7d7      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        if (IDLE == MCI_GetSTMState(pMCI))
 8002bd0:	4638      	mov	r0, r7
 8002bd2:	f7ff f8df 	bl	8001d94 <MCI_GetSTMState>
 8002bd6:	2800      	cmp	r0, #0
 8002bd8:	d045      	beq.n	8002c66 <MCP_ReceivedPacket+0x17a>
          (void)MCI_StopMotor(pMCI);
 8002bda:	4638      	mov	r0, r7
 8002bdc:	f7ff f910 	bl	8001e00 <MCI_StopMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002be0:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_CMD_OK;
 8002be2:	2000      	movs	r0, #0
 8002be4:	e7cc      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        if (RUN == MCI_GetSTMState(pMCI))
 8002be6:	4638      	mov	r0, r7
 8002be8:	f7ff f8d4 	bl	8001d94 <MCI_GetSTMState>
 8002bec:	2806      	cmp	r0, #6
 8002bee:	d1f7      	bne.n	8002be0 <MCP_ReceivedPacket+0xf4>
          MCI_StopRamp(pMCI);
 8002bf0:	4638      	mov	r0, r7
 8002bf2:	f7ff f94b 	bl	8001e8c <MCI_StopRamp>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bf6:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002bf8:	2000      	movs	r0, #0
 8002bfa:	e7c1      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        (void)MCI_FaultAcknowledged(pMCI);
 8002bfc:	4638      	mov	r0, r7
 8002bfe:	f7ff f91f 	bl	8001e40 <MCI_FaultAcknowledged>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c02:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002c04:	2000      	movs	r0, #0
        break;
 8002c06:	e7bb      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        *pHandle->txBuffer = MCP_VERSION;
 8002c08:	68a3      	ldr	r3, [r4, #8]
        pHandle->txLength = 4U;
 8002c0a:	2104      	movs	r1, #4
        *pHandle->txBuffer = MCP_VERSION;
 8002c0c:	2201      	movs	r2, #1
        pHandle->txLength = 4U;
 8002c0e:	81e1      	strh	r1, [r4, #14]
        *pHandle->txBuffer = MCP_VERSION;
 8002c10:	701a      	strb	r2, [r3, #0]
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c12:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002c14:	2000      	movs	r0, #0
        break;
 8002c16:	e7b3      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        MCPResponse = RI_SetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002c18:	4620      	mov	r0, r4
 8002c1a:	f7ff feb7 	bl	800298c <RI_SetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c1e:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002c20:	e7ae      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        MCPResponse = RI_GetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002c22:	4620      	mov	r0, r4
 8002c24:	f7ff ff18 	bl	8002a58 <RI_GetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c28:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002c2a:	e7a9      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == false) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002c2c:	4638      	mov	r0, r7
 8002c2e:	f7ff f8cd 	bl	8001dcc <MCI_StartWithPolarizationMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c32:	89e3      	ldrh	r3, [r4, #14]
 8002c34:	e7a4      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002c36:	3a01      	subs	r2, #1
 8002c38:	b212      	sxth	r2, r2
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002c3a:	4b11      	ldr	r3, [pc, #68]	; (8002c80 <MCP_ReceivedPacket+0x194>)
 8002c3c:	f853 602c 	ldr.w	r6, [r3, ip, lsl #2]
 8002c40:	2e00      	cmp	r6, #0
 8002c42:	d0c2      	beq.n	8002bca <MCP_ReceivedPacket+0xde>
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 8002c44:	68a3      	ldr	r3, [r4, #8]
 8002c46:	9300      	str	r3, [sp, #0]
 8002c48:	4629      	mov	r1, r5
 8002c4a:	f104 030e 	add.w	r3, r4, #14
 8002c4e:	47b0      	blx	r6
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c50:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 8002c52:	e795      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
        MCPResponse = MC_ProfilerCommand(pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace, &pHandle->txLength,
 8002c54:	68a3      	ldr	r3, [r4, #8]
 8002c56:	9300      	str	r3, [sp, #0]
 8002c58:	4629      	mov	r1, r5
 8002c5a:	f104 030e 	add.w	r3, r4, #14
 8002c5e:	f7ff f80d 	bl	8001c7c <MC_ProfilerCommand>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c62:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002c64:	e78c      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
          MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002c66:	4638      	mov	r0, r7
 8002c68:	f7ff f8b0 	bl	8001dcc <MCI_StartWithPolarizationMotor>
 8002c6c:	f080 0001 	eor.w	r0, r0, #1
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c70:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002c72:	b2c0      	uxtb	r0, r0
 8002c74:	e784      	b.n	8002b80 <MCP_ReceivedPacket+0x94>
    switch (command)
 8002c76:	46b4      	mov	ip, r6
 8002c78:	e7df      	b.n	8002c3a <MCP_ReceivedPacket+0x14e>
 8002c7a:	bf00      	nop
 8002c7c:	20001a90 	.word	0x20001a90
 8002c80:	20002c18 	.word	0x20002c18

08002c84 <MX_MotorControl_Init>:
 *
 * CubeMX calls this function after all peripherals initializations and
 * before the NVIC is configured
 */
__weak void MX_MotorControl_Init(void)
{
 8002c84:	b508      	push	{r3, lr}
  /* Reconfigure the SysTick interrupt to fire every 500 us. */
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / SYS_TICK_FREQUENCY);
 8002c86:	f004 fa05 	bl	8007094 <HAL_RCC_GetHCLKFreq>
 8002c8a:	4b0a      	ldr	r3, [pc, #40]	; (8002cb4 <MX_MotorControl_Init+0x30>)
 8002c8c:	fba3 3000 	umull	r3, r0, r3, r0
 8002c90:	09c0      	lsrs	r0, r0, #7
 8002c92:	f003 fbd7 	bl	8006444 <HAL_SYSTICK_Config>
  HAL_NVIC_SetPriority(SysTick_IRQn, uwTickPrio, 0U);
 8002c96:	4b08      	ldr	r3, [pc, #32]	; (8002cb8 <MX_MotorControl_Init+0x34>)
 8002c98:	2200      	movs	r2, #0
 8002c9a:	6819      	ldr	r1, [r3, #0]
 8002c9c:	f04f 30ff 	mov.w	r0, #4294967295
 8002ca0:	f003 fb84 	bl	80063ac <HAL_NVIC_SetPriority>

  /* Initialize the Motor Control Subsystem */
  MCboot(pMCI);
 8002ca4:	4805      	ldr	r0, [pc, #20]	; (8002cbc <MX_MotorControl_Init+0x38>)
 8002ca6:	f7ff fa5f 	bl	8002168 <MCboot>
  mc_lock_pins();
}
 8002caa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  mc_lock_pins();
 8002cae:	f7ff bdf7 	b.w	80028a0 <mc_lock_pins>
 8002cb2:	bf00      	nop
 8002cb4:	10624dd3 	.word	0x10624dd3
 8002cb8:	200014ac 	.word	0x200014ac
 8002cbc:	20002c88 	.word	0x20002c88

08002cc0 <ai_network_get_error>:
}

AI_API_ENTRY
ai_error ai_network_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8002cc0:	f008 b818 	b.w	800acf4 <ai_platform_network_get_error>

08002cc4 <ai_network_inputs_get>:
}

AI_API_ENTRY
ai_buffer* ai_network_inputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 8002cc4:	b108      	cbz	r0, 8002cca <ai_network_inputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_inputs_get(network, n_buffer);
 8002cc6:	f008 b889 	b.w	800addc <ai_platform_inputs_get>
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 8002cca:	4802      	ldr	r0, [pc, #8]	; (8002cd4 <ai_network_inputs_get+0x10>)
 8002ccc:	4b02      	ldr	r3, [pc, #8]	; (8002cd8 <ai_network_inputs_get+0x14>)
 8002cce:	6003      	str	r3, [r0, #0]
  return ai_platform_inputs_get(network, n_buffer);
 8002cd0:	f008 b884 	b.w	800addc <ai_platform_inputs_get>
 8002cd4:	20001198 	.word	0x20001198
 8002cd8:	a1c00100 	.word	0xa1c00100

08002cdc <ai_network_outputs_get>:
}

AI_API_ENTRY
ai_buffer* ai_network_outputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 8002cdc:	b108      	cbz	r0, 8002ce2 <ai_network_outputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_outputs_get(network, n_buffer);
 8002cde:	f008 b953 	b.w	800af88 <ai_platform_outputs_get>
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 8002ce2:	4802      	ldr	r0, [pc, #8]	; (8002cec <ai_network_outputs_get+0x10>)
 8002ce4:	4b02      	ldr	r3, [pc, #8]	; (8002cf0 <ai_network_outputs_get+0x14>)
 8002ce6:	6003      	str	r3, [r0, #0]
  return ai_platform_outputs_get(network, n_buffer);
 8002ce8:	f008 b94e 	b.w	800af88 <ai_platform_outputs_get>
 8002cec:	20001198 	.word	0x20001198
 8002cf0:	a1c00100 	.word	0xa1c00100

08002cf4 <ai_network_init>:
}

AI_API_ENTRY
ai_bool ai_network_init(
  ai_handle network, const ai_network_params* params)
{
 8002cf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002cf8:	b085      	sub	sp, #20
 8002cfa:	460d      	mov	r5, r1
 8002cfc:	9001      	str	r0, [sp, #4]
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8002cfe:	f008 fae9 	bl	800b2d4 <ai_platform_network_init>
  if (!net_ctx) return false;
 8002d02:	4604      	mov	r4, r0
 8002d04:	2800      	cmp	r0, #0
 8002d06:	f000 80fb 	beq.w	8002f00 <ai_network_init+0x20c>
  if (ai_platform_get_weights_map(g_network_weights_map, 1, params)) {
 8002d0a:	4e85      	ldr	r6, [pc, #532]	; (8002f20 <ai_network_init+0x22c>)
 8002d0c:	462a      	mov	r2, r5
 8002d0e:	2101      	movs	r1, #1
 8002d10:	4630      	mov	r0, r6
 8002d12:	f007 ff25 	bl	800ab60 <ai_platform_get_weights_map>
 8002d16:	9002      	str	r0, [sp, #8]
 8002d18:	2800      	cmp	r0, #0
 8002d1a:	f000 80f4 	beq.w	8002f06 <ai_network_init+0x212>
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002d1e:	f8df 8254 	ldr.w	r8, [pc, #596]	; 8002f74 <ai_network_init+0x280>
    model__model_a2c_network_sigma_array.data = AI_PTR(g_network_weights_map[0] + 0);
 8002d22:	6833      	ldr	r3, [r6, #0]
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002d24:	f8d8 2000 	ldr.w	r2, [r8]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d28:	4e7e      	ldr	r6, [pc, #504]	; (8002f24 <ai_network_init+0x230>)
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d2a:	487f      	ldr	r0, [pc, #508]	; (8002f28 <ai_network_init+0x234>)
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d2c:	497f      	ldr	r1, [pc, #508]	; (8002f2c <ai_network_init+0x238>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d2e:	4f80      	ldr	r7, [pc, #512]	; (8002f30 <ai_network_init+0x23c>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d30:	f8df c244 	ldr.w	ip, [pc, #580]	; 8002f78 <ai_network_init+0x284>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d34:	f8df e244 	ldr.w	lr, [pc, #580]	; 8002f7c <ai_network_init+0x288>
    value_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d38:	f8df b244 	ldr.w	fp, [pc, #580]	; 8002f80 <ai_network_init+0x28c>
    value_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d3c:	f8df a244 	ldr.w	sl, [pc, #580]	; 8002f84 <ai_network_init+0x290>
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002d40:	f042 4980 	orr.w	r9, r2, #1073741824	; 0x40000000
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d44:	6832      	ldr	r2, [r6, #0]
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002d46:	f8c8 9000 	str.w	r9, [r8]
    model__model_a2c_network_sigma_array.data = AI_PTR(g_network_weights_map[0] + 0);
 8002d4a:	e9c8 3302 	strd	r3, r3, [r8, #8]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d4e:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d52:	6802      	ldr	r2, [r0, #0]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d54:	f8c6 8000 	str.w	r8, [r6]
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d58:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d5c:	680a      	ldr	r2, [r1, #0]
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d5e:	f8c0 8000 	str.w	r8, [r0]
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d62:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d66:	683a      	ldr	r2, [r7, #0]
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d68:	f8c1 8000 	str.w	r8, [r1]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d6c:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d70:	f8dc 2000 	ldr.w	r2, [ip]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d74:	f8c7 8000 	str.w	r8, [r7]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d78:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d7c:	f8de 2000 	ldr.w	r2, [lr]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d80:	f8cc 8000 	str.w	r8, [ip]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d84:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d88:	4a6a      	ldr	r2, [pc, #424]	; (8002f34 <ai_network_init+0x240>)
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d8a:	f8ce 8000 	str.w	r8, [lr]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d8e:	6817      	ldr	r7, [r2, #0]
    mu_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d90:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 8002f88 <ai_network_init+0x294>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d94:	f047 4880 	orr.w	r8, r7, #1073741824	; 0x40000000
 8002d98:	f8c2 8000 	str.w	r8, [r2]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002d9c:	f503 470b 	add.w	r7, r3, #35584	; 0x8b00
 8002da0:	4a64      	ldr	r2, [pc, #400]	; (8002f34 <ai_network_init+0x240>)
    mu_bias_array.format |= AI_FMT_FLAG_CONST;
 8002da2:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8002f8c <ai_network_init+0x298>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002da6:	3720      	adds	r7, #32
 8002da8:	6097      	str	r7, [r2, #8]
 8002daa:	9703      	str	r7, [sp, #12]
    _model_a2c_network_Constant_output_0_array.data = AI_PTR(g_network_weights_map[0] + 4);
 8002dac:	1d1f      	adds	r7, r3, #4
 8002dae:	e9c6 7702 	strd	r7, r7, [r6, #8]
    onnxDiv_43_array.data = AI_PTR(g_network_weights_map[0] + 8);
 8002db2:	f103 0608 	add.w	r6, r3, #8
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 1568);
 8002db6:	f503 62c4 	add.w	r2, r3, #1568	; 0x620
    onnxDiv_43_array.data = AI_PTR(g_network_weights_map[0] + 8);
 8002dba:	e9c0 6602 	strd	r6, r6, [r0, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002dbe:	4f5c      	ldr	r7, [pc, #368]	; (8002f30 <ai_network_init+0x23c>)
    onnxSub_40_array.data = AI_PTR(g_network_weights_map[0] + 20);
 8002dc0:	f103 0014 	add.w	r0, r3, #20
 8002dc4:	e9c1 0002 	strd	r0, r0, [r1, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 1568);
 8002dc8:	e9cc 2202 	strd	r2, r2, [ip, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002dcc:	f103 0120 	add.w	r1, r3, #32
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 2080);
 8002dd0:	f503 6202 	add.w	r2, r3, #2080	; 0x820
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002dd4:	e9c7 1102 	strd	r1, r1, [r7, #8]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 2080);
 8002dd8:	e9ce 2202 	strd	r2, r2, [lr, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002ddc:	4956      	ldr	r1, [pc, #344]	; (8002f38 <ai_network_init+0x244>)
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002dde:	4a55      	ldr	r2, [pc, #340]	; (8002f34 <ai_network_init+0x240>)
 8002de0:	9f03      	ldr	r7, [sp, #12]
 8002de2:	60d7      	str	r7, [r2, #12]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002de4:	680a      	ldr	r2, [r1, #0]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002de6:	4855      	ldr	r0, [pc, #340]	; (8002f3c <ai_network_init+0x248>)
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002de8:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dec:	600a      	str	r2, [r1, #0]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002dee:	6802      	ldr	r2, [r0, #0]
 8002df0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002df4:	6002      	str	r2, [r0, #0]
    value_weights_array.format |= AI_FMT_FLAG_CONST;
 8002df6:	f8db 2000 	ldr.w	r2, [fp]
 8002dfa:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dfe:	f8cb 2000 	str.w	r2, [fp]
    value_bias_array.format |= AI_FMT_FLAG_CONST;
 8002e02:	f8da 2000 	ldr.w	r2, [sl]
 8002e06:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002e0a:	f8ca 2000 	str.w	r2, [sl]
    mu_weights_array.format |= AI_FMT_FLAG_CONST;
 8002e0e:	f8d9 2000 	ldr.w	r2, [r9]
 8002e12:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002e16:	f8c9 2000 	str.w	r2, [r9]
    mu_bias_array.format |= AI_FMT_FLAG_CONST;
 8002e1a:	f8d8 2000 	ldr.w	r2, [r8]
 8002e1e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002e22:	f8c8 2000 	str.w	r2, [r8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 35872);
 8002e26:	f503 420c 	add.w	r2, r3, #35840	; 0x8c00
 8002e2a:	3220      	adds	r2, #32
 8002e2c:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 44448);
 8002e30:	f503 422d 	add.w	r2, r3, #44288	; 0xad00
 8002e34:	32a0      	adds	r2, #160	; 0xa0
 8002e36:	e9c0 2202 	strd	r2, r2, [r0, #8]
    value_weights_array.data = AI_PTR(g_network_weights_map[0] + 44576);
 8002e3a:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
 8002e3e:	3220      	adds	r2, #32
 8002e40:	e9cb 2202 	strd	r2, r2, [fp, #8]
    value_bias_array.data = AI_PTR(g_network_weights_map[0] + 44704);
 8002e44:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
 8002e48:	32a0      	adds	r2, #160	; 0xa0
 8002e4a:	e9ca 2202 	strd	r2, r2, [sl, #8]
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e4e:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e52:	f503 432f 	add.w	r3, r3, #44800	; 0xaf00
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e56:	32a4      	adds	r2, #164	; 0xa4
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e58:	3324      	adds	r3, #36	; 0x24
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e5a:	e9c9 2202 	strd	r2, r2, [r9, #8]
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e5e:	e9c8 3302 	strd	r3, r3, [r8, #8]
  if (ai_platform_get_activations_map(g_network_activations_map, 1, params)) {
 8002e62:	4e37      	ldr	r6, [pc, #220]	; (8002f40 <ai_network_init+0x24c>)
 8002e64:	462a      	mov	r2, r5
 8002e66:	2101      	movs	r1, #1
 8002e68:	4630      	mov	r0, r6
 8002e6a:	f007 fecd 	bl	800ac08 <ai_platform_get_activations_map>
 8002e6e:	4605      	mov	r5, r0
 8002e70:	2800      	cmp	r0, #0
 8002e72:	d04e      	beq.n	8002f12 <ai_network_init+0x21e>
    obs_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e74:	6833      	ldr	r3, [r6, #0]
 8002e76:	4a33      	ldr	r2, [pc, #204]	; (8002f44 <ai_network_init+0x250>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e78:	4933      	ldr	r1, [pc, #204]	; (8002f48 <ai_network_init+0x254>)
    _model_a2c_network_actor_mlp_Concat_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e7a:	f8df 9114 	ldr.w	r9, [pc, #276]	; 8002f90 <ai_network_init+0x29c>
    _model_a2c_network_actor_mlp_Concat_1_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e7e:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8002f94 <ai_network_init+0x2a0>
    _model_a2c_network_actor_mlp_activations_1_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 268);
 8002e82:	f8df e114 	ldr.w	lr, [pc, #276]	; 8002f98 <ai_network_init+0x2a4>
    _model_a2c_network_actor_mlp_activations_2_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 128);
 8002e86:	f8df c114 	ldr.w	ip, [pc, #276]	; 8002f9c <ai_network_init+0x2a8>
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e8a:	4830      	ldr	r0, [pc, #192]	; (8002f4c <ai_network_init+0x258>)
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002e8c:	4e30      	ldr	r6, [pc, #192]	; (8002f50 <ai_network_init+0x25c>)
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002e8e:	4c31      	ldr	r4, [pc, #196]	; (8002f54 <ai_network_init+0x260>)
    obs_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e90:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Sub_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e94:	4a30      	ldr	r2, [pc, #192]	; (8002f58 <ai_network_init+0x264>)
 8002e96:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Div_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e9a:	4a30      	ldr	r2, [pc, #192]	; (8002f5c <ai_network_init+0x268>)
 8002e9c:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Clip_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002ea0:	4a2f      	ldr	r2, [pc, #188]	; (8002f60 <ai_network_init+0x26c>)
 8002ea2:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002ea6:	f103 020c 	add.w	r2, r3, #12
 8002eaa:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_activations_0_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002eae:	492d      	ldr	r1, [pc, #180]	; (8002f64 <ai_network_init+0x270>)
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002eb0:	6082      	str	r2, [r0, #8]
    _model_a2c_network_actor_mlp_activations_0_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002eb2:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002eb6:	492c      	ldr	r1, [pc, #176]	; (8002f68 <ai_network_init+0x274>)
 8002eb8:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002ebc:	492b      	ldr	r1, [pc, #172]	; (8002f6c <ai_network_init+0x278>)
 8002ebe:	e9c1 3302 	strd	r3, r3, [r1, #8]
    value_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002ec2:	492b      	ldr	r1, [pc, #172]	; (8002f70 <ai_network_init+0x27c>)
 8002ec4:	e9c1 3302 	strd	r3, r3, [r1, #8]
    _model_a2c_network_actor_mlp_Concat_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002ec8:	f503 7103 	add.w	r1, r3, #524	; 0x20c
 8002ecc:	e9c9 1102 	strd	r1, r1, [r9, #8]
    _model_a2c_network_actor_mlp_Concat_1_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002ed0:	e9c8 1102 	strd	r1, r1, [r8, #8]
    _model_a2c_network_actor_mlp_activations_1_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 268);
 8002ed4:	f503 7186 	add.w	r1, r3, #268	; 0x10c
 8002ed8:	e9ce 1102 	strd	r1, r1, [lr, #8]
    _model_a2c_network_actor_mlp_activations_2_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 128);
 8002edc:	f103 0180 	add.w	r1, r3, #128	; 0x80
 8002ee0:	e9cc 1102 	strd	r1, r1, [ip, #8]
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002ee4:	1d19      	adds	r1, r3, #4
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002ee6:	3308      	adds	r3, #8
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002ee8:	e9c6 1102 	strd	r1, r1, [r6, #8]
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002eec:	e9c4 3302 	strd	r3, r3, [r4, #8]
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002ef0:	60c2      	str	r2, [r0, #12]

  ai_bool ok = true;
  ok &= network_configure_weights(net_ctx, params);
  ok &= network_configure_activations(net_ctx, params);

  ok &= ai_platform_network_post_init(network);
 8002ef2:	9801      	ldr	r0, [sp, #4]
 8002ef4:	f008 fadc 	bl	800b4b0 <ai_platform_network_post_init>
 8002ef8:	9b02      	ldr	r3, [sp, #8]
 8002efa:	4028      	ands	r0, r5
 8002efc:	4003      	ands	r3, r0
 8002efe:	b2d8      	uxtb	r0, r3

  return ok;
}
 8002f00:	b005      	add	sp, #20
 8002f02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_WEIGHTS);
 8002f06:	2212      	movs	r2, #18
 8002f08:	2130      	movs	r1, #48	; 0x30
 8002f0a:	4620      	mov	r0, r4
 8002f0c:	f007 ff60 	bl	800add0 <ai_platform_network_set_error>
  return false;
 8002f10:	e7a7      	b.n	8002e62 <ai_network_init+0x16e>
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_ACTIVATIONS);
 8002f12:	2213      	movs	r2, #19
 8002f14:	4620      	mov	r0, r4
 8002f16:	2130      	movs	r1, #48	; 0x30
 8002f18:	f007 ff5a 	bl	800add0 <ai_platform_network_set_error>
  return false;
 8002f1c:	e7e9      	b.n	8002ef2 <ai_network_init+0x1fe>
 8002f1e:	bf00      	nop
 8002f20:	20002dc4 	.word	0x20002dc4
 8002f24:	20000cc0 	.word	0x20000cc0
 8002f28:	20001360 	.word	0x20001360
 8002f2c:	20001390 	.word	0x20001390
 8002f30:	20000db8 	.word	0x20000db8
 8002f34:	20000de8 	.word	0x20000de8
 8002f38:	20000f08 	.word	0x20000f08
 8002f3c:	20000e90 	.word	0x20000e90
 8002f40:	20002dc0 	.word	0x20002dc0
 8002f44:	20001330 	.word	0x20001330
 8002f48:	20000d88 	.word	0x20000d88
 8002f4c:	20001228 	.word	0x20001228
 8002f50:	200012d0 	.word	0x200012d0
 8002f54:	20000d10 	.word	0x20000d10
 8002f58:	20001188 	.word	0x20001188
 8002f5c:	20001138 	.word	0x20001138
 8002f60:	200010e8 	.word	0x200010e8
 8002f64:	20000ff8 	.word	0x20000ff8
 8002f68:	20000e30 	.word	0x20000e30
 8002f6c:	20000ed8 	.word	0x20000ed8
 8002f70:	20001408 	.word	0x20001408
 8002f74:	20001258 	.word	0x20001258
 8002f78:	20000d40 	.word	0x20000d40
 8002f7c:	20000e60 	.word	0x20000e60
 8002f80:	20001438 	.word	0x20001438
 8002f84:	200013c0 	.word	0x200013c0
 8002f88:	20001300 	.word	0x20001300
 8002f8c:	20001288 	.word	0x20001288
 8002f90:	20000fa8 	.word	0x20000fa8
 8002f94:	20000f58 	.word	0x20000f58
 8002f98:	20001048 	.word	0x20001048
 8002f9c:	20001098 	.word	0x20001098

08002fa0 <ai_network_create_and_init>:
{
 8002fa0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002fa4:	b091      	sub	sp, #68	; 0x44
  return ai_platform_network_create(
 8002fa6:	2300      	movs	r3, #0
 8002fa8:	2405      	movs	r4, #5
 8002faa:	9400      	str	r4, [sp, #0]
 8002fac:	9301      	str	r3, [sp, #4]
{
 8002fae:	460f      	mov	r7, r1
 8002fb0:	4616      	mov	r6, r2
  return ai_platform_network_create(
 8002fb2:	4619      	mov	r1, r3
 8002fb4:	4a26      	ldr	r2, [pc, #152]	; (8003050 <ai_network_create_and_init+0xb0>)
 8002fb6:	2301      	movs	r3, #1
{
 8002fb8:	4680      	mov	r8, r0
  return ai_platform_network_create(
 8002fba:	f008 f8b5 	bl	800b128 <ai_platform_network_create>
    if (err.type != AI_ERROR_NONE)
 8002fbe:	f010 09ff 	ands.w	r9, r0, #255	; 0xff
 8002fc2:	4604      	mov	r4, r0
 8002fc4:	d003      	beq.n	8002fce <ai_network_create_and_init+0x2e>
}
 8002fc6:	4620      	mov	r0, r4
 8002fc8:	b011      	add	sp, #68	; 0x44
 8002fca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (ai_network_data_params_get(&params) != true) {
 8002fce:	a802      	add	r0, sp, #8
 8002fd0:	f000 f842 	bl	8003058 <ai_network_data_params_get>
 8002fd4:	b3a8      	cbz	r0, 8003042 <ai_network_create_and_init+0xa2>
    if (activations) {
 8002fd6:	b17f      	cbz	r7, 8002ff8 <ai_network_create_and_init+0x58>
        for (int idx=0;idx<params.map_activations.size;idx++)
 8002fd8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002fdc:	b163      	cbz	r3, 8002ff8 <ai_network_create_and_init+0x58>
 8002fde:	3f04      	subs	r7, #4
 8002fe0:	464d      	mov	r5, r9
            AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_activations, idx, activations[idx]);
 8002fe2:	4629      	mov	r1, r5
 8002fe4:	f857 2f04 	ldr.w	r2, [r7, #4]!
 8002fe8:	a805      	add	r0, sp, #20
 8002fea:	f007 fda5 	bl	800ab38 <ai_buffer_array_item_set_address>
        for (int idx=0;idx<params.map_activations.size;idx++)
 8002fee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002ff2:	3501      	adds	r5, #1
 8002ff4:	42ab      	cmp	r3, r5
 8002ff6:	dcf4      	bgt.n	8002fe2 <ai_network_create_and_init+0x42>
    if (weights) {
 8002ff8:	b17e      	cbz	r6, 800301a <ai_network_create_and_init+0x7a>
        for (int idx=0;idx<params.map_weights.size;idx++)
 8002ffa:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002ffe:	b163      	cbz	r3, 800301a <ai_network_create_and_init+0x7a>
 8003000:	3e04      	subs	r6, #4
 8003002:	2500      	movs	r5, #0
            AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_weights, idx, weights[idx]);
 8003004:	4629      	mov	r1, r5
 8003006:	f856 2f04 	ldr.w	r2, [r6, #4]!
 800300a:	a803      	add	r0, sp, #12
 800300c:	f007 fd94 	bl	800ab38 <ai_buffer_array_item_set_address>
        for (int idx=0;idx<params.map_weights.size;idx++)
 8003010:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8003014:	3501      	adds	r5, #1
 8003016:	42ab      	cmp	r3, r5
 8003018:	dcf4      	bgt.n	8003004 <ai_network_create_and_init+0x64>
    if (ai_network_init(*network, &params) != true) {
 800301a:	f8d8 0000 	ldr.w	r0, [r8]
 800301e:	a902      	add	r1, sp, #8
 8003020:	f7ff fe68 	bl	8002cf4 <ai_network_init>
 8003024:	b128      	cbz	r0, 8003032 <ai_network_create_and_init+0x92>
    return err;
 8003026:	f369 0407 	bfi	r4, r9, #0, #8
}
 800302a:	4620      	mov	r0, r4
 800302c:	b011      	add	sp, #68	; 0x44
 800302e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  return ai_platform_network_get_error(network);
 8003032:	f8d8 0000 	ldr.w	r0, [r8]
 8003036:	f007 fe5d 	bl	800acf4 <ai_platform_network_get_error>
 800303a:	fa5f f980 	uxtb.w	r9, r0
 800303e:	4604      	mov	r4, r0
 8003040:	e7f1      	b.n	8003026 <ai_network_create_and_init+0x86>
 8003042:	f8d8 0000 	ldr.w	r0, [r8]
 8003046:	f007 fe55 	bl	800acf4 <ai_platform_network_get_error>
 800304a:	4604      	mov	r4, r0
        return err;
 800304c:	e7bb      	b.n	8002fc6 <ai_network_create_and_init+0x26>
 800304e:	bf00      	nop
 8003050:	20001198 	.word	0x20001198

08003054 <ai_network_run>:

AI_API_ENTRY
ai_i32 ai_network_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 8003054:	f008 bab4 	b.w	800b5c0 <ai_platform_network_process>

08003058 <ai_network_data_params_get>:
 * @return true if a valid configuration is present, false otherwise
 */
AI_API_ENTRY
ai_bool ai_network_data_params_get(ai_network_params* params)
{
  if (!params) return false;
 8003058:	4603      	mov	r3, r0
 800305a:	b198      	cbz	r0, 8003084 <ai_network_data_params_get+0x2c>
{
 800305c:	b510      	push	{r4, lr}
  
  const ai_buffer_array map_activations = 
 800305e:	4c0a      	ldr	r4, [pc, #40]	; (8003088 <ai_network_data_params_get+0x30>)
 8003060:	e894 0003 	ldmia.w	r4, {r0, r1}
{
 8003064:	b084      	sub	sp, #16
  const ai_buffer_array map_activations = 
 8003066:	466a      	mov	r2, sp
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_ACTIVATIONS_COUNT, g_network_data_map_activations);
  
  const ai_buffer_array map_weights = 
 8003068:	3408      	adds	r4, #8
  const ai_buffer_array map_activations = 
 800306a:	e882 0003 	stmia.w	r2, {r0, r1}
  const ai_buffer_array map_weights = 
 800306e:	e894 0003 	ldmia.w	r4, {r0, r1}
 8003072:	ac02      	add	r4, sp, #8
 8003074:	e884 0003 	stmia.w	r4, {r0, r1}
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_WEIGHTS_COUNT, g_network_data_map_weights);

  return ai_platform_bind_network_params(params, &map_weights, &map_activations);
 8003078:	4621      	mov	r1, r4
 800307a:	4618      	mov	r0, r3
 800307c:	f007 fe18 	bl	800acb0 <ai_platform_bind_network_params>
}
 8003080:	b004      	add	sp, #16
 8003082:	bd10      	pop	{r4, pc}
 8003084:	4770      	bx	lr
 8003086:	bf00      	nop
 8003088:	0800eec0 	.word	0x0800eec0

0800308c <PWMC_GetPhaseCurrents>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctGetPhaseCurrents(pHandle, Iab);
 800308c:	6803      	ldr	r3, [r0, #0]
 800308e:	4718      	bx	r3

08003090 <PWMC_SetPhaseVoltage>:
  * @param  Valfa_beta: Voltage Components expressed in the @f$(\alpha, \beta)@f$ reference frame.
  * @retval #MC_NO_ERROR if no error occurred or #MC_DURATION if the duty cycles were
  *         set too late for being taken into account in the next PWM cycle.
  */
__weak uint16_t PWMC_SetPhaseVoltage(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta)
{
 8003090:	b530      	push	{r4, r5, lr}
    int32_t wTimePhA;
    int32_t wTimePhB;
    int32_t wTimePhC;

    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8003092:	f8b0 e072 	ldrh.w	lr, [r0, #114]	; 0x72
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 8003096:	f8b0 204e 	ldrh.w	r2, [r0, #78]	; 0x4e
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 800309a:	ea4f 4c21 	mov.w	ip, r1, asr #16
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 800309e:	b20b      	sxth	r3, r1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 80030a0:	fb0e fc0c 	mul.w	ip, lr, ip
 80030a4:	ebcc 7ccc 	rsb	ip, ip, ip, lsl #31
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 80030a8:	fb02 f303 	mul.w	r3, r2, r3
{
 80030ac:	b083      	sub	sp, #12

    wX = wUBeta;
    wY = (wUBeta + wUAlpha) / 2;
 80030ae:	eb03 024c 	add.w	r2, r3, ip, lsl #1
    wZ = (wUBeta - wUAlpha) / 2;
 80030b2:	ebc3 034c 	rsb	r3, r3, ip, lsl #1
{
 80030b6:	9101      	str	r1, [sp, #4]
    wZ = (wUBeta - wUAlpha) / 2;
 80030b8:	eb03 74d3 	add.w	r4, r3, r3, lsr #31
    wY = (wUBeta + wUAlpha) / 2;
 80030bc:	eb02 71d2 	add.w	r1, r2, r2, lsr #31

    /* Sector calculation from wX, wY, wZ */
    if (wY < 0)
 80030c0:	1c55      	adds	r5, r2, #1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 80030c2:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 80030c6:	ea4f 0161 	mov.w	r1, r1, asr #1
    wZ = (wUBeta - wUAlpha) / 2;
 80030ca:	ea4f 0464 	mov.w	r4, r4, asr #1
    if (wY < 0)
 80030ce:	f2c0 809c 	blt.w	800320a <PWMC_SetPhaseVoltage+0x17a>
        }
        }
    }
    else /* wY > 0 */
    {
      if (wZ >= 0)
 80030d2:	1c5d      	adds	r5, r3, #1
 80030d4:	db65      	blt.n	80031a2 <PWMC_SetPhaseVoltage+0x112>
      {
        pHandle->Sector = SECTOR_2;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80030d6:	1b09      	subs	r1, r1, r4
 80030d8:	bf44      	itt	mi
 80030da:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 80030de:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 80030e2:	2b00      	cmp	r3, #0
 80030e4:	bfbc      	itt	lt
 80030e6:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 80030ea:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
        wTimePhC = wTimePhA - (wY / 131072);
 80030ee:	2a00      	cmp	r2, #0
 80030f0:	bfb8      	it	lt
 80030f2:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80030f6:	ea4f 0e9e 	mov.w	lr, lr, lsr #2

        if(true == pHandle->SingleShuntTopology)
 80030fa:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80030fe:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
        pHandle->Sector = SECTOR_2;
 8003102:	f04f 0c01 	mov.w	ip, #1
        wTimePhC = wTimePhA - (wY / 131072);
 8003106:	bfb8      	it	lt
 8003108:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
        pHandle->Sector = SECTOR_2;
 800310c:	f880 c07c 	strb.w	ip, [r0, #124]	; 0x7c
        wTimePhB = wTimePhA + (wZ / 131072);
 8003110:	eb01 43a3 	add.w	r3, r1, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072);
 8003114:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 8003118:	2c00      	cmp	r4, #0
 800311a:	f040 80a0 	bne.w	800325e <PWMC_SetPhaseVoltage+0x1ce>
          pHandle->midDuty = 0U;
          pHandle->highDuty = 1U;
        }
        else
        {
        pHandle->lowDuty = (uint16_t)wTimePhB;
 800311e:	fa1f fe83 	uxth.w	lr, r3
        pHandle->midDuty = (uint16_t)wTimePhA;
 8003122:	fa1f fc81 	uxth.w	ip, r1
        pHandle->highDuty = (uint16_t)wTimePhC;
 8003126:	b294      	uxth	r4, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 8003128:	f8a0 405c 	strh.w	r4, [r0, #92]	; 0x5c

    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));

    if (1U == pHandle->DTTest)
 800312c:	f8b0 4070 	ldrh.w	r4, [r0, #112]	; 0x70
          pHandle->lowDuty = (uint16_t)wTimePhC;
 8003130:	f8a0 e058 	strh.w	lr, [r0, #88]	; 0x58
 8003134:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 8003138:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800313c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 8003140:	b289      	uxth	r1, r1
 8003142:	b29b      	uxth	r3, r3
 8003144:	b292      	uxth	r2, r2
    if (1U == pHandle->DTTest)
 8003146:	2c01      	cmp	r4, #1
          pHandle->midDuty = (uint16_t)wTimePhB;
 8003148:	f8a0 c05a 	strh.w	ip, [r0, #90]	; 0x5a
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 800314c:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 8003150:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 8003154:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
    if (1U == pHandle->DTTest)
 8003158:	d11e      	bne.n	8003198 <PWMC_SetPhaseVoltage+0x108>
    {
      /* Dead time compensation */
      if (pHandle->Ia > 0)
 800315a:	f9b0 4062 	ldrsh.w	r4, [r0, #98]	; 0x62
 800315e:	2c00      	cmp	r4, #0
      {
        pHandle->CntPhA += pHandle->DTCompCnt;
 8003160:	f8b0 4074 	ldrh.w	r4, [r0, #116]	; 0x74
 8003164:	bfcc      	ite	gt
 8003166:	1909      	addgt	r1, r1, r4
      }
      else
      {
        pHandle->CntPhA -= pHandle->DTCompCnt;
 8003168:	1b09      	suble	r1, r1, r4
 800316a:	b289      	uxth	r1, r1
 800316c:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
      }

      if (pHandle->Ib > 0)
 8003170:	f9b0 1064 	ldrsh.w	r1, [r0, #100]	; 0x64
 8003174:	2900      	cmp	r1, #0
      else
      {
        pHandle->CntPhB -= pHandle->DTCompCnt;
      }

      if (pHandle->Ic > 0)
 8003176:	f9b0 1066 	ldrsh.w	r1, [r0, #102]	; 0x66
        pHandle->CntPhB += pHandle->DTCompCnt;
 800317a:	bfcc      	ite	gt
 800317c:	191b      	addgt	r3, r3, r4
        pHandle->CntPhB -= pHandle->DTCompCnt;
 800317e:	1b1b      	suble	r3, r3, r4
      if (pHandle->Ic > 0)
 8003180:	2900      	cmp	r1, #0
        pHandle->CntPhB -= pHandle->DTCompCnt;
 8003182:	b29b      	uxth	r3, r3
      {
        pHandle->CntPhC += pHandle->DTCompCnt;
 8003184:	bfcc      	ite	gt
 8003186:	18a4      	addgt	r4, r4, r2
      }
      else
      {
        pHandle->CntPhC -= pHandle->DTCompCnt;
 8003188:	1b12      	suble	r2, r2, r4
 800318a:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
        pHandle->CntPhC += pHandle->DTCompCnt;
 800318e:	bfcc      	ite	gt
 8003190:	f8a0 4054 	strhgt.w	r4, [r0, #84]	; 0x54
        pHandle->CntPhC -= pHandle->DTCompCnt;
 8003194:	f8a0 2054 	strhle.w	r2, [r0, #84]	; 0x54
      }
    }
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 8003198:	6943      	ldr	r3, [r0, #20]
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (returnValue);
}
 800319a:	b003      	add	sp, #12
 800319c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 80031a0:	4718      	bx	r3
        if ( wX <= 0 )
 80031a2:	f1bc 0f00 	cmp.w	ip, #0
 80031a6:	f340 808c 	ble.w	80032c2 <PWMC_SetPhaseVoltage+0x232>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80031aa:	ebbc 0404 	subs.w	r4, ip, r4
 80031ae:	bf44      	itt	mi
 80031b0:	f504 347f 	addmi.w	r4, r4, #261120	; 0x3fc00
 80031b4:	f204 34ff 	addwmi	r4, r4, #1023	; 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 80031b8:	2b00      	cmp	r3, #0
 80031ba:	bfbc      	itt	lt
 80031bc:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 80031c0:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80031c4:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhC = wTimePhB - (wX / 131072);
 80031c8:	f1bc 0f00 	cmp.w	ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 80031cc:	eb0e 41a4 	add.w	r1, lr, r4, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80031d0:	bfb8      	it	lt
 80031d2:	f50c 3cff 	addlt.w	ip, ip, #130560	; 0x1fe00
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80031d6:	f890 407f 	ldrb.w	r4, [r0, #127]	; 0x7f
          pHandle->Sector = SECTOR_1;
 80031da:	f04f 0200 	mov.w	r2, #0
          wTimePhB = wTimePhA + (wZ / 131072);
 80031de:	eb01 43a3 	add.w	r3, r1, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80031e2:	bfb8      	it	lt
 80031e4:	f20c 1cff 	addwlt	ip, ip, #511	; 0x1ff
          pHandle->Sector = SECTOR_1;
 80031e8:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
          wTimePhC = wTimePhB - (wX / 131072);
 80031ec:	eba3 426c 	sub.w	r2, r3, ip, asr #17
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80031f0:	2c00      	cmp	r4, #0
 80031f2:	f040 80c6 	bne.w	8003382 <PWMC_SetPhaseVoltage+0x2f2>
 80031f6:	f890 5087 	ldrb.w	r5, [r0, #135]	; 0x87
 80031fa:	2d00      	cmp	r5, #0
 80031fc:	f000 80d3 	beq.w	80033a6 <PWMC_SetPhaseVoltage+0x316>
 8003200:	f04f 0e02 	mov.w	lr, #2
 8003204:	f04f 0c01 	mov.w	ip, #1
 8003208:	e78e      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
      if (wZ < 0)
 800320a:	1c5d      	adds	r5, r3, #1
 800320c:	f2c0 8085 	blt.w	800331a <PWMC_SetPhaseVoltage+0x28a>
        if (wX <= 0)
 8003210:	f1bc 0f00 	cmp.w	ip, #0
 8003214:	dd29      	ble.n	800326a <PWMC_SetPhaseVoltage+0x1da>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 8003216:	ebb1 010c 	subs.w	r1, r1, ip
 800321a:	bf44      	itt	mi
 800321c:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 8003220:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 8003224:	2a00      	cmp	r2, #0
 8003226:	bfb8      	it	lt
 8003228:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 800322c:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
 8003230:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
          wTimePhC = wTimePhA - (wY / 131072);
 8003234:	bfb8      	it	lt
 8003236:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
          if(true == pHandle->SingleShuntTopology)
 800323a:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          pHandle->Sector = SECTOR_3;
 800323e:	2302      	movs	r3, #2
          wTimePhC = wTimePhA - (wY / 131072);
 8003240:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
          pHandle->Sector = SECTOR_3;
 8003244:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
          wTimePhB = wTimePhC + (wX / 131072);
 8003248:	eb02 436c 	add.w	r3, r2, ip, asr #17
          if(true == pHandle->SingleShuntTopology)
 800324c:	2c00      	cmp	r4, #0
 800324e:	f040 8092 	bne.w	8003376 <PWMC_SetPhaseVoltage+0x2e6>
          pHandle->lowDuty = (uint16_t)wTimePhB;
 8003252:	fa1f fe83 	uxth.w	lr, r3
          pHandle->midDuty = (uint16_t)wTimePhC;
 8003256:	fa1f fc82 	uxth.w	ip, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 800325a:	b28c      	uxth	r4, r1
 800325c:	e764      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
 800325e:	f04f 0e02 	mov.w	lr, #2
 8003262:	f04f 0c00 	mov.w	ip, #0
 8003266:	2401      	movs	r4, #1
 8003268:	e75e      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 800326a:	ebbc 0404 	subs.w	r4, ip, r4
 800326e:	bf44      	itt	mi
 8003270:	f504 347f 	addmi.w	r4, r4, #261120	; 0x3fc00
 8003274:	f204 34ff 	addwmi	r4, r4, #1023	; 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 8003278:	2b00      	cmp	r3, #0
 800327a:	bfb8      	it	lt
 800327c:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
          pHandle->Sector = SECTOR_4;
 8003280:	f04f 0203 	mov.w	r2, #3
          wTimePhB = wTimePhA + (wZ / 131072);
 8003284:	bfb8      	it	lt
 8003286:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
          pHandle->Sector = SECTOR_4;
 800328a:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 800328e:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhC = wTimePhB - (wX / 131072);
 8003292:	f1bc 0200 	subs.w	r2, ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8003296:	eb0e 41a4 	add.w	r1, lr, r4, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 800329a:	bfb8      	it	lt
 800329c:	f502 32ff 	addlt.w	r2, r2, #130560	; 0x1fe00
          if(true == pHandle->SingleShuntTopology)
 80032a0:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          wTimePhB = wTimePhA + (wZ / 131072);
 80032a4:	eb01 43a3 	add.w	r3, r1, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 80032a8:	bfb8      	it	lt
 80032aa:	f202 12ff 	addwlt	r2, r2, #511	; 0x1ff
 80032ae:	eba3 4262 	sub.w	r2, r3, r2, asr #17
          if(true == pHandle->SingleShuntTopology)
 80032b2:	2c00      	cmp	r4, #0
 80032b4:	d071      	beq.n	800339a <PWMC_SetPhaseVoltage+0x30a>
 80032b6:	f04f 0e00 	mov.w	lr, #0
 80032ba:	f04f 0c01 	mov.w	ip, #1
 80032be:	2402      	movs	r4, #2
 80032c0:	e732      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80032c2:	ebb1 010c 	subs.w	r1, r1, ip
 80032c6:	bf44      	itt	mi
 80032c8:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 80032cc:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 80032d0:	2a00      	cmp	r2, #0
 80032d2:	bfb8      	it	lt
 80032d4:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
          pHandle->Sector = SECTOR_6;
 80032d8:	f04f 0305 	mov.w	r3, #5
          wTimePhC = wTimePhA - (wY / 131072);
 80032dc:	bfb8      	it	lt
 80032de:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
          pHandle->Sector = SECTOR_6;
 80032e2:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80032e6:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhB = wTimePhC + (wX / 131072);
 80032ea:	f1bc 0300 	subs.w	r3, ip, #0
 80032ee:	bfb8      	it	lt
 80032f0:	f503 33ff 	addlt.w	r3, r3, #130560	; 0x1fe00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80032f4:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
          if(true == pHandle->SingleShuntTopology)
 80032f8:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          wTimePhC = wTimePhA - (wY / 131072);
 80032fc:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
          wTimePhB = wTimePhC + (wX / 131072);
 8003300:	bfb8      	it	lt
 8003302:	f203 13ff 	addwlt	r3, r3, #511	; 0x1ff
 8003306:	eb02 4363 	add.w	r3, r2, r3, asr #17
          if(true == pHandle->SingleShuntTopology)
 800330a:	2c00      	cmp	r4, #0
 800330c:	d03f      	beq.n	800338e <PWMC_SetPhaseVoltage+0x2fe>
 800330e:	f04f 0e01 	mov.w	lr, #1
 8003312:	f04f 0c02 	mov.w	ip, #2
 8003316:	2400      	movs	r4, #0
 8003318:	e706      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800331a:	1b09      	subs	r1, r1, r4
 800331c:	bf44      	itt	mi
 800331e:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 8003322:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 8003326:	2b00      	cmp	r3, #0
 8003328:	bfbc      	itt	lt
 800332a:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 800332e:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
        wTimePhC = wTimePhA - (wY / 131072) ;
 8003332:	2a00      	cmp	r2, #0
 8003334:	bfb8      	it	lt
 8003336:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800333a:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
        if(true == pHandle->SingleShuntTopology)
 800333e:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 8003342:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
        pHandle->Sector = SECTOR_5;
 8003346:	f04f 0c04 	mov.w	ip, #4
        wTimePhC = wTimePhA - (wY / 131072) ;
 800334a:	bfb8      	it	lt
 800334c:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
        pHandle->Sector = SECTOR_5;
 8003350:	f880 c07c 	strb.w	ip, [r0, #124]	; 0x7c
        wTimePhB = wTimePhA + (wZ / 131072);
 8003354:	eb01 43a3 	add.w	r3, r1, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072) ;
 8003358:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 800335c:	b92c      	cbnz	r4, 800336a <PWMC_SetPhaseVoltage+0x2da>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 800335e:	fa1f fe82 	uxth.w	lr, r2
          pHandle->midDuty = (uint16_t)wTimePhA;
 8003362:	fa1f fc81 	uxth.w	ip, r1
          pHandle->highDuty = (uint16_t)wTimePhB;
 8003366:	b29c      	uxth	r4, r3
 8003368:	e6de      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
 800336a:	f04f 0e01 	mov.w	lr, #1
 800336e:	f04f 0c00 	mov.w	ip, #0
 8003372:	2402      	movs	r4, #2
 8003374:	e6d8      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
 8003376:	f04f 0e00 	mov.w	lr, #0
 800337a:	f04f 0c02 	mov.w	ip, #2
 800337e:	2401      	movs	r4, #1
 8003380:	e6d2      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
 8003382:	f04f 0e02 	mov.w	lr, #2
 8003386:	f04f 0c01 	mov.w	ip, #1
 800338a:	2400      	movs	r4, #0
 800338c:	e6cc      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 800338e:	fa1f fe81 	uxth.w	lr, r1
            pHandle->midDuty = (uint16_t)wTimePhC;
 8003392:	fa1f fc82 	uxth.w	ip, r2
            pHandle->highDuty = (uint16_t)wTimePhB;
 8003396:	b29c      	uxth	r4, r3
 8003398:	e6c6      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 800339a:	fa1f fe82 	uxth.w	lr, r2
          pHandle->midDuty = (uint16_t)wTimePhB;
 800339e:	fa1f fc83 	uxth.w	ip, r3
          pHandle->highDuty = (uint16_t)wTimePhA;
 80033a2:	b28c      	uxth	r4, r1
 80033a4:	e6c0      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 80033a6:	fa1f fe81 	uxth.w	lr, r1
            pHandle->midDuty = (uint16_t)wTimePhB;
 80033aa:	fa1f fc83 	uxth.w	ip, r3
            pHandle->highDuty = (uint16_t)wTimePhC;
 80033ae:	b294      	uxth	r4, r2
 80033b0:	e6ba      	b.n	8003128 <PWMC_SetPhaseVoltage+0x98>
 80033b2:	bf00      	nop

080033b4 <PWMC_SwitchOffPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOffPwm(pHandle);
 80033b4:	6843      	ldr	r3, [r0, #4]
 80033b6:	4718      	bx	r3

080033b8 <PWMC_SwitchOnPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOnPwm(pHandle);
 80033b8:	6883      	ldr	r3, [r0, #8]
 80033ba:	4718      	bx	r3

080033bc <PWMC_CurrentReadingCalibr>:
  *         #CRC_EXEC to execute the offset calibration.
  * @retval true if the current calibration has been completed, **false** if it is
  *         still ongoing.
  */
__weak bool PWMC_CurrentReadingCalibr(PWMC_Handle_t *pHandle, CRCAction_t action)
{
 80033bc:	b510      	push	{r4, lr}
 80033be:	4604      	mov	r4, r0
 80033c0:	b082      	sub	sp, #8
    /* Nothing to do */
  }
  else
  {
#endif
    if (CRC_START == action)
 80033c2:	b199      	cbz	r1, 80033ec <PWMC_CurrentReadingCalibr+0x30>
    {
      PWMC_SwitchOffPWM(pHandle);
      pHandle->pFctCurrReadingCalib(pHandle);
      retVal = true;
    }
    else if (CRC_EXEC == action)
 80033c4:	2901      	cmp	r1, #1
 80033c6:	d002      	beq.n	80033ce <PWMC_CurrentReadingCalibr+0x12>
  bool retVal = false;
 80033c8:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (retVal);
}
 80033ca:	b002      	add	sp, #8
 80033cc:	bd10      	pop	{r4, pc}
      if (pHandle->OffCalibrWaitTimeCounter > 0u)
 80033ce:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 80033d2:	b19b      	cbz	r3, 80033fc <PWMC_CurrentReadingCalibr+0x40>
        pHandle->OffCalibrWaitTimeCounter--;
 80033d4:	3b01      	subs	r3, #1
 80033d6:	b29b      	uxth	r3, r3
 80033d8:	9101      	str	r1, [sp, #4]
 80033da:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
        if (0U == pHandle->OffCalibrWaitTimeCounter)
 80033de:	2b00      	cmp	r3, #0
 80033e0:	d1f2      	bne.n	80033c8 <PWMC_CurrentReadingCalibr+0xc>
          pHandle->pFctCurrReadingCalib(pHandle);
 80033e2:	68c3      	ldr	r3, [r0, #12]
 80033e4:	4798      	blx	r3
          retVal = true;
 80033e6:	9901      	ldr	r1, [sp, #4]
 80033e8:	4608      	mov	r0, r1
 80033ea:	e7ee      	b.n	80033ca <PWMC_CurrentReadingCalibr+0xe>
      PWMC_SwitchOffPWM(pHandle);
 80033ec:	f7ff ffe2 	bl	80033b4 <PWMC_SwitchOffPWM>
      pHandle->pFctCurrReadingCalib(pHandle);
 80033f0:	4620      	mov	r0, r4
 80033f2:	68e3      	ldr	r3, [r4, #12]
 80033f4:	4798      	blx	r3
      retVal = true;
 80033f6:	2001      	movs	r0, #1
}
 80033f8:	b002      	add	sp, #8
 80033fa:	bd10      	pop	{r4, pc}
        retVal = true;
 80033fc:	4608      	mov	r0, r1
}
 80033fe:	b002      	add	sp, #8
 8003400:	bd10      	pop	{r4, pc}
 8003402:	bf00      	nop

08003404 <PWMC_OVP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 8003404:	6c4a      	ldr	r2, [r1, #68]	; 0x44
{
 8003406:	4603      	mov	r3, r0
    pHandle->OverVoltageFlag = true;
 8003408:	f04f 0c01 	mov.w	ip, #1
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 800340c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8003410:	644a      	str	r2, [r1, #68]	; 0x44
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 8003412:	307a      	adds	r0, #122	; 0x7a
    pHandle->OverVoltageFlag = true;
 8003414:	f883 c083 	strb.w	ip, [r3, #131]	; 0x83
    pHandle->BrakeActionLock = true;
 8003418:	f883 c085 	strb.w	ip, [r3, #133]	; 0x85
}
 800341c:	4770      	bx	lr
 800341e:	bf00      	nop

08003420 <PWMC_IsFaultOccurred>:
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns #MC_OVER_CURR if an overcurrent has been
  *                  detected since last method call, #MC_NO_FAULTS otherwise.
  */
__weak uint16_t PWMC_IsFaultOccurred(PWMC_Handle_t *pHandle)
{
 8003420:	4603      	mov	r3, r0
  uint16_t retVal = MC_NO_FAULTS;

  if (true == pHandle->OverVoltageFlag)
 8003422:	f890 0083 	ldrb.w	r0, [r0, #131]	; 0x83
 8003426:	b1a8      	cbz	r0, 8003454 <PWMC_IsFaultOccurred+0x34>
  {
    retVal = MC_OVER_VOLT;
    pHandle->OverVoltageFlag = false;
 8003428:	2200      	movs	r2, #0
 800342a:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
 800342e:	2142      	movs	r1, #66	; 0x42
    retVal = MC_OVER_VOLT;
 8003430:	2002      	movs	r0, #2
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->OverCurrentFlag)
 8003432:	f893 2082 	ldrb.w	r2, [r3, #130]	; 0x82
 8003436:	b11a      	cbz	r2, 8003440 <PWMC_IsFaultOccurred+0x20>
  {
    retVal |= MC_OVER_CURR;
    pHandle->OverCurrentFlag = false;
 8003438:	2200      	movs	r2, #0
 800343a:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
    retVal |= MC_OVER_CURR;
 800343e:	4608      	mov	r0, r1
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->driverProtectionFlag)
 8003440:	f893 2084 	ldrb.w	r2, [r3, #132]	; 0x84
 8003444:	b12a      	cbz	r2, 8003452 <PWMC_IsFaultOccurred+0x32>
  {
    retVal |= MC_DP_FAULT;
 8003446:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
    pHandle->driverProtectionFlag = false;
 800344a:	2200      	movs	r2, #0
    retVal |= MC_DP_FAULT;
 800344c:	b280      	uxth	r0, r0
    pHandle->driverProtectionFlag = false;
 800344e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
  {
    /* Nothing to do */
  }

  return (retVal);
}
 8003452:	4770      	bx	lr
 8003454:	2140      	movs	r1, #64	; 0x40
 8003456:	e7ec      	b.n	8003432 <PWMC_IsFaultOccurred+0x12>

08003458 <RI_SetRegisterGlobal>:
#include "mcp_config.h"
#include "mcpa.h"
#include "mc_configuration_registers.h"

uint8_t RI_SetRegisterGlobal(uint16_t regID, uint8_t typeID, uint8_t *data, uint16_t *size, int16_t dataAvailable)
{
 8003458:	b510      	push	{r4, lr}
  uint8_t retVal = MCP_CMD_OK;
  switch(typeID)
 800345a:	3908      	subs	r1, #8
{
 800345c:	f9bd c008 	ldrsh.w	ip, [sp, #8]
  switch(typeID)
 8003460:	2920      	cmp	r1, #32
 8003462:	d812      	bhi.n	800348a <RI_SetRegisterGlobal+0x32>
 8003464:	e8df f001 	tbb	[pc, r1]
 8003468:	11111115 	.word	0x11111115
 800346c:	11111111 	.word	0x11111111
 8003470:	1111111d 	.word	0x1111111d
 8003474:	11111111 	.word	0x11111111
 8003478:	1111112d 	.word	0x1111112d
 800347c:	11111111 	.word	0x11111111
 8003480:	11111135 	.word	0x11111135
 8003484:	11111111 	.word	0x11111111
 8003488:	4c          	.byte	0x4c
 8003489:	00          	.byte	0x00
    }

    default:
    {
      retVal = MCP_ERROR_BAD_DATA_TYPE;
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 800348a:	2200      	movs	r2, #0
 800348c:	801a      	strh	r2, [r3, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 800348e:	2007      	movs	r0, #7
      break;
    }
  }
  return (retVal);
}
 8003490:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_UNKNOWN_REG;
 8003492:	2848      	cmp	r0, #72	; 0x48
      *size = 1;
 8003494:	f04f 0201 	mov.w	r2, #1
          retVal = MCP_ERROR_UNKNOWN_REG;
 8003498:	bf0c      	ite	eq
 800349a:	2004      	moveq	r0, #4
 800349c:	2005      	movne	r0, #5
      *size = 1;
 800349e:	801a      	strh	r2, [r3, #0]
}
 80034a0:	bd10      	pop	{r4, pc}
      switch (regID)
 80034a2:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 80034a6:	d04e      	beq.n	8003546 <RI_SetRegisterGlobal+0xee>
 80034a8:	d93c      	bls.n	8003524 <RI_SetRegisterGlobal+0xcc>
 80034aa:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 80034ae:	d04a      	beq.n	8003546 <RI_SetRegisterGlobal+0xee>
 80034b0:	f641 3258 	movw	r2, #7000	; 0x1b58
 80034b4:	4290      	cmp	r0, r2
 80034b6:	bf14      	ite	ne
 80034b8:	2005      	movne	r0, #5
 80034ba:	2004      	moveq	r0, #4
      *size = 2;
 80034bc:	2202      	movs	r2, #2
 80034be:	801a      	strh	r2, [r3, #0]
}
 80034c0:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_UNKNOWN_REG;
 80034c2:	2818      	cmp	r0, #24
      *size = 4;
 80034c4:	f04f 0204 	mov.w	r2, #4
          retVal = MCP_ERROR_UNKNOWN_REG;
 80034c8:	bf0c      	ite	eq
 80034ca:	4610      	moveq	r0, r2
 80034cc:	2005      	movne	r0, #5
      *size = 4;
 80034ce:	801a      	strh	r2, [r3, #0]
}
 80034d0:	bd10      	pop	{r4, pc}
uint8_t RI_MovString(const char_t *srcString, char_t *destString, uint16_t *size, int16_t maxSize)
{
  uint8_t retVal = MCP_CMD_OK;
  const char_t *tempsrcString = srcString;
  char_t *tempdestString = destString;
  *size= 1U ; /* /0 is the min String size */
 80034d2:	2101      	movs	r1, #1
 80034d4:	8019      	strh	r1, [r3, #0]

  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034d6:	f992 0000 	ldrsb.w	r0, [r2]
 80034da:	b358      	cbz	r0, 8003534 <RI_SetRegisterGlobal+0xdc>
 80034dc:	fa1f fc8c 	uxth.w	ip, ip
 80034e0:	1850      	adds	r0, r2, r1
 80034e2:	e004      	b.n	80034ee <RI_SetRegisterGlobal+0x96>
  {
    *tempdestString = *tempsrcString;
    tempdestString++;
    tempsrcString++;
    *size = *size + 1U;
 80034e4:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034e6:	f992 4000 	ldrsb.w	r4, [r2]
 80034ea:	3001      	adds	r0, #1
 80034ec:	b314      	cbz	r4, 8003534 <RI_SetRegisterGlobal+0xdc>
    *size = *size + 1U;
 80034ee:	f101 0e01 	add.w	lr, r1, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034f2:	4561      	cmp	r1, ip
    tempdestString++;
 80034f4:	4602      	mov	r2, r0
    *size = *size + 1U;
 80034f6:	fa1f f18e 	uxth.w	r1, lr
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034fa:	d3f3      	bcc.n	80034e4 <RI_SetRegisterGlobal+0x8c>
      retVal = MCP_ERROR_RO_REG;
 80034fc:	2004      	movs	r0, #4
}
 80034fe:	bd10      	pop	{r4, pc}
      *size = rawSize + 2U;
 8003500:	8812      	ldrh	r2, [r2, #0]
 8003502:	3202      	adds	r2, #2
 8003504:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 8003506:	fa1f fc8c 	uxth.w	ip, ip
 800350a:	4562      	cmp	r2, ip
      *size = rawSize + 2U;
 800350c:	801a      	strh	r2, [r3, #0]
      if (*size > (uint16_t)dataAvailable)
 800350e:	d81c      	bhi.n	800354a <RI_SetRegisterGlobal+0xf2>
        switch (regID)
 8003510:	28a8      	cmp	r0, #168	; 0xa8
 8003512:	d0f3      	beq.n	80034fc <RI_SetRegisterGlobal+0xa4>
 8003514:	d812      	bhi.n	800353c <RI_SetRegisterGlobal+0xe4>
 8003516:	f020 0040 	bic.w	r0, r0, #64	; 0x40
            retVal = MCP_ERROR_RO_REG;
 800351a:	2828      	cmp	r0, #40	; 0x28
 800351c:	bf14      	ite	ne
 800351e:	2005      	movne	r0, #5
 8003520:	2004      	moveq	r0, #4
}
 8003522:	bd10      	pop	{r4, pc}
 8003524:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 8003528:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 800352c:	bf14      	ite	ne
 800352e:	2005      	movne	r0, #5
 8003530:	2004      	moveq	r0, #4
 8003532:	e7c3      	b.n	80034bc <RI_SetRegisterGlobal+0x64>
  { /* Last string char must be 0 */
    retVal = MCP_ERROR_STRING_FORMAT;
  }
  else
  {
    *tempdestString = (int8_t)0;
 8003534:	2300      	movs	r3, #0
 8003536:	7013      	strb	r3, [r2, #0]
      retVal = MCP_ERROR_RO_REG;
 8003538:	2004      	movs	r0, #4
  return (retVal);
 800353a:	e7e0      	b.n	80034fe <RI_SetRegisterGlobal+0xa6>
            retVal = MCP_ERROR_RO_REG;
 800353c:	28e8      	cmp	r0, #232	; 0xe8
 800353e:	bf14      	ite	ne
 8003540:	2005      	movne	r0, #5
 8003542:	2004      	moveq	r0, #4
}
 8003544:	bd10      	pop	{r4, pc}
  uint8_t retVal = MCP_CMD_OK;
 8003546:	2000      	movs	r0, #0
 8003548:	e7b8      	b.n	80034bc <RI_SetRegisterGlobal+0x64>
        *size = 0;
 800354a:	2200      	movs	r2, #0
 800354c:	801a      	strh	r2, [r3, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 800354e:	200a      	movs	r0, #10
}
 8003550:	bd10      	pop	{r4, pc}
 8003552:	bf00      	nop

08003554 <RI_SetRegisterMotor1>:
{
 8003554:	b530      	push	{r4, r5, lr}
 8003556:	b083      	sub	sp, #12
  switch(typeID)
 8003558:	3908      	subs	r1, #8
{
 800355a:	f9bd e018 	ldrsh.w	lr, [sp, #24]
 800355e:	4694      	mov	ip, r2
 8003560:	461c      	mov	r4, r3
  switch(typeID)
 8003562:	2920      	cmp	r1, #32
 8003564:	d812      	bhi.n	800358c <RI_SetRegisterMotor1+0x38>
 8003566:	e8df f001 	tbb	[pc, r1]
 800356a:	1116      	.short	0x1116
 800356c:	11111111 	.word	0x11111111
 8003570:	11251111 	.word	0x11251111
 8003574:	11111111 	.word	0x11111111
 8003578:	117b1111 	.word	0x117b1111
 800357c:	11111111 	.word	0x11111111
 8003580:	11491111 	.word	0x11491111
 8003584:	11111111 	.word	0x11111111
 8003588:	1111      	.short	0x1111
 800358a:	64          	.byte	0x64
 800358b:	00          	.byte	0x00
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 800358c:	2300      	movs	r3, #0
 800358e:	8023      	strh	r3, [r4, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 8003590:	2007      	movs	r0, #7
}
 8003592:	b003      	add	sp, #12
 8003594:	bd30      	pop	{r4, r5, pc}
      switch (regID)
 8003596:	2848      	cmp	r0, #72	; 0x48
 8003598:	f000 81d1 	beq.w	800393e <RI_SetRegisterMotor1+0x3ea>
 800359c:	2888      	cmp	r0, #136	; 0x88
 800359e:	f040 81c3 	bne.w	8003928 <RI_SetRegisterMotor1+0x3d4>
          uint8_t regdata8 = *data;
 80035a2:	7813      	ldrb	r3, [r2, #0]
          if ((uint8_t)MCM_TORQUE_MODE == regdata8)
 80035a4:	2b04      	cmp	r3, #4
 80035a6:	f000 81e9 	beq.w	800397c <RI_SetRegisterMotor1+0x428>
          if ((uint8_t)MCM_SPEED_MODE == regdata8)
 80035aa:	2b03      	cmp	r3, #3
 80035ac:	f000 8210 	beq.w	80039d0 <RI_SetRegisterMotor1+0x47c>
  uint8_t retVal = MCP_CMD_OK;
 80035b0:	2000      	movs	r0, #0
 80035b2:	e1ba      	b.n	800392a <RI_SetRegisterMotor1+0x3d6>
      uint16_t regdata16 = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 80035b4:	f5b0 6f15 	cmp.w	r0, #2384	; 0x950
 80035b8:	8815      	ldrh	r5, [r2, #0]
      switch (regID)
 80035ba:	f000 8245 	beq.w	8003a48 <RI_SetRegisterMotor1+0x4f4>
 80035be:	d871      	bhi.n	80036a4 <RI_SetRegisterMotor1+0x150>
 80035c0:	f5b0 7f34 	cmp.w	r0, #720	; 0x2d0
 80035c4:	f000 823a 	beq.w	8003a3c <RI_SetRegisterMotor1+0x4e8>
 80035c8:	d959      	bls.n	800367e <RI_SetRegisterMotor1+0x12a>
 80035ca:	f5b0 6f8a 	cmp.w	r0, #1104	; 0x450
 80035ce:	f000 8229 	beq.w	8003a24 <RI_SetRegisterMotor1+0x4d0>
 80035d2:	f240 8100 	bls.w	80037d6 <RI_SetRegisterMotor1+0x282>
 80035d6:	f5b0 6fba 	cmp.w	r0, #1488	; 0x5d0
 80035da:	d00a      	beq.n	80035f2 <RI_SetRegisterMotor1+0x9e>
 80035dc:	f240 811c 	bls.w	8003818 <RI_SetRegisterMotor1+0x2c4>
 80035e0:	f5b0 6f05 	cmp.w	r0, #2128	; 0x850
 80035e4:	d005      	beq.n	80035f2 <RI_SetRegisterMotor1+0x9e>
 80035e6:	f240 810b 	bls.w	8003800 <RI_SetRegisterMotor1+0x2ac>
 80035ea:	f5b0 6f11 	cmp.w	r0, #2320	; 0x910
 80035ee:	f040 8122 	bne.w	8003836 <RI_SetRegisterMotor1+0x2e2>
 80035f2:	2004      	movs	r0, #4
      *size = 2;
 80035f4:	2302      	movs	r3, #2
 80035f6:	8023      	strh	r3, [r4, #0]
}
 80035f8:	b003      	add	sp, #12
 80035fa:	bd30      	pop	{r4, r5, pc}
  *size= 1U ; /* /0 is the min String size */
 80035fc:	2201      	movs	r2, #1
 80035fe:	8022      	strh	r2, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003600:	f99c 3000 	ldrsb.w	r3, [ip]
 8003604:	2b00      	cmp	r3, #0
 8003606:	f000 816a 	beq.w	80038de <RI_SetRegisterMotor1+0x38a>
 800360a:	fa1f f18e 	uxth.w	r1, lr
 800360e:	eb0c 0302 	add.w	r3, ip, r2
 8003612:	e006      	b.n	8003622 <RI_SetRegisterMotor1+0xce>
    *size = *size + 1U;
 8003614:	8022      	strh	r2, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003616:	f99c 0000 	ldrsb.w	r0, [ip]
 800361a:	3301      	adds	r3, #1
 800361c:	2800      	cmp	r0, #0
 800361e:	f000 815e 	beq.w	80038de <RI_SetRegisterMotor1+0x38a>
    *size = *size + 1U;
 8003622:	1c50      	adds	r0, r2, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003624:	4291      	cmp	r1, r2
    tempdestString++;
 8003626:	469c      	mov	ip, r3
    *size = *size + 1U;
 8003628:	b282      	uxth	r2, r0
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800362a:	d8f3      	bhi.n	8003614 <RI_SetRegisterMotor1+0xc0>
      retVal = MCP_ERROR_RO_REG;
 800362c:	2004      	movs	r0, #4
}
 800362e:	b003      	add	sp, #12
 8003630:	bd30      	pop	{r4, r5, pc}
      *size = rawSize + 2U;
 8003632:	8813      	ldrh	r3, [r2, #0]
 8003634:	3302      	adds	r3, #2
 8003636:	b29b      	uxth	r3, r3
      if (*size > (uint16_t)dataAvailable)
 8003638:	fa1f f18e 	uxth.w	r1, lr
 800363c:	428b      	cmp	r3, r1
      *size = rawSize + 2U;
 800363e:	8023      	strh	r3, [r4, #0]
      if (*size > (uint16_t)dataAvailable)
 8003640:	f200 8179 	bhi.w	8003936 <RI_SetRegisterMotor1+0x3e2>
        switch (regID)
 8003644:	f5b0 7ff4 	cmp.w	r0, #488	; 0x1e8
 8003648:	f000 81ba 	beq.w	80039c0 <RI_SetRegisterMotor1+0x46c>
 800364c:	f200 8156 	bhi.w	80038fc <RI_SetRegisterMotor1+0x3a8>
 8003650:	f5b0 7fd4 	cmp.w	r0, #424	; 0x1a8
 8003654:	f000 81a6 	beq.w	80039a4 <RI_SetRegisterMotor1+0x450>
 8003658:	f240 8146 	bls.w	80038e8 <RI_SetRegisterMotor1+0x394>
 800365c:	2005      	movs	r0, #5
 800365e:	e798      	b.n	8003592 <RI_SetRegisterMotor1+0x3e>
      switch (regID)
 8003660:	2898      	cmp	r0, #152	; 0x98
 8003662:	f000 817d 	beq.w	8003960 <RI_SetRegisterMotor1+0x40c>
 8003666:	f200 8129 	bhi.w	80038bc <RI_SetRegisterMotor1+0x368>
 800366a:	f020 0040 	bic.w	r0, r0, #64	; 0x40
          retVal = MCP_ERROR_RO_REG;
 800366e:	2818      	cmp	r0, #24
 8003670:	bf14      	ite	ne
 8003672:	2005      	movne	r0, #5
 8003674:	2004      	moveq	r0, #4
      *size = 4;
 8003676:	2304      	movs	r3, #4
 8003678:	8023      	strh	r3, [r4, #0]
}
 800367a:	b003      	add	sp, #12
 800367c:	bd30      	pop	{r4, r5, pc}
 800367e:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 8003682:	f000 81f3 	beq.w	8003a6c <RI_SetRegisterMotor1+0x518>
 8003686:	f240 809a 	bls.w	80037be <RI_SetRegisterMotor1+0x26a>
 800368a:	f5b0 7f04 	cmp.w	r0, #528	; 0x210
 800368e:	f000 81bd 	beq.w	8003a0c <RI_SetRegisterMotor1+0x4b8>
 8003692:	f5b0 7f24 	cmp.w	r0, #656	; 0x290
 8003696:	d121      	bne.n	80036dc <RI_SetRegisterMotor1+0x188>
          PID_SetKP(&PIDIdHandle_M1, (int16_t)regdata16);
 8003698:	48aa      	ldr	r0, [pc, #680]	; (8003944 <RI_SetRegisterMotor1+0x3f0>)
 800369a:	b229      	sxth	r1, r5
 800369c:	f005 fd90 	bl	80091c0 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 80036a0:	2000      	movs	r0, #0
          break;
 80036a2:	e7a7      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80036a4:	f241 5310 	movw	r3, #5392	; 0x1510
 80036a8:	4298      	cmp	r0, r3
 80036aa:	f000 81eb 	beq.w	8003a84 <RI_SetRegisterMotor1+0x530>
 80036ae:	d940      	bls.n	8003732 <RI_SetRegisterMotor1+0x1de>
 80036b0:	f241 6310 	movw	r3, #5648	; 0x1610
 80036b4:	4298      	cmp	r0, r3
 80036b6:	f000 81df 	beq.w	8003a78 <RI_SetRegisterMotor1+0x524>
 80036ba:	d92b      	bls.n	8003714 <RI_SetRegisterMotor1+0x1c0>
 80036bc:	f641 03d0 	movw	r3, #6352	; 0x18d0
 80036c0:	4298      	cmp	r0, r3
 80036c2:	f000 81cd 	beq.w	8003a60 <RI_SetRegisterMotor1+0x50c>
 80036c6:	d91a      	bls.n	80036fe <RI_SetRegisterMotor1+0x1aa>
 80036c8:	f641 1310 	movw	r3, #6416	; 0x1910
 80036cc:	4298      	cmp	r0, r3
 80036ce:	d10f      	bne.n	80036f0 <RI_SetRegisterMotor1+0x19c>
          PID_SetKPDivisorPOW2 (&(&STO_PLL_M1)->PIRegulator,regdata16);
 80036d0:	489d      	ldr	r0, [pc, #628]	; (8003948 <RI_SetRegisterMotor1+0x3f4>)
 80036d2:	4629      	mov	r1, r5
 80036d4:	f005 fd84 	bl	80091e0 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80036d8:	2000      	movs	r0, #0
          break;
 80036da:	e78b      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80036dc:	f5b0 7fe8 	cmp.w	r0, #464	; 0x1d0
 80036e0:	f040 80de 	bne.w	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKI(&PIDIqHandle_M1, (int16_t)regdata16);
 80036e4:	4899      	ldr	r0, [pc, #612]	; (800394c <RI_SetRegisterMotor1+0x3f8>)
 80036e6:	b229      	sxth	r1, r5
 80036e8:	f005 fd6c 	bl	80091c4 <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 80036ec:	2000      	movs	r0, #0
          break;
 80036ee:	e781      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80036f0:	f641 3358 	movw	r3, #7000	; 0x1b58
 80036f4:	4298      	cmp	r0, r3
 80036f6:	bf14      	ite	ne
 80036f8:	2005      	movne	r0, #5
 80036fa:	2004      	moveq	r0, #4
 80036fc:	e77a      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80036fe:	f241 6350 	movw	r3, #5712	; 0x1650
 8003702:	4298      	cmp	r0, r3
 8003704:	f040 80cc 	bne.w	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKDDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8003708:	4890      	ldr	r0, [pc, #576]	; (800394c <RI_SetRegisterMotor1+0x3f8>)
 800370a:	4629      	mov	r1, r5
 800370c:	f005 fd90 	bl	8009230 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003710:	2000      	movs	r0, #0
          break;
 8003712:	e76f      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003714:	f241 5390 	movw	r3, #5520	; 0x1590
 8003718:	4298      	cmp	r0, r3
 800371a:	f000 8163 	beq.w	80039e4 <RI_SetRegisterMotor1+0x490>
 800371e:	f241 53d0 	movw	r3, #5584	; 0x15d0
 8003722:	4298      	cmp	r0, r3
 8003724:	d11b      	bne.n	800375e <RI_SetRegisterMotor1+0x20a>
          PID_SetKPDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8003726:	4889      	ldr	r0, [pc, #548]	; (800394c <RI_SetRegisterMotor1+0x3f8>)
 8003728:	4629      	mov	r1, r5
 800372a:	f005 fd59 	bl	80091e0 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 800372e:	2000      	movs	r0, #0
          break;
 8003730:	e760      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003732:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 8003736:	f000 80fc 	beq.w	8003932 <RI_SetRegisterMotor1+0x3de>
 800373a:	d92a      	bls.n	8003792 <RI_SetRegisterMotor1+0x23e>
 800373c:	f241 4390 	movw	r3, #5264	; 0x1490
 8003740:	4298      	cmp	r0, r3
 8003742:	f000 8175 	beq.w	8003a30 <RI_SetRegisterMotor1+0x4dc>
 8003746:	d915      	bls.n	8003774 <RI_SetRegisterMotor1+0x220>
 8003748:	f241 43d0 	movw	r3, #5328	; 0x14d0
 800374c:	4298      	cmp	r0, r3
 800374e:	f040 80a7 	bne.w	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKDDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8003752:	487f      	ldr	r0, [pc, #508]	; (8003950 <RI_SetRegisterMotor1+0x3fc>)
 8003754:	4629      	mov	r1, r5
 8003756:	f005 fd6b 	bl	8009230 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 800375a:	2000      	movs	r0, #0
          break;
 800375c:	e74a      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 800375e:	f241 5350 	movw	r3, #5456	; 0x1550
 8003762:	4298      	cmp	r0, r3
 8003764:	f040 809c 	bne.w	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKIDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8003768:	4876      	ldr	r0, [pc, #472]	; (8003944 <RI_SetRegisterMotor1+0x3f0>)
 800376a:	4629      	mov	r1, r5
 800376c:	f005 fd44 	bl	80091f8 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003770:	2000      	movs	r0, #0
          break;
 8003772:	e73f      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003774:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003778:	f000 80db 	beq.w	8003932 <RI_SetRegisterMotor1+0x3de>
 800377c:	f241 4350 	movw	r3, #5200	; 0x1450
 8003780:	4298      	cmp	r0, r3
 8003782:	f040 808d 	bne.w	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKPDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8003786:	4872      	ldr	r0, [pc, #456]	; (8003950 <RI_SetRegisterMotor1+0x3fc>)
 8003788:	4629      	mov	r1, r5
 800378a:	f005 fd29 	bl	80091e0 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 800378e:	2000      	movs	r0, #0
          break;
 8003790:	e730      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003792:	f5b0 6f29 	cmp.w	r0, #2704	; 0xa90
 8003796:	f43f af2c 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 800379a:	d967      	bls.n	800386c <RI_SetRegisterMotor1+0x318>
 800379c:	f5b0 6f3d 	cmp.w	r0, #3024	; 0xbd0
 80037a0:	f43f af27 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 80037a4:	d957      	bls.n	8003856 <RI_SetRegisterMotor1+0x302>
 80037a6:	f5b0 6f49 	cmp.w	r0, #3216	; 0xc90
 80037aa:	f43f af22 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 80037ae:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80037b2:	f5b0 6f41 	cmp.w	r0, #3088	; 0xc10
 80037b6:	bf14      	ite	ne
 80037b8:	2005      	movne	r0, #5
 80037ba:	2004      	moveq	r0, #4
 80037bc:	e71a      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80037be:	28d0      	cmp	r0, #208	; 0xd0
 80037c0:	f000 812a 	beq.w	8003a18 <RI_SetRegisterMotor1+0x4c4>
 80037c4:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
 80037c8:	d13d      	bne.n	8003846 <RI_SetRegisterMotor1+0x2f2>
          PID_SetKD(&PIDSpeedHandle_M1, (int16_t)regdata16);
 80037ca:	4861      	ldr	r0, [pc, #388]	; (8003950 <RI_SetRegisterMotor1+0x3fc>)
 80037cc:	b229      	sxth	r1, r5
 80037ce:	f005 fd27 	bl	8009220 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 80037d2:	2000      	movs	r0, #0
          break;
 80037d4:	e70e      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80037d6:	f5b0 7f54 	cmp.w	r0, #848	; 0x350
 80037da:	f000 8109 	beq.w	80039f0 <RI_SetRegisterMotor1+0x49c>
 80037de:	f5b0 7f64 	cmp.w	r0, #912	; 0x390
 80037e2:	d173      	bne.n	80038cc <RI_SetRegisterMotor1+0x378>
          STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 80037e4:	485b      	ldr	r0, [pc, #364]	; (8003954 <RI_SetRegisterMotor1+0x400>)
 80037e6:	aa01      	add	r2, sp, #4
 80037e8:	f10d 0102 	add.w	r1, sp, #2
 80037ec:	f007 f8f0 	bl	800a9d0 <STO_PLL_GetObserverGains>
          STO_PLL_SetObserverGains(&STO_PLL_M1, hC1, (int16_t)regdata16);
 80037f0:	4858      	ldr	r0, [pc, #352]	; (8003954 <RI_SetRegisterMotor1+0x400>)
 80037f2:	f9bd 1002 	ldrsh.w	r1, [sp, #2]
 80037f6:	b22a      	sxth	r2, r5
 80037f8:	f007 f8f2 	bl	800a9e0 <STO_PLL_SetObserverGains>
  uint8_t retVal = MCP_CMD_OK;
 80037fc:	2000      	movs	r0, #0
 80037fe:	e6f9      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003800:	f5b0 6f01 	cmp.w	r0, #2064	; 0x810
 8003804:	f43f aef5 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 8003808:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800380c:	f5b0 6ff2 	cmp.w	r0, #1936	; 0x790
 8003810:	bf14      	ite	ne
 8003812:	2005      	movne	r0, #5
 8003814:	2004      	moveq	r0, #4
 8003816:	e6ed      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003818:	f5b0 6f92 	cmp.w	r0, #1168	; 0x490
 800381c:	d105      	bne.n	800382a <RI_SetRegisterMotor1+0x2d6>
          PID_SetKP (&(&STO_PLL_M1)->PIRegulator, (int16_t)regdata16);
 800381e:	484a      	ldr	r0, [pc, #296]	; (8003948 <RI_SetRegisterMotor1+0x3f4>)
 8003820:	b229      	sxth	r1, r5
 8003822:	f005 fccd 	bl	80091c0 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8003826:	2000      	movs	r0, #0
          break;
 8003828:	e6e4      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 800382a:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 800382e:	bf14      	ite	ne
 8003830:	2005      	movne	r0, #5
 8003832:	2004      	moveq	r0, #4
 8003834:	e6de      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003836:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800383a:	f5b0 6f09 	cmp.w	r0, #2192	; 0x890
 800383e:	bf14      	ite	ne
 8003840:	2005      	movne	r0, #5
 8003842:	2004      	moveq	r0, #4
 8003844:	e6d6      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003846:	2890      	cmp	r0, #144	; 0x90
 8003848:	d12a      	bne.n	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKP(&PIDSpeedHandle_M1, (int16_t)regdata16);
 800384a:	4841      	ldr	r0, [pc, #260]	; (8003950 <RI_SetRegisterMotor1+0x3fc>)
 800384c:	b229      	sxth	r1, r5
 800384e:	f005 fcb7 	bl	80091c0 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8003852:	2000      	movs	r0, #0
          break;
 8003854:	e6ce      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003856:	f5b0 6f35 	cmp.w	r0, #2896	; 0xb50
 800385a:	f43f aeca 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 800385e:	d914      	bls.n	800388a <RI_SetRegisterMotor1+0x336>
 8003860:	f5b0 6f39 	cmp.w	r0, #2960	; 0xb90
 8003864:	bf14      	ite	ne
 8003866:	2005      	movne	r0, #5
 8003868:	2004      	moveq	r0, #4
 800386a:	e6c3      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 800386c:	f5b0 6f19 	cmp.w	r0, #2448	; 0x990
 8003870:	d115      	bne.n	800389e <RI_SetRegisterMotor1+0x34a>
          currComp = MCI_GetIqdref(pMCIN);
 8003872:	4839      	ldr	r0, [pc, #228]	; (8003958 <RI_SetRegisterMotor1+0x404>)
 8003874:	f7fe fb54 	bl	8001f20 <MCI_GetIqdref>
 8003878:	9001      	str	r0, [sp, #4]
          currComp.d = (int16_t)regdata16;
 800387a:	f8ad 5006 	strh.w	r5, [sp, #6]
          MCI_SetCurrentReferences(pMCIN,currComp);
 800387e:	4836      	ldr	r0, [pc, #216]	; (8003958 <RI_SetRegisterMotor1+0x404>)
 8003880:	9901      	ldr	r1, [sp, #4]
 8003882:	f7fe fa35 	bl	8001cf0 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 8003886:	2000      	movs	r0, #0
 8003888:	e6b4      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 800388a:	f5b0 6f2d 	cmp.w	r0, #2768	; 0xad0
 800388e:	f43f aeb0 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 8003892:	f5b0 6f31 	cmp.w	r0, #2832	; 0xb10
 8003896:	bf14      	ite	ne
 8003898:	2005      	movne	r0, #5
 800389a:	2004      	moveq	r0, #4
 800389c:	e6aa      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 800389e:	d201      	bcs.n	80038a4 <RI_SetRegisterMotor1+0x350>
          retVal = MCP_ERROR_UNKNOWN_REG;
 80038a0:	2005      	movs	r0, #5
 80038a2:	e6a7      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80038a4:	f020 0340 	bic.w	r3, r0, #64	; 0x40
 80038a8:	f5b3 6f21 	cmp.w	r3, #2576	; 0xa10
 80038ac:	f43f aea1 	beq.w	80035f2 <RI_SetRegisterMotor1+0x9e>
 80038b0:	f5b0 6f1d 	cmp.w	r0, #2512	; 0x9d0
 80038b4:	bf14      	ite	ne
 80038b6:	2005      	movne	r0, #5
 80038b8:	2004      	moveq	r0, #4
 80038ba:	e69b      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 80038bc:	28d8      	cmp	r0, #216	; 0xd8
 80038be:	d067      	beq.n	8003990 <RI_SetRegisterMotor1+0x43c>
          retVal = MCP_ERROR_RO_REG;
 80038c0:	f5b0 7f8c 	cmp.w	r0, #280	; 0x118
 80038c4:	bf14      	ite	ne
 80038c6:	2005      	movne	r0, #5
 80038c8:	2004      	moveq	r0, #4
 80038ca:	e6d4      	b.n	8003676 <RI_SetRegisterMotor1+0x122>
 80038cc:	f5b0 7f44 	cmp.w	r0, #784	; 0x310
 80038d0:	d1e6      	bne.n	80038a0 <RI_SetRegisterMotor1+0x34c>
          PID_SetKD(&PIDIdHandle_M1, (int16_t)regdata16);
 80038d2:	481c      	ldr	r0, [pc, #112]	; (8003944 <RI_SetRegisterMotor1+0x3f0>)
 80038d4:	b229      	sxth	r1, r5
 80038d6:	f005 fca3 	bl	8009220 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 80038da:	2000      	movs	r0, #0
          break;
 80038dc:	e68a      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
    *tempdestString = (int8_t)0;
 80038de:	2300      	movs	r3, #0
 80038e0:	f88c 3000 	strb.w	r3, [ip]
      retVal = MCP_ERROR_RO_REG;
 80038e4:	2004      	movs	r0, #4
  return (retVal);
 80038e6:	e6a2      	b.n	800362e <RI_SetRegisterMotor1+0xda>
 80038e8:	28a8      	cmp	r0, #168	; 0xa8
 80038ea:	f43f ae9f 	beq.w	800362c <RI_SetRegisterMotor1+0xd8>
 80038ee:	d913      	bls.n	8003918 <RI_SetRegisterMotor1+0x3c4>
            retVal = MCP_ERROR_RO_REG;
 80038f0:	28e8      	cmp	r0, #232	; 0xe8
 80038f2:	bf14      	ite	ne
 80038f4:	2005      	movne	r0, #5
 80038f6:	2004      	moveq	r0, #4
}
 80038f8:	b003      	add	sp, #12
 80038fa:	bd30      	pop	{r4, r5, pc}
 80038fc:	f5b0 7f5a 	cmp.w	r0, #872	; 0x368
 8003900:	d048      	beq.n	8003994 <RI_SetRegisterMotor1+0x440>
 8003902:	f5b0 6fa5 	cmp.w	r0, #1320	; 0x528
 8003906:	f47f aea9 	bne.w	800365c <RI_SetRegisterMotor1+0x108>
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 800390a:	4814      	ldr	r0, [pc, #80]	; (800395c <RI_SetRegisterMotor1+0x408>)
 800390c:	1c91      	adds	r1, r2, #2
}
 800390e:	b003      	add	sp, #12
 8003910:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 8003914:	f005 bbb4 	b.w	8009080 <MCPA_cfgLog>
 8003918:	f020 0040 	bic.w	r0, r0, #64	; 0x40
            retVal = MCP_ERROR_RO_REG;
 800391c:	2828      	cmp	r0, #40	; 0x28
 800391e:	bf14      	ite	ne
 8003920:	2005      	movne	r0, #5
 8003922:	2004      	moveq	r0, #4
}
 8003924:	b003      	add	sp, #12
 8003926:	bd30      	pop	{r4, r5, pc}
 8003928:	2005      	movs	r0, #5
      *size = 1;
 800392a:	2301      	movs	r3, #1
 800392c:	8023      	strh	r3, [r4, #0]
}
 800392e:	b003      	add	sp, #12
 8003930:	bd30      	pop	{r4, r5, pc}
  uint8_t retVal = MCP_CMD_OK;
 8003932:	2000      	movs	r0, #0
 8003934:	e65e      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
        *size = 0;
 8003936:	2300      	movs	r3, #0
 8003938:	8023      	strh	r3, [r4, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 800393a:	200a      	movs	r0, #10
 800393c:	e629      	b.n	8003592 <RI_SetRegisterMotor1+0x3e>
            retVal = MCP_ERROR_RO_REG;
 800393e:	2004      	movs	r0, #4
 8003940:	e7f3      	b.n	800392a <RI_SetRegisterMotor1+0x3d6>
 8003942:	bf00      	nop
 8003944:	200000c0 	.word	0x200000c0
 8003948:	20000244 	.word	0x20000244
 800394c:	200000ec 	.word	0x200000ec
 8003950:	20000118 	.word	0x20000118
 8003954:	20000210 	.word	0x20000210
 8003958:	20001a90 	.word	0x20001a90
 800395c:	20000400 	.word	0x20000400
          MCI_ExecSpeedRamp(pMCIN,((((int16_t)regdata32) * ((int16_t)SPEED_UNIT)) / (int16_t)U_RPM), 0);
 8003960:	f9b2 3000 	ldrsh.w	r3, [r2]
 8003964:	494a      	ldr	r1, [pc, #296]	; (8003a90 <RI_SetRegisterMotor1+0x53c>)
 8003966:	484b      	ldr	r0, [pc, #300]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 8003968:	fb81 2103 	smull	r2, r1, r1, r3
 800396c:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8003970:	2200      	movs	r2, #0
 8003972:	b209      	sxth	r1, r1
 8003974:	f7fe f998 	bl	8001ca8 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003978:	2000      	movs	r0, #0
          break;
 800397a:	e67c      	b.n	8003676 <RI_SetRegisterMotor1+0x122>
            MCI_ExecTorqueRamp(pMCIN, MCI_GetTeref(pMCIN), 0);
 800397c:	4845      	ldr	r0, [pc, #276]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 800397e:	f7fe faf9 	bl	8001f74 <MCI_GetTeref>
 8003982:	2200      	movs	r2, #0
 8003984:	4601      	mov	r1, r0
 8003986:	4843      	ldr	r0, [pc, #268]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 8003988:	f7fe f998 	bl	8001cbc <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 800398c:	2000      	movs	r0, #0
 800398e:	e7cc      	b.n	800392a <RI_SetRegisterMotor1+0x3d6>
          retVal = MCP_ERROR_RO_REG;
 8003990:	2004      	movs	r0, #4
 8003992:	e670      	b.n	8003676 <RI_SetRegisterMotor1+0x122>
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8003994:	f8d2 1002 	ldr.w	r1, [r2, #2]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8003998:	483e      	ldr	r0, [pc, #248]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 800399a:	9101      	str	r1, [sp, #4]
            MCI_SetCurrentReferences(pMCIN, currComp);
 800399c:	f7fe f9a8 	bl	8001cf0 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 80039a0:	2000      	movs	r0, #0
 80039a2:	e5f6      	b.n	8003592 <RI_SetRegisterMotor1+0x3e>
            MCI_ExecSpeedRamp(pMCIN, (int16_t)((rpm * SPEED_UNIT) / U_RPM), duration);
 80039a4:	f8d2 1002 	ldr.w	r1, [r2, #2]
 80039a8:	4b39      	ldr	r3, [pc, #228]	; (8003a90 <RI_SetRegisterMotor1+0x53c>)
 80039aa:	88d2      	ldrh	r2, [r2, #6]
 80039ac:	fb83 0301 	smull	r0, r3, r3, r1
 80039b0:	eba3 71e1 	sub.w	r1, r3, r1, asr #31
 80039b4:	4837      	ldr	r0, [pc, #220]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 80039b6:	b209      	sxth	r1, r1
 80039b8:	f7fe f976 	bl	8001ca8 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 80039bc:	2000      	movs	r0, #0
            break;
 80039be:	e5e8      	b.n	8003592 <RI_SetRegisterMotor1+0x3e>
            MCI_ExecTorqueRamp(pMCIN, (int16_t)torque, duration);
 80039c0:	4834      	ldr	r0, [pc, #208]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 80039c2:	88d2      	ldrh	r2, [r2, #6]
 80039c4:	f9bc 1002 	ldrsh.w	r1, [ip, #2]
 80039c8:	f7fe f978 	bl	8001cbc <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 80039cc:	2000      	movs	r0, #0
            break;
 80039ce:	e5e0      	b.n	8003592 <RI_SetRegisterMotor1+0x3e>
            MCI_ExecSpeedRamp(pMCIN, MCI_GetMecSpeedRefUnit(pMCIN), 0);
 80039d0:	4830      	ldr	r0, [pc, #192]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 80039d2:	f7fe fa77 	bl	8001ec4 <MCI_GetMecSpeedRefUnit>
 80039d6:	2200      	movs	r2, #0
 80039d8:	4601      	mov	r1, r0
 80039da:	482e      	ldr	r0, [pc, #184]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 80039dc:	f7fe f964 	bl	8001ca8 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 80039e0:	2000      	movs	r0, #0
 80039e2:	e7a2      	b.n	800392a <RI_SetRegisterMotor1+0x3d6>
          PID_SetKDDivisorPOW2(&PIDIdHandle_M1, regdata16);
 80039e4:	482c      	ldr	r0, [pc, #176]	; (8003a98 <RI_SetRegisterMotor1+0x544>)
 80039e6:	4629      	mov	r1, r5
 80039e8:	f005 fc22 	bl	8009230 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80039ec:	2000      	movs	r0, #0
          break;
 80039ee:	e601      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 80039f0:	482a      	ldr	r0, [pc, #168]	; (8003a9c <RI_SetRegisterMotor1+0x548>)
 80039f2:	aa01      	add	r2, sp, #4
 80039f4:	f10d 0102 	add.w	r1, sp, #2
 80039f8:	f006 ffea 	bl	800a9d0 <STO_PLL_GetObserverGains>
          STO_PLL_SetObserverGains(&STO_PLL_M1, (int16_t)regdata16, hC2);
 80039fc:	4827      	ldr	r0, [pc, #156]	; (8003a9c <RI_SetRegisterMotor1+0x548>)
 80039fe:	f9bd 2004 	ldrsh.w	r2, [sp, #4]
 8003a02:	b229      	sxth	r1, r5
 8003a04:	f006 ffec 	bl	800a9e0 <STO_PLL_SetObserverGains>
  uint8_t retVal = MCP_CMD_OK;
 8003a08:	2000      	movs	r0, #0
 8003a0a:	e5f3      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKD(&PIDIqHandle_M1, (int16_t)regdata16);
 8003a0c:	4824      	ldr	r0, [pc, #144]	; (8003aa0 <RI_SetRegisterMotor1+0x54c>)
 8003a0e:	b229      	sxth	r1, r5
 8003a10:	f005 fc06 	bl	8009220 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 8003a14:	2000      	movs	r0, #0
          break;
 8003a16:	e5ed      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKI(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8003a18:	4822      	ldr	r0, [pc, #136]	; (8003aa4 <RI_SetRegisterMotor1+0x550>)
 8003a1a:	b229      	sxth	r1, r5
 8003a1c:	f005 fbd2 	bl	80091c4 <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 8003a20:	2000      	movs	r0, #0
          break;
 8003a22:	e5e7      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKI (&(&STO_PLL_M1)->PIRegulator, (int16_t)regdata16);
 8003a24:	4820      	ldr	r0, [pc, #128]	; (8003aa8 <RI_SetRegisterMotor1+0x554>)
 8003a26:	b229      	sxth	r1, r5
 8003a28:	f005 fbcc 	bl	80091c4 <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 8003a2c:	2000      	movs	r0, #0
          break;
 8003a2e:	e5e1      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 8003a30:	481c      	ldr	r0, [pc, #112]	; (8003aa4 <RI_SetRegisterMotor1+0x550>)
 8003a32:	4629      	mov	r1, r5
 8003a34:	f005 fbe0 	bl	80091f8 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a38:	2000      	movs	r0, #0
          break;
 8003a3a:	e5db      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKI(&PIDIdHandle_M1, (int16_t)regdata16);
 8003a3c:	4816      	ldr	r0, [pc, #88]	; (8003a98 <RI_SetRegisterMotor1+0x544>)
 8003a3e:	b229      	sxth	r1, r5
 8003a40:	f005 fbc0 	bl	80091c4 <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 8003a44:	2000      	movs	r0, #0
          break;
 8003a46:	e5d5      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          currComp = MCI_GetIqdref(pMCIN);
 8003a48:	4812      	ldr	r0, [pc, #72]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 8003a4a:	f7fe fa69 	bl	8001f20 <MCI_GetIqdref>
 8003a4e:	9001      	str	r0, [sp, #4]
          currComp.q = (int16_t)regdata16;
 8003a50:	f8ad 5004 	strh.w	r5, [sp, #4]
          MCI_SetCurrentReferences(pMCIN,currComp);
 8003a54:	480f      	ldr	r0, [pc, #60]	; (8003a94 <RI_SetRegisterMotor1+0x540>)
 8003a56:	9901      	ldr	r1, [sp, #4]
 8003a58:	f7fe f94a 	bl	8001cf0 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 8003a5c:	2000      	movs	r0, #0
 8003a5e:	e5c9      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2 (&(&STO_PLL_M1)->PIRegulator,regdata16);
 8003a60:	4811      	ldr	r0, [pc, #68]	; (8003aa8 <RI_SetRegisterMotor1+0x554>)
 8003a62:	4629      	mov	r1, r5
 8003a64:	f005 fbc8 	bl	80091f8 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a68:	2000      	movs	r0, #0
          break;
 8003a6a:	e5c3      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKP(&PIDIqHandle_M1, (int16_t)regdata16);
 8003a6c:	480c      	ldr	r0, [pc, #48]	; (8003aa0 <RI_SetRegisterMotor1+0x54c>)
 8003a6e:	b229      	sxth	r1, r5
 8003a70:	f005 fba6 	bl	80091c0 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8003a74:	2000      	movs	r0, #0
          break;
 8003a76:	e5bd      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8003a78:	4809      	ldr	r0, [pc, #36]	; (8003aa0 <RI_SetRegisterMotor1+0x54c>)
 8003a7a:	4629      	mov	r1, r5
 8003a7c:	f005 fbbc 	bl	80091f8 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a80:	2000      	movs	r0, #0
          break;
 8003a82:	e5b7      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
          PID_SetKPDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8003a84:	4804      	ldr	r0, [pc, #16]	; (8003a98 <RI_SetRegisterMotor1+0x544>)
 8003a86:	4629      	mov	r1, r5
 8003a88:	f005 fbaa 	bl	80091e0 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a8c:	2000      	movs	r0, #0
          break;
 8003a8e:	e5b1      	b.n	80035f4 <RI_SetRegisterMotor1+0xa0>
 8003a90:	2aaaaaab 	.word	0x2aaaaaab
 8003a94:	20001a90 	.word	0x20001a90
 8003a98:	200000c0 	.word	0x200000c0
 8003a9c:	20000210 	.word	0x20000210
 8003aa0:	200000ec 	.word	0x200000ec
 8003aa4:	20000118 	.word	0x20000118
 8003aa8:	20000244 	.word	0x20000244

08003aac <RI_GetRegisterGlobal>:
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8003aac:	b510      	push	{r4, lr}
    switch (typeID)
 8003aae:	f1a1 0c08 	sub.w	ip, r1, #8
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8003ab2:	f9bd e008 	ldrsh.w	lr, [sp, #8]
    switch (typeID)
 8003ab6:	f1bc 0f20 	cmp.w	ip, #32
 8003aba:	d812      	bhi.n	8003ae2 <RI_GetRegisterGlobal+0x36>
 8003abc:	e8df f00c 	tbb	[pc, ip]
 8003ac0:	1111111b 	.word	0x1111111b
 8003ac4:	11111111 	.word	0x11111111
 8003ac8:	11111129 	.word	0x11111129
 8003acc:	11111111 	.word	0x11111111
 8003ad0:	11111122 	.word	0x11111122
 8003ad4:	11111111 	.word	0x11111111
 8003ad8:	11111137 	.word	0x11111137
 8003adc:	11111111 	.word	0x11111111
 8003ae0:	13          	.byte	0x13
 8003ae1:	00          	.byte	0x00
 8003ae2:	2007      	movs	r0, #7
}
 8003ae4:	bd10      	pop	{r4, pc}
        switch (regID)
 8003ae6:	2828      	cmp	r0, #40	; 0x28
 8003ae8:	d02d      	beq.n	8003b46 <RI_GetRegisterGlobal+0x9a>
        *size = (*rawSize) + 2U;
 8003aea:	8812      	ldrh	r2, [r2, #0]
 8003aec:	3202      	adds	r2, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003aee:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 8003af0:	b292      	uxth	r2, r2
 8003af2:	801a      	strh	r2, [r3, #0]
}
 8003af4:	bd10      	pop	{r4, pc}
        if (freeSpace > 0)
 8003af6:	f1be 0f00 	cmp.w	lr, #0
 8003afa:	dd22      	ble.n	8003b42 <RI_GetRegisterGlobal+0x96>
          *size = 1;
 8003afc:	2201      	movs	r2, #1
 8003afe:	801a      	strh	r2, [r3, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8003b00:	2005      	movs	r0, #5
}
 8003b02:	bd10      	pop	{r4, pc}
        if (freeSpace >= 4)
 8003b04:	f1be 0f03 	cmp.w	lr, #3
 8003b08:	dd19      	ble.n	8003b3e <RI_GetRegisterGlobal+0x92>
          *size = 4;
 8003b0a:	2204      	movs	r2, #4
 8003b0c:	801a      	strh	r2, [r3, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8003b0e:	2005      	movs	r0, #5
}
 8003b10:	bd10      	pop	{r4, pc}
        if (freeSpace >= 2)
 8003b12:	f1be 0f01 	cmp.w	lr, #1
 8003b16:	dd12      	ble.n	8003b3e <RI_GetRegisterGlobal+0x92>
          switch (regID)
 8003b18:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 8003b1c:	d05b      	beq.n	8003bd6 <RI_GetRegisterGlobal+0x12a>
    uint8_t retVal = MCP_CMD_OK;
 8003b1e:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003b22:	bf14      	ite	ne
 8003b24:	2005      	movne	r0, #5
 8003b26:	2000      	moveq	r0, #0
          *size = 2;
 8003b28:	2202      	movs	r2, #2
 8003b2a:	801a      	strh	r2, [r3, #0]
}
 8003b2c:	bd10      	pop	{r4, pc}
        switch (regID)
 8003b2e:	2820      	cmp	r0, #32
 8003b30:	d02d      	beq.n	8003b8e <RI_GetRegisterGlobal+0xe2>
 8003b32:	2860      	cmp	r0, #96	; 0x60
 8003b34:	d011      	beq.n	8003b5a <RI_GetRegisterGlobal+0xae>
            *size= 0 ; /* */
 8003b36:	2200      	movs	r2, #0
 8003b38:	801a      	strh	r2, [r3, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003b3a:	2005      	movs	r0, #5
}
 8003b3c:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003b3e:	2008      	movs	r0, #8
}
 8003b40:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003b42:	4608      	mov	r0, r1
}
 8003b44:	bd10      	pop	{r4, pc}
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003b46:	fa1f fe8e 	uxth.w	lr, lr
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8003b4a:	210a      	movs	r1, #10
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003b4c:	f1be 0f0b 	cmp.w	lr, #11
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8003b50:	8011      	strh	r1, [r2, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003b52:	d834      	bhi.n	8003bbe <RI_GetRegisterGlobal+0x112>
 8003b54:	220c      	movs	r2, #12
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003b56:	2008      	movs	r0, #8
 8003b58:	e7cb      	b.n	8003af2 <RI_GetRegisterGlobal+0x46>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b5a:	4c20      	ldr	r4, [pc, #128]	; (8003bdc <RI_GetRegisterGlobal+0x130>)
 8003b5c:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8003b60:	2101      	movs	r1, #1
 8003b62:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b64:	b180      	cbz	r0, 8003b88 <RI_GetRegisterGlobal+0xdc>
 8003b66:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8003b6a:	46a4      	mov	ip, r4
 8003b6c:	e008      	b.n	8003b80 <RI_GetRegisterGlobal+0xd4>
    *tempdestString = *tempsrcString;
 8003b6e:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8003b72:	8819      	ldrh	r1, [r3, #0]
 8003b74:	3101      	adds	r1, #1
 8003b76:	b289      	uxth	r1, r1
 8003b78:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b7a:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8003b7e:	b118      	cbz	r0, 8003b88 <RI_GetRegisterGlobal+0xdc>
 8003b80:	458e      	cmp	lr, r1
 8003b82:	d8f4      	bhi.n	8003b6e <RI_GetRegisterGlobal+0xc2>
    retVal = MCP_ERROR_STRING_FORMAT;
 8003b84:	2006      	movs	r0, #6
}
 8003b86:	bd10      	pop	{r4, pc}
    *tempdestString = (int8_t)0;
 8003b88:	2000      	movs	r0, #0
 8003b8a:	7010      	strb	r0, [r2, #0]
}
 8003b8c:	bd10      	pop	{r4, pc}
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b8e:	4c14      	ldr	r4, [pc, #80]	; (8003be0 <RI_GetRegisterGlobal+0x134>)
 8003b90:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8003b94:	2101      	movs	r1, #1
 8003b96:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b98:	2800      	cmp	r0, #0
 8003b9a:	d0f5      	beq.n	8003b88 <RI_GetRegisterGlobal+0xdc>
 8003b9c:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8003ba0:	46a4      	mov	ip, r4
 8003ba2:	e009      	b.n	8003bb8 <RI_GetRegisterGlobal+0x10c>
    *tempdestString = *tempsrcString;
 8003ba4:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8003ba8:	8819      	ldrh	r1, [r3, #0]
 8003baa:	3101      	adds	r1, #1
 8003bac:	b289      	uxth	r1, r1
 8003bae:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003bb0:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8003bb4:	2800      	cmp	r0, #0
 8003bb6:	d0e7      	beq.n	8003b88 <RI_GetRegisterGlobal+0xdc>
 8003bb8:	458e      	cmp	lr, r1
 8003bba:	d8f3      	bhi.n	8003ba4 <RI_GetRegisterGlobal+0xf8>
 8003bbc:	e7e2      	b.n	8003b84 <RI_GetRegisterGlobal+0xd8>
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8003bbe:	4909      	ldr	r1, [pc, #36]	; (8003be4 <RI_GetRegisterGlobal+0x138>)
 8003bc0:	6848      	ldr	r0, [r1, #4]
 8003bc2:	680c      	ldr	r4, [r1, #0]
 8003bc4:	8909      	ldrh	r1, [r1, #8]
 8003bc6:	f8c2 0006 	str.w	r0, [r2, #6]
 8003bca:	f8c2 4002 	str.w	r4, [r2, #2]
 8003bce:	8151      	strh	r1, [r2, #10]
    uint8_t retVal = MCP_CMD_OK;
 8003bd0:	2000      	movs	r0, #0
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8003bd2:	220c      	movs	r2, #12
 8003bd4:	e78d      	b.n	8003af2 <RI_GetRegisterGlobal+0x46>
    uint8_t retVal = MCP_CMD_OK;
 8003bd6:	2000      	movs	r0, #0
 8003bd8:	e7a6      	b.n	8003b28 <RI_GetRegisterGlobal+0x7c>
 8003bda:	bf00      	nop
 8003bdc:	0800f090 	.word	0x0800f090
 8003be0:	0800f0a0 	.word	0x0800f0a0
 8003be4:	0800f124 	.word	0x0800f124

08003be8 <RI_GetRegisterMotor1>:
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8003be8:	b530      	push	{r4, r5, lr}
 8003bea:	b095      	sub	sp, #84	; 0x54
 8003bec:	461d      	mov	r5, r3
    switch (typeID)
 8003bee:	f1a1 0308 	sub.w	r3, r1, #8
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8003bf2:	f9bd c060 	ldrsh.w	ip, [sp, #96]	; 0x60
 8003bf6:	4614      	mov	r4, r2
    switch (typeID)
 8003bf8:	2b20      	cmp	r3, #32
 8003bfa:	d812      	bhi.n	8003c22 <RI_GetRegisterMotor1+0x3a>
 8003bfc:	e8df f003 	tbb	[pc, r3]
 8003c00:	1111112d 	.word	0x1111112d
 8003c04:	11111111 	.word	0x11111111
 8003c08:	11111140 	.word	0x11111140
 8003c0c:	11111111 	.word	0x11111111
 8003c10:	11111167 	.word	0x11111167
 8003c14:	11111111 	.word	0x11111111
 8003c18:	11111182 	.word	0x11111182
 8003c1c:	11111111 	.word	0x11111111
 8003c20:	14          	.byte	0x14
 8003c21:	00          	.byte	0x00
 8003c22:	2007      	movs	r0, #7
  }
 8003c24:	b015      	add	sp, #84	; 0x54
 8003c26:	bd30      	pop	{r4, r5, pc}
        rawData++;
 8003c28:	f5b0 7f94 	cmp.w	r0, #296	; 0x128
 8003c2c:	f104 0302 	add.w	r3, r4, #2
        switch (regID)
 8003c30:	f000 82cb 	beq.w	80041ca <RI_GetRegisterMotor1+0x5e2>
 8003c34:	d87e      	bhi.n	8003d34 <RI_GetRegisterMotor1+0x14c>
 8003c36:	28a8      	cmp	r0, #168	; 0xa8
 8003c38:	f000 82bd 	beq.w	80041b6 <RI_GetRegisterMotor1+0x5ce>
 8003c3c:	28e8      	cmp	r0, #232	; 0xe8
 8003c3e:	d16b      	bne.n	8003d18 <RI_GetRegisterMotor1+0x130>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003c40:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 8003c44:	220e      	movs	r2, #14
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003c46:	f1bc 0f0f 	cmp.w	ip, #15
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 8003c4a:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003c4c:	f200 8280 	bhi.w	8004150 <RI_GetRegisterMotor1+0x568>
 8003c50:	2310      	movs	r3, #16
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003c52:	2008      	movs	r0, #8
        *size = (*rawSize) + 2U;
 8003c54:	802b      	strh	r3, [r5, #0]
  }
 8003c56:	b015      	add	sp, #84	; 0x54
 8003c58:	bd30      	pop	{r4, r5, pc}
        if (freeSpace > 0)
 8003c5a:	f1bc 0f00 	cmp.w	ip, #0
 8003c5e:	f340 82a0 	ble.w	80041a2 <RI_GetRegisterMotor1+0x5ba>
          switch (regID)
 8003c62:	2848      	cmp	r0, #72	; 0x48
 8003c64:	f000 829f 	beq.w	80041a6 <RI_GetRegisterMotor1+0x5be>
 8003c68:	2888      	cmp	r0, #136	; 0x88
 8003c6a:	f040 823b 	bne.w	80040e4 <RI_GetRegisterMotor1+0x4fc>
              *data = (uint8_t)MCI_GetControlMode(pMCIN);
 8003c6e:	48b2      	ldr	r0, [pc, #712]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003c70:	f7fe f8fe 	bl	8001e70 <MCI_GetControlMode>
 8003c74:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003c76:	2000      	movs	r0, #0
          *size = 1;
 8003c78:	2301      	movs	r3, #1
 8003c7a:	802b      	strh	r3, [r5, #0]
  }
 8003c7c:	b015      	add	sp, #84	; 0x54
 8003c7e:	bd30      	pop	{r4, r5, pc}
        if (freeSpace >= 2)
 8003c80:	f1bc 0f01 	cmp.w	ip, #1
 8003c84:	f340 822b 	ble.w	80040de <RI_GetRegisterMotor1+0x4f6>
          switch (regID)
 8003c88:	f5b0 6f1d 	cmp.w	r0, #2512	; 0x9d0
 8003c8c:	f000 8315 	beq.w	80042ba <RI_GetRegisterMotor1+0x6d2>
 8003c90:	f200 80a7 	bhi.w	8003de2 <RI_GetRegisterMotor1+0x1fa>
 8003c94:	f5b0 6f8a 	cmp.w	r0, #1104	; 0x450
 8003c98:	f000 8309 	beq.w	80042ae <RI_GetRegisterMotor1+0x6c6>
 8003c9c:	f240 817a 	bls.w	8003f94 <RI_GetRegisterMotor1+0x3ac>
 8003ca0:	f5b0 6f05 	cmp.w	r0, #2128	; 0x850
 8003ca4:	f000 82fd 	beq.w	80042a2 <RI_GetRegisterMotor1+0x6ba>
 8003ca8:	f240 808b 	bls.w	8003dc2 <RI_GetRegisterMotor1+0x1da>
 8003cac:	f5b0 6f11 	cmp.w	r0, #2320	; 0x910
 8003cb0:	f000 82ef 	beq.w	8004292 <RI_GetRegisterMotor1+0x6aa>
 8003cb4:	d979      	bls.n	8003daa <RI_GetRegisterMotor1+0x1c2>
 8003cb6:	f5b0 6f15 	cmp.w	r0, #2384	; 0x950
 8003cba:	d16a      	bne.n	8003d92 <RI_GetRegisterMotor1+0x1aa>
              *regdata16 = MCI_GetIqdref(pMCIN).q;
 8003cbc:	489e      	ldr	r0, [pc, #632]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003cbe:	f7fe f92f 	bl	8001f20 <MCI_GetIqdref>
 8003cc2:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003cc4:	2000      	movs	r0, #0
          *size = 2;
 8003cc6:	2302      	movs	r3, #2
 8003cc8:	802b      	strh	r3, [r5, #0]
  }
 8003cca:	b015      	add	sp, #84	; 0x54
 8003ccc:	bd30      	pop	{r4, r5, pc}
        if (freeSpace >= 4)
 8003cce:	f1bc 0f03 	cmp.w	ip, #3
 8003cd2:	f340 8204 	ble.w	80040de <RI_GetRegisterMotor1+0x4f6>
          switch (regID)
 8003cd6:	28d8      	cmp	r0, #216	; 0xd8
 8003cd8:	f000 82bf 	beq.w	800425a <RI_GetRegisterMotor1+0x672>
 8003cdc:	f200 81ed 	bhi.w	80040ba <RI_GetRegisterMotor1+0x4d2>
 8003ce0:	2858      	cmp	r0, #88	; 0x58
 8003ce2:	f000 82b1 	beq.w	8004248 <RI_GetRegisterMotor1+0x660>
 8003ce6:	2898      	cmp	r0, #152	; 0x98
 8003ce8:	f040 81de 	bne.w	80040a8 <RI_GetRegisterMotor1+0x4c0>
              *regdata32 = (((int32_t)MCI_GetMecSpeedRefUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8003cec:	4892      	ldr	r0, [pc, #584]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003cee:	f7fe f8e9 	bl	8001ec4 <MCI_GetMecSpeedRefUnit>
 8003cf2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003cf6:	0040      	lsls	r0, r0, #1
 8003cf8:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003cfa:	2000      	movs	r0, #0
          *size = 4;
 8003cfc:	2304      	movs	r3, #4
 8003cfe:	802b      	strh	r3, [r5, #0]
  }
 8003d00:	b015      	add	sp, #84	; 0x54
 8003d02:	bd30      	pop	{r4, r5, pc}
        switch (regID)
 8003d04:	28a0      	cmp	r0, #160	; 0xa0
 8003d06:	f000 820b 	beq.w	8004120 <RI_GetRegisterMotor1+0x538>
 8003d0a:	28e0      	cmp	r0, #224	; 0xe0
 8003d0c:	f000 81ec 	beq.w	80040e8 <RI_GetRegisterMotor1+0x500>
            *size= 0 ; /* */
 8003d10:	2300      	movs	r3, #0
 8003d12:	802b      	strh	r3, [r5, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003d14:	2005      	movs	r0, #5
            break;
 8003d16:	e785      	b.n	8003c24 <RI_GetRegisterMotor1+0x3c>
 8003d18:	2868      	cmp	r0, #104	; 0x68
 8003d1a:	f040 8269 	bne.w	80041f0 <RI_GetRegisterMotor1+0x608>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003d1e:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003d22:	223c      	movs	r2, #60	; 0x3c
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003d24:	f1bc 0f3d 	cmp.w	ip, #61	; 0x3d
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003d28:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003d2a:	f200 821e 	bhi.w	800416a <RI_GetRegisterMotor1+0x582>
 8003d2e:	233e      	movs	r3, #62	; 0x3e
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003d30:	2008      	movs	r0, #8
 8003d32:	e78f      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
 8003d34:	f5b0 7ff4 	cmp.w	r0, #488	; 0x1e8
 8003d38:	f000 825f 	beq.w	80041fa <RI_GetRegisterMotor1+0x612>
 8003d3c:	f5b0 7f5a 	cmp.w	r0, #872	; 0x368
 8003d40:	d112      	bne.n	8003d68 <RI_GetRegisterMotor1+0x180>
            *rawSize = 4;
 8003d42:	2304      	movs	r3, #4
 8003d44:	8023      	strh	r3, [r4, #0]
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8003d46:	487c      	ldr	r0, [pc, #496]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003d48:	f7fe f8ea 	bl	8001f20 <MCI_GetIqdref>
 8003d4c:	4603      	mov	r3, r0
 8003d4e:	8063      	strh	r3, [r4, #2]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d50:	4879      	ldr	r0, [pc, #484]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8003d52:	9312      	str	r3, [sp, #72]	; 0x48
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d54:	f7fe f8e4 	bl	8001f20 <MCI_GetIqdref>
        *size = (*rawSize) + 2U;
 8003d58:	8823      	ldrh	r3, [r4, #0]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d5a:	f3c0 400f 	ubfx	r0, r0, #16, #16
        *size = (*rawSize) + 2U;
 8003d5e:	3302      	adds	r3, #2
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d60:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8003d62:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8003d64:	2000      	movs	r0, #0
            break;
 8003d66:	e775      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
 8003d68:	f5b0 7fd4 	cmp.w	r0, #424	; 0x1a8
 8003d6c:	f040 8240 	bne.w	80041f0 <RI_GetRegisterMotor1+0x608>
            *rpm = (((int32_t)MCI_GetLastRampFinalSpeed(pMCIN) * U_RPM) / (int32_t)SPEED_UNIT);
 8003d70:	4871      	ldr	r0, [pc, #452]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003d72:	f7fe f881 	bl	8001e78 <MCI_GetLastRampFinalSpeed>
 8003d76:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003d7a:	0043      	lsls	r3, r0, #1
 8003d7c:	f8c4 3002 	str.w	r3, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003d80:	486d      	ldr	r0, [pc, #436]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003d82:	f7fe f881 	bl	8001e88 <MCI_GetLastRampFinalDuration>
            *rawSize = 6;
 8003d86:	2306      	movs	r3, #6
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003d88:	80e0      	strh	r0, [r4, #6]
            *rawSize = 6;
 8003d8a:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003d8c:	2000      	movs	r0, #0
            break;
 8003d8e:	2308      	movs	r3, #8
 8003d90:	e760      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
 8003d92:	f5b0 6f19 	cmp.w	r0, #2448	; 0x990
 8003d96:	f040 82de 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIqdref(pMCIN).d;
 8003d9a:	4867      	ldr	r0, [pc, #412]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003d9c:	f7fe f8c0 	bl	8001f20 <MCI_GetIqdref>
 8003da0:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003da4:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003da6:	2000      	movs	r0, #0
              break;
 8003da8:	e78d      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003daa:	f5b0 6f09 	cmp.w	r0, #2192	; 0x890
 8003dae:	f040 8108 	bne.w	8003fc2 <RI_GetRegisterMotor1+0x3da>
              *regdata16 = MCI_GetIalphabeta(pMCIN).beta;
 8003db2:	4861      	ldr	r0, [pc, #388]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003db4:	f7fe f898 	bl	8001ee8 <MCI_GetIalphabeta>
 8003db8:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003dbc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003dbe:	2000      	movs	r0, #0
              break;
 8003dc0:	e781      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003dc2:	f5b0 6fba 	cmp.w	r0, #1488	; 0x5d0
 8003dc6:	f000 82a2 	beq.w	800430e <RI_GetRegisterMotor1+0x726>
 8003dca:	f240 8151 	bls.w	8004070 <RI_GetRegisterMotor1+0x488>
 8003dce:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
 8003dd2:	f040 8141 	bne.w	8004058 <RI_GetRegisterMotor1+0x470>
              *regdata16 = MCI_GetIab(pMCIN).a;
 8003dd6:	4858      	ldr	r0, [pc, #352]	; (8003f38 <RI_GetRegisterMotor1+0x350>)
 8003dd8:	f7fe f878 	bl	8001ecc <MCI_GetIab>
 8003ddc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003dde:	2000      	movs	r0, #0
              break;
 8003de0:	e771      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003de2:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003de6:	d011      	beq.n	8003e0c <RI_GetRegisterMotor1+0x224>
 8003de8:	d836      	bhi.n	8003e58 <RI_GetRegisterMotor1+0x270>
 8003dea:	f5b0 6f35 	cmp.w	r0, #2896	; 0xb50
 8003dee:	f000 82ac 	beq.w	800434a <RI_GetRegisterMotor1+0x762>
 8003df2:	d922      	bls.n	8003e3a <RI_GetRegisterMotor1+0x252>
 8003df4:	f5b0 6f41 	cmp.w	r0, #3088	; 0xc10
 8003df8:	f000 829f 	beq.w	800433a <RI_GetRegisterMotor1+0x752>
 8003dfc:	d914      	bls.n	8003e28 <RI_GetRegisterMotor1+0x240>
 8003dfe:	f5b0 6f49 	cmp.w	r0, #3216	; 0xc90
 8003e02:	f000 8292 	beq.w	800432a <RI_GetRegisterMotor1+0x742>
 8003e06:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 8003e0a:	d103      	bne.n	8003e14 <RI_GetRegisterMotor1+0x22c>
          *size = 2;
 8003e0c:	2302      	movs	r3, #2
    uint8_t retVal = MCP_CMD_OK;
 8003e0e:	2000      	movs	r0, #0
          *size = 2;
 8003e10:	802b      	strh	r3, [r5, #0]
 8003e12:	e75a      	b.n	8003cca <RI_GetRegisterMotor1+0xe2>
 8003e14:	f5b0 6f45 	cmp.w	r0, #3152	; 0xc50
 8003e18:	f040 829d 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = STO_PLL_GetEstimatedBemf(&STO_PLL_M1).alpha;
 8003e1c:	4847      	ldr	r0, [pc, #284]	; (8003f3c <RI_GetRegisterMotor1+0x354>)
 8003e1e:	f006 fdb7 	bl	800a990 <STO_PLL_GetEstimatedBemf>
 8003e22:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e24:	2000      	movs	r0, #0
              break;
 8003e26:	e74e      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003e28:	f5b0 6f39 	cmp.w	r0, #2960	; 0xb90
 8003e2c:	d12a      	bne.n	8003e84 <RI_GetRegisterMotor1+0x29c>
              *regdata16 = SPD_GetS16Speed((SpeednPosFdbk_Handle_t *)&STO_PLL_M1);
 8003e2e:	4843      	ldr	r0, [pc, #268]	; (8003f3c <RI_GetRegisterMotor1+0x354>)
 8003e30:	f006 fabe 	bl	800a3b0 <SPD_GetS16Speed>
 8003e34:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e36:	2000      	movs	r0, #0
              break;
 8003e38:	e745      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003e3a:	f5b0 6f29 	cmp.w	r0, #2704	; 0xa90
 8003e3e:	f000 826c 	beq.w	800431a <RI_GetRegisterMotor1+0x732>
 8003e42:	f240 8087 	bls.w	8003f54 <RI_GetRegisterMotor1+0x36c>
 8003e46:	f5b0 6f2d 	cmp.w	r0, #2768	; 0xad0
 8003e4a:	d16a      	bne.n	8003f22 <RI_GetRegisterMotor1+0x33a>
              *regdata16 = SPD_GetElAngle ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 8003e4c:	483c      	ldr	r0, [pc, #240]	; (8003f40 <RI_GetRegisterMotor1+0x358>)
 8003e4e:	f006 fa75 	bl	800a33c <SPD_GetElAngle>
 8003e52:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e54:	2000      	movs	r0, #0
              break;
 8003e56:	e736      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003e58:	f241 5390 	movw	r3, #5520	; 0x1590
 8003e5c:	4298      	cmp	r0, r3
 8003e5e:	f000 8244 	beq.w	80042ea <RI_GetRegisterMotor1+0x702>
 8003e62:	d92e      	bls.n	8003ec2 <RI_GetRegisterMotor1+0x2da>
 8003e64:	f241 6350 	movw	r3, #5712	; 0x1650
 8003e68:	4298      	cmp	r0, r3
 8003e6a:	f000 8238 	beq.w	80042de <RI_GetRegisterMotor1+0x6f6>
 8003e6e:	d91e      	bls.n	8003eae <RI_GetRegisterMotor1+0x2c6>
 8003e70:	f641 03d0 	movw	r3, #6352	; 0x18d0
 8003e74:	4298      	cmp	r0, r3
 8003e76:	d10f      	bne.n	8003e98 <RI_GetRegisterMotor1+0x2b0>
              *regdataU16 = PID_GetKIDivisorPOW2(&(&STO_PLL_M1)->PIRegulator);
 8003e78:	4832      	ldr	r0, [pc, #200]	; (8003f44 <RI_GetRegisterMotor1+0x35c>)
 8003e7a:	f005 f9b7 	bl	80091ec <PID_GetKIDivisorPOW2>
 8003e7e:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e80:	2000      	movs	r0, #0
              break;
 8003e82:	e720      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003e84:	f5b0 6f3d 	cmp.w	r0, #3024	; 0xbd0
 8003e88:	f040 8265 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = STO_PLL_GetEstimatedCurrent(&STO_PLL_M1).alpha;
 8003e8c:	482b      	ldr	r0, [pc, #172]	; (8003f3c <RI_GetRegisterMotor1+0x354>)
 8003e8e:	f006 fd8b 	bl	800a9a8 <STO_PLL_GetEstimatedCurrent>
 8003e92:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e94:	2000      	movs	r0, #0
              break;
 8003e96:	e716      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003e98:	f641 1310 	movw	r3, #6416	; 0x1910
 8003e9c:	4298      	cmp	r0, r3
 8003e9e:	f040 825a 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKPDivisorPOW2(&(&STO_PLL_M1)->PIRegulator);
 8003ea2:	4828      	ldr	r0, [pc, #160]	; (8003f44 <RI_GetRegisterMotor1+0x35c>)
 8003ea4:	f005 f99a 	bl	80091dc <PID_GetKPDivisorPOW2>
 8003ea8:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003eaa:	2000      	movs	r0, #0
              break;
 8003eac:	e70b      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003eae:	f241 53d0 	movw	r3, #5584	; 0x15d0
 8003eb2:	4298      	cmp	r0, r3
 8003eb4:	d115      	bne.n	8003ee2 <RI_GetRegisterMotor1+0x2fa>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIqHandle_M1);
 8003eb6:	4824      	ldr	r0, [pc, #144]	; (8003f48 <RI_GetRegisterMotor1+0x360>)
 8003eb8:	f005 f990 	bl	80091dc <PID_GetKPDivisorPOW2>
 8003ebc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ebe:	2000      	movs	r0, #0
              break;
 8003ec0:	e701      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003ec2:	f241 43d0 	movw	r3, #5328	; 0x14d0
 8003ec6:	4298      	cmp	r0, r3
 8003ec8:	f000 8203 	beq.w	80042d2 <RI_GetRegisterMotor1+0x6ea>
 8003ecc:	d91f      	bls.n	8003f0e <RI_GetRegisterMotor1+0x326>
 8003ece:	f241 5310 	movw	r3, #5392	; 0x1510
 8003ed2:	4298      	cmp	r0, r3
 8003ed4:	d110      	bne.n	8003ef8 <RI_GetRegisterMotor1+0x310>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIdHandle_M1);
 8003ed6:	481d      	ldr	r0, [pc, #116]	; (8003f4c <RI_GetRegisterMotor1+0x364>)
 8003ed8:	f005 f980 	bl	80091dc <PID_GetKPDivisorPOW2>
 8003edc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ede:	2000      	movs	r0, #0
              break;
 8003ee0:	e6f1      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003ee2:	f241 6310 	movw	r3, #5648	; 0x1610
 8003ee6:	4298      	cmp	r0, r3
 8003ee8:	f040 8235 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIqHandle_M1);
 8003eec:	4816      	ldr	r0, [pc, #88]	; (8003f48 <RI_GetRegisterMotor1+0x360>)
 8003eee:	f005 f97d 	bl	80091ec <PID_GetKIDivisorPOW2>
 8003ef2:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ef4:	2000      	movs	r0, #0
              break;
 8003ef6:	e6e6      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003ef8:	f241 5350 	movw	r3, #5456	; 0x1550
 8003efc:	4298      	cmp	r0, r3
 8003efe:	f040 822a 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIdHandle_M1);
 8003f02:	4812      	ldr	r0, [pc, #72]	; (8003f4c <RI_GetRegisterMotor1+0x364>)
 8003f04:	f005 f972 	bl	80091ec <PID_GetKIDivisorPOW2>
 8003f08:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f0a:	2000      	movs	r0, #0
              break;
 8003f0c:	e6db      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f0e:	f241 4350 	movw	r3, #5200	; 0x1450
 8003f12:	4298      	cmp	r0, r3
 8003f14:	d129      	bne.n	8003f6a <RI_GetRegisterMotor1+0x382>
              *regdataU16 = (uint16_t)PID_GetKPDivisorPOW2(&PIDSpeedHandle_M1);
 8003f16:	480e      	ldr	r0, [pc, #56]	; (8003f50 <RI_GetRegisterMotor1+0x368>)
 8003f18:	f005 f960 	bl	80091dc <PID_GetKPDivisorPOW2>
 8003f1c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f1e:	2000      	movs	r0, #0
              break;
 8003f20:	e6d1      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f22:	f5b0 6f31 	cmp.w	r0, #2832	; 0xb10
 8003f26:	f040 8216 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = SPD_GetS16Speed ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 8003f2a:	4805      	ldr	r0, [pc, #20]	; (8003f40 <RI_GetRegisterMotor1+0x358>)
 8003f2c:	f006 fa40 	bl	800a3b0 <SPD_GetS16Speed>
 8003f30:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f32:	2000      	movs	r0, #0
              break;
 8003f34:	e6c7      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f36:	bf00      	nop
 8003f38:	20001a90 	.word	0x20001a90
 8003f3c:	20000210 	.word	0x20000210
 8003f40:	20000024 	.word	0x20000024
 8003f44:	20000244 	.word	0x20000244
 8003f48:	200000ec 	.word	0x200000ec
 8003f4c:	200000c0 	.word	0x200000c0
 8003f50:	20000118 	.word	0x20000118
 8003f54:	f5b0 6f21 	cmp.w	r0, #2576	; 0xa10
 8003f58:	d112      	bne.n	8003f80 <RI_GetRegisterMotor1+0x398>
              *regdata16 = MCI_GetVqd(pMCIN).d;
 8003f5a:	48af      	ldr	r0, [pc, #700]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8003f5c:	f7fd ffee 	bl	8001f3c <MCI_GetVqd>
 8003f60:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003f64:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f66:	2000      	movs	r0, #0
              break;
 8003f68:	e6ad      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f6a:	f241 4390 	movw	r3, #5264	; 0x1490
 8003f6e:	4298      	cmp	r0, r3
 8003f70:	f040 81f1 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = (uint16_t)PID_GetKIDivisorPOW2(&PIDSpeedHandle_M1);
 8003f74:	48a9      	ldr	r0, [pc, #676]	; (800421c <RI_GetRegisterMotor1+0x634>)
 8003f76:	f005 f939 	bl	80091ec <PID_GetKIDivisorPOW2>
 8003f7a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f7c:	2000      	movs	r0, #0
              break;
 8003f7e:	e6a2      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f80:	f5b0 6f25 	cmp.w	r0, #2640	; 0xa50
 8003f84:	f040 81e7 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetValphabeta(pMCIN).alpha;
 8003f88:	48a3      	ldr	r0, [pc, #652]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8003f8a:	f7fd ffe5 	bl	8001f58 <MCI_GetValphabeta>
 8003f8e:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f90:	2000      	movs	r0, #0
              break;
 8003f92:	e698      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003f94:	f5b0 7f04 	cmp.w	r0, #528	; 0x210
 8003f98:	f000 8195 	beq.w	80042c6 <RI_GetRegisterMotor1+0x6de>
 8003f9c:	d932      	bls.n	8004004 <RI_GetRegisterMotor1+0x41c>
 8003f9e:	f5b0 7f44 	cmp.w	r0, #784	; 0x310
 8003fa2:	f000 81ae 	beq.w	8004302 <RI_GetRegisterMotor1+0x71a>
 8003fa6:	d924      	bls.n	8003ff2 <RI_GetRegisterMotor1+0x40a>
 8003fa8:	f5b0 7f54 	cmp.w	r0, #848	; 0x350
 8003fac:	d113      	bne.n	8003fd6 <RI_GetRegisterMotor1+0x3ee>
              STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 8003fae:	489c      	ldr	r0, [pc, #624]	; (8004220 <RI_GetRegisterMotor1+0x638>)
 8003fb0:	aa13      	add	r2, sp, #76	; 0x4c
 8003fb2:	a912      	add	r1, sp, #72	; 0x48
 8003fb4:	f006 fd0c 	bl	800a9d0 <STO_PLL_GetObserverGains>
              *regdata16 = hC1;
 8003fb8:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8003fbc:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fbe:	2000      	movs	r0, #0
 8003fc0:	e681      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003fc2:	f5b0 6f0d 	cmp.w	r0, #2256	; 0x8d0
 8003fc6:	f040 81c6 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIqd(pMCIN).q;
 8003fca:	4893      	ldr	r0, [pc, #588]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8003fcc:	f7fd ff9a 	bl	8001f04 <MCI_GetIqd>
 8003fd0:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fd2:	2000      	movs	r0, #0
              break;
 8003fd4:	e677      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003fd6:	f5b0 7f64 	cmp.w	r0, #912	; 0x390
 8003fda:	f040 81bc 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 8003fde:	4890      	ldr	r0, [pc, #576]	; (8004220 <RI_GetRegisterMotor1+0x638>)
 8003fe0:	aa13      	add	r2, sp, #76	; 0x4c
 8003fe2:	a912      	add	r1, sp, #72	; 0x48
 8003fe4:	f006 fcf4 	bl	800a9d0 <STO_PLL_GetObserverGains>
              *regdata16 = hC2;
 8003fe8:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
 8003fec:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fee:	2000      	movs	r0, #0
 8003ff0:	e669      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8003ff2:	f5b0 7f24 	cmp.w	r0, #656	; 0x290
 8003ff6:	d113      	bne.n	8004020 <RI_GetRegisterMotor1+0x438>
              *regdata16 = PID_GetKP(&PIDIdHandle_M1);
 8003ff8:	488a      	ldr	r0, [pc, #552]	; (8004224 <RI_GetRegisterMotor1+0x63c>)
 8003ffa:	f005 f8e5 	bl	80091c8 <PID_GetKP>
 8003ffe:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004000:	2000      	movs	r0, #0
              break;
 8004002:	e660      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004004:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
 8004008:	f000 8175 	beq.w	80042f6 <RI_GetRegisterMotor1+0x70e>
 800400c:	d91c      	bls.n	8004048 <RI_GetRegisterMotor1+0x460>
 800400e:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 8004012:	d10f      	bne.n	8004034 <RI_GetRegisterMotor1+0x44c>
              *regdata16 = PID_GetKP(&PIDIqHandle_M1);
 8004014:	4884      	ldr	r0, [pc, #528]	; (8004228 <RI_GetRegisterMotor1+0x640>)
 8004016:	f005 f8d7 	bl	80091c8 <PID_GetKP>
 800401a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800401c:	2000      	movs	r0, #0
              break;
 800401e:	e652      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004020:	f5b0 7f34 	cmp.w	r0, #720	; 0x2d0
 8004024:	f040 8197 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDIdHandle_M1);
 8004028:	487e      	ldr	r0, [pc, #504]	; (8004224 <RI_GetRegisterMotor1+0x63c>)
 800402a:	f005 f8d1 	bl	80091d0 <PID_GetKI>
 800402e:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004030:	2000      	movs	r0, #0
              break;
 8004032:	e648      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004034:	f5b0 7fe8 	cmp.w	r0, #464	; 0x1d0
 8004038:	f040 818d 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDIqHandle_M1);
 800403c:	487a      	ldr	r0, [pc, #488]	; (8004228 <RI_GetRegisterMotor1+0x640>)
 800403e:	f005 f8c7 	bl	80091d0 <PID_GetKI>
 8004042:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004044:	2000      	movs	r0, #0
              break;
 8004046:	e63e      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004048:	2890      	cmp	r0, #144	; 0x90
 800404a:	d11a      	bne.n	8004082 <RI_GetRegisterMotor1+0x49a>
              *regdata16 = PID_GetKP(&PIDSpeedHandle_M1);
 800404c:	4873      	ldr	r0, [pc, #460]	; (800421c <RI_GetRegisterMotor1+0x634>)
 800404e:	f005 f8bb 	bl	80091c8 <PID_GetKP>
 8004052:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004054:	2000      	movs	r0, #0
              break;
 8004056:	e636      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004058:	f5b0 6f01 	cmp.w	r0, #2064	; 0x810
 800405c:	f040 817b 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIab(pMCIN).b;
 8004060:	486d      	ldr	r0, [pc, #436]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8004062:	f7fd ff33 	bl	8001ecc <MCI_GetIab>
 8004066:	f3c0 400f 	ubfx	r0, r0, #16, #16
 800406a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800406c:	2000      	movs	r0, #0
              break;
 800406e:	e62a      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004070:	f5b0 6f92 	cmp.w	r0, #1168	; 0x490
 8004074:	d10e      	bne.n	8004094 <RI_GetRegisterMotor1+0x4ac>
              *regdata16 = PID_GetKP (&(&STO_PLL_M1)->PIRegulator);
 8004076:	486d      	ldr	r0, [pc, #436]	; (800422c <RI_GetRegisterMotor1+0x644>)
 8004078:	f005 f8a6 	bl	80091c8 <PID_GetKP>
 800407c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800407e:	2000      	movs	r0, #0
              break;
 8004080:	e621      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004082:	28d0      	cmp	r0, #208	; 0xd0
 8004084:	f040 8167 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDSpeedHandle_M1);
 8004088:	4864      	ldr	r0, [pc, #400]	; (800421c <RI_GetRegisterMotor1+0x634>)
 800408a:	f005 f8a1 	bl	80091d0 <PID_GetKI>
 800408e:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004090:	2000      	movs	r0, #0
              break;
 8004092:	e618      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004094:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 8004098:	f040 815d 	bne.w	8004356 <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = VBS_GetAvBusVoltage_V(BusVoltageSensor);
 800409c:	4864      	ldr	r0, [pc, #400]	; (8004230 <RI_GetRegisterMotor1+0x648>)
 800409e:	f004 fd1b 	bl	8008ad8 <VBS_GetAvBusVoltage_V>
 80040a2:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80040a4:	2000      	movs	r0, #0
              break;
 80040a6:	e60e      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 80040a8:	2818      	cmp	r0, #24
 80040aa:	f040 8082 	bne.w	80041b2 <RI_GetRegisterMotor1+0x5ca>
              *regdataU32 = MCI_GetFaultState(pMCIN);
 80040ae:	485a      	ldr	r0, [pc, #360]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 80040b0:	f7fd fed8 	bl	8001e64 <MCI_GetFaultState>
 80040b4:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80040b6:	2000      	movs	r0, #0
              break;
 80040b8:	e620      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
 80040ba:	f5b0 7f8c 	cmp.w	r0, #280	; 0x118
 80040be:	f000 80d2 	beq.w	8004266 <RI_GetRegisterMotor1+0x67e>
 80040c2:	f641 3358 	movw	r3, #7000	; 0x1b58
 80040c6:	4298      	cmp	r0, r3
 80040c8:	d173      	bne.n	80041b2 <RI_GetRegisterMotor1+0x5ca>
              ReadVal.Float_Val = PQD_GetAvrgElMotorPowerW(pMPM[M1]);
 80040ca:	4b5a      	ldr	r3, [pc, #360]	; (8004234 <RI_GetRegisterMotor1+0x64c>)
 80040cc:	6818      	ldr	r0, [r3, #0]
 80040ce:	f005 f919 	bl	8009304 <PQD_GetAvrgElMotorPowerW>
 80040d2:	ed8d 0a01 	vstr	s0, [sp, #4]
              *regdataU32 = ReadVal.U32_Val; //cstat !UNION-type-punning
 80040d6:	9b01      	ldr	r3, [sp, #4]
 80040d8:	6023      	str	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80040da:	2000      	movs	r0, #0
 80040dc:	e60e      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80040de:	2008      	movs	r0, #8
  }
 80040e0:	b015      	add	sp, #84	; 0x54
 80040e2:	bd30      	pop	{r4, r5, pc}
 80040e4:	2005      	movs	r0, #5
 80040e6:	e5c7      	b.n	8003c78 <RI_GetRegisterMotor1+0x90>
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80040e8:	4b53      	ldr	r3, [pc, #332]	; (8004238 <RI_GetRegisterMotor1+0x650>)
 80040ea:	681a      	ldr	r2, [r3, #0]
  *size= 1U ; /* /0 is the min String size */
 80040ec:	2301      	movs	r3, #1
 80040ee:	802b      	strh	r3, [r5, #0]
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80040f0:	f102 0124 	add.w	r1, r2, #36	; 0x24
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80040f4:	f992 2024 	ldrsb.w	r2, [r2, #36]	; 0x24
 80040f8:	b17a      	cbz	r2, 800411a <RI_GetRegisterMotor1+0x532>
 80040fa:	fa1f fc8c 	uxth.w	ip, ip
 80040fe:	e008      	b.n	8004112 <RI_GetRegisterMotor1+0x52a>
    *tempdestString = *tempsrcString;
 8004100:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 8004104:	882b      	ldrh	r3, [r5, #0]
 8004106:	3301      	adds	r3, #1
 8004108:	b29b      	uxth	r3, r3
 800410a:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800410c:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8004110:	b11a      	cbz	r2, 800411a <RI_GetRegisterMotor1+0x532>
 8004112:	4563      	cmp	r3, ip
 8004114:	d3f4      	bcc.n	8004100 <RI_GetRegisterMotor1+0x518>
    retVal = MCP_ERROR_STRING_FORMAT;
 8004116:	2006      	movs	r0, #6
 8004118:	e584      	b.n	8003c24 <RI_GetRegisterMotor1+0x3c>
    *tempdestString = (int8_t)0;
 800411a:	2000      	movs	r0, #0
 800411c:	7020      	strb	r0, [r4, #0]
    return (retVal);
 800411e:	e581      	b.n	8003c24 <RI_GetRegisterMotor1+0x3c>
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 8004120:	4a46      	ldr	r2, [pc, #280]	; (800423c <RI_GetRegisterMotor1+0x654>)
  *size= 1U ; /* /0 is the min String size */
 8004122:	2301      	movs	r3, #1
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 8004124:	6811      	ldr	r1, [r2, #0]
  *size= 1U ; /* /0 is the min String size */
 8004126:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8004128:	f991 2000 	ldrsb.w	r2, [r1]
 800412c:	2a00      	cmp	r2, #0
 800412e:	d0f4      	beq.n	800411a <RI_GetRegisterMotor1+0x532>
 8004130:	fa1f fc8c 	uxth.w	ip, ip
 8004134:	e009      	b.n	800414a <RI_GetRegisterMotor1+0x562>
    *tempdestString = *tempsrcString;
 8004136:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 800413a:	882b      	ldrh	r3, [r5, #0]
 800413c:	3301      	adds	r3, #1
 800413e:	b29b      	uxth	r3, r3
 8004140:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8004142:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 8004146:	2a00      	cmp	r2, #0
 8004148:	d0e7      	beq.n	800411a <RI_GetRegisterMotor1+0x532>
 800414a:	4563      	cmp	r3, ip
 800414c:	d3f3      	bcc.n	8004136 <RI_GetRegisterMotor1+0x54e>
 800414e:	e7e2      	b.n	8004116 <RI_GetRegisterMotor1+0x52e>
              FOCFwConfig_reg_t const *pFOCConfig_reg = FOCConfig_reg[motorID];
 8004150:	4a3b      	ldr	r2, [pc, #236]	; (8004240 <RI_GetRegisterMotor1+0x658>)
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 8004152:	6812      	ldr	r2, [r2, #0]
 8004154:	6810      	ldr	r0, [r2, #0]
 8004156:	6851      	ldr	r1, [r2, #4]
 8004158:	6894      	ldr	r4, [r2, #8]
 800415a:	609c      	str	r4, [r3, #8]
 800415c:	6018      	str	r0, [r3, #0]
 800415e:	6059      	str	r1, [r3, #4]
 8004160:	8992      	ldrh	r2, [r2, #12]
 8004162:	819a      	strh	r2, [r3, #12]
    uint8_t retVal = MCP_CMD_OK;
 8004164:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 8004166:	2310      	movs	r3, #16
 8004168:	e574      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
              MotorConfig_reg_t const *pMotorConfig_reg = MotorConfig_reg[motorID];
 800416a:	4a33      	ldr	r2, [pc, #204]	; (8004238 <RI_GetRegisterMotor1+0x650>)
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 800416c:	6812      	ldr	r2, [r2, #0]
 800416e:	f102 0e30 	add.w	lr, r2, #48	; 0x30
 8004172:	6814      	ldr	r4, [r2, #0]
 8004174:	6850      	ldr	r0, [r2, #4]
 8004176:	6891      	ldr	r1, [r2, #8]
 8004178:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 800417c:	f8c3 c00c 	str.w	ip, [r3, #12]
 8004180:	3210      	adds	r2, #16
 8004182:	4572      	cmp	r2, lr
 8004184:	601c      	str	r4, [r3, #0]
 8004186:	6058      	str	r0, [r3, #4]
 8004188:	6099      	str	r1, [r3, #8]
 800418a:	f103 0310 	add.w	r3, r3, #16
 800418e:	d1f0      	bne.n	8004172 <RI_GetRegisterMotor1+0x58a>
 8004190:	6810      	ldr	r0, [r2, #0]
 8004192:	6851      	ldr	r1, [r2, #4]
 8004194:	6892      	ldr	r2, [r2, #8]
 8004196:	609a      	str	r2, [r3, #8]
 8004198:	6018      	str	r0, [r3, #0]
 800419a:	6059      	str	r1, [r3, #4]
    uint8_t retVal = MCP_CMD_OK;
 800419c:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 800419e:	233e      	movs	r3, #62	; 0x3e
 80041a0:	e558      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80041a2:	4608      	mov	r0, r1
 80041a4:	e53e      	b.n	8003c24 <RI_GetRegisterMotor1+0x3c>
              *data = (uint8_t)MCI_GetSTMState(pMCIN);
 80041a6:	481c      	ldr	r0, [pc, #112]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 80041a8:	f7fd fdf4 	bl	8001d94 <MCI_GetSTMState>
 80041ac:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80041ae:	2000      	movs	r0, #0
              break;
 80041b0:	e562      	b.n	8003c78 <RI_GetRegisterMotor1+0x90>
 80041b2:	2005      	movs	r0, #5
 80041b4:	e5a2      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80041b6:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 80041ba:	2210      	movs	r2, #16
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80041bc:	f1bc 0f11 	cmp.w	ip, #17
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 80041c0:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 80041c2:	d859      	bhi.n	8004278 <RI_GetRegisterMotor1+0x690>
 80041c4:	2312      	movs	r3, #18
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80041c6:	2008      	movs	r0, #8
 80041c8:	e544      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 80041ca:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = 12;
 80041ce:	220c      	movs	r2, #12
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 80041d0:	f1bc 0f0d 	cmp.w	ip, #13
            *rawSize = 12;
 80041d4:	8022      	strh	r2, [r4, #0]
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 80041d6:	d94c      	bls.n	8004272 <RI_GetRegisterMotor1+0x68a>
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 80041d8:	4a1a      	ldr	r2, [pc, #104]	; (8004244 <RI_GetRegisterMotor1+0x65c>)
 80041da:	6850      	ldr	r0, [r2, #4]
 80041dc:	6814      	ldr	r4, [r2, #0]
 80041de:	6891      	ldr	r1, [r2, #8]
 80041e0:	68d2      	ldr	r2, [r2, #12]
 80041e2:	60da      	str	r2, [r3, #12]
 80041e4:	6058      	str	r0, [r3, #4]
 80041e6:	601c      	str	r4, [r3, #0]
 80041e8:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 80041ea:	2000      	movs	r0, #0
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 80041ec:	230e      	movs	r3, #14
 80041ee:	e531      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
        *size = (*rawSize) + 2U;
 80041f0:	8823      	ldrh	r3, [r4, #0]
 80041f2:	3302      	adds	r3, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 80041f4:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 80041f6:	b29b      	uxth	r3, r3
 80041f8:	e52c      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
            *rawSize = 4;
 80041fa:	2304      	movs	r3, #4
 80041fc:	8023      	strh	r3, [r4, #0]
            *torque = MCI_GetLastRampFinalTorque(pMCIN);
 80041fe:	4806      	ldr	r0, [pc, #24]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8004200:	f7fd fe3e 	bl	8001e80 <MCI_GetLastRampFinalTorque>
 8004204:	8060      	strh	r0, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 8004206:	4804      	ldr	r0, [pc, #16]	; (8004218 <RI_GetRegisterMotor1+0x630>)
 8004208:	f7fd fe3e 	bl	8001e88 <MCI_GetLastRampFinalDuration>
        *size = (*rawSize) + 2U;
 800420c:	8823      	ldrh	r3, [r4, #0]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 800420e:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8004210:	3302      	adds	r3, #2
 8004212:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8004214:	2000      	movs	r0, #0
            break;
 8004216:	e51d      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
 8004218:	20001a90 	.word	0x20001a90
 800421c:	20000118 	.word	0x20000118
 8004220:	20000210 	.word	0x20000210
 8004224:	200000c0 	.word	0x200000c0
 8004228:	200000ec 	.word	0x200000ec
 800422c:	20000244 	.word	0x20000244
 8004230:	20000004 	.word	0x20000004
 8004234:	200003d0 	.word	0x200003d0
 8004238:	200003e8 	.word	0x200003e8
 800423c:	200003ec 	.word	0x200003ec
 8004240:	200003e4 	.word	0x200003e4
 8004244:	200003f0 	.word	0x200003f0
              *regdata32 = (((int32_t)MCI_GetAvrgMecSpeedUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8004248:	4844      	ldr	r0, [pc, #272]	; (800435c <RI_GetRegisterMotor1+0x774>)
 800424a:	f7fd fe23 	bl	8001e94 <MCI_GetAvrgMecSpeedUnit>
 800424e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8004252:	0040      	lsls	r0, r0, #1
 8004254:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004256:	2000      	movs	r0, #0
              break;
 8004258:	e550      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
              *regdata32 = STO_PLL_GetEstimatedBemfLevel(&STO_PLL_M1);
 800425a:	4841      	ldr	r0, [pc, #260]	; (8004360 <RI_GetRegisterMotor1+0x778>)
 800425c:	f006 fbc4 	bl	800a9e8 <STO_PLL_GetEstimatedBemfLevel>
 8004260:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004262:	2000      	movs	r0, #0
              break;
 8004264:	e54a      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
              *regdata32 = STO_PLL_GetObservedBemfLevel(&STO_PLL_M1);
 8004266:	483e      	ldr	r0, [pc, #248]	; (8004360 <RI_GetRegisterMotor1+0x778>)
 8004268:	f006 fbc2 	bl	800a9f0 <STO_PLL_GetObservedBemfLevel>
 800426c:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800426e:	2000      	movs	r0, #0
              break;
 8004270:	e544      	b.n	8003cfc <RI_GetRegisterMotor1+0x114>
 8004272:	230e      	movs	r3, #14
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8004274:	2008      	movs	r0, #8
 8004276:	e4ed      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
              ApplicationConfig_reg_t const *pApplicationConfig_reg = ApplicationConfig_reg[motorID];
 8004278:	4a3a      	ldr	r2, [pc, #232]	; (8004364 <RI_GetRegisterMotor1+0x77c>)
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 800427a:	6812      	ldr	r2, [r2, #0]
 800427c:	6850      	ldr	r0, [r2, #4]
 800427e:	6814      	ldr	r4, [r2, #0]
 8004280:	6891      	ldr	r1, [r2, #8]
 8004282:	68d2      	ldr	r2, [r2, #12]
 8004284:	60da      	str	r2, [r3, #12]
 8004286:	6058      	str	r0, [r3, #4]
 8004288:	601c      	str	r4, [r3, #0]
 800428a:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 800428c:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 800428e:	2312      	movs	r3, #18
 8004290:	e4e0      	b.n	8003c54 <RI_GetRegisterMotor1+0x6c>
              *regdata16 = MCI_GetIqd(pMCIN).d;
 8004292:	4832      	ldr	r0, [pc, #200]	; (800435c <RI_GetRegisterMotor1+0x774>)
 8004294:	f7fd fe36 	bl	8001f04 <MCI_GetIqd>
 8004298:	f3c0 400f 	ubfx	r0, r0, #16, #16
 800429c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800429e:	2000      	movs	r0, #0
              break;
 80042a0:	e511      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetIalphabeta(pMCIN).alpha;
 80042a2:	482e      	ldr	r0, [pc, #184]	; (800435c <RI_GetRegisterMotor1+0x774>)
 80042a4:	f7fd fe20 	bl	8001ee8 <MCI_GetIalphabeta>
 80042a8:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042aa:	2000      	movs	r0, #0
              break;
 80042ac:	e50b      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKI (&(&STO_PLL_M1)->PIRegulator);
 80042ae:	482e      	ldr	r0, [pc, #184]	; (8004368 <RI_GetRegisterMotor1+0x780>)
 80042b0:	f004 ff8e 	bl	80091d0 <PID_GetKI>
 80042b4:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042b6:	2000      	movs	r0, #0
              break;
 80042b8:	e505      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetVqd(pMCIN).q;
 80042ba:	4828      	ldr	r0, [pc, #160]	; (800435c <RI_GetRegisterMotor1+0x774>)
 80042bc:	f7fd fe3e 	bl	8001f3c <MCI_GetVqd>
 80042c0:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042c2:	2000      	movs	r0, #0
              break;
 80042c4:	e4ff      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDIqHandle_M1);
 80042c6:	4829      	ldr	r0, [pc, #164]	; (800436c <RI_GetRegisterMotor1+0x784>)
 80042c8:	f004 ffac 	bl	8009224 <PID_GetKD>
 80042cc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042ce:	2000      	movs	r0, #0
              break;
 80042d0:	e4f9      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDSpeedHandle_M1);
 80042d2:	4827      	ldr	r0, [pc, #156]	; (8004370 <RI_GetRegisterMotor1+0x788>)
 80042d4:	f004 ffaa 	bl	800922c <PID_GetKDDivisorPOW2>
 80042d8:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042da:	2000      	movs	r0, #0
              break;
 80042dc:	e4f3      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIqHandle_M1);
 80042de:	4823      	ldr	r0, [pc, #140]	; (800436c <RI_GetRegisterMotor1+0x784>)
 80042e0:	f004 ffa4 	bl	800922c <PID_GetKDDivisorPOW2>
 80042e4:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042e6:	2000      	movs	r0, #0
              break;
 80042e8:	e4ed      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIdHandle_M1);
 80042ea:	4822      	ldr	r0, [pc, #136]	; (8004374 <RI_GetRegisterMotor1+0x78c>)
 80042ec:	f004 ff9e 	bl	800922c <PID_GetKDDivisorPOW2>
 80042f0:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042f2:	2000      	movs	r0, #0
              break;
 80042f4:	e4e7      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDSpeedHandle_M1);
 80042f6:	481e      	ldr	r0, [pc, #120]	; (8004370 <RI_GetRegisterMotor1+0x788>)
 80042f8:	f004 ff94 	bl	8009224 <PID_GetKD>
 80042fc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042fe:	2000      	movs	r0, #0
              break;
 8004300:	e4e1      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDIdHandle_M1);
 8004302:	481c      	ldr	r0, [pc, #112]	; (8004374 <RI_GetRegisterMotor1+0x78c>)
 8004304:	f004 ff8e 	bl	8009224 <PID_GetKD>
 8004308:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800430a:	2000      	movs	r0, #0
              break;
 800430c:	e4db      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = NTC_GetAvTemp_C(&TempSensor_M1);
 800430e:	481a      	ldr	r0, [pc, #104]	; (8004378 <RI_GetRegisterMotor1+0x790>)
 8004310:	f004 ff3c 	bl	800918c <NTC_GetAvTemp_C>
 8004314:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004316:	2000      	movs	r0, #0
              break;
 8004318:	e4d5      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetValphabeta(pMCIN).beta;
 800431a:	4810      	ldr	r0, [pc, #64]	; (800435c <RI_GetRegisterMotor1+0x774>)
 800431c:	f7fd fe1c 	bl	8001f58 <MCI_GetValphabeta>
 8004320:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8004324:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004326:	2000      	movs	r0, #0
              break;
 8004328:	e4cd      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = STO_PLL_GetEstimatedBemf(&STO_PLL_M1).beta;
 800432a:	480d      	ldr	r0, [pc, #52]	; (8004360 <RI_GetRegisterMotor1+0x778>)
 800432c:	f006 fb30 	bl	800a990 <STO_PLL_GetEstimatedBemf>
 8004330:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8004334:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004336:	2000      	movs	r0, #0
              break;
 8004338:	e4c5      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = STO_PLL_GetEstimatedCurrent(&STO_PLL_M1).beta;
 800433a:	4809      	ldr	r0, [pc, #36]	; (8004360 <RI_GetRegisterMotor1+0x778>)
 800433c:	f006 fb34 	bl	800a9a8 <STO_PLL_GetEstimatedCurrent>
 8004340:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8004344:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004346:	2000      	movs	r0, #0
              break;
 8004348:	e4bd      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
              *regdata16 = SPD_GetElAngle((SpeednPosFdbk_Handle_t *)&STO_PLL_M1);
 800434a:	4805      	ldr	r0, [pc, #20]	; (8004360 <RI_GetRegisterMotor1+0x778>)
 800434c:	f005 fff6 	bl	800a33c <SPD_GetElAngle>
 8004350:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004352:	2000      	movs	r0, #0
              break;
 8004354:	e4b7      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 8004356:	2005      	movs	r0, #5
 8004358:	e4b5      	b.n	8003cc6 <RI_GetRegisterMotor1+0xde>
 800435a:	bf00      	nop
 800435c:	20001a90 	.word	0x20001a90
 8004360:	20000210 	.word	0x20000210
 8004364:	200003e0 	.word	0x200003e0
 8004368:	20000244 	.word	0x20000244
 800436c:	200000ec 	.word	0x200000ec
 8004370:	20000118 	.word	0x20000118
 8004374:	200000c0 	.word	0x200000c0
 8004378:	2000036c 	.word	0x2000036c

0800437c <RI_GetIDSize>:
  return (retVal);
}

uint8_t RI_GetIDSize(uint16_t dataID)
{
  uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;
 800437c:	f000 0038 	and.w	r0, r0, #56	; 0x38
 8004380:	3808      	subs	r0, #8
 8004382:	b2c0      	uxtb	r0, r0
 8004384:	2810      	cmp	r0, #16
 8004386:	bf9a      	itte	ls
 8004388:	4b01      	ldrls	r3, [pc, #4]	; (8004390 <RI_GetIDSize+0x14>)
 800438a:	5c18      	ldrbls	r0, [r3, r0]
 800438c:	2000      	movhi	r0, #0
      break;
    }
  }

  return (result);
}
 800438e:	4770      	bx	lr
 8004390:	0801a1a8 	.word	0x0801a1a8

08004394 <RI_GetPtrReg>:

    MCI_Handle_t *pMCIN = &Mci[0];
    uint16_t regID = dataID & REG_MASK;
    uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;

    switch (typeID)
 8004394:	f000 0338 	and.w	r3, r0, #56	; 0x38
 8004398:	2b10      	cmp	r3, #16
 800439a:	d003      	beq.n	80043a4 <RI_GetPtrReg+0x10>
 800439c:	4a4d      	ldr	r2, [pc, #308]	; (80044d4 <RI_GetPtrReg+0x140>)
          }

          default:
          {
            *dataPtr = &nullData16;
            retVal = MCP_ERROR_UNKNOWN_REG;
 800439e:	2005      	movs	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 80043a0:	600a      	str	r2, [r1, #0]
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 80043a2:	4770      	bx	lr
    uint16_t regID = dataID & REG_MASK;
 80043a4:	f020 0007 	bic.w	r0, r0, #7
 80043a8:	f5b0 6f21 	cmp.w	r0, #2576	; 0xa10
 80043ac:	b283      	uxth	r3, r0
 80043ae:	f000 8082 	beq.w	80044b6 <RI_GetPtrReg+0x122>
 80043b2:	d811      	bhi.n	80043d8 <RI_GetPtrReg+0x44>
 80043b4:	f5b3 6f0d 	cmp.w	r3, #2256	; 0x8d0
 80043b8:	f000 8082 	beq.w	80044c0 <RI_GetPtrReg+0x12c>
 80043bc:	d929      	bls.n	8004412 <RI_GetPtrReg+0x7e>
 80043be:	f5b3 6f19 	cmp.w	r3, #2448	; 0x990
 80043c2:	f000 8082 	beq.w	80044ca <RI_GetPtrReg+0x136>
 80043c6:	d919      	bls.n	80043fc <RI_GetPtrReg+0x68>
 80043c8:	f5b3 6f1d 	cmp.w	r3, #2512	; 0x9d0
 80043cc:	d1e6      	bne.n	800439c <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 80043ce:	4b42      	ldr	r3, [pc, #264]	; (80044d8 <RI_GetPtrReg+0x144>)
 80043d0:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80043d2:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 80043d4:	3216      	adds	r2, #22
            break;
 80043d6:	e7e3      	b.n	80043a0 <RI_GetPtrReg+0xc>
 80043d8:	f5b3 6f35 	cmp.w	r3, #2896	; 0xb50
 80043dc:	d055      	beq.n	800448a <RI_GetPtrReg+0xf6>
 80043de:	d82f      	bhi.n	8004440 <RI_GetPtrReg+0xac>
 80043e0:	f5b3 6f2d 	cmp.w	r3, #2768	; 0xad0
 80043e4:	d04e      	beq.n	8004484 <RI_GetPtrReg+0xf0>
 80043e6:	d920      	bls.n	800442a <RI_GetPtrReg+0x96>
 80043e8:	483c      	ldr	r0, [pc, #240]	; (80044dc <RI_GetPtrReg+0x148>)
 80043ea:	4a3a      	ldr	r2, [pc, #232]	; (80044d4 <RI_GetPtrReg+0x140>)
 80043ec:	f5b3 6f31 	cmp.w	r3, #2832	; 0xb10
 80043f0:	bf0a      	itet	eq
 80043f2:	4602      	moveq	r2, r0
 80043f4:	2005      	movne	r0, #5
 80043f6:	2000      	moveq	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 80043f8:	600a      	str	r2, [r1, #0]
}
 80043fa:	4770      	bx	lr
 80043fc:	f5b3 6f11 	cmp.w	r3, #2320	; 0x910
 8004400:	d04b      	beq.n	800449a <RI_GetPtrReg+0x106>
 8004402:	f5b3 6f15 	cmp.w	r3, #2384	; 0x950
 8004406:	d1c9      	bne.n	800439c <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 8004408:	4b33      	ldr	r3, [pc, #204]	; (80044d8 <RI_GetPtrReg+0x144>)
 800440a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800440c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 800440e:	3210      	adds	r2, #16
            break;
 8004410:	e7c6      	b.n	80043a0 <RI_GetPtrReg+0xc>
 8004412:	f5b3 6f05 	cmp.w	r3, #2128	; 0x850
 8004416:	d03b      	beq.n	8004490 <RI_GetPtrReg+0xfc>
 8004418:	d91c      	bls.n	8004454 <RI_GetPtrReg+0xc0>
 800441a:	f5b3 6f09 	cmp.w	r3, #2192	; 0x890
 800441e:	d1bd      	bne.n	800439c <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 8004420:	4b2d      	ldr	r3, [pc, #180]	; (80044d8 <RI_GetPtrReg+0x144>)
 8004422:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004424:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 8004426:	3206      	adds	r2, #6
            break;
 8004428:	e7ba      	b.n	80043a0 <RI_GetPtrReg+0xc>
 800442a:	f5b3 6f25 	cmp.w	r3, #2640	; 0xa50
 800442e:	d039      	beq.n	80044a4 <RI_GetPtrReg+0x110>
 8004430:	f5b3 6f29 	cmp.w	r3, #2704	; 0xa90
 8004434:	d1b2      	bne.n	800439c <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 8004436:	4b28      	ldr	r3, [pc, #160]	; (80044d8 <RI_GetPtrReg+0x144>)
 8004438:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800443a:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 800443c:	321c      	adds	r2, #28
            break;
 800443e:	e7af      	b.n	80043a0 <RI_GetPtrReg+0xc>
 8004440:	f5b3 6f45 	cmp.w	r3, #3152	; 0xc50
 8004444:	d01b      	beq.n	800447e <RI_GetPtrReg+0xea>
 8004446:	f5b3 6f49 	cmp.w	r3, #3216	; 0xc90
 800444a:	d10e      	bne.n	800446a <RI_GetPtrReg+0xd6>
 800444c:	4a24      	ldr	r2, [pc, #144]	; (80044e0 <RI_GetPtrReg+0x14c>)
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 800444e:	600a      	str	r2, [r1, #0]
  uint8_t retVal = MCP_CMD_OK;
 8004450:	2000      	movs	r0, #0
}
 8004452:	4770      	bx	lr
 8004454:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8004458:	d029      	beq.n	80044ae <RI_GetPtrReg+0x11a>
 800445a:	f5b3 6f01 	cmp.w	r3, #2064	; 0x810
 800445e:	d19d      	bne.n	800439c <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004460:	4b1d      	ldr	r3, [pc, #116]	; (80044d8 <RI_GetPtrReg+0x144>)
 8004462:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004464:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004466:	3202      	adds	r2, #2
            break;
 8004468:	e79a      	b.n	80043a0 <RI_GetPtrReg+0xc>
 800446a:	481e      	ldr	r0, [pc, #120]	; (80044e4 <RI_GetPtrReg+0x150>)
 800446c:	4a19      	ldr	r2, [pc, #100]	; (80044d4 <RI_GetPtrReg+0x140>)
 800446e:	f5b3 6f39 	cmp.w	r3, #2960	; 0xb90
 8004472:	bf0a      	itet	eq
 8004474:	4602      	moveq	r2, r0
 8004476:	2005      	movne	r0, #5
 8004478:	2000      	moveq	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 800447a:	600a      	str	r2, [r1, #0]
}
 800447c:	4770      	bx	lr
 800447e:	4a1a      	ldr	r2, [pc, #104]	; (80044e8 <RI_GetPtrReg+0x154>)
  uint8_t retVal = MCP_CMD_OK;
 8004480:	2000      	movs	r0, #0
 8004482:	e78d      	b.n	80043a0 <RI_GetPtrReg+0xc>
 8004484:	4a19      	ldr	r2, [pc, #100]	; (80044ec <RI_GetPtrReg+0x158>)
 8004486:	2000      	movs	r0, #0
 8004488:	e78a      	b.n	80043a0 <RI_GetPtrReg+0xc>
 800448a:	4a19      	ldr	r2, [pc, #100]	; (80044f0 <RI_GetPtrReg+0x15c>)
 800448c:	2000      	movs	r0, #0
 800448e:	e787      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 8004490:	4b11      	ldr	r3, [pc, #68]	; (80044d8 <RI_GetPtrReg+0x144>)
 8004492:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004494:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 8004496:	3204      	adds	r2, #4
            break;
 8004498:	e782      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 800449a:	4b0f      	ldr	r3, [pc, #60]	; (80044d8 <RI_GetPtrReg+0x144>)
 800449c:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800449e:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 80044a0:	320e      	adds	r2, #14
            break;
 80044a2:	e77d      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 80044a4:	4b0c      	ldr	r3, [pc, #48]	; (80044d8 <RI_GetPtrReg+0x144>)
 80044a6:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80044a8:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 80044aa:	321a      	adds	r2, #26
            break;
 80044ac:	e778      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80044ae:	4b0a      	ldr	r3, [pc, #40]	; (80044d8 <RI_GetPtrReg+0x144>)
  uint8_t retVal = MCP_CMD_OK;
 80044b0:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 80044b2:	685a      	ldr	r2, [r3, #4]
             break;
 80044b4:	e774      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 80044b6:	4b08      	ldr	r3, [pc, #32]	; (80044d8 <RI_GetPtrReg+0x144>)
 80044b8:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80044ba:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 80044bc:	3218      	adds	r2, #24
            break;
 80044be:	e76f      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 80044c0:	4b05      	ldr	r3, [pc, #20]	; (80044d8 <RI_GetPtrReg+0x144>)
 80044c2:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80044c4:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 80044c6:	320c      	adds	r2, #12
            break;
 80044c8:	e76a      	b.n	80043a0 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 80044ca:	4b03      	ldr	r3, [pc, #12]	; (80044d8 <RI_GetPtrReg+0x144>)
 80044cc:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80044ce:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 80044d0:	3212      	adds	r2, #18
            break;
 80044d2:	e765      	b.n	80043a0 <RI_GetPtrReg+0xc>
 80044d4:	20002dc8 	.word	0x20002dc8
 80044d8:	20001a90 	.word	0x20001a90
 80044dc:	20000030 	.word	0x20000030
 80044e0:	20000282 	.word	0x20000282
 80044e4:	2000021c 	.word	0x2000021c
 80044e8:	20000280 	.word	0x20000280
 80044ec:	20000028 	.word	0x20000028
 80044f0:	20000214 	.word	0x20000214

080044f4 <RCM_RegisterRegConv>:

    /* Parse the array to be sure that same
     * conversion does not already exist*/
    while (i < RCM_MAX_CONV)
    {
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044f4:	4980      	ldr	r1, [pc, #512]	; (80046f8 <RCM_RegisterRegConv+0x204>)
 80044f6:	680b      	ldr	r3, [r1, #0]
{
 80044f8:	b570      	push	{r4, r5, r6, lr}
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044fa:	2b00      	cmp	r3, #0
 80044fc:	f000 8094 	beq.w	8004628 <RCM_RegisterRegConv+0x134>
        /* Nothing to do */
      }
      /* Ticket 64042 : If RCM_handle_array [i] is null access to data member will cause Memory Fault */
      if (RCM_handle_array [i] != 0)
      {
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004500:	f890 c004 	ldrb.w	ip, [r0, #4]
 8004504:	791a      	ldrb	r2, [r3, #4]
 8004506:	4594      	cmp	ip, r2
 8004508:	d027      	beq.n	800455a <RCM_RegisterRegConv+0x66>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800450a:	684a      	ldr	r2, [r1, #4]
 800450c:	2a00      	cmp	r2, #0
 800450e:	f000 80a6 	beq.w	800465e <RCM_RegisterRegConv+0x16a>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004512:	7914      	ldrb	r4, [r2, #4]
 8004514:	4564      	cmp	r4, ip
  uint8_t handle = 255U;
 8004516:	f04f 03ff 	mov.w	r3, #255	; 0xff
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800451a:	f000 808e 	beq.w	800463a <RCM_RegisterRegConv+0x146>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800451e:	688c      	ldr	r4, [r1, #8]
 8004520:	2c00      	cmp	r4, #0
 8004522:	f000 80c0 	beq.w	80046a6 <RCM_RegisterRegConv+0x1b2>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004526:	7922      	ldrb	r2, [r4, #4]
 8004528:	4562      	cmp	r2, ip
 800452a:	f000 808f 	beq.w	800464c <RCM_RegisterRegConv+0x158>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800452e:	68ca      	ldr	r2, [r1, #12]
 8004530:	2a00      	cmp	r2, #0
 8004532:	f000 80c1 	beq.w	80046b8 <RCM_RegisterRegConv+0x1c4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004536:	7914      	ldrb	r4, [r2, #4]
 8004538:	4564      	cmp	r4, ip
 800453a:	f000 809c 	beq.w	8004676 <RCM_RegisterRegConv+0x182>
    while (i < RCM_MAX_CONV)
 800453e:	f04f 0200 	mov.w	r2, #0
 8004542:	f363 0207 	bfi	r2, r3, #0, #8
 8004546:	f363 220f 	bfi	r2, r3, #8, #8
      {
        /* Nothing to do */
      }
      i++;
    }
    if (handle < RCM_MAX_CONV)
 800454a:	2b03      	cmp	r3, #3
 800454c:	4614      	mov	r4, r2
 800454e:	bf88      	it	hi
 8004550:	23ff      	movhi	r3, #255	; 0xff
 8004552:	f240 80ce 	bls.w	80046f2 <RCM_RegisterRegConv+0x1fe>
      /* Nothing to do handle is already set to error value : 255 */
    }
#ifdef NULL_PTR_CHECK_REG_CON_MNG
  }
#endif
  regConv->convHandle = handle;
 8004556:	7303      	strb	r3, [r0, #12]
}
 8004558:	bd70      	pop	{r4, r5, r6, pc}
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800455a:	6802      	ldr	r2, [r0, #0]
 800455c:	681b      	ldr	r3, [r3, #0]
 800455e:	429a      	cmp	r2, r3
 8004560:	d1d3      	bne.n	800450a <RCM_RegisterRegConv+0x16>
    uint8_t i = 0;
 8004562:	2300      	movs	r3, #0
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8004564:	461c      	mov	r4, r3
      RCM_handle_array [handle] = regConv;
 8004566:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 800456a:	4d64      	ldr	r5, [pc, #400]	; (80046fc <RCM_RegisterRegConv+0x208>)
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800456c:	6891      	ldr	r1, [r2, #8]
 800456e:	2600      	movs	r6, #0
 8004570:	f845 6033 	str.w	r6, [r5, r3, lsl #3]
 8004574:	07ce      	lsls	r6, r1, #31
 8004576:	d422      	bmi.n	80045be <RCM_RegisterRegConv+0xca>
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 8004578:	6851      	ldr	r1, [r2, #4]
 800457a:	f021 0104 	bic.w	r1, r1, #4
 800457e:	6051      	str	r1, [r2, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8004580:	2104      	movs	r1, #4
 8004582:	6011      	str	r1, [r2, #0]
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 8004584:	6851      	ldr	r1, [r2, #4]
 8004586:	f021 0120 	bic.w	r1, r1, #32
 800458a:	6051      	str	r1, [r2, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 800458c:	2120      	movs	r1, #32
 800458e:	6011      	str	r1, [r2, #0]
  MODIFY_REG(ADCx->CR,
 8004590:	6891      	ldr	r1, [r2, #8]
 8004592:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 8004596:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 800459a:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 800459e:	6091      	str	r1, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 80045a0:	6891      	ldr	r1, [r2, #8]
 80045a2:	2900      	cmp	r1, #0
 80045a4:	dbfc      	blt.n	80045a0 <RCM_RegisterRegConv+0xac>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 80045a6:	6811      	ldr	r1, [r2, #0]
 80045a8:	07cd      	lsls	r5, r1, #31
 80045aa:	d408      	bmi.n	80045be <RCM_RegisterRegConv+0xca>
  MODIFY_REG(ADCx->CR,
 80045ac:	4d54      	ldr	r5, [pc, #336]	; (8004700 <RCM_RegisterRegConv+0x20c>)
 80045ae:	6891      	ldr	r1, [r2, #8]
 80045b0:	4029      	ands	r1, r5
 80045b2:	f041 0101 	orr.w	r1, r1, #1
 80045b6:	6091      	str	r1, [r2, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 80045b8:	6811      	ldr	r1, [r2, #0]
 80045ba:	07c9      	lsls	r1, r1, #31
 80045bc:	d5f7      	bpl.n	80045ae <RCM_RegisterRegConv+0xba>
      RCM_NoInj_array[handle].enable = false;
 80045be:	4d51      	ldr	r5, [pc, #324]	; (8004704 <RCM_RegisterRegConv+0x210>)
 80045c0:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80045c4:	0049      	lsls	r1, r1, #1
      RCM_NoInj_array[handle].prev = handle;
 80045c6:	eb05 0c01 	add.w	ip, r5, r1
      RCM_NoInj_array[handle].enable = false;
 80045ca:	f04f 0e00 	mov.w	lr, #0
 80045ce:	f805 e001 	strb.w	lr, [r5, r1]
      RCM_NoInj_array[handle].prev = handle;
 80045d2:	f8ac 4004 	strh.w	r4, [ip, #4]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 80045d6:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80045d8:	f021 010f 	bic.w	r1, r1, #15
 80045dc:	6311      	str	r1, [r2, #48]	; 0x30
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 80045de:	f890 c004 	ldrb.w	ip, [r0, #4]
 80045e2:	f1bc 0f09 	cmp.w	ip, #9
 80045e6:	d84f      	bhi.n	8004688 <RCM_RegisterRegConv+0x194>
 80045e8:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 80045ec:	ea4f 618c 	mov.w	r1, ip, lsl #26
 80045f0:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 80045f4:	2401      	movs	r4, #1
 80045f6:	fa04 f40c 	lsl.w	r4, r4, ip
 80045fa:	4321      	orrs	r1, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80045fc:	0dcc      	lsrs	r4, r1, #23
 80045fe:	f004 0404 	and.w	r4, r4, #4
 8004602:	f102 0514 	add.w	r5, r2, #20
  MODIFY_REG(*preg,
 8004606:	6886      	ldr	r6, [r0, #8]
 8004608:	592a      	ldr	r2, [r5, r4]
 800460a:	f3c1 5104 	ubfx	r1, r1, #20, #5
 800460e:	f04f 0e07 	mov.w	lr, #7
 8004612:	fa06 fc01 	lsl.w	ip, r6, r1
 8004616:	fa0e f101 	lsl.w	r1, lr, r1
 800461a:	ea22 0101 	bic.w	r1, r2, r1
 800461e:	ea41 010c 	orr.w	r1, r1, ip
 8004622:	5129      	str	r1, [r5, r4]
  regConv->convHandle = handle;
 8004624:	7303      	strb	r3, [r0, #12]
}
 8004626:	bd70      	pop	{r4, r5, r6, pc}
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8004628:	684a      	ldr	r2, [r1, #4]
 800462a:	2a00      	cmp	r2, #0
 800462c:	d04b      	beq.n	80046c6 <RCM_RegisterRegConv+0x1d2>
 800462e:	f890 c004 	ldrb.w	ip, [r0, #4]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004632:	7914      	ldrb	r4, [r2, #4]
 8004634:	4564      	cmp	r4, ip
 8004636:	f47f af72 	bne.w	800451e <RCM_RegisterRegConv+0x2a>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800463a:	6814      	ldr	r4, [r2, #0]
 800463c:	6802      	ldr	r2, [r0, #0]
 800463e:	4294      	cmp	r4, r2
 8004640:	f47f af6d 	bne.w	800451e <RCM_RegisterRegConv+0x2a>
      i++;
 8004644:	2301      	movs	r3, #1
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8004646:	f240 1401 	movw	r4, #257	; 0x101
 800464a:	e78c      	b.n	8004566 <RCM_RegisterRegConv+0x72>
 800464c:	6824      	ldr	r4, [r4, #0]
 800464e:	6802      	ldr	r2, [r0, #0]
 8004650:	4294      	cmp	r4, r2
 8004652:	f47f af6c 	bne.w	800452e <RCM_RegisterRegConv+0x3a>
      i++;
 8004656:	2302      	movs	r3, #2
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004658:	f240 2402 	movw	r4, #514	; 0x202
 800465c:	e783      	b.n	8004566 <RCM_RegisterRegConv+0x72>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800465e:	688c      	ldr	r4, [r1, #8]
      i++;
 8004660:	2301      	movs	r3, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8004662:	2c00      	cmp	r4, #0
 8004664:	f47f af5f 	bne.w	8004526 <RCM_RegisterRegConv+0x32>
 8004668:	68ca      	ldr	r2, [r1, #12]
 800466a:	2a00      	cmp	r2, #0
 800466c:	d03b      	beq.n	80046e6 <RCM_RegisterRegConv+0x1f2>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 800466e:	7915      	ldrb	r5, [r2, #4]
 8004670:	7904      	ldrb	r4, [r0, #4]
 8004672:	42a5      	cmp	r5, r4
 8004674:	d137      	bne.n	80046e6 <RCM_RegisterRegConv+0x1f2>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8004676:	6814      	ldr	r4, [r2, #0]
 8004678:	6802      	ldr	r2, [r0, #0]
 800467a:	4294      	cmp	r4, r2
 800467c:	f47f af5f 	bne.w	800453e <RCM_RegisterRegConv+0x4a>
      i++;
 8004680:	2303      	movs	r3, #3
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8004682:	f240 3403 	movw	r4, #771	; 0x303
 8004686:	e76e      	b.n	8004566 <RCM_RegisterRegConv+0x72>
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8004688:	f06f 011d 	mvn.w	r1, #29
 800468c:	2403      	movs	r4, #3
 800468e:	fb14 140c 	smlabb	r4, r4, ip, r1
 8004692:	2101      	movs	r1, #1
 8004694:	fa01 f10c 	lsl.w	r1, r1, ip
 8004698:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 800469c:	ea41 618c 	orr.w	r1, r1, ip, lsl #26
 80046a0:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80046a4:	e7aa      	b.n	80045fc <RCM_RegisterRegConv+0x108>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80046a6:	2b04      	cmp	r3, #4
 80046a8:	d913      	bls.n	80046d2 <RCM_RegisterRegConv+0x1de>
 80046aa:	68cb      	ldr	r3, [r1, #12]
 80046ac:	b113      	cbz	r3, 80046b4 <RCM_RegisterRegConv+0x1c0>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80046ae:	791a      	ldrb	r2, [r3, #4]
 80046b0:	4562      	cmp	r2, ip
 80046b2:	d010      	beq.n	80046d6 <RCM_RegisterRegConv+0x1e2>
 80046b4:	6802      	ldr	r2, [r0, #0]
 80046b6:	e7ce      	b.n	8004656 <RCM_RegisterRegConv+0x162>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80046b8:	2b04      	cmp	r3, #4
 80046ba:	d914      	bls.n	80046e6 <RCM_RegisterRegConv+0x1f2>
 80046bc:	6802      	ldr	r2, [r0, #0]
      i++;
 80046be:	2303      	movs	r3, #3
 80046c0:	f240 3403 	movw	r4, #771	; 0x303
 80046c4:	e74f      	b.n	8004566 <RCM_RegisterRegConv+0x72>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80046c6:	688c      	ldr	r4, [r1, #8]
 80046c8:	b11c      	cbz	r4, 80046d2 <RCM_RegisterRegConv+0x1de>
 80046ca:	f890 c004 	ldrb.w	ip, [r0, #4]
    uint8_t i = 0;
 80046ce:	4613      	mov	r3, r2
 80046d0:	e729      	b.n	8004526 <RCM_RegisterRegConv+0x32>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80046d2:	4623      	mov	r3, r4
 80046d4:	e7c8      	b.n	8004668 <RCM_RegisterRegConv+0x174>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80046d6:	681b      	ldr	r3, [r3, #0]
 80046d8:	6802      	ldr	r2, [r0, #0]
 80046da:	4293      	cmp	r3, r2
 80046dc:	d0d0      	beq.n	8004680 <RCM_RegisterRegConv+0x18c>
 80046de:	f240 2402 	movw	r4, #514	; 0x202
      i++;
 80046e2:	2302      	movs	r3, #2
 80046e4:	e73f      	b.n	8004566 <RCM_RegisterRegConv+0x72>
    while (i < RCM_MAX_CONV)
 80046e6:	f04f 0400 	mov.w	r4, #0
 80046ea:	f363 0407 	bfi	r4, r3, #0, #8
 80046ee:	f363 240f 	bfi	r4, r3, #8, #8
 80046f2:	6802      	ldr	r2, [r0, #0]
    if (handle < RCM_MAX_CONV)
 80046f4:	e737      	b.n	8004566 <RCM_RegisterRegConv+0x72>
 80046f6:	bf00      	nop
 80046f8:	20002e10 	.word	0x20002e10
 80046fc:	20002dcc 	.word	0x20002dcc
 8004700:	7fffffc0 	.word	0x7fffffc0
 8004704:	20002dec 	.word	0x20002dec

08004708 <RCM_ExecRegularConv>:
 * Otherwise, the latest stored conversion result will be returned.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
uint16_t RCM_ExecRegularConv (RegConv_t *regConv)
{
 8004708:	b510      	push	{r4, lr}
  uint16_t retVal;
  uint8_t handle = regConv->convHandle;
 800470a:	7b03      	ldrb	r3, [r0, #12]
  uint8_t formerNext;
  uint8_t i=0;
  uint8_t LastEnable = RCM_MAX_CONV;

  if (false == RCM_NoInj_array [handle].enable)
 800470c:	4a5e      	ldr	r2, [pc, #376]	; (8004888 <RCM_ExecRegularConv+0x180>)
 800470e:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 8004712:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8004716:	f812 1011 	ldrb.w	r1, [r2, r1, lsl #1]
 800471a:	2900      	cmp	r1, #0
 800471c:	d13c      	bne.n	8004798 <RCM_ExecRegularConv+0x90>
  {
    /* Find position in the list */
    while (i < RCM_MAX_CONV)
    {
      if (true == RCM_NoInj_array [i].enable)
 800471e:	7810      	ldrb	r0, [r2, #0]
 8004720:	b9a8      	cbnz	r0, 800474e <RCM_ExecRegularConv+0x46>
  uint8_t LastEnable = RCM_MAX_CONV;
 8004722:	2104      	movs	r1, #4
      if (true == RCM_NoInj_array [i].enable)
 8004724:	7990      	ldrb	r0, [r2, #6]
 8004726:	2800      	cmp	r0, #0
 8004728:	d07f      	beq.n	800482a <RCM_ExecRegularConv+0x122>
      {
        if (RCM_NoInj_array[i].next > handle)
 800472a:	7ad0      	ldrb	r0, [r2, #11]
 800472c:	4283      	cmp	r3, r0
 800472e:	f0c0 809b 	bcc.w	8004868 <RCM_ExecRegularConv+0x160>
      if (true == RCM_NoInj_array [i].enable)
 8004732:	7b11      	ldrb	r1, [r2, #12]
 8004734:	2900      	cmp	r1, #0
 8004736:	f000 809a 	beq.w	800486e <RCM_ExecRegularConv+0x166>
        if (RCM_NoInj_array[i].next > handle)
 800473a:	7c50      	ldrb	r0, [r2, #17]
 800473c:	4283      	cmp	r3, r0
 800473e:	f0c0 80a0 	bcc.w	8004882 <RCM_ExecRegularConv+0x17a>
      if (true == RCM_NoInj_array [i].enable)
 8004742:	7c91      	ldrb	r1, [r2, #18]
 8004744:	2900      	cmp	r1, #0
 8004746:	f040 8096 	bne.w	8004876 <RCM_ExecRegularConv+0x16e>
      }
      else
      {
        /* Nothing to do */
      }
      i++;
 800474a:	2102      	movs	r1, #2
 800474c:	e074      	b.n	8004838 <RCM_ExecRegularConv+0x130>
        if (RCM_NoInj_array[i].next > handle)
 800474e:	7950      	ldrb	r0, [r2, #5]
 8004750:	4298      	cmp	r0, r3
 8004752:	d9e7      	bls.n	8004724 <RCM_ExecRegularConv+0x1c>
      if (true == RCM_NoInj_array [i].enable)
 8004754:	468e      	mov	lr, r1
          RCM_NoInj_array[handle].next = formerNext;
 8004756:	eb0c 0403 	add.w	r4, ip, r3
 800475a:	eb02 0444 	add.w	r4, r2, r4, lsl #1
          RCM_NoInj_array[i].next = handle;
 800475e:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
          RCM_NoInj_array[handle].prev = i;
 8004762:	7121      	strb	r1, [r4, #4]
          RCM_NoInj_array[handle].next = formerNext;
 8004764:	7160      	strb	r0, [r4, #5]
      }
    }
    /* The handle is now linked with others, we can set the enable flag */
    RCM_NoInj_array[handle].enable = true;
    RCM_NoInj_array[handle].status = notvalid;
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004766:	4c49      	ldr	r4, [pc, #292]	; (800488c <RCM_ExecRegularConv+0x184>)
          RCM_NoInj_array[formerNext].prev = handle;
 8004768:	eb00 0040 	add.w	r0, r0, r0, lsl #1
          RCM_NoInj_array[i].next = handle;
 800476c:	eb02 0e4e 	add.w	lr, r2, lr, lsl #1
          RCM_NoInj_array[formerNext].prev = handle;
 8004770:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004774:	7821      	ldrb	r1, [r4, #0]
          RCM_NoInj_array[i].next = handle;
 8004776:	f88e 3005 	strb.w	r3, [lr, #5]
          RCM_NoInj_array[formerNext].prev = handle;
 800477a:	7103      	strb	r3, [r0, #4]
    RCM_NoInj_array[handle].enable = true;
 800477c:	eb0c 0003 	add.w	r0, ip, r3
 8004780:	f04f 0e01 	mov.w	lr, #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004784:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    RCM_NoInj_array[handle].enable = true;
 8004788:	f822 e010 	strh.w	lr, [r2, r0, lsl #1]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800478c:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8004790:	7849      	ldrb	r1, [r1, #1]
 8004792:	4571      	cmp	r1, lr
    {/* Select the new conversion to be the next scheduled only if a conversion is not ongoing */
      RCM_currentHandle = handle;
 8004794:	bf18      	it	ne
 8004796:	7023      	strbne	r3, [r4, #0]
  }
  else
  {
    /* Nothing to do the current handle is already scheduled */
  }
  if (false == PWM_Handle_M1.ADCRegularLocked)
 8004798:	493d      	ldr	r1, [pc, #244]	; (8004890 <RCM_ExecRegularConv+0x188>)
 800479a:	f891 10a0 	ldrb.w	r1, [r1, #160]	; 0xa0
 800479e:	2900      	cmp	r1, #0
 80047a0:	d133      	bne.n	800480a <RCM_ExecRegularConv+0x102>
  /* The ADC is free to be used asynchronously */
  {
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80047a2:	493c      	ldr	r1, [pc, #240]	; (8004894 <RCM_ExecRegularConv+0x18c>)
 80047a4:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80047a8:	790c      	ldrb	r4, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80047aa:	6808      	ldr	r0, [r1, #0]
 80047ac:	2c09      	cmp	r4, #9
 80047ae:	d931      	bls.n	8004814 <RCM_ExecRegularConv+0x10c>
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80047b0:	f06f 011d 	mvn.w	r1, #29
 80047b4:	f04f 0e03 	mov.w	lr, #3
 80047b8:	fb1e 1e04 	smlabb	lr, lr, r4, r1
 80047bc:	2101      	movs	r1, #1
 80047be:	40a1      	lsls	r1, r4
 80047c0:	ea41 510e 	orr.w	r1, r1, lr, lsl #20
 80047c4:	ea41 6184 	orr.w	r1, r1, r4, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80047c8:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  MODIFY_REG(*preg,
 80047cc:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80047ce:	0d09      	lsrs	r1, r1, #20
 80047d0:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
 80047d4:	f424 64f8 	bic.w	r4, r4, #1984	; 0x7c0
 80047d8:	4321      	orrs	r1, r4
 80047da:	6301      	str	r1, [r0, #48]	; 0x30
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 80047dc:	6c01      	ldr	r1, [r0, #64]	; 0x40
  MODIFY_REG(ADCx->CR,
 80047de:	6881      	ldr	r1, [r0, #8]
 80047e0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80047e4:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80047e8:	f041 0104 	orr.w	r1, r1, #4
 80047ec:	6081      	str	r1, [r0, #8]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 80047ee:	6801      	ldr	r1, [r0, #0]
 80047f0:	0749      	lsls	r1, r1, #29
 80047f2:	d5fc      	bpl.n	80047ee <RCM_ExecRegularConv+0xe6>
    {
      /* Nothing to do */
    }

    /* Read the "Regular" conversion (Not related to current sampling) */
    RCM_NoInj_array[handle].value = LL_ADC_REG_ReadConversionData12(RCM_handle_array[handle]->regADC);
 80047f4:	eb0c 0103 	add.w	r1, ip, r3
 80047f8:	eb02 0141 	add.w	r1, r2, r1, lsl #1
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 80047fc:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80047fe:	8048      	strh	r0, [r1, #2]
    RCM_currentHandle = RCM_NoInj_array[handle].next;
 8004800:	4822      	ldr	r0, [pc, #136]	; (800488c <RCM_ExecRegularConv+0x184>)
 8004802:	794c      	ldrb	r4, [r1, #5]
 8004804:	7004      	strb	r4, [r0, #0]
    RCM_NoInj_array[handle].status = valid;
 8004806:	2002      	movs	r0, #2
 8004808:	7048      	strb	r0, [r1, #1]
  }
  else
  {
    /* Nothing to do */
  }
  retVal = RCM_NoInj_array[handle].value;
 800480a:	449c      	add	ip, r3
 800480c:	eb02 024c 	add.w	r2, r2, ip, lsl #1
  return (retVal);
}
 8004810:	8850      	ldrh	r0, [r2, #2]
 8004812:	bd10      	pop	{r4, pc}
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 8004814:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 8004818:	06a1      	lsls	r1, r4, #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 800481a:	ea41 510e 	orr.w	r1, r1, lr, lsl #20
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 800481e:	f04f 0e01 	mov.w	lr, #1
 8004822:	fa0e f404 	lsl.w	r4, lr, r4
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8004826:	4321      	orrs	r1, r4
 8004828:	e7d0      	b.n	80047cc <RCM_ExecRegularConv+0xc4>
      if (true == RCM_NoInj_array [i].enable)
 800482a:	7b10      	ldrb	r0, [r2, #12]
 800482c:	2800      	cmp	r0, #0
 800482e:	d184      	bne.n	800473a <RCM_ExecRegularConv+0x32>
 8004830:	7c90      	ldrb	r0, [r2, #18]
 8004832:	bb00      	cbnz	r0, 8004876 <RCM_ExecRegularConv+0x16e>
       if (LastEnable != RCM_MAX_CONV )
 8004834:	2904      	cmp	r1, #4
 8004836:	d013      	beq.n	8004860 <RCM_ExecRegularConv+0x158>
         formerNext = RCM_NoInj_array[LastEnable].next;
 8004838:	eb01 0041 	add.w	r0, r1, r1, lsl #1
         RCM_NoInj_array[handle].next = formerNext;
 800483c:	eb0c 0403 	add.w	r4, ip, r3
 8004840:	eb02 0444 	add.w	r4, r2, r4, lsl #1
         formerNext = RCM_NoInj_array[LastEnable].next;
 8004844:	eb02 0040 	add.w	r0, r2, r0, lsl #1
         RCM_NoInj_array[handle].prev = LastEnable;
 8004848:	7121      	strb	r1, [r4, #4]
         formerNext = RCM_NoInj_array[LastEnable].next;
 800484a:	7941      	ldrb	r1, [r0, #5]
         RCM_NoInj_array[handle].next = formerNext;
 800484c:	7161      	strb	r1, [r4, #5]
         RCM_NoInj_array[formerNext].prev = handle;
 800484e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8004852:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004856:	4c0d      	ldr	r4, [pc, #52]	; (800488c <RCM_ExecRegularConv+0x184>)
         RCM_NoInj_array[formerNext].prev = handle;
 8004858:	710b      	strb	r3, [r1, #4]
         RCM_NoInj_array[LastEnable].next = handle;
 800485a:	7143      	strb	r3, [r0, #5]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800485c:	7821      	ldrb	r1, [r4, #0]
 800485e:	e78d      	b.n	800477c <RCM_ExecRegularConv+0x74>
         RCM_currentHandle = handle;
 8004860:	4c0a      	ldr	r4, [pc, #40]	; (800488c <RCM_ExecRegularConv+0x184>)
 8004862:	4619      	mov	r1, r3
 8004864:	7023      	strb	r3, [r4, #0]
    while (i < RCM_MAX_CONV)
 8004866:	e789      	b.n	800477c <RCM_ExecRegularConv+0x74>
      i++;
 8004868:	2101      	movs	r1, #1
      if (true == RCM_NoInj_array [i].enable)
 800486a:	468e      	mov	lr, r1
 800486c:	e773      	b.n	8004756 <RCM_ExecRegularConv+0x4e>
 800486e:	7c91      	ldrb	r1, [r2, #18]
 8004870:	b909      	cbnz	r1, 8004876 <RCM_ExecRegularConv+0x16e>
      i++;
 8004872:	2101      	movs	r1, #1
 8004874:	e7e0      	b.n	8004838 <RCM_ExecRegularConv+0x130>
        if (RCM_NoInj_array[i].next > handle)
 8004876:	7dd0      	ldrb	r0, [r2, #23]
 8004878:	4298      	cmp	r0, r3
      i++;
 800487a:	f04f 0103 	mov.w	r1, #3
        if (RCM_NoInj_array[i].next > handle)
 800487e:	d9db      	bls.n	8004838 <RCM_ExecRegularConv+0x130>
 8004880:	e768      	b.n	8004754 <RCM_ExecRegularConv+0x4c>
      i++;
 8004882:	2102      	movs	r1, #2
 8004884:	e766      	b.n	8004754 <RCM_ExecRegularConv+0x4c>
 8004886:	bf00      	nop
 8004888:	20002dec 	.word	0x20002dec
 800488c:	20002e0c 	.word	0x20002e0c
 8004890:	20000154 	.word	0x20000154
 8004894:	20002e10 	.word	0x20002e10

08004898 <RCM_ExecUserConv>:
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecUserConv()
{
  uint8_t handle;
  if (RCM_UserConvHandle != NULL)
 8004898:	4b14      	ldr	r3, [pc, #80]	; (80048ec <RCM_ExecUserConv+0x54>)
{
 800489a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCM_UserConvHandle != NULL)
 800489e:	681c      	ldr	r4, [r3, #0]
 80048a0:	b124      	cbz	r4, 80048ac <RCM_ExecUserConv+0x14>
  {
    handle = RCM_UserConvHandle->convHandle;
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 80048a2:	4d13      	ldr	r5, [pc, #76]	; (80048f0 <RCM_ExecUserConv+0x58>)
    handle = RCM_UserConvHandle->convHandle;
 80048a4:	7b26      	ldrb	r6, [r4, #12]
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 80048a6:	782b      	ldrb	r3, [r5, #0]
 80048a8:	2b01      	cmp	r3, #1
 80048aa:	d001      	beq.n	80048b0 <RCM_ExecUserConv+0x18>
  }
  else
  {
     /* Nothing to do */
  }
}
 80048ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 80048b0:	4620      	mov	r0, r4
 80048b2:	f7ff ff29 	bl	8004708 <RCM_ExecRegularConv>
 80048b6:	4b0f      	ldr	r3, [pc, #60]	; (80048f4 <RCM_ExecUserConv+0x5c>)
 80048b8:	8018      	strh	r0, [r3, #0]
      if (RCM_NoInj_array [handle].status != notvalid)
 80048ba:	4b0f      	ldr	r3, [pc, #60]	; (80048f8 <RCM_ExecUserConv+0x60>)
 80048bc:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 80048c0:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 80048c4:	4601      	mov	r1, r0
      if (RCM_NoInj_array [handle].status != notvalid)
 80048c6:	785b      	ldrb	r3, [r3, #1]
 80048c8:	b10b      	cbz	r3, 80048ce <RCM_ExecUserConv+0x36>
        RCM_UserConvState = RCM_USERCONV_EOC;
 80048ca:	2302      	movs	r3, #2
 80048cc:	702b      	strb	r3, [r5, #0]
      if (RCM_CB_array[handle].cb != NULL)
 80048ce:	4b0b      	ldr	r3, [pc, #44]	; (80048fc <RCM_ExecUserConv+0x64>)
 80048d0:	f853 7036 	ldr.w	r7, [r3, r6, lsl #3]
 80048d4:	2f00      	cmp	r7, #0
 80048d6:	d0e9      	beq.n	80048ac <RCM_ExecUserConv+0x14>
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 80048d8:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 80048dc:	4620      	mov	r0, r4
 80048de:	685a      	ldr	r2, [r3, #4]
        RCM_UserConvState = RCM_USERCONV_IDLE;
 80048e0:	2300      	movs	r3, #0
 80048e2:	702b      	strb	r3, [r5, #0]
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 80048e4:	463b      	mov	r3, r7
}
 80048e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 80048ea:	4718      	bx	r3
 80048ec:	20002e04 	.word	0x20002e04
 80048f0:	20002e08 	.word	0x20002e08
 80048f4:	20002e0a 	.word	0x20002e0a
 80048f8:	20002dec 	.word	0x20002dec
 80048fc:	20002dcc 	.word	0x20002dcc

08004900 <RCM_ExecNextConv>:
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecNextConv(void)
{
  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 8004900:	4b24      	ldr	r3, [pc, #144]	; (8004994 <RCM_ExecNextConv+0x94>)
 8004902:	4825      	ldr	r0, [pc, #148]	; (8004998 <RCM_ExecNextConv+0x98>)
 8004904:	781a      	ldrb	r2, [r3, #0]
 8004906:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800490a:	f810 3013 	ldrb.w	r3, [r0, r3, lsl #1]
 800490e:	b3a3      	cbz	r3, 800497a <RCM_ExecNextConv+0x7a>
    /* When this function is called, the ADC conversions triggered by External
       event for current reading has been completed.
       ADC is therefore ready to be started because already stopped */

    /* Clear EOC */
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8004910:	4b22      	ldr	r3, [pc, #136]	; (800499c <RCM_ExecNextConv+0x9c>)
{
 8004912:	b510      	push	{r4, lr}
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8004914:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004918:	6819      	ldr	r1, [r3, #0]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 800491a:	2404      	movs	r4, #4
 800491c:	600c      	str	r4, [r1, #0]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 800491e:	f893 c004 	ldrb.w	ip, [r3, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8004922:	f1bc 0f09 	cmp.w	ip, #9
 8004926:	ea4f 0e42 	mov.w	lr, r2, lsl #1
 800492a:	d927      	bls.n	800497c <RCM_ExecNextConv+0x7c>
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 800492c:	f06f 031d 	mvn.w	r3, #29
 8004930:	2403      	movs	r4, #3
 8004932:	fb14 340c 	smlabb	r4, r4, ip, r3
 8004936:	2301      	movs	r3, #1
 8004938:	fa03 f30c 	lsl.w	r3, r3, ip
 800493c:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
 8004940:	ea43 638c 	orr.w	r3, r3, ip, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8004944:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000

    (void)LL_ADC_REG_ReadConversionData12(RCM_handle_array[RCM_currentHandle]->regADC);

    /* Start ADC for regular conversion */
    LL_ADC_REG_StartConversion(RCM_handle_array[RCM_currentHandle]->regADC);
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 8004948:	4496      	add	lr, r2
  MODIFY_REG(*preg,
 800494a:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 800494c:	0d1b      	lsrs	r3, r3, #20
 800494e:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 8004952:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 8004956:	4313      	orrs	r3, r2
 8004958:	630b      	str	r3, [r1, #48]	; 0x30
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 800495a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  MODIFY_REG(ADCx->CR,
 800495c:	688b      	ldr	r3, [r1, #8]
 800495e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8004962:	eb00 004e 	add.w	r0, r0, lr, lsl #1
 8004966:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800496a:	f04f 0c01 	mov.w	ip, #1
 800496e:	f043 0304 	orr.w	r3, r3, #4
 8004972:	608b      	str	r3, [r1, #8]
 8004974:	f880 c001 	strb.w	ip, [r0, #1]
  }
  else
  {
    /* Nothing to do, conversion not enabled have already notvalid status */
  }
}
 8004978:	bd10      	pop	{r4, pc}
 800497a:	4770      	bx	lr
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 800497c:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8004980:	ea4f 638c 	mov.w	r3, ip, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8004984:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 8004988:	2401      	movs	r4, #1
 800498a:	fa04 f40c 	lsl.w	r4, r4, ip
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 800498e:	4323      	orrs	r3, r4
 8004990:	e7da      	b.n	8004948 <RCM_ExecNextConv+0x48>
 8004992:	bf00      	nop
 8004994:	20002e0c 	.word	0x20002e0c
 8004998:	20002dec 	.word	0x20002dec
 800499c:	20002e10 	.word	0x20002e10

080049a0 <RCM_ReadOngoingConv>:
 * and user conversion.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ReadOngoingConv(void)
{
 80049a0:	b510      	push	{r4, lr}
  uint32_t result;
  RCM_status_t status;

  status = RCM_NoInj_array[RCM_currentHandle].status;
 80049a2:	4814      	ldr	r0, [pc, #80]	; (80049f4 <RCM_ReadOngoingConv+0x54>)
  result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80049a4:	4a14      	ldr	r2, [pc, #80]	; (80049f8 <RCM_ReadOngoingConv+0x58>)
  status = RCM_NoInj_array[RCM_currentHandle].status;
 80049a6:	7803      	ldrb	r3, [r0, #0]
  result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80049a8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80049ac:	6814      	ldr	r4, [r2, #0]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 80049ae:	6822      	ldr	r2, [r4, #0]
 80049b0:	f012 0f04 	tst.w	r2, #4
  status = RCM_NoInj_array[RCM_currentHandle].status;
 80049b4:	ea4f 0143 	mov.w	r1, r3, lsl #1
 80049b8:	4a10      	ldr	r2, [pc, #64]	; (80049fc <RCM_ReadOngoingConv+0x5c>)
 80049ba:	d008      	beq.n	80049ce <RCM_ReadOngoingConv+0x2e>
 80049bc:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 80049c0:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
  if (( valid == status ) || ( notvalid == status ) || ( 0U == result ))
 80049c4:	f89c e001 	ldrb.w	lr, [ip, #1]
 80049c8:	f01e 0ffd 	tst.w	lr, #253	; 0xfd
 80049cc:	d105      	bne.n	80049da <RCM_ReadOngoingConv+0x3a>
    RCM_NoInj_array[RCM_currentHandle].status = valid;
    /* Restore back DMA configuration */
  }

  /* Prepare next conversion */
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 80049ce:	440b      	add	r3, r1
 80049d0:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 80049d4:	7953      	ldrb	r3, [r2, #5]
 80049d6:	7003      	strb	r3, [r0, #0]
}
 80049d8:	bd10      	pop	{r4, pc}
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 80049da:	440b      	add	r3, r1
 80049dc:	eb02 0243 	add.w	r2, r2, r3, lsl #1
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 80049e0:	6c24      	ldr	r4, [r4, #64]	; 0x40
 80049e2:	7953      	ldrb	r3, [r2, #5]
 80049e4:	f8ac 4002 	strh.w	r4, [ip, #2]
    RCM_NoInj_array[RCM_currentHandle].status = valid;
 80049e8:	2402      	movs	r4, #2
 80049ea:	f88c 4001 	strb.w	r4, [ip, #1]
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 80049ee:	7003      	strb	r3, [r0, #0]
}
 80049f0:	bd10      	pop	{r4, pc}
 80049f2:	bf00      	nop
 80049f4:	20002e0c 	.word	0x20002e0c
 80049f8:	20002e10 	.word	0x20002e10
 80049fc:	20002dec 	.word	0x20002dec

08004a00 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004a00:	4b0e      	ldr	r3, [pc, #56]	; (8004a3c <HAL_MspInit+0x3c>)
{
 8004a02:	b500      	push	{lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004a04:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004a06:	f042 0201 	orr.w	r2, r2, #1
 8004a0a:	661a      	str	r2, [r3, #96]	; 0x60
 8004a0c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 8004a0e:	b083      	sub	sp, #12
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004a10:	f002 0201 	and.w	r2, r2, #1
 8004a14:	9200      	str	r2, [sp, #0]
 8004a16:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8004a18:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004a1a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004a1e:	659a      	str	r2, [r3, #88]	; 0x58
 8004a20:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004a22:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004a26:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 8004a28:	2004      	movs	r0, #4
  __HAL_RCC_PWR_CLK_ENABLE();
 8004a2a:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 8004a2c:	f001 fcac 	bl	8006388 <HAL_NVIC_SetPriorityGrouping>
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8004a30:	b003      	add	sp, #12
 8004a32:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_PWREx_DisableUCPDDeadBattery();
 8004a36:	f001 bf9d 	b.w	8006974 <HAL_PWREx_DisableUCPDDeadBattery>
 8004a3a:	bf00      	nop
 8004a3c:	40021000 	.word	0x40021000

08004a40 <TIM5_IRQHandler>:
  * @brief This function handles TIM5 global interrupt.
  */
void TIM5_IRQHandler(void)
{
  /* USER CODE BEGIN TIM5_IRQn 0 */
  data_flag=1;
 8004a40:	4b02      	ldr	r3, [pc, #8]	; (8004a4c <TIM5_IRQHandler+0xc>)
  /* USER CODE END TIM5_IRQn 0 */
  HAL_TIM_IRQHandler(&htim5);
 8004a42:	4803      	ldr	r0, [pc, #12]	; (8004a50 <TIM5_IRQHandler+0x10>)
  data_flag=1;
 8004a44:	2201      	movs	r2, #1
 8004a46:	701a      	strb	r2, [r3, #0]
  HAL_TIM_IRQHandler(&htim5);
 8004a48:	f003 b9ca 	b.w	8007de0 <HAL_TIM_IRQHandler>
 8004a4c:	20001a6c 	.word	0x20001a6c
 8004a50:	20002f08 	.word	0x20002f08

08004a54 <ADC1_2_IRQHandler>:
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 8004a54:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8004a58:	2240      	movs	r2, #64	; 0x40
 8004a5a:	601a      	str	r2, [r3, #0]
  /* USER CODE END ADC1_2_IRQn 0 */

    /* Clear Flags M1 */
    LL_ADC_ClearFlag_JEOS(ADC1);

  (void)TSK_HighFrequencyTask();
 8004a5c:	f7fd bdfe 	b.w	800265c <TSK_HighFrequencyTask>

08004a60 <TIM1_UP_TIM16_IRQHandler>:
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8004a60:	4b03      	ldr	r3, [pc, #12]	; (8004a70 <TIM1_UP_TIM16_IRQHandler+0x10>)
 /* USER CODE BEGIN TIMx_UP_M1_IRQn 0 */

 /* USER CODE END  TIMx_UP_M1_IRQn 0 */

  LL_TIM_ClearFlag_UPDATE(TIM1);
  (void)R3_1_TIMx_UP_IRQHandler(&PWM_Handle_M1);
 8004a62:	4804      	ldr	r0, [pc, #16]	; (8004a74 <TIM1_UP_TIM16_IRQHandler+0x14>)
 8004a64:	f06f 0201 	mvn.w	r2, #1
 8004a68:	611a      	str	r2, [r3, #16]
 8004a6a:	f005 ba1f 	b.w	8009eac <R3_1_TIMx_UP_IRQHandler>
 8004a6e:	bf00      	nop
 8004a70:	40012c00 	.word	0x40012c00
 8004a74:	20000154 	.word	0x20000154

08004a78 <TIM1_BRK_TIM15_IRQHandler>:
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
 8004a78:	490c      	ldr	r1, [pc, #48]	; (8004aac <TIM1_BRK_TIM15_IRQHandler+0x34>)

 /* USER CODE END  TIMx_UP_M1_IRQn 1 */
}

void TIMx_BRK_M1_IRQHandler(void)
{
 8004a7a:	b508      	push	{r3, lr}
 8004a7c:	690b      	ldr	r3, [r1, #16]
 8004a7e:	061a      	lsls	r2, r3, #24
 8004a80:	d505      	bpl.n	8004a8e <TIM1_BRK_TIM15_IRQHandler+0x16>
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8004a82:	f06f 0380 	mvn.w	r3, #128	; 0x80
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 8004a86:	480a      	ldr	r0, [pc, #40]	; (8004ab0 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 8004a88:	610b      	str	r3, [r1, #16]
 8004a8a:	f7fe fcbb 	bl	8003404 <PWMC_OVP_Handler>
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK2(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8004a8e:	4907      	ldr	r1, [pc, #28]	; (8004aac <TIM1_BRK_TIM15_IRQHandler+0x34>)
 8004a90:	690b      	ldr	r3, [r1, #16]
 8004a92:	05db      	lsls	r3, r3, #23
 8004a94:	d505      	bpl.n	8004aa2 <TIM1_BRK_TIM15_IRQHandler+0x2a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8004a96:	f46f 7380 	mvn.w	r3, #256	; 0x100
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK2(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 8004a9a:	4805      	ldr	r0, [pc, #20]	; (8004ab0 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 8004a9c:	610b      	str	r3, [r1, #16]
 8004a9e:	f7fe fcb1 	bl	8003404 <PWMC_OVP_Handler>
  MC_Scheduler();

  /* USER CODE BEGIN TIMx_BRK_M1_IRQn 1 */

  /* USER CODE END TIMx_BRK_M1_IRQn 1 */
}
 8004aa2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MC_Scheduler();
 8004aa6:	f7fd bd93 	b.w	80025d0 <MC_Scheduler>
 8004aaa:	bf00      	nop
 8004aac:	40012c00 	.word	0x40012c00
 8004ab0:	20000154 	.word	0x20000154

08004ab4 <TIM2_IRQHandler>:
  /* USER CODE BEGIN SPD_TIM_M1_IRQn 0 */

  /* USER CODE END SPD_TIM_M1_IRQn 0 */

 /* Encoder Timer UPDATE IT is dynamicaly enabled/disabled, checking enable state is required */
  if (LL_TIM_IsEnabledIT_UPDATE (ENCODER_M1.TIMx) != 0U)
 8004ab4:	4806      	ldr	r0, [pc, #24]	; (8004ad0 <TIM2_IRQHandler+0x1c>)
 8004ab6:	6a03      	ldr	r3, [r0, #32]
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
 8004ab8:	68da      	ldr	r2, [r3, #12]
 8004aba:	07d1      	lsls	r1, r2, #31
 8004abc:	d507      	bpl.n	8004ace <TIM2_IRQHandler+0x1a>
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8004abe:	691a      	ldr	r2, [r3, #16]
 8004ac0:	07d2      	lsls	r2, r2, #31
 8004ac2:	d504      	bpl.n	8004ace <TIM2_IRQHandler+0x1a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8004ac4:	f06f 0201 	mvn.w	r2, #1
 8004ac8:	611a      	str	r2, [r3, #16]
  {
    if (LL_TIM_IsActiveFlag_UPDATE (ENCODER_M1.TIMx) != 0U)
    {
      LL_TIM_ClearFlag_UPDATE(ENCODER_M1.TIMx);
      (void)ENC_IRQHandler(&ENCODER_M1);
 8004aca:	f004 b9dd 	b.w	8008e88 <ENC_IRQHandler>
    /* No other IT to manage for encoder config */
  }
  /* USER CODE BEGIN SPD_TIM_M1_IRQn 1 */

  /* USER CODE END SPD_TIM_M1_IRQn 1 */
}
 8004ace:	4770      	bx	lr
 8004ad0:	20000024 	.word	0x20000024

08004ad4 <DMA1_Channel1_IRQHandler>:
}

//cstat !MISRAC2012-Rule-8.13
__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC(DMA_TypeDef *DMAx, uint32_t Channel)
{
  return ((NULL == DMAx) ? 0U : ((READ_BIT(DMAx->ISR,
 8004ad4:	4b04      	ldr	r3, [pc, #16]	; (8004ae8 <DMA1_Channel1_IRQHandler+0x14>)
 8004ad6:	681a      	ldr	r2, [r3, #0]
 8004ad8:	0792      	lsls	r2, r2, #30
 8004ada:	d400      	bmi.n	8004ade <DMA1_Channel1_IRQHandler+0xa>
  }
  /* USER CODE BEGIN DMA1_Channel1_IRQHandler 1 */

  /* USER CODE BEGIN DMA1_Channel1_IRQHandler 1 */

}
 8004adc:	4770      	bx	lr
    WRITE_REG (DMAx->IFCR, DMA_IFCR_CTCIF1 << ((Channel-LL_DMA_CHANNEL_1)<<2));
 8004ade:	2202      	movs	r2, #2
    ASPEP_HWDataReceivedIT (&aspepOverUartA);
 8004ae0:	4802      	ldr	r0, [pc, #8]	; (8004aec <DMA1_Channel1_IRQHandler+0x18>)
 8004ae2:	605a      	str	r2, [r3, #4]
 8004ae4:	f7fc be40 	b.w	8001768 <ASPEP_HWDataReceivedIT>
 8004ae8:	40020000 	.word	0x40020000
 8004aec:	20000450 	.word	0x20000450

08004af0 <USART2_IRQHandler>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
 8004af0:	4b42      	ldr	r3, [pc, #264]	; (8004bfc <USART2_IRQHandler+0x10c>)
 8004af2:	69da      	ldr	r2, [r3, #28]
 8004af4:	0652      	lsls	r2, r2, #25
  * @brief  This function handles USART interrupt request.
  * @param  None
  */
//cstat !MISRAC2012-Rule-8.4
void USART2_IRQHandler(void)
{
 8004af6:	b510      	push	{r4, lr}
 8004af8:	d509      	bpl.n	8004b0e <USART2_IRQHandler+0x1e>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8004afa:	4941      	ldr	r1, [pc, #260]	; (8004c00 <USART2_IRQHandler+0x110>)
    /* Disable the DMA channel to prepare the next chunck of data */
    LL_DMA_DisableChannel(DMA_TX_A, DMACH_TX_A);
    LL_USART_ClearFlag_TC (USARTA);
    /* Data Sent by UART */
    /* Need to free the buffer, and to check pending transfer */
    ASPEP_HWDataTransmittedIT (&aspepOverUartA);
 8004afc:	4841      	ldr	r0, [pc, #260]	; (8004c04 <USART2_IRQHandler+0x114>)
 8004afe:	69ca      	ldr	r2, [r1, #28]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004b00:	2440      	movs	r4, #64	; 0x40
 8004b02:	f022 0201 	bic.w	r2, r2, #1
 8004b06:	61ca      	str	r2, [r1, #28]
 8004b08:	621c      	str	r4, [r3, #32]
 8004b0a:	f7fc fc81 	bl	8001410 <ASPEP_HWDataTransmittedIT>
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8004b0e:	4b3b      	ldr	r3, [pc, #236]	; (8004bfc <USART2_IRQHandler+0x10c>)
 8004b10:	69d8      	ldr	r0, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8004b12:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8004b14:	69d9      	ldr	r1, [r3, #28]
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE)) ? 1UL : 0UL);
 8004b16:	689c      	ldr	r4, [r3, #8]
 8004b18:	07e4      	lsls	r4, r4, #31
 8004b1a:	d526      	bpl.n	8004b6a <USART2_IRQHandler+0x7a>
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8004b1c:	f002 0202 	and.w	r2, r2, #2
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8004b20:	f000 0008 	and.w	r0, r0, #8
  feFlag = LL_USART_IsActiveFlag_FE(USARTA);
  neFlag = LL_USART_IsActiveFlag_NE(USARTA);
  errorMask = LL_USART_IsEnabledIT_ERROR(USARTA);

  flags = ((oreFlag | feFlag | neFlag) & errorMask);
  if (0U == flags)
 8004b24:	4302      	orrs	r2, r0
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8004b26:	f001 0104 	and.w	r1, r1, #4
 8004b2a:	430a      	orrs	r2, r1
 8004b2c:	d01d      	beq.n	8004b6a <USART2_IRQHandler+0x7a>
  {
    /* Nothing to do */
  }
  else
  { /* Stopping the debugger will generate an OverRun error */
    WRITE_REG(USARTA->ICR, USART_ICR_FECF|USART_ICR_ORECF|USART_ICR_NECF);
 8004b2e:	220e      	movs	r2, #14
 8004b30:	621a      	str	r2, [r3, #32]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b32:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b36:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004b3a:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8004b3e:	f023 0301 	bic.w	r3, r3, #1
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b42:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004b46:	e840 3100 	strex	r1, r3, [r0]
 8004b4a:	2900      	cmp	r1, #0
 8004b4c:	d1f3      	bne.n	8004b36 <USART2_IRQHandler+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b4e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b52:	f502 6380 	add.w	r3, r2, #1024	; 0x400
 8004b56:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004b5a:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b5e:	f502 6080 	add.w	r0, r2, #1024	; 0x400
 8004b62:	e840 3100 	strex	r1, r3, [r0]
 8004b66:	2900      	cmp	r1, #0
 8004b68:	d1f3      	bne.n	8004b52 <USART2_IRQHandler+0x62>
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8004b6a:	4b24      	ldr	r3, [pc, #144]	; (8004bfc <USART2_IRQHandler+0x10c>)
 8004b6c:	69da      	ldr	r2, [r3, #28]
 8004b6e:	06d2      	lsls	r2, r2, #27
 8004b70:	d541      	bpl.n	8004bf6 <USART2_IRQHandler+0x106>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8004b72:	681b      	ldr	r3, [r3, #0]
 8004b74:	06db      	lsls	r3, r3, #27
 8004b76:	d53f      	bpl.n	8004bf8 <USART2_IRQHandler+0x108>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b78:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b7c:	f502 6380 	add.w	r3, r2, #1024	; 0x400
 8004b80:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004b84:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b88:	f502 6080 	add.w	r0, r2, #1024	; 0x400
 8004b8c:	e840 3100 	strex	r1, r3, [r0]
 8004b90:	2900      	cmp	r1, #0
 8004b92:	d1f3      	bne.n	8004b7c <USART2_IRQHandler+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b94:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b98:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004b9c:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8004ba0:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004ba4:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004ba8:	e840 3100 	strex	r1, r3, [r0]
 8004bac:	2900      	cmp	r1, #0
 8004bae:	d1f3      	bne.n	8004b98 <USART2_IRQHandler+0xa8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004bb0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004bb4:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004bb8:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
{
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004bbc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004bc0:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004bc4:	e840 3100 	strex	r1, r3, [r0]
 8004bc8:	2900      	cmp	r1, #0
 8004bca:	d1f3      	bne.n	8004bb4 <USART2_IRQHandler+0xc4>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 8004bcc:	4b0b      	ldr	r3, [pc, #44]	; (8004bfc <USART2_IRQHandler+0x10c>)
 8004bce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004bd0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004bd4:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004bd8:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004bdc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004be0:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004be4:	e840 3100 	strex	r1, r3, [r0]
 8004be8:	2900      	cmp	r1, #0
 8004bea:	d1f3      	bne.n	8004bd4 <USART2_IRQHandler+0xe4>
  }

  /* USER CODE BEGIN USART2_IRQHandler 1 */

  /* USER CODE END USART2_IRQHandler 1 */
}
 8004bec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ASPEP_HWDMAReset (&aspepOverUartA);
 8004bf0:	4804      	ldr	r0, [pc, #16]	; (8004c04 <USART2_IRQHandler+0x114>)
 8004bf2:	f7fc be07 	b.w	8001804 <ASPEP_HWDMAReset>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8004bf6:	681b      	ldr	r3, [r3, #0]
}
 8004bf8:	bd10      	pop	{r4, pc}
 8004bfa:	bf00      	nop
 8004bfc:	40004400 	.word	0x40004400
 8004c00:	40020000 	.word	0x40020000
 8004c04:	20000450 	.word	0x20000450

08004c08 <HardFault_Handler>:
/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  */
void HardFault_Handler(void)
{
 8004c08:	b508      	push	{r3, lr}
 /* USER CODE BEGIN HardFault_IRQn 0 */

 /* USER CODE END HardFault_IRQn 0 */
  TSK_HardwareFaultTask();
 8004c0a:	f7fd fe2d 	bl	8002868 <TSK_HardwareFaultTask>

  /* Go to infinite loop when Hard Fault exception occurs */
  while (true)
 8004c0e:	e7fe      	b.n	8004c0e <HardFault_Handler+0x6>

08004c10 <SysTick_Handler>:
 /* USER CODE END HardFault_IRQn 1 */

}

void SysTick_Handler(void)
{
 8004c10:	b510      	push	{r4, lr}
#ifdef MC_HAL_IS_USED
static uint8_t SystickDividerCounter = SYSTICK_DIVIDER;
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  if (SystickDividerCounter == SYSTICK_DIVIDER)
 8004c12:	4c0a      	ldr	r4, [pc, #40]	; (8004c3c <SysTick_Handler+0x2c>)
 8004c14:	7823      	ldrb	r3, [r4, #0]
 8004c16:	2b02      	cmp	r3, #2
 8004c18:	d006      	beq.n	8004c28 <SysTick_Handler+0x18>
  {
    HAL_IncTick();
    HAL_SYSTICK_IRQHandler();
    SystickDividerCounter = 0;
  }
  SystickDividerCounter ++;
 8004c1a:	3301      	adds	r3, #1
 8004c1c:	b2db      	uxtb	r3, r3
 8004c1e:	7023      	strb	r3, [r4, #0]
  /* USER CODE END SysTick_IRQn 1 */
    MC_RunMotorControlTasks();

  /* USER CODE BEGIN SysTick_IRQn 2 */
  /* USER CODE END SysTick_IRQn 2 */
}
 8004c20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MC_RunMotorControlTasks();
 8004c24:	f7fd be14 	b.w	8002850 <MC_RunMotorControlTasks>
    HAL_IncTick();
 8004c28:	f000 fc04 	bl	8005434 <HAL_IncTick>
    HAL_SYSTICK_IRQHandler();
 8004c2c:	f001 fc26 	bl	800647c <HAL_SYSTICK_IRQHandler>
 8004c30:	2301      	movs	r3, #1
  SystickDividerCounter ++;
 8004c32:	7023      	strb	r3, [r4, #0]
}
 8004c34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MC_RunMotorControlTasks();
 8004c38:	f7fd be0a 	b.w	8002850 <MC_RunMotorControlTasks>
 8004c3c:	200014a0 	.word	0x200014a0

08004c40 <EXTI15_10_IRQHandler>:
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval @note This bit is set when the selected edge event arrives on the interrupt
  */
__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
{
  return (uint32_t)(READ_BIT(EXTI->PR1, ExtiLine));
 8004c40:	4b04      	ldr	r3, [pc, #16]	; (8004c54 <EXTI15_10_IRQHandler+0x14>)
 8004c42:	695a      	ldr	r2, [r3, #20]
  * @brief  This function handles Button IRQ on PIN PC13.
  */
void EXTI15_10_IRQHandler (void)
{
  /* USER CODE BEGIN START_STOP_BTN */
  if (0U == LL_EXTI_ReadFlag_0_31(LL_EXTI_LINE_13))
 8004c44:	0492      	lsls	r2, r2, #18
 8004c46:	d400      	bmi.n	8004c4a <EXTI15_10_IRQHandler+0xa>
  {
    LL_EXTI_ClearFlag_0_31 (LL_EXTI_LINE_13);
    (void)UI_HandleStartStopButton_cb ();
  }

}
 8004c48:	4770      	bx	lr
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
  WRITE_REG(EXTI->PR1, ExtiLine);
 8004c4a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8004c4e:	615a      	str	r2, [r3, #20]
    (void)UI_HandleStartStopButton_cb ();
 8004c50:	f7fd be1a 	b.w	8002888 <UI_HandleStartStopButton_cb>
 8004c54:	40010400 	.word	0x40010400

08004c58 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8004c58:	490c      	ldr	r1, [pc, #48]	; (8004c8c <_sbrk+0x34>)
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8004c5a:	4a0d      	ldr	r2, [pc, #52]	; (8004c90 <_sbrk+0x38>)
  if (NULL == __sbrk_heap_end)
 8004c5c:	680b      	ldr	r3, [r1, #0]
{
 8004c5e:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8004c60:	4c0c      	ldr	r4, [pc, #48]	; (8004c94 <_sbrk+0x3c>)
 8004c62:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8004c64:	b12b      	cbz	r3, 8004c72 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8004c66:	4418      	add	r0, r3
 8004c68:	4290      	cmp	r0, r2
 8004c6a:	d807      	bhi.n	8004c7c <_sbrk+0x24>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8004c6c:	6008      	str	r0, [r1, #0]

  return (void *)prev_heap_end;
}
 8004c6e:	4618      	mov	r0, r3
 8004c70:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8004c72:	4b09      	ldr	r3, [pc, #36]	; (8004c98 <_sbrk+0x40>)
 8004c74:	600b      	str	r3, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8004c76:	4418      	add	r0, r3
 8004c78:	4290      	cmp	r0, r2
 8004c7a:	d9f7      	bls.n	8004c6c <_sbrk+0x14>
    errno = ENOMEM;
 8004c7c:	f008 fda4 	bl	800d7c8 <__errno>
 8004c80:	230c      	movs	r3, #12
 8004c82:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8004c84:	f04f 33ff 	mov.w	r3, #4294967295
}
 8004c88:	4618      	mov	r0, r3
 8004c8a:	bd10      	pop	{r4, pc}
 8004c8c:	20002e20 	.word	0x20002e20
 8004c90:	20020000 	.word	0x20020000
 8004c94:	00000800 	.word	0x00000800
 8004c98:	200031f8 	.word	0x200031f8

08004c9c <MX_TIM2_Init>:
  HAL_TIM_MspPostInit(&htim1);

}
/* TIM2 init function */
void MX_TIM2_Init(void)
{
 8004c9c:	b510      	push	{r4, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8004c9e:	4819      	ldr	r0, [pc, #100]	; (8004d04 <MX_TIM2_Init+0x68>)
{
 8004ca0:	b08c      	sub	sp, #48	; 0x30
  htim2.Instance = TIM2;
 8004ca2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  TIM_Encoder_InitTypeDef sConfig = {0};
 8004ca6:	2300      	movs	r3, #0
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = M1_PULSE_NBR;
 8004ca8:	f640 71ff 	movw	r1, #4095	; 0xfff
  htim2.Instance = TIM2;
 8004cac:	6002      	str	r2, [r0, #0]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = M1_ENC_IC_FILTER;
 8004cae:	220c      	movs	r2, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8004cb0:	2401      	movs	r4, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004cb2:	e9cd 3300 	strd	r3, r3, [sp]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8004cb6:	e9c0 3301 	strd	r3, r3, [r0, #4]
  TIM_Encoder_InitTypeDef sConfig = {0};
 8004cba:	9304      	str	r3, [sp, #16]
 8004cbc:	9306      	str	r3, [sp, #24]
 8004cbe:	9308      	str	r3, [sp, #32]
 8004cc0:	930a      	str	r3, [sp, #40]	; 0x28
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004cc2:	9302      	str	r3, [sp, #8]
  htim2.Init.Period = M1_PULSE_NBR;
 8004cc4:	60c1      	str	r1, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004cc6:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004cc8:	6183      	str	r3, [r0, #24]
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = M1_ENC_IC_FILTER;
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8004cca:	eb0d 0102 	add.w	r1, sp, r2
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8004cce:	2303      	movs	r3, #3
 8004cd0:	9303      	str	r3, [sp, #12]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8004cd2:	9405      	str	r4, [sp, #20]
  sConfig.IC1Filter = M1_ENC_IC_FILTER;
 8004cd4:	9207      	str	r2, [sp, #28]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8004cd6:	9409      	str	r4, [sp, #36]	; 0x24
  sConfig.IC2Filter = M1_ENC_IC_FILTER;
 8004cd8:	920b      	str	r2, [sp, #44]	; 0x2c
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8004cda:	f002 fe3f 	bl	800795c <HAL_TIM_Encoder_Init>
 8004cde:	b948      	cbnz	r0, 8004cf4 <MX_TIM2_Init+0x58>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004ce0:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004ce2:	4808      	ldr	r0, [pc, #32]	; (8004d04 <MX_TIM2_Init+0x68>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004ce4:	9300      	str	r3, [sp, #0]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004ce6:	4669      	mov	r1, sp
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004ce8:	9302      	str	r3, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004cea:	f003 facf 	bl	800828c <HAL_TIMEx_MasterConfigSynchronization>
 8004cee:	b920      	cbnz	r0, 8004cfa <MX_TIM2_Init+0x5e>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 8004cf0:	b00c      	add	sp, #48	; 0x30
 8004cf2:	bd10      	pop	{r4, pc}
    Error_Handler();
 8004cf4:	f7fc ffa0 	bl	8001c38 <Error_Handler>
 8004cf8:	e7f2      	b.n	8004ce0 <MX_TIM2_Init+0x44>
    Error_Handler();
 8004cfa:	f7fc ff9d 	bl	8001c38 <Error_Handler>
}
 8004cfe:	b00c      	add	sp, #48	; 0x30
 8004d00:	bd10      	pop	{r4, pc}
 8004d02:	bf00      	nop
 8004d04:	20002e70 	.word	0x20002e70

08004d08 <MX_TIM3_Init>:
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 8004d08:	b500      	push	{lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8004d0a:	481b      	ldr	r0, [pc, #108]	; (8004d78 <MX_TIM3_Init+0x70>)
 8004d0c:	4a1b      	ldr	r2, [pc, #108]	; (8004d7c <MX_TIM3_Init+0x74>)
 8004d0e:	6002      	str	r2, [r0, #0]
{
 8004d10:	b089      	sub	sp, #36	; 0x24
  htim3.Init.Prescaler = 17000;
 8004d12:	f244 2268 	movw	r2, #17000	; 0x4268
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d16:	2300      	movs	r3, #0
  htim3.Init.Prescaler = 17000;
 8004d18:	6042      	str	r2, [r0, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8004d1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d1e:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004d22:	e9cd 3306 	strd	r3, r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004d26:	e9cd 3301 	strd	r3, r3, [sp, #4]
  htim3.Init.Period = 65535;
 8004d2a:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004d2e:	9303      	str	r3, [sp, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004d30:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004d32:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8004d34:	f002 fc4a 	bl	80075cc <HAL_TIM_Base_Init>
 8004d38:	b990      	cbnz	r0, 8004d60 <MX_TIM3_Init+0x58>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004d3a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8004d3e:	480e      	ldr	r0, [pc, #56]	; (8004d78 <MX_TIM3_Init+0x70>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004d40:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8004d42:	a904      	add	r1, sp, #16
 8004d44:	f002 feba 	bl	8007abc <HAL_TIM_ConfigClockSource>
 8004d48:	b990      	cbnz	r0, 8004d70 <MX_TIM3_Init+0x68>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d4a:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d4c:	480a      	ldr	r0, [pc, #40]	; (8004d78 <MX_TIM3_Init+0x70>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d4e:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d50:	a901      	add	r1, sp, #4
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004d52:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d54:	f003 fa9a 	bl	800828c <HAL_TIMEx_MasterConfigSynchronization>
 8004d58:	b928      	cbnz	r0, 8004d66 <MX_TIM3_Init+0x5e>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8004d5a:	b009      	add	sp, #36	; 0x24
 8004d5c:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d60:	f7fc ff6a 	bl	8001c38 <Error_Handler>
 8004d64:	e7e9      	b.n	8004d3a <MX_TIM3_Init+0x32>
    Error_Handler();
 8004d66:	f7fc ff67 	bl	8001c38 <Error_Handler>
}
 8004d6a:	b009      	add	sp, #36	; 0x24
 8004d6c:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d70:	f7fc ff62 	bl	8001c38 <Error_Handler>
 8004d74:	e7e9      	b.n	8004d4a <MX_TIM3_Init+0x42>
 8004d76:	bf00      	nop
 8004d78:	20002ebc 	.word	0x20002ebc
 8004d7c:	40000400 	.word	0x40000400

08004d80 <MX_TIM5_Init>:
/* TIM5 init function */
void MX_TIM5_Init(void)
{
 8004d80:	b500      	push	{lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
 8004d82:	481a      	ldr	r0, [pc, #104]	; (8004dec <MX_TIM5_Init+0x6c>)
 8004d84:	4a1a      	ldr	r2, [pc, #104]	; (8004df0 <MX_TIM5_Init+0x70>)
 8004d86:	6002      	str	r2, [r0, #0]
{
 8004d88:	b089      	sub	sp, #36	; 0x24
  htim5.Init.Prescaler = 170;
 8004d8a:	22aa      	movs	r2, #170	; 0xaa
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d8c:	2300      	movs	r3, #0
  htim5.Init.Prescaler = 170;
 8004d8e:	6042      	str	r2, [r0, #4]
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 10000;
 8004d90:	f242 7210 	movw	r2, #10000	; 0x2710
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d94:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004d98:	e9cd 3306 	strd	r3, r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004d9c:	e9cd 3301 	strd	r3, r3, [sp, #4]
  htim5.Init.Period = 10000;
 8004da0:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004da4:	9303      	str	r3, [sp, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004da6:	6103      	str	r3, [r0, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004da8:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8004daa:	f002 fc0f 	bl	80075cc <HAL_TIM_Base_Init>
 8004dae:	b990      	cbnz	r0, 8004dd6 <MX_TIM5_Init+0x56>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004db0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8004db4:	480d      	ldr	r0, [pc, #52]	; (8004dec <MX_TIM5_Init+0x6c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004db6:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8004db8:	a904      	add	r1, sp, #16
 8004dba:	f002 fe7f 	bl	8007abc <HAL_TIM_ConfigClockSource>
 8004dbe:	b990      	cbnz	r0, 8004de6 <MX_TIM5_Init+0x66>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004dc0:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004dc2:	480a      	ldr	r0, [pc, #40]	; (8004dec <MX_TIM5_Init+0x6c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004dc4:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004dc6:	a901      	add	r1, sp, #4
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004dc8:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004dca:	f003 fa5f 	bl	800828c <HAL_TIMEx_MasterConfigSynchronization>
 8004dce:	b928      	cbnz	r0, 8004ddc <MX_TIM5_Init+0x5c>
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */

}
 8004dd0:	b009      	add	sp, #36	; 0x24
 8004dd2:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004dd6:	f7fc ff2f 	bl	8001c38 <Error_Handler>
 8004dda:	e7e9      	b.n	8004db0 <MX_TIM5_Init+0x30>
    Error_Handler();
 8004ddc:	f7fc ff2c 	bl	8001c38 <Error_Handler>
}
 8004de0:	b009      	add	sp, #36	; 0x24
 8004de2:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004de6:	f7fc ff27 	bl	8001c38 <Error_Handler>
 8004dea:	e7e9      	b.n	8004dc0 <MX_TIM5_Init+0x40>
 8004dec:	20002f08 	.word	0x20002f08
 8004df0:	40000c00 	.word	0x40000c00

08004df4 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 8004df4:	b500      	push	{lr}

  if(tim_baseHandle->Instance==TIM1)
 8004df6:	4a1e      	ldr	r2, [pc, #120]	; (8004e70 <HAL_TIM_Base_MspInit+0x7c>)
 8004df8:	6803      	ldr	r3, [r0, #0]
 8004dfa:	4293      	cmp	r3, r2
{
 8004dfc:	b085      	sub	sp, #20
  if(tim_baseHandle->Instance==TIM1)
 8004dfe:	d015      	beq.n	8004e2c <HAL_TIM_Base_MspInit+0x38>
    __HAL_RCC_TIM1_CLK_ENABLE();
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM3)
 8004e00:	4a1c      	ldr	r2, [pc, #112]	; (8004e74 <HAL_TIM_Base_MspInit+0x80>)
 8004e02:	4293      	cmp	r3, r2
 8004e04:	d005      	beq.n	8004e12 <HAL_TIM_Base_MspInit+0x1e>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
 8004e06:	4a1c      	ldr	r2, [pc, #112]	; (8004e78 <HAL_TIM_Base_MspInit+0x84>)
 8004e08:	4293      	cmp	r3, r2
 8004e0a:	d01c      	beq.n	8004e46 <HAL_TIM_Base_MspInit+0x52>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}
 8004e0c:	b005      	add	sp, #20
 8004e0e:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM3_CLK_ENABLE();
 8004e12:	4b1a      	ldr	r3, [pc, #104]	; (8004e7c <HAL_TIM_Base_MspInit+0x88>)
 8004e14:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004e16:	f042 0202 	orr.w	r2, r2, #2
 8004e1a:	659a      	str	r2, [r3, #88]	; 0x58
 8004e1c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004e1e:	f003 0302 	and.w	r3, r3, #2
 8004e22:	9302      	str	r3, [sp, #8]
 8004e24:	9b02      	ldr	r3, [sp, #8]
}
 8004e26:	b005      	add	sp, #20
 8004e28:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM1_CLK_ENABLE();
 8004e2c:	4b13      	ldr	r3, [pc, #76]	; (8004e7c <HAL_TIM_Base_MspInit+0x88>)
 8004e2e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004e30:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8004e34:	661a      	str	r2, [r3, #96]	; 0x60
 8004e36:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004e38:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004e3c:	9301      	str	r3, [sp, #4]
 8004e3e:	9b01      	ldr	r3, [sp, #4]
}
 8004e40:	b005      	add	sp, #20
 8004e42:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004e46:	4b0d      	ldr	r3, [pc, #52]	; (8004e7c <HAL_TIM_Base_MspInit+0x88>)
 8004e48:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8004e4a:	f041 0108 	orr.w	r1, r1, #8
 8004e4e:	6599      	str	r1, [r3, #88]	; 0x58
 8004e50:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e52:	2200      	movs	r2, #0
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004e54:	f003 0308 	and.w	r3, r3, #8
 8004e58:	9303      	str	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e5a:	2032      	movs	r0, #50	; 0x32
 8004e5c:	4611      	mov	r1, r2
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004e5e:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e60:	f001 faa4 	bl	80063ac <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8004e64:	2032      	movs	r0, #50	; 0x32
}
 8004e66:	b005      	add	sp, #20
 8004e68:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8004e6c:	f001 badc 	b.w	8006428 <HAL_NVIC_EnableIRQ>
 8004e70:	40012c00 	.word	0x40012c00
 8004e74:	40000400 	.word	0x40000400
 8004e78:	40000c00 	.word	0x40000c00
 8004e7c:	40021000 	.word	0x40021000

08004e80 <HAL_TIM_Encoder_MspInit>:

void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* tim_encoderHandle)
{
 8004e80:	b530      	push	{r4, r5, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(tim_encoderHandle->Instance==TIM2)
 8004e82:	6803      	ldr	r3, [r0, #0]
{
 8004e84:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004e86:	2400      	movs	r4, #0
  if(tim_encoderHandle->Instance==TIM2)
 8004e88:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004e8c:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8004e90:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8004e94:	9408      	str	r4, [sp, #32]
  if(tim_encoderHandle->Instance==TIM2)
 8004e96:	d001      	beq.n	8004e9c <HAL_TIM_Encoder_MspInit+0x1c>

  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}
 8004e98:	b00b      	add	sp, #44	; 0x2c
 8004e9a:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_TIM2_CLK_ENABLE();
 8004e9c:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004ea0:	2501      	movs	r5, #1
    __HAL_RCC_TIM2_CLK_ENABLE();
 8004ea2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004ea4:	f042 0201 	orr.w	r2, r2, #1
 8004ea8:	659a      	str	r2, [r3, #88]	; 0x58
 8004eaa:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004eac:	f002 0201 	and.w	r2, r2, #1
 8004eb0:	9201      	str	r2, [sp, #4]
 8004eb2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004eb4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004eb6:	f042 0201 	orr.w	r2, r2, #1
 8004eba:	64da      	str	r2, [r3, #76]	; 0x4c
 8004ebc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004ebe:	f002 0201 	and.w	r2, r2, #1
 8004ec2:	9202      	str	r2, [sp, #8]
 8004ec4:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004ec6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004ec8:	f042 0202 	orr.w	r2, r2, #2
 8004ecc:	64da      	str	r2, [r3, #76]	; 0x4c
 8004ece:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004ed0:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004ed2:	f003 0302 	and.w	r3, r3, #2
 8004ed6:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004ed8:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8004eda:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004ede:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8004ee2:	2302      	movs	r3, #2
 8004ee4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004ee8:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004eea:	f001 fbd3 	bl	8006694 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_ENCODER_B_Pin;
 8004eee:	2208      	movs	r2, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004ef0:	2302      	movs	r3, #2
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004ef2:	4805      	ldr	r0, [pc, #20]	; (8004f08 <HAL_TIM_Encoder_MspInit+0x88>)
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004ef4:	9508      	str	r5, [sp, #32]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004ef6:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004ef8:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004efc:	e9cd 4406 	strd	r4, r4, [sp, #24]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004f00:	f001 fbc8 	bl	8006694 <HAL_GPIO_Init>
}
 8004f04:	b00b      	add	sp, #44	; 0x2c
 8004f06:	bd30      	pop	{r4, r5, pc}
 8004f08:	48000400 	.word	0x48000400

08004f0c <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 8004f0c:	b5d0      	push	{r4, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM1)
 8004f0e:	4a20      	ldr	r2, [pc, #128]	; (8004f90 <HAL_TIM_MspPostInit+0x84>)
 8004f10:	6801      	ldr	r1, [r0, #0]
{
 8004f12:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004f14:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM1)
 8004f16:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004f18:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8004f1c:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004f20:	9306      	str	r3, [sp, #24]
  if(timHandle->Instance==TIM1)
 8004f22:	d001      	beq.n	8004f28 <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 8004f24:	b008      	add	sp, #32
 8004f26:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004f28:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8004f2c:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004f30:	2406      	movs	r4, #6
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004f32:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004f34:	f042 0201 	orr.w	r2, r2, #1
 8004f38:	64da      	str	r2, [r3, #76]	; 0x4c
 8004f3a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004f3c:	f002 0201 	and.w	r2, r2, #1
 8004f40:	9200      	str	r2, [sp, #0]
 8004f42:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004f44:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004f46:	f042 0202 	orr.w	r2, r2, #2
 8004f4a:	64da      	str	r2, [r3, #76]	; 0x4c
 8004f4c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004f4e:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004f50:	f003 0302 	and.w	r3, r3, #2
 8004f54:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f56:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin|M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8004f58:	f44f 62f0 	mov.w	r2, #1920	; 0x780
 8004f5c:	2602      	movs	r6, #2
 8004f5e:	2702      	movs	r7, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f60:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin|M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8004f64:	2302      	movs	r3, #2
 8004f66:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8004f6a:	e9cd 6704 	strd	r6, r7, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004f6e:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f70:	f001 fb90 	bl	8006694 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8004f74:	2203      	movs	r2, #3
 8004f76:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f78:	4806      	ldr	r0, [pc, #24]	; (8004f94 <HAL_TIM_MspPostInit+0x88>)
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004f7a:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f7c:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8004f7e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8004f82:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f86:	f001 fb85 	bl	8006694 <HAL_GPIO_Init>
}
 8004f8a:	b008      	add	sp, #32
 8004f8c:	bdd0      	pop	{r4, r6, r7, pc}
 8004f8e:	bf00      	nop
 8004f90:	40012c00 	.word	0x40012c00
 8004f94:	48000400 	.word	0x48000400

08004f98 <MX_TIM1_Init>:
{
 8004f98:	b510      	push	{r4, lr}
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004f9a:	2400      	movs	r4, #0
{
 8004f9c:	b09e      	sub	sp, #120	; 0x78
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8004f9e:	2234      	movs	r2, #52	; 0x34
 8004fa0:	4621      	mov	r1, r4
 8004fa2:	a811      	add	r0, sp, #68	; 0x44
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004fa4:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8004fa8:	e9cd 4407 	strd	r4, r4, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004fac:	e9cd 4401 	strd	r4, r4, [sp, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8004fb0:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
 8004fb4:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
 8004fb8:	e9cd 440f 	strd	r4, r4, [sp, #60]	; 0x3c
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004fbc:	9404      	str	r4, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004fbe:	9400      	str	r4, [sp, #0]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8004fc0:	940a      	str	r4, [sp, #40]	; 0x28
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8004fc2:	f008 fba3 	bl	800d70c <memset>
  htim1.Instance = TIM1;
 8004fc6:	484f      	ldr	r0, [pc, #316]	; (8005104 <MX_TIM1_Init+0x16c>)
 8004fc8:	4a4f      	ldr	r2, [pc, #316]	; (8005108 <MX_TIM1_Init+0x170>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8004fca:	2320      	movs	r3, #32
  htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);
 8004fcc:	e9c0 2400 	strd	r2, r4, [r0]
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8004fd0:	6083      	str	r3, [r0, #8]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 8004fd2:	f44f 52a6 	mov.w	r2, #5312	; 0x14c0
 8004fd6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004fda:	e9c0 2303 	strd	r2, r3, [r0, #12]
  htim1.Init.RepetitionCounter = (REP_COUNTER);
 8004fde:	2301      	movs	r3, #1
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004fe0:	e9c0 3405 	strd	r3, r4, [r0, #20]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8004fe4:	f002 faf2 	bl	80075cc <HAL_TIM_Base_Init>
 8004fe8:	2800      	cmp	r0, #0
 8004fea:	d168      	bne.n	80050be <MX_TIM1_Init+0x126>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8004fec:	4845      	ldr	r0, [pc, #276]	; (8005104 <MX_TIM1_Init+0x16c>)
 8004fee:	f002 fc1b 	bl	8007828 <HAL_TIM_PWM_Init>
 8004ff2:	2800      	cmp	r0, #0
 8004ff4:	d16a      	bne.n	80050cc <MX_TIM1_Init+0x134>
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;
 8004ff6:	2206      	movs	r2, #6
 8004ff8:	2310      	movs	r3, #16
  if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)
 8004ffa:	4842      	ldr	r0, [pc, #264]	; (8005104 <MX_TIM1_Init+0x16c>)
 8004ffc:	a904      	add	r1, sp, #16
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;
 8004ffe:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)
 8005002:	f002 fe3b 	bl	8007c7c <HAL_TIM_SlaveConfigSynchro>
 8005006:	2800      	cmp	r0, #0
 8005008:	d179      	bne.n	80050fe <MX_TIM1_Init+0x166>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 800500a:	2300      	movs	r3, #0
 800500c:	2270      	movs	r2, #112	; 0x70
 800500e:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8005012:	483c      	ldr	r0, [pc, #240]	; (8005104 <MX_TIM1_Init+0x16c>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005014:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8005016:	4669      	mov	r1, sp
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8005018:	9302      	str	r3, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800501a:	f003 f937 	bl	800828c <HAL_TIMEx_MasterConfigSynchronization>
 800501e:	2800      	cmp	r0, #0
 8005020:	d16a      	bne.n	80050f8 <MX_TIM1_Init+0x160>
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8005022:	2160      	movs	r1, #96	; 0x60
 8005024:	f44f 6326 	mov.w	r3, #2656	; 0xa60
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8005028:	2000      	movs	r0, #0
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 800502a:	e9cd 130a 	strd	r1, r3, [sp, #40]	; 0x28
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800502e:	2100      	movs	r1, #0
 8005030:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8005034:	2200      	movs	r2, #0
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005036:	4833      	ldr	r0, [pc, #204]	; (8005104 <MX_TIM1_Init+0x16c>)
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8005038:	9210      	str	r2, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800503a:	a90a      	add	r1, sp, #40	; 0x28
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800503c:	e9cd 220c 	strd	r2, r2, [sp, #48]	; 0x30
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8005040:	f003 f81a 	bl	8008078 <HAL_TIM_PWM_ConfigChannel>
 8005044:	2800      	cmp	r0, #0
 8005046:	d154      	bne.n	80050f2 <MX_TIM1_Init+0x15a>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005048:	482e      	ldr	r0, [pc, #184]	; (8005104 <MX_TIM1_Init+0x16c>)
 800504a:	2204      	movs	r2, #4
 800504c:	a90a      	add	r1, sp, #40	; 0x28
 800504e:	f003 f813 	bl	8008078 <HAL_TIM_PWM_ConfigChannel>
 8005052:	2800      	cmp	r0, #0
 8005054:	d14a      	bne.n	80050ec <MX_TIM1_Init+0x154>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8005056:	482b      	ldr	r0, [pc, #172]	; (8005104 <MX_TIM1_Init+0x16c>)
 8005058:	2208      	movs	r2, #8
 800505a:	a90a      	add	r1, sp, #40	; 0x28
 800505c:	f003 f80c 	bl	8008078 <HAL_TIM_PWM_ConfigChannel>
 8005060:	2800      	cmp	r0, #0
 8005062:	d140      	bne.n	80050e6 <MX_TIM1_Init+0x14e>
  sConfigOC.OCMode = TIM_OCMODE_PWM2;
 8005064:	2270      	movs	r2, #112	; 0x70
 8005066:	f241 43bf 	movw	r3, #5311	; 0x14bf
 800506a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 800506e:	4825      	ldr	r0, [pc, #148]	; (8005104 <MX_TIM1_Init+0x16c>)
 8005070:	a90a      	add	r1, sp, #40	; 0x28
 8005072:	220c      	movs	r2, #12
 8005074:	f003 f800 	bl	8008078 <HAL_TIM_PWM_ConfigChannel>
 8005078:	bb90      	cbnz	r0, 80050e0 <MX_TIM1_Init+0x148>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;
 800507a:	f44f 6400 	mov.w	r4, #2048	; 0x800
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 800507e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8005082:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 8005084:	e9cd 4211 	strd	r4, r2, [sp, #68]	; 0x44
  sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);
 8005088:	2448      	movs	r4, #72	; 0x48
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 800508a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);
 800508e:	e9cd 3413 	strd	r3, r4, [sp, #76]	; 0x4c
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8005092:	e9cd 3215 	strd	r3, r2, [sp, #84]	; 0x54
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8005096:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
  sBreakDeadTimeConfig.Break2Filter = 3;
 800509a:	2203      	movs	r2, #3
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 800509c:	4819      	ldr	r0, [pc, #100]	; (8005104 <MX_TIM1_Init+0x16c>)
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 800509e:	931d      	str	r3, [sp, #116]	; 0x74
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80050a0:	a911      	add	r1, sp, #68	; 0x44
  sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
 80050a2:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80050a6:	e9cd 3419 	strd	r3, r4, [sp, #100]	; 0x64
  sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
 80050aa:	e9cd 231b 	strd	r2, r3, [sp, #108]	; 0x6c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80050ae:	f003 f949 	bl	8008344 <HAL_TIMEx_ConfigBreakDeadTime>
 80050b2:	b970      	cbnz	r0, 80050d2 <MX_TIM1_Init+0x13a>
  HAL_TIM_MspPostInit(&htim1);
 80050b4:	4813      	ldr	r0, [pc, #76]	; (8005104 <MX_TIM1_Init+0x16c>)
 80050b6:	f7ff ff29 	bl	8004f0c <HAL_TIM_MspPostInit>
}
 80050ba:	b01e      	add	sp, #120	; 0x78
 80050bc:	bd10      	pop	{r4, pc}
    Error_Handler();
 80050be:	f7fc fdbb 	bl	8001c38 <Error_Handler>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 80050c2:	4810      	ldr	r0, [pc, #64]	; (8005104 <MX_TIM1_Init+0x16c>)
 80050c4:	f002 fbb0 	bl	8007828 <HAL_TIM_PWM_Init>
 80050c8:	2800      	cmp	r0, #0
 80050ca:	d094      	beq.n	8004ff6 <MX_TIM1_Init+0x5e>
    Error_Handler();
 80050cc:	f7fc fdb4 	bl	8001c38 <Error_Handler>
 80050d0:	e791      	b.n	8004ff6 <MX_TIM1_Init+0x5e>
    Error_Handler();
 80050d2:	f7fc fdb1 	bl	8001c38 <Error_Handler>
  HAL_TIM_MspPostInit(&htim1);
 80050d6:	480b      	ldr	r0, [pc, #44]	; (8005104 <MX_TIM1_Init+0x16c>)
 80050d8:	f7ff ff18 	bl	8004f0c <HAL_TIM_MspPostInit>
}
 80050dc:	b01e      	add	sp, #120	; 0x78
 80050de:	bd10      	pop	{r4, pc}
    Error_Handler();
 80050e0:	f7fc fdaa 	bl	8001c38 <Error_Handler>
 80050e4:	e7c9      	b.n	800507a <MX_TIM1_Init+0xe2>
    Error_Handler();
 80050e6:	f7fc fda7 	bl	8001c38 <Error_Handler>
 80050ea:	e7bb      	b.n	8005064 <MX_TIM1_Init+0xcc>
    Error_Handler();
 80050ec:	f7fc fda4 	bl	8001c38 <Error_Handler>
 80050f0:	e7b1      	b.n	8005056 <MX_TIM1_Init+0xbe>
    Error_Handler();
 80050f2:	f7fc fda1 	bl	8001c38 <Error_Handler>
 80050f6:	e7a7      	b.n	8005048 <MX_TIM1_Init+0xb0>
    Error_Handler();
 80050f8:	f7fc fd9e 	bl	8001c38 <Error_Handler>
 80050fc:	e791      	b.n	8005022 <MX_TIM1_Init+0x8a>
    Error_Handler();
 80050fe:	f7fc fd9b 	bl	8001c38 <Error_Handler>
 8005102:	e782      	b.n	800500a <MX_TIM1_Init+0x72>
 8005104:	20002e24 	.word	0x20002e24
 8005108:	40012c00 	.word	0x40012c00

0800510c <MX_USART2_UART_Init>:
DMA_HandleTypeDef hdma_usart2_tx;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 800510c:	b510      	push	{r4, lr}
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 800510e:	481f      	ldr	r0, [pc, #124]	; (800518c <MX_USART2_UART_Init+0x80>)
 8005110:	4c1f      	ldr	r4, [pc, #124]	; (8005190 <MX_USART2_UART_Init+0x84>)
  huart2.Init.BaudRate = 1843200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8005112:	2300      	movs	r3, #0
  huart2.Init.BaudRate = 1843200;
 8005114:	f44f 11e1 	mov.w	r1, #1843200	; 0x1c2000
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8005118:	220c      	movs	r2, #12
  huart2.Init.BaudRate = 1843200;
 800511a:	e9c0 4100 	strd	r4, r1, [r0]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800511e:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8005122:	e9c0 3204 	strd	r3, r2, [r0, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8005126:	e9c0 3306 	strd	r3, r3, [r0, #24]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800512a:	e9c0 3308 	strd	r3, r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800512e:	6283      	str	r3, [r0, #40]	; 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8005130:	f003 fbc2 	bl	80088b8 <HAL_UART_Init>
 8005134:	b970      	cbnz	r0, 8005154 <MX_USART2_UART_Init+0x48>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005136:	4815      	ldr	r0, [pc, #84]	; (800518c <MX_USART2_UART_Init+0x80>)
 8005138:	2100      	movs	r1, #0
 800513a:	f003 fc47 	bl	80089cc <HAL_UARTEx_SetTxFifoThreshold>
 800513e:	b988      	cbnz	r0, 8005164 <MX_USART2_UART_Init+0x58>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005140:	4812      	ldr	r0, [pc, #72]	; (800518c <MX_USART2_UART_Init+0x80>)
 8005142:	2100      	movs	r1, #0
 8005144:	f003 fc84 	bl	8008a50 <HAL_UARTEx_SetRxFifoThreshold>
 8005148:	b9a0      	cbnz	r0, 8005174 <MX_USART2_UART_Init+0x68>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 800514a:	4810      	ldr	r0, [pc, #64]	; (800518c <MX_USART2_UART_Init+0x80>)
 800514c:	f003 fc20 	bl	8008990 <HAL_UARTEx_DisableFifoMode>
 8005150:	b9b8      	cbnz	r0, 8005182 <MX_USART2_UART_Init+0x76>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8005152:	bd10      	pop	{r4, pc}
    Error_Handler();
 8005154:	f7fc fd70 	bl	8001c38 <Error_Handler>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005158:	480c      	ldr	r0, [pc, #48]	; (800518c <MX_USART2_UART_Init+0x80>)
 800515a:	2100      	movs	r1, #0
 800515c:	f003 fc36 	bl	80089cc <HAL_UARTEx_SetTxFifoThreshold>
 8005160:	2800      	cmp	r0, #0
 8005162:	d0ed      	beq.n	8005140 <MX_USART2_UART_Init+0x34>
    Error_Handler();
 8005164:	f7fc fd68 	bl	8001c38 <Error_Handler>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005168:	4808      	ldr	r0, [pc, #32]	; (800518c <MX_USART2_UART_Init+0x80>)
 800516a:	2100      	movs	r1, #0
 800516c:	f003 fc70 	bl	8008a50 <HAL_UARTEx_SetRxFifoThreshold>
 8005170:	2800      	cmp	r0, #0
 8005172:	d0ea      	beq.n	800514a <MX_USART2_UART_Init+0x3e>
    Error_Handler();
 8005174:	f7fc fd60 	bl	8001c38 <Error_Handler>
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 8005178:	4804      	ldr	r0, [pc, #16]	; (800518c <MX_USART2_UART_Init+0x80>)
 800517a:	f003 fc09 	bl	8008990 <HAL_UARTEx_DisableFifoMode>
 800517e:	2800      	cmp	r0, #0
 8005180:	d0e7      	beq.n	8005152 <MX_USART2_UART_Init+0x46>
}
 8005182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 8005186:	f7fc bd57 	b.w	8001c38 <Error_Handler>
 800518a:	bf00      	nop
 800518c:	20003014 	.word	0x20003014
 8005190:	40004400 	.word	0x40004400

08005194 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8005194:	b570      	push	{r4, r5, r6, lr}
 8005196:	4604      	mov	r4, r0
 8005198:	b09c      	sub	sp, #112	; 0x70

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800519a:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800519c:	2254      	movs	r2, #84	; 0x54
 800519e:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80051a0:	e9cd 1102 	strd	r1, r1, [sp, #8]
 80051a4:	e9cd 1104 	strd	r1, r1, [sp, #16]
 80051a8:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80051aa:	f008 faaf 	bl	800d70c <memset>
  if(uartHandle->Instance==USART2)
 80051ae:	4b31      	ldr	r3, [pc, #196]	; (8005274 <HAL_UART_MspInit+0xe0>)
 80051b0:	6822      	ldr	r2, [r4, #0]
 80051b2:	429a      	cmp	r2, r3
 80051b4:	d001      	beq.n	80051ba <HAL_UART_MspInit+0x26>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 80051b6:	b01c      	add	sp, #112	; 0x70
 80051b8:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 80051ba:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80051bc:	a807      	add	r0, sp, #28
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 80051be:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80051c0:	f001 ff9a 	bl	80070f8 <HAL_RCCEx_PeriphCLKConfig>
 80051c4:	2800      	cmp	r0, #0
 80051c6:	d14c      	bne.n	8005262 <HAL_UART_MspInit+0xce>
    __HAL_RCC_USART2_CLK_ENABLE();
 80051c8:	4b2b      	ldr	r3, [pc, #172]	; (8005278 <HAL_UART_MspInit+0xe4>)
    hdma_usart2_rx.Instance = DMA1_Channel1;
 80051ca:	4e2c      	ldr	r6, [pc, #176]	; (800527c <HAL_UART_MspInit+0xe8>)
    __HAL_RCC_USART2_CLK_ENABLE();
 80051cc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80051ce:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80051d2:	659a      	str	r2, [r3, #88]	; 0x58
 80051d4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80051d6:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80051da:	9200      	str	r2, [sp, #0]
 80051dc:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80051de:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80051e0:	f042 0201 	orr.w	r2, r2, #1
 80051e4:	64da      	str	r2, [r3, #76]	; 0x4c
 80051e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80051e8:	f003 0301 	and.w	r3, r3, #1
 80051ec:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 80051ee:	220c      	movs	r2, #12
 80051f0:	2302      	movs	r3, #2
 80051f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80051f6:	2200      	movs	r2, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80051f8:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 80051fa:	2300      	movs	r3, #0
 80051fc:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005200:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8005202:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005204:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8005208:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800520a:	f001 fa43 	bl	8006694 <HAL_GPIO_Init>
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 800520e:	491c      	ldr	r1, [pc, #112]	; (8005280 <HAL_UART_MspInit+0xec>)
 8005210:	221a      	movs	r2, #26
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8005212:	2300      	movs	r3, #0
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8005214:	e9c6 1200 	strd	r1, r2, [r6]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8005218:	4630      	mov	r0, r6
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
 800521a:	2280      	movs	r2, #128	; 0x80
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 800521c:	e9c6 3302 	strd	r3, r3, [r6, #8]
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8005220:	e9c6 2304 	strd	r2, r3, [r6, #16]
    hdma_usart2_rx.Init.Mode = DMA_NORMAL;
 8005224:	e9c6 3306 	strd	r3, r3, [r6, #24]
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
 8005228:	6233      	str	r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 800522a:	f001 f99d 	bl	8006568 <HAL_DMA_Init>
 800522e:	b9f0      	cbnz	r0, 800526e <HAL_UART_MspInit+0xda>
    hdma_usart2_tx.Instance = DMA1_Channel2;
 8005230:	4d14      	ldr	r5, [pc, #80]	; (8005284 <HAL_UART_MspInit+0xf0>)
 8005232:	4915      	ldr	r1, [pc, #84]	; (8005288 <HAL_UART_MspInit+0xf4>)
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 8005234:	67e6      	str	r6, [r4, #124]	; 0x7c
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8005236:	221b      	movs	r2, #27
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8005238:	2300      	movs	r3, #0
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 800523a:	e9c5 1200 	strd	r1, r2, [r5]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 800523e:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8005240:	2110      	movs	r1, #16
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8005242:	2280      	movs	r2, #128	; 0x80
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8005244:	e9c5 1302 	strd	r1, r3, [r5, #8]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8005248:	e9c5 3305 	strd	r3, r3, [r5, #20]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 800524c:	e9c5 3307 	strd	r3, r3, [r5, #28]
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 8005250:	62b4      	str	r4, [r6, #40]	; 0x28
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8005252:	612a      	str	r2, [r5, #16]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8005254:	f001 f988 	bl	8006568 <HAL_DMA_Init>
 8005258:	b930      	cbnz	r0, 8005268 <HAL_UART_MspInit+0xd4>
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 800525a:	67a5      	str	r5, [r4, #120]	; 0x78
 800525c:	62ac      	str	r4, [r5, #40]	; 0x28
}
 800525e:	b01c      	add	sp, #112	; 0x70
 8005260:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 8005262:	f7fc fce9 	bl	8001c38 <Error_Handler>
 8005266:	e7af      	b.n	80051c8 <HAL_UART_MspInit+0x34>
      Error_Handler();
 8005268:	f7fc fce6 	bl	8001c38 <Error_Handler>
 800526c:	e7f5      	b.n	800525a <HAL_UART_MspInit+0xc6>
      Error_Handler();
 800526e:	f7fc fce3 	bl	8001c38 <Error_Handler>
 8005272:	e7dd      	b.n	8005230 <HAL_UART_MspInit+0x9c>
 8005274:	40004400 	.word	0x40004400
 8005278:	40021000 	.word	0x40021000
 800527c:	20002f54 	.word	0x20002f54
 8005280:	40020008 	.word	0x40020008
 8005284:	20002fb4 	.word	0x20002fb4
 8005288:	4002001c 	.word	0x4002001c

0800528c <UASPEP_INIT>:
  }
  else
  {
#endif
    /* Enable DMA UART */
    LL_USART_ClearFlag_TC(pHandle->USARTx);
 800528c:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 800528e:	2340      	movs	r3, #64	; 0x40
{
 8005290:	b470      	push	{r4, r5, r6}
 8005292:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005294:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8005298:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800529c:	e842 3100 	strex	r1, r3, [r2]
 80052a0:	2900      	cmp	r1, #0
 80052a2:	d1f7      	bne.n	8005294 <UASPEP_INIT+0x8>
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 80052a4:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052a8:	e851 3f00 	ldrex	r3, [r1]
 80052ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052b0:	e841 3400 	strex	r4, r3, [r1]
 80052b4:	2c00      	cmp	r4, #0
 80052b6:	d1f7      	bne.n	80052a8 <UASPEP_INIT+0x1c>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 80052b8:	6901      	ldr	r1, [r0, #16]
 80052ba:	4e17      	ldr	r6, [pc, #92]	; (8005318 <UASPEP_INIT+0x8c>)
 80052bc:	6883      	ldr	r3, [r0, #8]
 80052be:	5c74      	ldrb	r4, [r6, r1]
  * @retval None
  */
__STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_TCIE);
 80052c0:	6845      	ldr	r5, [r0, #4]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 80052c2:	4423      	add	r3, r4
    LL_USART_EnableDMAReq_TX(pHandle->USARTx);

    /* Write the USART_TDR register address in the DMA control register to configure it as
     * the destination of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)&pHandle->USARTx->TDR);
 80052c4:	f102 0128 	add.w	r1, r2, #40	; 0x28
 80052c8:	6099      	str	r1, [r3, #8]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_TCIE);
 80052ca:	68c3      	ldr	r3, [r0, #12]
 80052cc:	5cf1      	ldrb	r1, [r6, r3]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80052ce:	2340      	movs	r3, #64	; 0x40
 80052d0:	6213      	str	r3, [r2, #32]
 80052d2:	586b      	ldr	r3, [r5, r1]
 80052d4:	f043 0302 	orr.w	r3, r3, #2
 80052d8:	506b      	str	r3, [r5, r1]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80052da:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052de:	e851 3f00 	ldrex	r3, [r1]
 80052e2:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052e6:	e841 3400 	strex	r4, r3, [r1]
 80052ea:	2c00      	cmp	r4, #0
 80052ec:	d1f7      	bne.n	80052de <UASPEP_INIT+0x52>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 80052ee:	68c3      	ldr	r3, [r0, #12]
 80052f0:	5cf0      	ldrb	r0, [r6, r3]
 80052f2:	4405      	add	r5, r0
    LL_USART_EnableIT_ERROR(pHandle->USARTx);

    /* Write the USART_RDR register address in the DMA control register to configure it as
     * the source of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)&pHandle->USARTx->RDR);
 80052f4:	f102 0124 	add.w	r1, r2, #36	; 0x24
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80052f8:	2340      	movs	r3, #64	; 0x40
 80052fa:	60a9      	str	r1, [r5, #8]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80052fc:	f102 0108 	add.w	r1, r2, #8
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8005300:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005302:	e851 3f00 	ldrex	r3, [r1]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8005306:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800530a:	e841 3200 	strex	r2, r3, [r1]
 800530e:	2a00      	cmp	r2, #0
 8005310:	d1f7      	bne.n	8005302 <UASPEP_INIT+0x76>
}
 8005312:	bc70      	pop	{r4, r5, r6}
 8005314:	4770      	bx	lr
 8005316:	bf00      	nop
 8005318:	0801a1bc 	.word	0x0801a1bc

0800531c <UASPEP_SEND_PACKET>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  data Data to be transmitted to controller
  * @param  length Length of the data to be transmitted
  */
bool UASPEP_SEND_PACKET(void *pHWHandle, void *data, uint16_t length)
{
 800531c:	b430      	push	{r4, r5}
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 800531e:	6903      	ldr	r3, [r0, #16]
 8005320:	4d0b      	ldr	r5, [pc, #44]	; (8005350 <UASPEP_SEND_PACKET+0x34>)
 8005322:	6884      	ldr	r4, [r0, #8]
 8005324:	5ceb      	ldrb	r3, [r5, r3]
 8005326:	58e5      	ldr	r5, [r4, r3]
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 8005328:	07ed      	lsls	r5, r5, #31
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 800532a:	eb04 0003 	add.w	r0, r4, r3
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 800532e:	d40b      	bmi.n	8005348 <UASPEP_SEND_PACKET+0x2c>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 8005330:	60c1      	str	r1, [r0, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 8005332:	6841      	ldr	r1, [r0, #4]
 8005334:	0c09      	lsrs	r1, r1, #16
 8005336:	0409      	lsls	r1, r1, #16
 8005338:	430a      	orrs	r2, r1
 800533a:	6042      	str	r2, [r0, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 800533c:	58e2      	ldr	r2, [r4, r3]
  {
    //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
    LL_DMA_SetMemoryAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)data);
    LL_DMA_SetDataLength(pHandle->txDMA, pHandle->txChannel, length);
    LL_DMA_EnableChannel(pHandle->txDMA, pHandle->txChannel);
    result = true;
 800533e:	2001      	movs	r0, #1
 8005340:	4302      	orrs	r2, r0
 8005342:	50e2      	str	r2, [r4, r3]
  else
  {
    result = false;
  }
  return (result);
}
 8005344:	bc30      	pop	{r4, r5}
 8005346:	4770      	bx	lr
    result = false;
 8005348:	2000      	movs	r0, #0
}
 800534a:	bc30      	pop	{r4, r5}
 800534c:	4770      	bx	lr
 800534e:	bf00      	nop
 8005350:	0801a1bc 	.word	0x0801a1bc

08005354 <UASPEP_RECEIVE_BUFFER>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  buffer Buffer which will receive the communicated data
  * @param  length Length of the received data
  */
void UASPEP_RECEIVE_BUFFER(void *pHWHandle, void* buffer, uint16_t length)
{
 8005354:	b430      	push	{r4, r5}
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8005356:	68c3      	ldr	r3, [r0, #12]
 8005358:	4d0b      	ldr	r5, [pc, #44]	; (8005388 <UASPEP_RECEIVE_BUFFER+0x34>)
 800535a:	6844      	ldr	r4, [r0, #4]
 800535c:	5ce8      	ldrb	r0, [r5, r3]
 800535e:	5823      	ldr	r3, [r4, r0]
 8005360:	eb04 0c00 	add.w	ip, r4, r0
 8005364:	f023 0301 	bic.w	r3, r3, #1
 8005368:	5023      	str	r3, [r4, r0]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 800536a:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 800536e:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8005372:	0c1b      	lsrs	r3, r3, #16
 8005374:	041b      	lsls	r3, r3, #16
 8005376:	431a      	orrs	r2, r3
 8005378:	f8cc 2004 	str.w	r2, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 800537c:	5823      	ldr	r3, [r4, r0]
 800537e:	f043 0301 	orr.w	r3, r3, #1
 8005382:	5023      	str	r3, [r4, r0]
  //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
  LL_DMA_SetMemoryAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)buffer);
  LL_DMA_SetDataLength(pHandle->rxDMA, pHandle->rxChannel, length);

  LL_DMA_EnableChannel(pHandle->rxDMA, pHandle->rxChannel);
}
 8005384:	bc30      	pop	{r4, r5}
 8005386:	4770      	bx	lr
 8005388:	0801a1bc 	.word	0x0801a1bc

0800538c <UASPEP_IDLE_ENABLE>:
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_IDLE_ENABLE(void *pHWHandle)
{
  UASPEP_Handle_t *pHandle = (UASPEP_Handle_t *)pHWHandle; //cstat !MISRAC2012-Rule-11.5
  LL_USART_ClearFlag_IDLE(pHandle->USARTx);
 800538c:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
 800538e:	2310      	movs	r3, #16
 8005390:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005392:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8005396:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800539a:	e842 3100 	strex	r1, r3, [r2]
 800539e:	2900      	cmp	r1, #0
 80053a0:	d1f7      	bne.n	8005392 <UASPEP_IDLE_ENABLE+0x6>
  LL_USART_EnableIT_IDLE(pHandle->USARTx);
}
 80053a2:	4770      	bx	lr

080053a4 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 80053a4:	4a03      	ldr	r2, [pc, #12]	; (80053b4 <SystemInit+0x10>)
 80053a6:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80053aa:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80053ae:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80053b2:	4770      	bx	lr
 80053b4:	e000ed00 	.word	0xe000ed00

080053b8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80053b8:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 80053ba:	4b0f      	ldr	r3, [pc, #60]	; (80053f8 <HAL_InitTick+0x40>)
 80053bc:	681b      	ldr	r3, [r3, #0]
 80053be:	b90b      	cbnz	r3, 80053c4 <HAL_InitTick+0xc>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 80053c0:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 80053c2:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 80053c4:	490d      	ldr	r1, [pc, #52]	; (80053fc <HAL_InitTick+0x44>)
 80053c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80053ca:	4605      	mov	r5, r0
 80053cc:	fbb2 f3f3 	udiv	r3, r2, r3
 80053d0:	6808      	ldr	r0, [r1, #0]
 80053d2:	fbb0 f0f3 	udiv	r0, r0, r3
 80053d6:	f001 f835 	bl	8006444 <HAL_SYSTICK_Config>
 80053da:	4604      	mov	r4, r0
 80053dc:	2800      	cmp	r0, #0
 80053de:	d1ef      	bne.n	80053c0 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80053e0:	2d0f      	cmp	r5, #15
 80053e2:	d8ed      	bhi.n	80053c0 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80053e4:	4602      	mov	r2, r0
 80053e6:	4629      	mov	r1, r5
 80053e8:	f04f 30ff 	mov.w	r0, #4294967295
 80053ec:	f000 ffde 	bl	80063ac <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 80053f0:	4b03      	ldr	r3, [pc, #12]	; (8005400 <HAL_InitTick+0x48>)
 80053f2:	4620      	mov	r0, r4
 80053f4:	601d      	str	r5, [r3, #0]
}
 80053f6:	bd38      	pop	{r3, r4, r5, pc}
 80053f8:	200014a8 	.word	0x200014a8
 80053fc:	200014a4 	.word	0x200014a4
 8005400:	200014ac 	.word	0x200014ac

08005404 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8005404:	4a0a      	ldr	r2, [pc, #40]	; (8005430 <HAL_Init+0x2c>)
 8005406:	6813      	ldr	r3, [r2, #0]
 8005408:	f443 7380 	orr.w	r3, r3, #256	; 0x100
{
 800540c:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800540e:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8005410:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8005412:	f000 ffb9 	bl	8006388 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8005416:	2004      	movs	r0, #4
 8005418:	f7ff ffce 	bl	80053b8 <HAL_InitTick>
 800541c:	b110      	cbz	r0, 8005424 <HAL_Init+0x20>
    status = HAL_ERROR;
 800541e:	2401      	movs	r4, #1
}
 8005420:	4620      	mov	r0, r4
 8005422:	bd10      	pop	{r4, pc}
 8005424:	4604      	mov	r4, r0
    HAL_MspInit();
 8005426:	f7ff faeb 	bl	8004a00 <HAL_MspInit>
}
 800542a:	4620      	mov	r0, r4
 800542c:	bd10      	pop	{r4, pc}
 800542e:	bf00      	nop
 8005430:	40022000 	.word	0x40022000

08005434 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8005434:	4a03      	ldr	r2, [pc, #12]	; (8005444 <HAL_IncTick+0x10>)
 8005436:	4904      	ldr	r1, [pc, #16]	; (8005448 <HAL_IncTick+0x14>)
 8005438:	6813      	ldr	r3, [r2, #0]
 800543a:	6809      	ldr	r1, [r1, #0]
 800543c:	440b      	add	r3, r1
 800543e:	6013      	str	r3, [r2, #0]
}
 8005440:	4770      	bx	lr
 8005442:	bf00      	nop
 8005444:	200030a4 	.word	0x200030a4
 8005448:	200014a8 	.word	0x200014a8

0800544c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800544c:	4b01      	ldr	r3, [pc, #4]	; (8005454 <HAL_GetTick+0x8>)
 800544e:	6818      	ldr	r0, [r3, #0]
}
 8005450:	4770      	bx	lr
 8005452:	bf00      	nop
 8005454:	200030a4 	.word	0x200030a4

08005458 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8005458:	b530      	push	{r4, r5, lr}
 800545a:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 800545c:	2300      	movs	r3, #0
 800545e:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8005460:	2800      	cmp	r0, #0
 8005462:	f000 80d4 	beq.w	800560e <HAL_ADC_Init+0x1b6>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8005466:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 8005468:	4604      	mov	r4, r0
 800546a:	2d00      	cmp	r5, #0
 800546c:	f000 809d 	beq.w	80055aa <HAL_ADC_Init+0x152>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8005470:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8005472:	6893      	ldr	r3, [r2, #8]
 8005474:	009d      	lsls	r5, r3, #2
 8005476:	d505      	bpl.n	8005484 <HAL_ADC_Init+0x2c>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8005478:	6893      	ldr	r3, [r2, #8]
 800547a:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 800547e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8005482:	6093      	str	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8005484:	6893      	ldr	r3, [r2, #8]
 8005486:	00d8      	lsls	r0, r3, #3
 8005488:	d419      	bmi.n	80054be <HAL_ADC_Init+0x66>
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 800548a:	4b7e      	ldr	r3, [pc, #504]	; (8005684 <HAL_ADC_Init+0x22c>)
 800548c:	487e      	ldr	r0, [pc, #504]	; (8005688 <HAL_ADC_Init+0x230>)
 800548e:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(ADCx->CR,
 8005490:	6891      	ldr	r1, [r2, #8]
 8005492:	099b      	lsrs	r3, r3, #6
 8005494:	fba0 0303 	umull	r0, r3, r0, r3
 8005498:	f021 4110 	bic.w	r1, r1, #2415919104	; 0x90000000
 800549c:	099b      	lsrs	r3, r3, #6
 800549e:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80054a2:	3301      	adds	r3, #1
 80054a4:	005b      	lsls	r3, r3, #1
 80054a6:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80054aa:	6091      	str	r1, [r2, #8]
 80054ac:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80054ae:	9b01      	ldr	r3, [sp, #4]
 80054b0:	b12b      	cbz	r3, 80054be <HAL_ADC_Init+0x66>
    {
      wait_loop_index--;
 80054b2:	9b01      	ldr	r3, [sp, #4]
 80054b4:	3b01      	subs	r3, #1
 80054b6:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80054b8:	9b01      	ldr	r3, [sp, #4]
 80054ba:	2b00      	cmp	r3, #0
 80054bc:	d1f9      	bne.n	80054b2 <HAL_ADC_Init+0x5a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80054be:	6893      	ldr	r3, [r2, #8]
 80054c0:	00d9      	lsls	r1, r3, #3
 80054c2:	d464      	bmi.n	800558e <HAL_ADC_Init+0x136>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80054c4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80054c6:	f043 0310 	orr.w	r3, r3, #16
 80054ca:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80054cc:	6e23      	ldr	r3, [r4, #96]	; 0x60

    tmp_hal_status = HAL_ERROR;
 80054ce:	2001      	movs	r0, #1
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80054d0:	4303      	orrs	r3, r0
 80054d2:	6623      	str	r3, [r4, #96]	; 0x60
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80054d4:	6893      	ldr	r3, [r2, #8]
 80054d6:	f013 0f04 	tst.w	r3, #4
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 80054da:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80054dc:	d15e      	bne.n	800559c <HAL_ADC_Init+0x144>
 80054de:	06db      	lsls	r3, r3, #27
 80054e0:	d45c      	bmi.n	800559c <HAL_ADC_Init+0x144>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80054e2:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80054e4:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 80054e8:	f043 0302 	orr.w	r3, r3, #2
 80054ec:	65e3      	str	r3, [r4, #92]	; 0x5c
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80054ee:	6893      	ldr	r3, [r2, #8]
 80054f0:	07dd      	lsls	r5, r3, #31
 80054f2:	d419      	bmi.n	8005528 <HAL_ADC_Init+0xd0>
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80054f4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80054f8:	4b64      	ldr	r3, [pc, #400]	; (800568c <HAL_ADC_Init+0x234>)
 80054fa:	f000 80a0 	beq.w	800563e <HAL_ADC_Init+0x1e6>
 80054fe:	429a      	cmp	r2, r3
 8005500:	f000 80a5 	beq.w	800564e <HAL_ADC_Init+0x1f6>
 8005504:	4962      	ldr	r1, [pc, #392]	; (8005690 <HAL_ADC_Init+0x238>)
 8005506:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800550a:	6889      	ldr	r1, [r1, #8]
 800550c:	689b      	ldr	r3, [r3, #8]
 800550e:	430b      	orrs	r3, r1
 8005510:	4960      	ldr	r1, [pc, #384]	; (8005694 <HAL_ADC_Init+0x23c>)
 8005512:	6889      	ldr	r1, [r1, #8]
 8005514:	430b      	orrs	r3, r1
 8005516:	07d9      	lsls	r1, r3, #31
 8005518:	d406      	bmi.n	8005528 <HAL_ADC_Init+0xd0>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800551a:	495f      	ldr	r1, [pc, #380]	; (8005698 <HAL_ADC_Init+0x240>)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 800551c:	688b      	ldr	r3, [r1, #8]
 800551e:	6865      	ldr	r5, [r4, #4]
 8005520:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8005524:	432b      	orrs	r3, r5
 8005526:	608b      	str	r3, [r1, #8]
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                                     |
                hadc->Init.DataAlign                                                   |
 8005528:	68e5      	ldr	r5, [r4, #12]
 800552a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
                hadc->Init.Resolution                                                  |
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 800552c:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
                hadc->Init.DataAlign                                                   |
 8005530:	432b      	orrs	r3, r5
 8005532:	68a5      	ldr	r5, [r4, #8]
 8005534:	432b      	orrs	r3, r5
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8005536:	7f65      	ldrb	r5, [r4, #29]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8005538:	2901      	cmp	r1, #1
                hadc->Init.DataAlign                                                   |
 800553a:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800553e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8005542:	d05f      	beq.n	8005604 <HAL_ADC_Init+0x1ac>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8005544:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8005546:	b121      	cbz	r1, 8005552 <HAL_ADC_Init+0xfa>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 8005548:	6b25      	ldr	r5, [r4, #48]	; 0x30
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800554a:	f401 7178 	and.w	r1, r1, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 800554e:	4329      	orrs	r1, r5
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8005550:	430b      	orrs	r3, r1
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8005552:	68d5      	ldr	r5, [r2, #12]
 8005554:	4951      	ldr	r1, [pc, #324]	; (800569c <HAL_ADC_Init+0x244>)
 8005556:	4029      	ands	r1, r5
 8005558:	4319      	orrs	r1, r3
 800555a:	60d1      	str	r1, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
 800555c:	6913      	ldr	r3, [r2, #16]
 800555e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005560:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8005564:	430b      	orrs	r3, r1
 8005566:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005568:	6893      	ldr	r3, [r2, #8]
 800556a:	075b      	lsls	r3, r3, #29
 800556c:	d523      	bpl.n	80055b6 <HAL_ADC_Init+0x15e>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800556e:	6893      	ldr	r3, [r2, #8]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8005570:	6963      	ldr	r3, [r4, #20]
 8005572:	2b01      	cmp	r3, #1
 8005574:	d04e      	beq.n	8005614 <HAL_ADC_Init+0x1bc>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8005576:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8005578:	f023 030f 	bic.w	r3, r3, #15
 800557c:	6313      	str	r3, [r2, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800557e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8005580:	f023 0303 	bic.w	r3, r3, #3
 8005584:	f043 0301 	orr.w	r3, r3, #1
 8005588:	65e3      	str	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
  }

  /* Return function status */
  return tmp_hal_status;
}
 800558a:	b003      	add	sp, #12
 800558c:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800558e:	6893      	ldr	r3, [r2, #8]
 8005590:	f013 0f04 	tst.w	r3, #4
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005594:	f04f 0000 	mov.w	r0, #0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8005598:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800559a:	d0a0      	beq.n	80054de <HAL_ADC_Init+0x86>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800559c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
 800559e:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80055a0:	f043 0310 	orr.w	r3, r3, #16
 80055a4:	65e3      	str	r3, [r4, #92]	; 0x5c
}
 80055a6:	b003      	add	sp, #12
 80055a8:	bd30      	pop	{r4, r5, pc}
    HAL_ADC_MspInit(hadc);
 80055aa:	f7fb fce5 	bl	8000f78 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 80055ae:	6625      	str	r5, [r4, #96]	; 0x60
    hadc->Lock = HAL_UNLOCKED;
 80055b0:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 80055b4:	e75c      	b.n	8005470 <HAL_ADC_Init+0x18>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80055b6:	6893      	ldr	r3, [r2, #8]
 80055b8:	071d      	lsls	r5, r3, #28
 80055ba:	d4d9      	bmi.n	8005570 <HAL_ADC_Init+0x118>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80055bc:	68d1      	ldr	r1, [r2, #12]
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80055be:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80055c2:	7f25      	ldrb	r5, [r4, #28]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80055c4:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80055c8:	005b      	lsls	r3, r3, #1
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80055ca:	f021 0102 	bic.w	r1, r1, #2
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80055ce:	ea43 3385 	orr.w	r3, r3, r5, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80055d2:	430b      	orrs	r3, r1
      if (hadc->Init.GainCompensation != 0UL)
 80055d4:	6921      	ldr	r1, [r4, #16]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80055d6:	60d3      	str	r3, [r2, #12]
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80055d8:	6913      	ldr	r3, [r2, #16]
      if (hadc->Init.GainCompensation != 0UL)
 80055da:	bb19      	cbnz	r1, 8005624 <HAL_ADC_Init+0x1cc>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80055dc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80055e0:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
 80055e2:	f8d2 30c0 	ldr.w	r3, [r2, #192]	; 0xc0
 80055e6:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 80055ea:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80055ee:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
      if (hadc->Init.OversamplingMode == ENABLE)
 80055f2:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80055f6:	2b01      	cmp	r3, #1
 80055f8:	d032      	beq.n	8005660 <HAL_ADC_Init+0x208>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80055fa:	6913      	ldr	r3, [r2, #16]
 80055fc:	f023 0301 	bic.w	r3, r3, #1
 8005600:	6113      	str	r3, [r2, #16]
 8005602:	e7b5      	b.n	8005570 <HAL_ADC_Init+0x118>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8005604:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8005606:	3901      	subs	r1, #1
 8005608:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 800560c:	e79a      	b.n	8005544 <HAL_ADC_Init+0xec>
    return HAL_ERROR;
 800560e:	2001      	movs	r0, #1
}
 8005610:	b003      	add	sp, #12
 8005612:	bd30      	pop	{r4, r5, pc}
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8005614:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8005616:	6a23      	ldr	r3, [r4, #32]
 8005618:	f021 010f 	bic.w	r1, r1, #15
 800561c:	3b01      	subs	r3, #1
 800561e:	430b      	orrs	r3, r1
 8005620:	6313      	str	r3, [r2, #48]	; 0x30
 8005622:	e7ac      	b.n	800557e <HAL_ADC_Init+0x126>
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8005624:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005628:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, hadc->Init.GainCompensation);
 800562a:	f8d2 30c0 	ldr.w	r3, [r2, #192]	; 0xc0
 800562e:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 8005632:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8005636:	430b      	orrs	r3, r1
 8005638:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
 800563c:	e7d9      	b.n	80055f2 <HAL_ADC_Init+0x19a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800563e:	6891      	ldr	r1, [r2, #8]
 8005640:	689b      	ldr	r3, [r3, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8005642:	430b      	orrs	r3, r1
 8005644:	07db      	lsls	r3, r3, #31
 8005646:	f53f af6f 	bmi.w	8005528 <HAL_ADC_Init+0xd0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800564a:	4915      	ldr	r1, [pc, #84]	; (80056a0 <HAL_ADC_Init+0x248>)
 800564c:	e766      	b.n	800551c <HAL_ADC_Init+0xc4>
 800564e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8005652:	689b      	ldr	r3, [r3, #8]
 8005654:	6891      	ldr	r1, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8005656:	430b      	orrs	r3, r1
 8005658:	07d9      	lsls	r1, r3, #31
 800565a:	f53f af65 	bmi.w	8005528 <HAL_ADC_Init+0xd0>
 800565e:	e7f4      	b.n	800564a <HAL_ADC_Init+0x1f2>
        MODIFY_REG(hadc->Instance->CFGR2,
 8005660:	6911      	ldr	r1, [r2, #16]
 8005662:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005664:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8005666:	f421 61ff 	bic.w	r1, r1, #2040	; 0x7f8
 800566a:	f021 0104 	bic.w	r1, r1, #4
 800566e:	432b      	orrs	r3, r5
 8005670:	430b      	orrs	r3, r1
 8005672:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8005674:	430b      	orrs	r3, r1
 8005676:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005678:	430b      	orrs	r3, r1
 800567a:	f043 0301 	orr.w	r3, r3, #1
 800567e:	6113      	str	r3, [r2, #16]
 8005680:	e776      	b.n	8005570 <HAL_ADC_Init+0x118>
 8005682:	bf00      	nop
 8005684:	200014a4 	.word	0x200014a4
 8005688:	053e2d63 	.word	0x053e2d63
 800568c:	50000100 	.word	0x50000100
 8005690:	50000400 	.word	0x50000400
 8005694:	50000600 	.word	0x50000600
 8005698:	50000700 	.word	0x50000700
 800569c:	fff04007 	.word	0xfff04007
 80056a0:	50000300 	.word	0x50000300

080056a4 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 80056a4:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80056a6:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
{
 80056aa:	b083      	sub	sp, #12
 80056ac:	4603      	mov	r3, r0
  __HAL_LOCK(hadc);
 80056ae:	2a01      	cmp	r2, #1
  __IO uint32_t wait_loop_index = 0UL;
 80056b0:	f04f 0000 	mov.w	r0, #0
 80056b4:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 80056b6:	f000 8174 	beq.w	80059a2 <HAL_ADC_ConfigChannel+0x2fe>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80056ba:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(hadc);
 80056bc:	2001      	movs	r0, #1
 80056be:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80056c2:	6894      	ldr	r4, [r2, #8]
 80056c4:	0766      	lsls	r6, r4, #29
 80056c6:	d45e      	bmi.n	8005786 <HAL_ADC_ConfigChannel+0xe2>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80056c8:	6848      	ldr	r0, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80056ca:	ea4f 1e90 	mov.w	lr, r0, lsr #6
  MODIFY_REG(*preg,
 80056ce:	f000 0c1f 	and.w	ip, r0, #31
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80056d2:	f00e 0e0c 	and.w	lr, lr, #12
  MODIFY_REG(*preg,
 80056d6:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80056d8:	f102 0430 	add.w	r4, r2, #48	; 0x30
  MODIFY_REG(*preg,
 80056dc:	f3c0 6084 	ubfx	r0, r0, #26, #5
 80056e0:	f854 500e 	ldr.w	r5, [r4, lr]
 80056e4:	261f      	movs	r6, #31
 80056e6:	fa00 f00c 	lsl.w	r0, r0, ip
 80056ea:	fa06 fc0c 	lsl.w	ip, r6, ip
 80056ee:	ea25 0c0c 	bic.w	ip, r5, ip
 80056f2:	ea40 000c 	orr.w	r0, r0, ip
 80056f6:	f844 000e 	str.w	r0, [r4, lr]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80056fa:	6890      	ldr	r0, [r2, #8]
 80056fc:	0745      	lsls	r5, r0, #29
 80056fe:	d572      	bpl.n	80057e6 <HAL_ADC_ConfigChannel+0x142>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005700:	6890      	ldr	r0, [r2, #8]
 8005702:	6808      	ldr	r0, [r1, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005704:	6894      	ldr	r4, [r2, #8]
 8005706:	f014 0f01 	tst.w	r4, #1
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800570a:	4604      	mov	r4, r0
 800570c:	d10c      	bne.n	8005728 <HAL_ADC_ConfigChannel+0x84>
  if (SingleDiff == LL_ADC_DIFFERENTIAL_ENDED)
 800570e:	4dbd      	ldr	r5, [pc, #756]	; (8005a04 <HAL_ADC_ConfigChannel+0x360>)
 8005710:	68ce      	ldr	r6, [r1, #12]
 8005712:	42ae      	cmp	r6, r5
 8005714:	f000 80eb 	beq.w	80058ee <HAL_ADC_ConfigChannel+0x24a>
    CLEAR_BIT(ADCx->DIFSEL,
 8005718:	f8d2 10b0 	ldr.w	r1, [r2, #176]	; 0xb0
 800571c:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8005720:	ea21 0100 	bic.w	r1, r1, r0
 8005724:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8005728:	49b7      	ldr	r1, [pc, #732]	; (8005a08 <HAL_ADC_ConfigChannel+0x364>)
 800572a:	420c      	tst	r4, r1
 800572c:	d059      	beq.n	80057e2 <HAL_ADC_ConfigChannel+0x13e>
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800572e:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8005732:	f000 8134 	beq.w	800599e <HAL_ADC_ConfigChannel+0x2fa>
 8005736:	4db5      	ldr	r5, [pc, #724]	; (8005a0c <HAL_ADC_ConfigChannel+0x368>)
 8005738:	49b5      	ldr	r1, [pc, #724]	; (8005a10 <HAL_ADC_ConfigChannel+0x36c>)
 800573a:	48b6      	ldr	r0, [pc, #728]	; (8005a14 <HAL_ADC_ConfigChannel+0x370>)
 800573c:	42aa      	cmp	r2, r5
 800573e:	bf18      	it	ne
 8005740:	4601      	movne	r1, r0
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8005742:	6888      	ldr	r0, [r1, #8]

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if (((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC1) || (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8005744:	49b4      	ldr	r1, [pc, #720]	; (8005a18 <HAL_ADC_ConfigChannel+0x374>)
 8005746:	428c      	cmp	r4, r1
 8005748:	f000 75e0 	and.w	r5, r0, #29360128	; 0x1c00000
 800574c:	d024      	beq.n	8005798 <HAL_ADC_ConfigChannel+0xf4>
 800574e:	49b3      	ldr	r1, [pc, #716]	; (8005a1c <HAL_ADC_ConfigChannel+0x378>)
 8005750:	428c      	cmp	r4, r1
 8005752:	d021      	beq.n	8005798 <HAL_ADC_ConfigChannel+0xf4>
          {
            wait_loop_index--;
          }
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8005754:	49b2      	ldr	r1, [pc, #712]	; (8005a20 <HAL_ADC_ConfigChannel+0x37c>)
 8005756:	428c      	cmp	r4, r1
 8005758:	f040 8139 	bne.w	80059ce <HAL_ADC_ConfigChannel+0x32a>
 800575c:	01c4      	lsls	r4, r0, #7
 800575e:	d440      	bmi.n	80057e2 <HAL_ADC_ConfigChannel+0x13e>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005760:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8005764:	f000 8215 	beq.w	8005b92 <HAL_ADC_ConfigChannel+0x4ee>
 8005768:	4ca8      	ldr	r4, [pc, #672]	; (8005a0c <HAL_ADC_ConfigChannel+0x368>)
 800576a:	49a9      	ldr	r1, [pc, #676]	; (8005a10 <HAL_ADC_ConfigChannel+0x36c>)
 800576c:	48a9      	ldr	r0, [pc, #676]	; (8005a14 <HAL_ADC_ConfigChannel+0x370>)
 800576e:	42a2      	cmp	r2, r4
 8005770:	bf18      	it	ne
 8005772:	4601      	movne	r1, r0
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005774:	688a      	ldr	r2, [r1, #8]
 8005776:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 800577a:	432a      	orrs	r2, r5
 800577c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005780:	2000      	movs	r0, #0
 8005782:	608a      	str	r2, [r1, #8]
}
 8005784:	e003      	b.n	800578e <HAL_ADC_ConfigChannel+0xea>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8005786:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8005788:	f042 0220 	orr.w	r2, r2, #32
 800578c:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800578e:	2200      	movs	r2, #0
 8005790:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8005794:	b003      	add	sp, #12
 8005796:	bdf0      	pop	{r4, r5, r6, r7, pc}
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8005798:	0201      	lsls	r1, r0, #8
 800579a:	d422      	bmi.n	80057e2 <HAL_ADC_ConfigChannel+0x13e>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800579c:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80057a0:	f000 8113 	beq.w	80059ca <HAL_ADC_ConfigChannel+0x326>
 80057a4:	499f      	ldr	r1, [pc, #636]	; (8005a24 <HAL_ADC_ConfigChannel+0x380>)
 80057a6:	428a      	cmp	r2, r1
 80057a8:	d11b      	bne.n	80057e2 <HAL_ADC_ConfigChannel+0x13e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80057aa:	489a      	ldr	r0, [pc, #616]	; (8005a14 <HAL_ADC_ConfigChannel+0x370>)
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80057ac:	4a9e      	ldr	r2, [pc, #632]	; (8005a28 <HAL_ADC_ConfigChannel+0x384>)
 80057ae:	4c9f      	ldr	r4, [pc, #636]	; (8005a2c <HAL_ADC_ConfigChannel+0x388>)
 80057b0:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 80057b2:	6881      	ldr	r1, [r0, #8]
 80057b4:	0992      	lsrs	r2, r2, #6
 80057b6:	fba4 4202 	umull	r4, r2, r4, r2
 80057ba:	0992      	lsrs	r2, r2, #6
 80057bc:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 80057c0:	3201      	adds	r2, #1
 80057c2:	4329      	orrs	r1, r5
 80057c4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80057c8:	0092      	lsls	r2, r2, #2
 80057ca:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80057ce:	6081      	str	r1, [r0, #8]
 80057d0:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80057d2:	9a01      	ldr	r2, [sp, #4]
 80057d4:	b12a      	cbz	r2, 80057e2 <HAL_ADC_ConfigChannel+0x13e>
            wait_loop_index--;
 80057d6:	9a01      	ldr	r2, [sp, #4]
 80057d8:	3a01      	subs	r2, #1
 80057da:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80057dc:	9a01      	ldr	r2, [sp, #4]
 80057de:	2a00      	cmp	r2, #0
 80057e0:	d1f9      	bne.n	80057d6 <HAL_ADC_ConfigChannel+0x132>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80057e2:	2000      	movs	r0, #0
 80057e4:	e7d3      	b.n	800578e <HAL_ADC_ConfigChannel+0xea>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80057e6:	6890      	ldr	r0, [r2, #8]
 80057e8:	0700      	lsls	r0, r0, #28
 80057ea:	d47e      	bmi.n	80058ea <HAL_ADC_ConfigChannel+0x246>
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80057ec:	6888      	ldr	r0, [r1, #8]
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80057ee:	680d      	ldr	r5, [r1, #0]
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80057f0:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 80057f4:	f000 8120 	beq.w	8005a38 <HAL_ADC_ConfigChannel+0x394>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80057f8:	0dee      	lsrs	r6, r5, #23
 80057fa:	f102 0c14 	add.w	ip, r2, #20
 80057fe:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
 8005802:	f3c5 5504 	ubfx	r5, r5, #20, #5
 8005806:	f85c 4006 	ldr.w	r4, [ip, r6]
 800580a:	2707      	movs	r7, #7
 800580c:	40a8      	lsls	r0, r5
 800580e:	fa07 f505 	lsl.w	r5, r7, r5
 8005812:	ea24 0405 	bic.w	r4, r4, r5
 8005816:	4320      	orrs	r0, r4
 8005818:	f84c 0006 	str.w	r0, [ip, r6]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 800581c:	6950      	ldr	r0, [r2, #20]
 800581e:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005822:	6150      	str	r0, [r2, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8005824:	e9d1 5604 	ldrd	r5, r6, [r1, #16]
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8005828:	2d04      	cmp	r5, #4
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800582a:	68d0      	ldr	r0, [r2, #12]
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800582c:	d02d      	beq.n	800588a <HAL_ADC_ConfigChannel+0x1e6>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800582e:	f102 0460 	add.w	r4, r2, #96	; 0x60
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8005832:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 8005836:	0040      	lsls	r0, r0, #1
  MODIFY_REG(*preg,
 8005838:	f854 c025 	ldr.w	ip, [r4, r5, lsl #2]
 800583c:	4f7c      	ldr	r7, [pc, #496]	; (8005a30 <HAL_ADC_ConfigChannel+0x38c>)
 800583e:	4086      	lsls	r6, r0
 8005840:	6808      	ldr	r0, [r1, #0]
 8005842:	ea0c 0707 	and.w	r7, ip, r7
 8005846:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 800584a:	4338      	orrs	r0, r7
 800584c:	4330      	orrs	r0, r6
 800584e:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 8005852:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005856:	690d      	ldr	r5, [r1, #16]
  MODIFY_REG(*preg,
 8005858:	698e      	ldr	r6, [r1, #24]
 800585a:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
 800585e:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 8005862:	4330      	orrs	r0, r6
 8005864:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005868:	690e      	ldr	r6, [r1, #16]
        LL_ADC_SetOffsetSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSaturation == ENABLE) ? LL_ADC_OFFSET_SATURATION_ENABLE : LL_ADC_OFFSET_SATURATION_DISABLE);
 800586a:	7f0d      	ldrb	r5, [r1, #28]
  MODIFY_REG(*preg,
 800586c:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 8005870:	f1a5 0501 	sub.w	r5, r5, #1
 8005874:	fab5 f585 	clz	r5, r5
 8005878:	096d      	lsrs	r5, r5, #5
 800587a:	f020 7000 	bic.w	r0, r0, #33554432	; 0x2000000
 800587e:	ea40 6045 	orr.w	r0, r0, r5, lsl #25
 8005882:	f844 0026 	str.w	r0, [r4, r6, lsl #2]
 8005886:	6808      	ldr	r0, [r1, #0]
}
 8005888:	e73c      	b.n	8005704 <HAL_ADC_ConfigChannel+0x60>
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800588a:	6808      	ldr	r0, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800588c:	6e14      	ldr	r4, [r2, #96]	; 0x60
 800588e:	6e14      	ldr	r4, [r2, #96]	; 0x60
 8005890:	f3c0 0512 	ubfx	r5, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005894:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005898:	2d00      	cmp	r5, #0
 800589a:	f040 80df 	bne.w	8005a5c <HAL_ADC_ConfigChannel+0x3b8>
 800589e:	f3c0 6584 	ubfx	r5, r0, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 80058a2:	42ac      	cmp	r4, r5
 80058a4:	f000 813d 	beq.w	8005b22 <HAL_ADC_ConfigChannel+0x47e>
 80058a8:	6e54      	ldr	r4, [r2, #100]	; 0x64
 80058aa:	6e56      	ldr	r6, [r2, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80058ac:	f102 0460 	add.w	r4, r2, #96	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80058b0:	f3c6 6684 	ubfx	r6, r6, #26, #5
 80058b4:	f102 0764 	add.w	r7, r2, #100	; 0x64
 80058b8:	42ae      	cmp	r6, r5
 80058ba:	f000 8158 	beq.w	8005b6e <HAL_ADC_ConfigChannel+0x4ca>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80058be:	68a6      	ldr	r6, [r4, #8]
 80058c0:	68a6      	ldr	r6, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80058c2:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80058c6:	f3c6 6684 	ubfx	r6, r6, #26, #5
 80058ca:	42ae      	cmp	r6, r5
 80058cc:	f000 813d 	beq.w	8005b4a <HAL_ADC_ConfigChannel+0x4a6>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80058d0:	68e6      	ldr	r6, [r4, #12]
 80058d2:	68e6      	ldr	r6, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80058d4:	f104 070c 	add.w	r7, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80058d8:	f3c6 6484 	ubfx	r4, r6, #26, #5
 80058dc:	42a5      	cmp	r5, r4
 80058de:	f47f af11 	bne.w	8005704 <HAL_ADC_ConfigChannel+0x60>
  MODIFY_REG(*preg,
 80058e2:	6838      	ldr	r0, [r7, #0]
 80058e4:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80058e8:	6038      	str	r0, [r7, #0]
 80058ea:	6808      	ldr	r0, [r1, #0]
}
 80058ec:	e70a      	b.n	8005704 <HAL_ADC_ConfigChannel+0x60>
    SET_BIT(ADCx->DIFSEL,
 80058ee:	f8d2 40b0 	ldr.w	r4, [r2, #176]	; 0xb0
 80058f2:	f3c0 0512 	ubfx	r5, r0, #0, #19
 80058f6:	432c      	orrs	r4, r5
 80058f8:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80058fc:	2d00      	cmp	r5, #0
 80058fe:	d053      	beq.n	80059a8 <HAL_ADC_ConfigChannel+0x304>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005900:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 8005904:	2c00      	cmp	r4, #0
 8005906:	f000 80e8 	beq.w	8005ada <HAL_ADC_ConfigChannel+0x436>
  return __builtin_clz(value);
 800590a:	fab4 f484 	clz	r4, r4
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800590e:	3401      	adds	r4, #1
 8005910:	f004 041f 	and.w	r4, r4, #31
 8005914:	2c09      	cmp	r4, #9
 8005916:	f240 80e0 	bls.w	8005ada <HAL_ADC_ConfigChannel+0x436>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800591a:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 800591e:	2c00      	cmp	r4, #0
 8005920:	f000 813d 	beq.w	8005b9e <HAL_ADC_ConfigChannel+0x4fa>
  return __builtin_clz(value);
 8005924:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8005928:	3401      	adds	r4, #1
 800592a:	06a4      	lsls	r4, r4, #26
 800592c:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005930:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005934:	2d00      	cmp	r5, #0
 8005936:	f000 8130 	beq.w	8005b9a <HAL_ADC_ConfigChannel+0x4f6>
  return __builtin_clz(value);
 800593a:	fab5 f585 	clz	r5, r5
 800593e:	3501      	adds	r5, #1
 8005940:	f005 051f 	and.w	r5, r5, #31
 8005944:	2601      	movs	r6, #1
 8005946:	fa06 f505 	lsl.w	r5, r6, r5
 800594a:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800594c:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 8005950:	2800      	cmp	r0, #0
 8005952:	f000 8120 	beq.w	8005b96 <HAL_ADC_ConfigChannel+0x4f2>
  return __builtin_clz(value);
 8005956:	fab0 f080 	clz	r0, r0
 800595a:	1c45      	adds	r5, r0, #1
 800595c:	f005 051f 	and.w	r5, r5, #31
 8005960:	2003      	movs	r0, #3
 8005962:	f06f 061d 	mvn.w	r6, #29
 8005966:	fb10 6005 	smlabb	r0, r0, r5, r6
 800596a:	0500      	lsls	r0, r0, #20
 800596c:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005970:	4320      	orrs	r0, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005972:	0dc5      	lsrs	r5, r0, #23
  MODIFY_REG(*preg,
 8005974:	688c      	ldr	r4, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005976:	f005 0504 	and.w	r5, r5, #4
 800597a:	f102 0614 	add.w	r6, r2, #20
  MODIFY_REG(*preg,
 800597e:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8005982:	fa04 fc00 	lsl.w	ip, r4, r0
 8005986:	f04f 0e07 	mov.w	lr, #7
 800598a:	5974      	ldr	r4, [r6, r5]
 800598c:	fa0e f000 	lsl.w	r0, lr, r0
 8005990:	ea24 0000 	bic.w	r0, r4, r0
 8005994:	ea40 000c 	orr.w	r0, r0, ip
 8005998:	5170      	str	r0, [r6, r5]
    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800599a:	680c      	ldr	r4, [r1, #0]
}
 800599c:	e6c4      	b.n	8005728 <HAL_ADC_ConfigChannel+0x84>
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800599e:	491c      	ldr	r1, [pc, #112]	; (8005a10 <HAL_ADC_ConfigChannel+0x36c>)
 80059a0:	e6cf      	b.n	8005742 <HAL_ADC_ConfigChannel+0x9e>
  __HAL_LOCK(hadc);
 80059a2:	2002      	movs	r0, #2
}
 80059a4:	b003      	add	sp, #12
 80059a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80059a8:	0e80      	lsrs	r0, r0, #26
 80059aa:	3001      	adds	r0, #1
 80059ac:	f000 051f 	and.w	r5, r0, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80059b0:	2d09      	cmp	r5, #9
 80059b2:	f200 8084 	bhi.w	8005abe <HAL_ADC_ConfigChannel+0x41a>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80059b6:	0684      	lsls	r4, r0, #26
 80059b8:	2001      	movs	r0, #1
 80059ba:	40a8      	lsls	r0, r5
 80059bc:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 80059c0:	4304      	orrs	r4, r0
 80059c2:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 80059c6:	0500      	lsls	r0, r0, #20
 80059c8:	e7d2      	b.n	8005970 <HAL_ADC_ConfigChannel+0x2cc>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80059ca:	4811      	ldr	r0, [pc, #68]	; (8005a10 <HAL_ADC_ConfigChannel+0x36c>)
 80059cc:	e6ee      	b.n	80057ac <HAL_ADC_ConfigChannel+0x108>
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 80059ce:	4919      	ldr	r1, [pc, #100]	; (8005a34 <HAL_ADC_ConfigChannel+0x390>)
 80059d0:	428c      	cmp	r4, r1
 80059d2:	f47f af06 	bne.w	80057e2 <HAL_ADC_ConfigChannel+0x13e>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 80059d6:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
 80059da:	f47f af02 	bne.w	80057e2 <HAL_ADC_ConfigChannel+0x13e>
        if (ADC_VREFINT_INSTANCE(hadc))
 80059de:	490b      	ldr	r1, [pc, #44]	; (8005a0c <HAL_ADC_ConfigChannel+0x368>)
 80059e0:	428a      	cmp	r2, r1
 80059e2:	f43f aefe 	beq.w	80057e2 <HAL_ADC_ConfigChannel+0x13e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80059e6:	4c0b      	ldr	r4, [pc, #44]	; (8005a14 <HAL_ADC_ConfigChannel+0x370>)
 80059e8:	f501 7100 	add.w	r1, r1, #512	; 0x200
 80059ec:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80059f0:	bf18      	it	ne
 80059f2:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 80059f4:	688a      	ldr	r2, [r1, #8]
 80059f6:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 80059fa:	432a      	orrs	r2, r5
 80059fc:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8005a00:	608a      	str	r2, [r1, #8]
}
 8005a02:	e6c4      	b.n	800578e <HAL_ADC_ConfigChannel+0xea>
 8005a04:	407f0000 	.word	0x407f0000
 8005a08:	80080000 	.word	0x80080000
 8005a0c:	50000100 	.word	0x50000100
 8005a10:	50000300 	.word	0x50000300
 8005a14:	50000700 	.word	0x50000700
 8005a18:	c3210000 	.word	0xc3210000
 8005a1c:	90c00010 	.word	0x90c00010
 8005a20:	c7520000 	.word	0xc7520000
 8005a24:	50000600 	.word	0x50000600
 8005a28:	200014a4 	.word	0x200014a4
 8005a2c:	053e2d63 	.word	0x053e2d63
 8005a30:	03fff000 	.word	0x03fff000
 8005a34:	cb840000 	.word	0xcb840000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005a38:	0de8      	lsrs	r0, r5, #23
 8005a3a:	f000 0004 	and.w	r0, r0, #4
 8005a3e:	f102 0414 	add.w	r4, r2, #20
  MODIFY_REG(*preg,
 8005a42:	f3c5 5504 	ubfx	r5, r5, #20, #5
 8005a46:	2607      	movs	r6, #7
 8005a48:	40ae      	lsls	r6, r5
 8005a4a:	5825      	ldr	r5, [r4, r0]
 8005a4c:	ea25 0506 	bic.w	r5, r5, r6
 8005a50:	5025      	str	r5, [r4, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005a52:	6950      	ldr	r0, [r2, #20]
 8005a54:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 8005a58:	6150      	str	r0, [r2, #20]
}
 8005a5a:	e6e3      	b.n	8005824 <HAL_ADC_ConfigChannel+0x180>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a5c:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a60:	b11d      	cbz	r5, 8005a6a <HAL_ADC_ConfigChannel+0x3c6>
  return __builtin_clz(value);
 8005a62:	fab5 f585 	clz	r5, r5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005a66:	42ac      	cmp	r4, r5
 8005a68:	d05b      	beq.n	8005b22 <HAL_ADC_ConfigChannel+0x47e>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005a6a:	6e54      	ldr	r4, [r2, #100]	; 0x64
 8005a6c:	6e56      	ldr	r6, [r2, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005a6e:	f102 0460 	add.w	r4, r2, #96	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005a72:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8005a76:	f102 0764 	add.w	r7, r2, #100	; 0x64
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a7a:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a7e:	b11d      	cbz	r5, 8005a88 <HAL_ADC_ConfigChannel+0x3e4>
  return __builtin_clz(value);
 8005a80:	fab5 f585 	clz	r5, r5
 8005a84:	42ae      	cmp	r6, r5
 8005a86:	d072      	beq.n	8005b6e <HAL_ADC_ConfigChannel+0x4ca>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005a88:	68a5      	ldr	r5, [r4, #8]
 8005a8a:	68a6      	ldr	r6, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005a8c:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005a90:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a94:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a98:	b11d      	cbz	r5, 8005aa2 <HAL_ADC_ConfigChannel+0x3fe>
  return __builtin_clz(value);
 8005a9a:	fab5 f585 	clz	r5, r5
 8005a9e:	42ae      	cmp	r6, r5
 8005aa0:	d053      	beq.n	8005b4a <HAL_ADC_ConfigChannel+0x4a6>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005aa2:	68e5      	ldr	r5, [r4, #12]
 8005aa4:	68e5      	ldr	r5, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005aa6:	f104 070c 	add.w	r7, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005aaa:	f3c5 6484 	ubfx	r4, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005aae:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005ab2:	2d00      	cmp	r5, #0
 8005ab4:	f43f ae26 	beq.w	8005704 <HAL_ADC_ConfigChannel+0x60>
  return __builtin_clz(value);
 8005ab8:	fab5 f585 	clz	r5, r5
 8005abc:	e70e      	b.n	80058dc <HAL_ADC_ConfigChannel+0x238>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8005abe:	0684      	lsls	r4, r0, #26
 8005ac0:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 8005ac4:	381e      	subs	r0, #30
 8005ac6:	2601      	movs	r6, #1
 8005ac8:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 8005acc:	0500      	lsls	r0, r0, #20
 8005ace:	fa06 f505 	lsl.w	r5, r6, r5
 8005ad2:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
 8005ad6:	432c      	orrs	r4, r5
 8005ad8:	e74a      	b.n	8005970 <HAL_ADC_ConfigChannel+0x2cc>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005ada:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 8005ade:	2c00      	cmp	r4, #0
 8005ae0:	d065      	beq.n	8005bae <HAL_ADC_ConfigChannel+0x50a>
  return __builtin_clz(value);
 8005ae2:	fab4 f484 	clz	r4, r4
 8005ae6:	3401      	adds	r4, #1
 8005ae8:	06a4      	lsls	r4, r4, #26
 8005aea:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005aee:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005af2:	2d00      	cmp	r5, #0
 8005af4:	d059      	beq.n	8005baa <HAL_ADC_ConfigChannel+0x506>
  return __builtin_clz(value);
 8005af6:	fab5 f585 	clz	r5, r5
 8005afa:	3501      	adds	r5, #1
 8005afc:	f005 051f 	and.w	r5, r5, #31
 8005b00:	2601      	movs	r6, #1
 8005b02:	fa06 f505 	lsl.w	r5, r6, r5
 8005b06:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005b08:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 8005b0c:	2800      	cmp	r0, #0
 8005b0e:	d049      	beq.n	8005ba4 <HAL_ADC_ConfigChannel+0x500>
  return __builtin_clz(value);
 8005b10:	fab0 f080 	clz	r0, r0
 8005b14:	3001      	adds	r0, #1
 8005b16:	f000 001f 	and.w	r0, r0, #31
 8005b1a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8005b1e:	0500      	lsls	r0, r0, #20
 8005b20:	e726      	b.n	8005970 <HAL_ADC_ConfigChannel+0x2cc>
  MODIFY_REG(*preg,
 8005b22:	6e10      	ldr	r0, [r2, #96]	; 0x60
 8005b24:	4614      	mov	r4, r2
 8005b26:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005b2a:	f844 0f60 	str.w	r0, [r4, #96]!
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b2e:	6e50      	ldr	r0, [r2, #100]	; 0x64
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b30:	6808      	ldr	r0, [r1, #0]
 8005b32:	6e56      	ldr	r6, [r2, #100]	; 0x64
 8005b34:	f3c0 0512 	ubfx	r5, r0, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005b38:	f102 0764 	add.w	r7, r2, #100	; 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005b3c:	f3c6 6684 	ubfx	r6, r6, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b40:	2d00      	cmp	r5, #0
 8005b42:	d19a      	bne.n	8005a7a <HAL_ADC_ConfigChannel+0x3d6>
 8005b44:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b48:	e6b6      	b.n	80058b8 <HAL_ADC_ConfigChannel+0x214>
  MODIFY_REG(*preg,
 8005b4a:	6838      	ldr	r0, [r7, #0]
 8005b4c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005b50:	6038      	str	r0, [r7, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b52:	68e0      	ldr	r0, [r4, #12]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b54:	6808      	ldr	r0, [r1, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005b56:	f104 070c 	add.w	r7, r4, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b5a:	68e4      	ldr	r4, [r4, #12]
 8005b5c:	f3c0 0512 	ubfx	r5, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005b60:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b64:	2d00      	cmp	r5, #0
 8005b66:	d1a2      	bne.n	8005aae <HAL_ADC_ConfigChannel+0x40a>
 8005b68:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b6c:	e6b6      	b.n	80058dc <HAL_ADC_ConfigChannel+0x238>
  MODIFY_REG(*preg,
 8005b6e:	6838      	ldr	r0, [r7, #0]
 8005b70:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005b74:	6038      	str	r0, [r7, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b76:	68a0      	ldr	r0, [r4, #8]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b78:	6808      	ldr	r0, [r1, #0]
 8005b7a:	68a6      	ldr	r6, [r4, #8]
 8005b7c:	f3c0 0512 	ubfx	r5, r0, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005b80:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005b84:	f3c6 6684 	ubfx	r6, r6, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b88:	2d00      	cmp	r5, #0
 8005b8a:	d183      	bne.n	8005a94 <HAL_ADC_ConfigChannel+0x3f0>
 8005b8c:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b90:	e69b      	b.n	80058ca <HAL_ADC_ConfigChannel+0x226>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005b92:	4908      	ldr	r1, [pc, #32]	; (8005bb4 <HAL_ADC_ConfigChannel+0x510>)
 8005b94:	e5ee      	b.n	8005774 <HAL_ADC_ConfigChannel+0xd0>
 8005b96:	4808      	ldr	r0, [pc, #32]	; (8005bb8 <HAL_ADC_ConfigChannel+0x514>)
 8005b98:	e6ea      	b.n	8005970 <HAL_ADC_ConfigChannel+0x2cc>
 8005b9a:	2502      	movs	r5, #2
 8005b9c:	e6d5      	b.n	800594a <HAL_ADC_ConfigChannel+0x2a6>
 8005b9e:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 8005ba2:	e6c5      	b.n	8005930 <HAL_ADC_ConfigChannel+0x28c>
 8005ba4:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 8005ba8:	e6e2      	b.n	8005970 <HAL_ADC_ConfigChannel+0x2cc>
 8005baa:	2502      	movs	r5, #2
 8005bac:	e7ab      	b.n	8005b06 <HAL_ADC_ConfigChannel+0x462>
 8005bae:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 8005bb2:	e79c      	b.n	8005aee <HAL_ADC_ConfigChannel+0x44a>
 8005bb4:	50000300 	.word	0x50000300
 8005bb8:	fe500000 	.word	0xfe500000

08005bbc <HAL_ADCEx_InjectedConfigChannel>:
  * @param sConfigInjected Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
{
 8005bbc:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8005bbe:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
{
 8005bc2:	4602      	mov	r2, r0
 8005bc4:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0;
 8005bc6:	2000      	movs	r0, #0
  __HAL_LOCK(hadc);
 8005bc8:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0;
 8005bca:	9001      	str	r0, [sp, #4]
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8005bcc:	6950      	ldr	r0, [r2, #20]
  __HAL_LOCK(hadc);
 8005bce:	f000 8178 	beq.w	8005ec2 <HAL_ADCEx_InjectedConfigChannel+0x306>
 8005bd2:	2301      	movs	r3, #1
 8005bd4:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58
  /*      injected channel rank. It is entered into queue only when all       */
  /*      injected ranks have been set.                                       */
  /*   Note: Scan mode is not present by hardware on this device, but used    */
  /*   by software for alignment over all STM32 devices.                      */

  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8005bd8:	b1e8      	cbz	r0, 8005c16 <HAL_ADCEx_InjectedConfigChannel+0x5a>
      (sConfigInjected->InjectedNbrOfConversion == 1U))
 8005bda:	6a0b      	ldr	r3, [r1, #32]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8005bdc:	2b01      	cmp	r3, #1
 8005bde:	d01a      	beq.n	8005c16 <HAL_ADCEx_InjectedConfigChannel+0x5a>
    /* 1. Start new context and set parameters related to all injected        */
    /*    channels: injected sequence length and trigger.                     */

    /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
    /*   call of the context under setting                                    */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005be0:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8005be2:	2800      	cmp	r0, #0
 8005be4:	f040 8129 	bne.w	8005e3a <HAL_ADCEx_InjectedConfigChannel+0x27e>
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005be8:	6a88      	ldr	r0, [r1, #40]	; 0x28
 8005bea:	2800      	cmp	r0, #0
 8005bec:	f000 823f 	beq.w	800606e <HAL_ADCEx_InjectedConfigChannel+0x4b2>
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005bf0:	1e5e      	subs	r6, r3, #1
 8005bf2:	6acc      	ldr	r4, [r1, #44]	; 0x2c
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8005bf4:	f000 007c 	and.w	r0, r0, #124	; 0x7c
 8005bf8:	4330      	orrs	r0, r6
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005bfa:	ea40 0304 	orr.w	r3, r0, r4
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005bfe:	e9d1 4500 	ldrd	r4, r5, [r1]
 8005c02:	f005 051f 	and.w	r5, r5, #31
 8005c06:	f3c4 6084 	ubfx	r0, r4, #26, #5
 8005c0a:	40a8      	lsls	r0, r5
    hadc->InjectionConfig.ChannelCount--;

    /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
          call, aggregate the setting to those already built during the previous
          HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005c0c:	4318      	orrs	r0, r3
    hadc->InjectionConfig.ChannelCount--;
 8005c0e:	6696      	str	r6, [r2, #104]	; 0x68

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005c10:	6813      	ldr	r3, [r2, #0]
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005c12:	6650      	str	r0, [r2, #100]	; 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005c14:	e005      	b.n	8005c22 <HAL_ADCEx_InjectedConfigChannel+0x66>
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8005c16:	684b      	ldr	r3, [r1, #4]
 8005c18:	2b09      	cmp	r3, #9
 8005c1a:	f000 80fa 	beq.w	8005e12 <HAL_ADCEx_InjectedConfigChannel+0x256>
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005c1e:	680c      	ldr	r4, [r1, #0]
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005c20:	6813      	ldr	r3, [r2, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005c22:	6898      	ldr	r0, [r3, #8]
 8005c24:	0707      	lsls	r7, r0, #28
 8005c26:	d410      	bmi.n	8005c4a <HAL_ADCEx_InjectedConfigChannel+0x8e>
  /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
  /*    mode is disabled.                                                     */
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (sConfigInjected->AutoInjectedConv == DISABLE)
 8005c28:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005c2c:	2800      	cmp	r0, #0
 8005c2e:	f040 80e7 	bne.w	8005e00 <HAL_ADCEx_InjectedConfigChannel+0x244>
    {
      MODIFY_REG(hadc->Instance->CFGR,
 8005c32:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
 8005c36:	68dd      	ldr	r5, [r3, #12]
 8005c38:	f891 6026 	ldrb.w	r6, [r1, #38]	; 0x26
 8005c3c:	0500      	lsls	r0, r0, #20
 8005c3e:	f425 1540 	bic.w	r5, r5, #3145728	; 0x300000
 8005c42:	ea40 5046 	orr.w	r0, r0, r6, lsl #21
 8005c46:	4328      	orrs	r0, r5
 8005c48:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005c4a:	6898      	ldr	r0, [r3, #8]
 8005c4c:	f010 0004 	ands.w	r0, r0, #4
 8005c50:	d06a      	beq.n	8005d28 <HAL_ADCEx_InjectedConfigChannel+0x16c>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005c52:	6898      	ldr	r0, [r3, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005c54:	2000      	movs	r0, #0
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005c56:	689d      	ldr	r5, [r3, #8]
 8005c58:	07ee      	lsls	r6, r5, #31
 8005c5a:	d40c      	bmi.n	8005c76 <HAL_ADCEx_InjectedConfigChannel+0xba>
  if (SingleDiff == LL_ADC_DIFFERENTIAL_ENDED)
 8005c5c:	4da9      	ldr	r5, [pc, #676]	; (8005f04 <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8005c5e:	68ce      	ldr	r6, [r1, #12]
 8005c60:	42ae      	cmp	r6, r5
 8005c62:	f000 810f 	beq.w	8005e84 <HAL_ADCEx_InjectedConfigChannel+0x2c8>
    CLEAR_BIT(ADCx->DIFSEL,
 8005c66:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
 8005c6a:	f3c4 0512 	ubfx	r5, r4, #0, #19
 8005c6e:	ea21 0105 	bic.w	r1, r1, r5
 8005c72:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
  /* internal measurement paths enable: If internal channel selected,       */
  /* enable dedicated internal buffers and path.                            */
  /* Note: these internal measurement paths can be disabled using           */
  /* HAL_ADC_DeInit().                                                      */

  if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 8005c76:	49a4      	ldr	r1, [pc, #656]	; (8005f08 <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8005c78:	420c      	tst	r4, r1
 8005c7a:	d029      	beq.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
  {
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8005c7c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005c80:	f000 811d 	beq.w	8005ebe <HAL_ADCEx_InjectedConfigChannel+0x302>
 8005c84:	4ea1      	ldr	r6, [pc, #644]	; (8005f0c <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005c86:	49a2      	ldr	r1, [pc, #648]	; (8005f10 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005c88:	4da2      	ldr	r5, [pc, #648]	; (8005f14 <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005c8a:	42b3      	cmp	r3, r6
 8005c8c:	bf18      	it	ne
 8005c8e:	4629      	movne	r1, r5

    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if (((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC1)
 8005c90:	4da1      	ldr	r5, [pc, #644]	; (8005f18 <HAL_ADCEx_InjectedConfigChannel+0x35c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8005c92:	6889      	ldr	r1, [r1, #8]
 8005c94:	42ac      	cmp	r4, r5
 8005c96:	f001 76e0 	and.w	r6, r1, #29360128	; 0x1c00000
 8005c9a:	d01e      	beq.n	8005cda <HAL_ADCEx_InjectedConfigChannel+0x11e>
         || (sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8005c9c:	4d9f      	ldr	r5, [pc, #636]	; (8005f1c <HAL_ADCEx_InjectedConfigChannel+0x360>)
 8005c9e:	42ac      	cmp	r4, r5
 8005ca0:	d01b      	beq.n	8005cda <HAL_ADCEx_InjectedConfigChannel+0x11e>
        {
          wait_loop_index--;
        }
      }
    }
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
 8005ca2:	4d9f      	ldr	r5, [pc, #636]	; (8005f20 <HAL_ADCEx_InjectedConfigChannel+0x364>)
 8005ca4:	42ac      	cmp	r4, r5
 8005ca6:	f040 8113 	bne.w	8005ed0 <HAL_ADCEx_InjectedConfigChannel+0x314>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8005caa:	01cd      	lsls	r5, r1, #7
 8005cac:	d410      	bmi.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
    {
      if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
      {
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005cae:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005cb2:	f000 8249 	beq.w	8006148 <HAL_ADCEx_InjectedConfigChannel+0x58c>
 8005cb6:	4d95      	ldr	r5, [pc, #596]	; (8005f0c <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005cb8:	4995      	ldr	r1, [pc, #596]	; (8005f10 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005cba:	4c96      	ldr	r4, [pc, #600]	; (8005f14 <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005cbc:	42ab      	cmp	r3, r5
 8005cbe:	bf18      	it	ne
 8005cc0:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005cc2:	688b      	ldr	r3, [r1, #8]
 8005cc4:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005cc8:	4333      	orrs	r3, r6
 8005cca:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005cce:	608b      	str	r3, [r1, #8]
      /* nothing to do */
    }
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8005cd0:	2300      	movs	r3, #0
 8005cd2:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8005cd6:	b003      	add	sp, #12
 8005cd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8005cda:	0209      	lsls	r1, r1, #8
 8005cdc:	d4f8      	bmi.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
      if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8005cde:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005ce2:	f000 8233 	beq.w	800614c <HAL_ADCEx_InjectedConfigChannel+0x590>
 8005ce6:	498f      	ldr	r1, [pc, #572]	; (8005f24 <HAL_ADCEx_InjectedConfigChannel+0x368>)
 8005ce8:	428b      	cmp	r3, r1
 8005cea:	d1f1      	bne.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005cec:	4c89      	ldr	r4, [pc, #548]	; (8005f14 <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005cee:	68a1      	ldr	r1, [r4, #8]
        wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (((SystemCoreClock / (100000UL * 2UL)) + 1UL) + 1UL));
 8005cf0:	4b8d      	ldr	r3, [pc, #564]	; (8005f28 <HAL_ADCEx_InjectedConfigChannel+0x36c>)
 8005cf2:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8005cf6:	4331      	orrs	r1, r6
 8005cf8:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8005cfc:	681b      	ldr	r3, [r3, #0]
 8005cfe:	60a1      	str	r1, [r4, #8]
 8005d00:	498a      	ldr	r1, [pc, #552]	; (8005f2c <HAL_ADCEx_InjectedConfigChannel+0x370>)
 8005d02:	099b      	lsrs	r3, r3, #6
 8005d04:	fba1 1303 	umull	r1, r3, r1, r3
 8005d08:	099b      	lsrs	r3, r3, #6
 8005d0a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8005d0e:	009b      	lsls	r3, r3, #2
 8005d10:	3318      	adds	r3, #24
 8005d12:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8005d14:	9b01      	ldr	r3, [sp, #4]
 8005d16:	2b00      	cmp	r3, #0
 8005d18:	d0da      	beq.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
          wait_loop_index--;
 8005d1a:	9b01      	ldr	r3, [sp, #4]
 8005d1c:	3b01      	subs	r3, #1
 8005d1e:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8005d20:	9b01      	ldr	r3, [sp, #4]
 8005d22:	2b00      	cmp	r3, #0
 8005d24:	d1f9      	bne.n	8005d1a <HAL_ADCEx_InjectedConfigChannel+0x15e>
 8005d26:	e7d3      	b.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005d28:	689d      	ldr	r5, [r3, #8]
 8005d2a:	f015 0508 	ands.w	r5, r5, #8
 8005d2e:	d192      	bne.n	8005c56 <HAL_ADCEx_InjectedConfigChannel+0x9a>
    if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8005d30:	6a88      	ldr	r0, [r1, #40]	; 0x28
 8005d32:	2800      	cmp	r0, #0
 8005d34:	f040 8097 	bne.w	8005e66 <HAL_ADCEx_InjectedConfigChannel+0x2aa>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005d38:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005d3c:	2801      	cmp	r0, #1
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005d3e:	68d8      	ldr	r0, [r3, #12]
 8005d40:	bf0c      	ite	eq
 8005d42:	f040 7000 	orreq.w	r0, r0, #33554432	; 0x2000000
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005d46:	f020 7000 	bicne.w	r0, r0, #33554432	; 0x2000000
 8005d4a:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005d4c:	2000      	movs	r0, #0
    if (sConfigInjected->InjecOversamplingMode == ENABLE)
 8005d4e:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 8005d52:	2d01      	cmp	r5, #1
 8005d54:	f000 8149 	beq.w	8005fea <HAL_ADCEx_InjectedConfigChannel+0x42e>
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 8005d58:	691d      	ldr	r5, [r3, #16]
 8005d5a:	f025 0502 	bic.w	r5, r5, #2
 8005d5e:	611d      	str	r5, [r3, #16]
    if (sConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8005d60:	688d      	ldr	r5, [r1, #8]
 8005d62:	f1b5 4f00 	cmp.w	r5, #2147483648	; 0x80000000
 8005d66:	f000 812e 	beq.w	8005fc6 <HAL_ADCEx_InjectedConfigChannel+0x40a>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005d6a:	0de6      	lsrs	r6, r4, #23
 8005d6c:	f006 0604 	and.w	r6, r6, #4
 8005d70:	f103 0c14 	add.w	ip, r3, #20
  MODIFY_REG(*preg,
 8005d74:	f3c4 5404 	ubfx	r4, r4, #20, #5
 8005d78:	2707      	movs	r7, #7
 8005d7a:	40a5      	lsls	r5, r4
 8005d7c:	40a7      	lsls	r7, r4
 8005d7e:	f85c 4006 	ldr.w	r4, [ip, r6]
 8005d82:	ea24 0407 	bic.w	r4, r4, r7
 8005d86:	432c      	orrs	r4, r5
 8005d88:	f84c 4006 	str.w	r4, [ip, r6]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005d8c:	695c      	ldr	r4, [r3, #20]
 8005d8e:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8005d92:	615c      	str	r4, [r3, #20]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8005d94:	e9d1 6504 	ldrd	r6, r5, [r1, #16]
 8005d98:	2e04      	cmp	r6, #4
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 8005d9a:	68dc      	ldr	r4, [r3, #12]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8005d9c:	f000 80ce 	beq.w	8005f3c <HAL_ADCEx_InjectedConfigChannel+0x380>
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 8005da0:	f3c4 04c1 	ubfx	r4, r4, #3, #2
 8005da4:	0064      	lsls	r4, r4, #1
 8005da6:	fa05 fc04 	lsl.w	ip, r5, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005daa:	f103 0560 	add.w	r5, r3, #96	; 0x60
  MODIFY_REG(*preg,
 8005dae:	680c      	ldr	r4, [r1, #0]
 8005db0:	f855 e026 	ldr.w	lr, [r5, r6, lsl #2]
 8005db4:	4f5e      	ldr	r7, [pc, #376]	; (8005f30 <HAL_ADCEx_InjectedConfigChannel+0x374>)
 8005db6:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 8005dba:	ea0e 0707 	and.w	r7, lr, r7
 8005dbe:	433c      	orrs	r4, r7
 8005dc0:	ea44 040c 	orr.w	r4, r4, ip
 8005dc4:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8005dc8:	f845 4026 	str.w	r4, [r5, r6, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005dcc:	690f      	ldr	r7, [r1, #16]
  MODIFY_REG(*preg,
 8005dce:	698e      	ldr	r6, [r1, #24]
 8005dd0:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8005dd4:	f024 7480 	bic.w	r4, r4, #16777216	; 0x1000000
 8005dd8:	4334      	orrs	r4, r6
 8005dda:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005dde:	690f      	ldr	r7, [r1, #16]
      LL_ADC_SetOffsetSaturation(hadc->Instance, sConfigInjected->InjectedOffsetNumber,
 8005de0:	7f0e      	ldrb	r6, [r1, #28]
  MODIFY_REG(*preg,
 8005de2:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8005de6:	f1a6 0601 	sub.w	r6, r6, #1
 8005dea:	fab6 f686 	clz	r6, r6
 8005dee:	0976      	lsrs	r6, r6, #5
 8005df0:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
 8005df4:	ea44 6446 	orr.w	r4, r4, r6, lsl #25
 8005df8:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 8005dfc:	680c      	ldr	r4, [r1, #0]
}
 8005dfe:	e72a      	b.n	8005c56 <HAL_ADCEx_InjectedConfigChannel+0x9a>
      MODIFY_REG(hadc->Instance->CFGR,
 8005e00:	68d8      	ldr	r0, [r3, #12]
 8005e02:	f891 5026 	ldrb.w	r5, [r1, #38]	; 0x26
 8005e06:	f420 1040 	bic.w	r0, r0, #3145728	; 0x300000
 8005e0a:	ea40 5045 	orr.w	r0, r0, r5, lsl #21
 8005e0e:	60d8      	str	r0, [r3, #12]
 8005e10:	e71b      	b.n	8005c4a <HAL_ADCEx_InjectedConfigChannel+0x8e>
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005e12:	6a8b      	ldr	r3, [r1, #40]	; 0x28
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005e14:	680c      	ldr	r4, [r1, #0]
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005e16:	2b00      	cmp	r3, #0
 8005e18:	d056      	beq.n	8005ec8 <HAL_ADCEx_InjectedConfigChannel+0x30c>
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005e1a:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8005e1c:	f003 037c 	and.w	r3, r3, #124	; 0x7c
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005e20:	0c65      	lsrs	r5, r4, #17
 8005e22:	f405 5578 	and.w	r5, r5, #15872	; 0x3e00
 8005e26:	4303      	orrs	r3, r0
 8005e28:	431d      	orrs	r5, r3
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
 8005e2a:	6813      	ldr	r3, [r2, #0]
 8005e2c:	4e41      	ldr	r6, [pc, #260]	; (8005f34 <HAL_ADCEx_InjectedConfigChannel+0x378>)
 8005e2e:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 8005e30:	4030      	ands	r0, r6
 8005e32:	4328      	orrs	r0, r5
 8005e34:	64d8      	str	r0, [r3, #76]	; 0x4c
      hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
 8005e36:	6655      	str	r5, [r2, #100]	; 0x64
 8005e38:	e6f3      	b.n	8005c22 <HAL_ADCEx_InjectedConfigChannel+0x66>
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005e3a:	680c      	ldr	r4, [r1, #0]
 8005e3c:	684b      	ldr	r3, [r1, #4]
 8005e3e:	f3c4 6584 	ubfx	r5, r4, #26, #5
 8005e42:	f003 031f 	and.w	r3, r3, #31
 8005e46:	409d      	lsls	r5, r3
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e48:	6e53      	ldr	r3, [r2, #100]	; 0x64
    hadc->InjectionConfig.ChannelCount--;
 8005e4a:	3801      	subs	r0, #1
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e4c:	431d      	orrs	r5, r3
    hadc->InjectionConfig.ChannelCount--;
 8005e4e:	6690      	str	r0, [r2, #104]	; 0x68
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005e50:	6813      	ldr	r3, [r2, #0]
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e52:	6655      	str	r5, [r2, #100]	; 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005e54:	2800      	cmp	r0, #0
 8005e56:	f47f aee4 	bne.w	8005c22 <HAL_ADCEx_InjectedConfigChannel+0x66>
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005e5a:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 8005e5c:	4e35      	ldr	r6, [pc, #212]	; (8005f34 <HAL_ADCEx_InjectedConfigChannel+0x378>)
 8005e5e:	4030      	ands	r0, r6
 8005e60:	4328      	orrs	r0, r5
 8005e62:	64d8      	str	r0, [r3, #76]	; 0x4c
 8005e64:	e6dd      	b.n	8005c22 <HAL_ADCEx_InjectedConfigChannel+0x66>
        || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 8005e66:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 8005e68:	2800      	cmp	r0, #0
 8005e6a:	f43f af65 	beq.w	8005d38 <HAL_ADCEx_InjectedConfigChannel+0x17c>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005e6e:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005e72:	2801      	cmp	r0, #1
 8005e74:	f000 8163 	beq.w	800613e <HAL_ADCEx_InjectedConfigChannel+0x582>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005e78:	4628      	mov	r0, r5
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005e7a:	68dd      	ldr	r5, [r3, #12]
 8005e7c:	f025 7500 	bic.w	r5, r5, #33554432	; 0x2000000
 8005e80:	60dd      	str	r5, [r3, #12]
 8005e82:	e764      	b.n	8005d4e <HAL_ADCEx_InjectedConfigChannel+0x192>
    SET_BIT(ADCx->DIFSEL,
 8005e84:	f8d3 50b0 	ldr.w	r5, [r3, #176]	; 0xb0
 8005e88:	f3c4 0612 	ubfx	r6, r4, #0, #19
 8005e8c:	4335      	orrs	r5, r6
 8005e8e:	f8c3 50b0 	str.w	r5, [r3, #176]	; 0xb0
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8005e92:	2e00      	cmp	r6, #0
 8005e94:	f040 80b4 	bne.w	8006000 <HAL_ADCEx_InjectedConfigChannel+0x444>
 8005e98:	0ea4      	lsrs	r4, r4, #26
 8005e9a:	3401      	adds	r4, #1
 8005e9c:	f004 0c1f 	and.w	ip, r4, #31
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005ea0:	f1bc 0f09 	cmp.w	ip, #9
 8005ea4:	f200 80e6 	bhi.w	8006074 <HAL_ADCEx_InjectedConfigChannel+0x4b8>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8005ea8:	06a5      	lsls	r5, r4, #26
 8005eaa:	2401      	movs	r4, #1
 8005eac:	fa04 f40c 	lsl.w	r4, r4, ip
 8005eb0:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 8005eb4:	4325      	orrs	r5, r4
 8005eb6:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8005eba:	0524      	lsls	r4, r4, #20
 8005ebc:	e0e7      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x4d2>
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8005ebe:	4914      	ldr	r1, [pc, #80]	; (8005f10 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005ec0:	e6e6      	b.n	8005c90 <HAL_ADCEx_InjectedConfigChannel+0xd4>
  __HAL_LOCK(hadc);
 8005ec2:	2002      	movs	r0, #2
}
 8005ec4:	b003      	add	sp, #12
 8005ec6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
 8005ec8:	0c65      	lsrs	r5, r4, #17
 8005eca:	f405 5578 	and.w	r5, r5, #15872	; 0x3e00
 8005ece:	e7ac      	b.n	8005e2a <HAL_ADCEx_InjectedConfigChannel+0x26e>
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
 8005ed0:	4d19      	ldr	r5, [pc, #100]	; (8005f38 <HAL_ADCEx_InjectedConfigChannel+0x37c>)
 8005ed2:	42ac      	cmp	r4, r5
 8005ed4:	f47f aefc 	bne.w	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8005ed8:	024c      	lsls	r4, r1, #9
 8005eda:	f53f aef9 	bmi.w	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
      if (ADC_VREFINT_INSTANCE(hadc))
 8005ede:	490b      	ldr	r1, [pc, #44]	; (8005f0c <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005ee0:	428b      	cmp	r3, r1
 8005ee2:	f43f aef5 	beq.w	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005ee6:	4c0b      	ldr	r4, [pc, #44]	; (8005f14 <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005ee8:	f501 7100 	add.w	r1, r1, #512	; 0x200
 8005eec:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005ef0:	bf18      	it	ne
 8005ef2:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005ef4:	688b      	ldr	r3, [r1, #8]
 8005ef6:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005efa:	4333      	orrs	r3, r6
 8005efc:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8005f00:	608b      	str	r3, [r1, #8]
}
 8005f02:	e6e5      	b.n	8005cd0 <HAL_ADCEx_InjectedConfigChannel+0x114>
 8005f04:	407f0000 	.word	0x407f0000
 8005f08:	80080000 	.word	0x80080000
 8005f0c:	50000100 	.word	0x50000100
 8005f10:	50000300 	.word	0x50000300
 8005f14:	50000700 	.word	0x50000700
 8005f18:	c3210000 	.word	0xc3210000
 8005f1c:	90c00010 	.word	0x90c00010
 8005f20:	c7520000 	.word	0xc7520000
 8005f24:	50000600 	.word	0x50000600
 8005f28:	200014a4 	.word	0x200014a4
 8005f2c:	053e2d63 	.word	0x053e2d63
 8005f30:	03fff000 	.word	0x03fff000
 8005f34:	04104000 	.word	0x04104000
 8005f38:	cb840000 	.word	0xcb840000
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005f3c:	6e1c      	ldr	r4, [r3, #96]	; 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005f3e:	680c      	ldr	r4, [r1, #0]
 8005f40:	6e1d      	ldr	r5, [r3, #96]	; 0x60
 8005f42:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005f46:	f3c5 6584 	ubfx	r5, r5, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005f4a:	2e00      	cmp	r6, #0
 8005f4c:	f000 80b7 	beq.w	80060be <HAL_ADCEx_InjectedConfigChannel+0x502>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f50:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f54:	b126      	cbz	r6, 8005f60 <HAL_ADCEx_InjectedConfigChannel+0x3a4>
  return __builtin_clz(value);
 8005f56:	fab6 f686 	clz	r6, r6
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005f5a:	42b5      	cmp	r5, r6
 8005f5c:	f000 80f8 	beq.w	8006150 <HAL_ADCEx_InjectedConfigChannel+0x594>
 8005f60:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 8005f62:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f64:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005f68:	f3c7 6784 	ubfx	r7, r7, #26, #5
 8005f6c:	f103 0c64 	add.w	ip, r3, #100	; 0x64
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f70:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f74:	b126      	cbz	r6, 8005f80 <HAL_ADCEx_InjectedConfigChannel+0x3c4>
  return __builtin_clz(value);
 8005f76:	fab6 f686 	clz	r6, r6
 8005f7a:	42b7      	cmp	r7, r6
 8005f7c:	f000 80fd 	beq.w	800617a <HAL_ADCEx_InjectedConfigChannel+0x5be>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005f80:	68ae      	ldr	r6, [r5, #8]
 8005f82:	68af      	ldr	r7, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f84:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005f88:	f3c7 6784 	ubfx	r7, r7, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f8c:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f90:	b126      	cbz	r6, 8005f9c <HAL_ADCEx_InjectedConfigChannel+0x3e0>
  return __builtin_clz(value);
 8005f92:	fab6 f686 	clz	r6, r6
 8005f96:	42b7      	cmp	r7, r6
 8005f98:	f000 8104 	beq.w	80061a4 <HAL_ADCEx_InjectedConfigChannel+0x5e8>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005f9c:	68ee      	ldr	r6, [r5, #12]
 8005f9e:	68ef      	ldr	r7, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005fa0:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005fa2:	f3c7 6784 	ubfx	r7, r7, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005fa6:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005faa:	2e00      	cmp	r6, #0
 8005fac:	f43f ae53 	beq.w	8005c56 <HAL_ADCEx_InjectedConfigChannel+0x9a>
  return __builtin_clz(value);
 8005fb0:	fab6 f686 	clz	r6, r6
 8005fb4:	42be      	cmp	r6, r7
 8005fb6:	f47f ae4e 	bne.w	8005c56 <HAL_ADCEx_InjectedConfigChannel+0x9a>
  MODIFY_REG(*preg,
 8005fba:	682c      	ldr	r4, [r5, #0]
 8005fbc:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8005fc0:	602c      	str	r4, [r5, #0]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 8005fc2:	680c      	ldr	r4, [r1, #0]
}
 8005fc4:	e647      	b.n	8005c56 <HAL_ADCEx_InjectedConfigChannel+0x9a>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005fc6:	0de5      	lsrs	r5, r4, #23
  MODIFY_REG(*preg,
 8005fc8:	f3c4 5604 	ubfx	r6, r4, #20, #5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005fcc:	f005 0504 	and.w	r5, r5, #4
 8005fd0:	f103 0414 	add.w	r4, r3, #20
  MODIFY_REG(*preg,
 8005fd4:	2707      	movs	r7, #7
 8005fd6:	40b7      	lsls	r7, r6
 8005fd8:	5966      	ldr	r6, [r4, r5]
 8005fda:	ea26 0607 	bic.w	r6, r6, r7
 8005fde:	5166      	str	r6, [r4, r5]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005fe0:	695c      	ldr	r4, [r3, #20]
 8005fe2:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8005fe6:	615c      	str	r4, [r3, #20]
}
 8005fe8:	e6d4      	b.n	8005d94 <HAL_ADCEx_InjectedConfigChannel+0x1d8>
      MODIFY_REG(hadc->Instance->CFGR2,
 8005fea:	e9d1 570d 	ldrd	r5, r7, [r1, #52]	; 0x34
 8005fee:	691e      	ldr	r6, [r3, #16]
 8005ff0:	433d      	orrs	r5, r7
 8005ff2:	f426 76ff 	bic.w	r6, r6, #510	; 0x1fe
 8005ff6:	4335      	orrs	r5, r6
 8005ff8:	f045 0502 	orr.w	r5, r5, #2
 8005ffc:	611d      	str	r5, [r3, #16]
 8005ffe:	e6af      	b.n	8005d60 <HAL_ADCEx_InjectedConfigChannel+0x1a4>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006000:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8006004:	2d00      	cmp	r5, #0
 8006006:	d076      	beq.n	80060f6 <HAL_ADCEx_InjectedConfigChannel+0x53a>
  return __builtin_clz(value);
 8006008:	fab5 f585 	clz	r5, r5
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800600c:	3501      	adds	r5, #1
 800600e:	f005 051f 	and.w	r5, r5, #31
 8006012:	2d09      	cmp	r5, #9
 8006014:	d96f      	bls.n	80060f6 <HAL_ADCEx_InjectedConfigChannel+0x53a>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006016:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 800601a:	2d00      	cmp	r5, #0
 800601c:	f000 80e2 	beq.w	80061e4 <HAL_ADCEx_InjectedConfigChannel+0x628>
  return __builtin_clz(value);
 8006020:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8006024:	3501      	adds	r5, #1
 8006026:	06ad      	lsls	r5, r5, #26
 8006028:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800602c:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8006030:	2e00      	cmp	r6, #0
 8006032:	f000 80d5 	beq.w	80061e0 <HAL_ADCEx_InjectedConfigChannel+0x624>
  return __builtin_clz(value);
 8006036:	fab6 f686 	clz	r6, r6
 800603a:	3601      	adds	r6, #1
 800603c:	f006 061f 	and.w	r6, r6, #31
 8006040:	2701      	movs	r7, #1
 8006042:	fa07 f606 	lsl.w	r6, r7, r6
 8006046:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006048:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 800604c:	2c00      	cmp	r4, #0
 800604e:	f000 80c5 	beq.w	80061dc <HAL_ADCEx_InjectedConfigChannel+0x620>
  return __builtin_clz(value);
 8006052:	fab4 f484 	clz	r4, r4
 8006056:	1c66      	adds	r6, r4, #1
 8006058:	f006 061f 	and.w	r6, r6, #31
 800605c:	2403      	movs	r4, #3
 800605e:	f06f 071d 	mvn.w	r7, #29
 8006062:	fb14 7406 	smlabb	r4, r4, r6, r7
 8006066:	0524      	lsls	r4, r4, #20
 8006068:	f044 7400 	orr.w	r4, r4, #33554432	; 0x2000000
 800606c:	e00f      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x4d2>
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
 800606e:	3b01      	subs	r3, #1
 8006070:	461e      	mov	r6, r3
 8006072:	e5c4      	b.n	8005bfe <HAL_ADCEx_InjectedConfigChannel+0x42>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8006074:	06a5      	lsls	r5, r4, #26
 8006076:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 800607a:	3c1e      	subs	r4, #30
 800607c:	2601      	movs	r6, #1
 800607e:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 8006082:	0524      	lsls	r4, r4, #20
 8006084:	fa06 f60c 	lsl.w	r6, r6, ip
 8006088:	f044 7400 	orr.w	r4, r4, #33554432	; 0x2000000
 800608c:	4335      	orrs	r5, r6
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800608e:	432c      	orrs	r4, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8006090:	ea4f 5cd4 	mov.w	ip, r4, lsr #23
  MODIFY_REG(*preg,
 8006094:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8006096:	f00c 0c04 	and.w	ip, ip, #4
 800609a:	f103 0e14 	add.w	lr, r3, #20
  MODIFY_REG(*preg,
 800609e:	f3c4 5404 	ubfx	r4, r4, #20, #5
 80060a2:	fa05 f604 	lsl.w	r6, r5, r4
 80060a6:	2707      	movs	r7, #7
 80060a8:	f85e 500c 	ldr.w	r5, [lr, ip]
 80060ac:	fa07 f404 	lsl.w	r4, r7, r4
 80060b0:	ea25 0404 	bic.w	r4, r5, r4
 80060b4:	4334      	orrs	r4, r6
 80060b6:	f84e 400c 	str.w	r4, [lr, ip]
  if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 80060ba:	680c      	ldr	r4, [r1, #0]
}
 80060bc:	e5db      	b.n	8005c76 <HAL_ADCEx_InjectedConfigChannel+0xba>
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80060be:	f3c4 6684 	ubfx	r6, r4, #26, #5
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 80060c2:	42b5      	cmp	r5, r6
 80060c4:	d044      	beq.n	8006150 <HAL_ADCEx_InjectedConfigChannel+0x594>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80060c6:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 80060c8:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80060ca:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 80060ce:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80060d2:	f103 0c64 	add.w	ip, r3, #100	; 0x64
 80060d6:	42b7      	cmp	r7, r6
 80060d8:	d04f      	beq.n	800617a <HAL_ADCEx_InjectedConfigChannel+0x5be>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80060da:	68af      	ldr	r7, [r5, #8]
 80060dc:	68af      	ldr	r7, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80060de:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80060e2:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80060e6:	42b7      	cmp	r7, r6
 80060e8:	d05c      	beq.n	80061a4 <HAL_ADCEx_InjectedConfigChannel+0x5e8>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80060ea:	68ef      	ldr	r7, [r5, #12]
 80060ec:	68ef      	ldr	r7, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80060ee:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80060f0:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80060f4:	e75e      	b.n	8005fb4 <HAL_ADCEx_InjectedConfigChannel+0x3f8>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80060f6:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 80060fa:	2d00      	cmp	r5, #0
 80060fc:	d068      	beq.n	80061d0 <HAL_ADCEx_InjectedConfigChannel+0x614>
  return __builtin_clz(value);
 80060fe:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8006102:	3501      	adds	r5, #1
 8006104:	06ad      	lsls	r5, r5, #26
 8006106:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800610a:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 800610e:	2e00      	cmp	r6, #0
 8006110:	d05c      	beq.n	80061cc <HAL_ADCEx_InjectedConfigChannel+0x610>
  return __builtin_clz(value);
 8006112:	fab6 f686 	clz	r6, r6
 8006116:	3601      	adds	r6, #1
 8006118:	f006 061f 	and.w	r6, r6, #31
 800611c:	2701      	movs	r7, #1
 800611e:	fa07 f606 	lsl.w	r6, r7, r6
 8006122:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006124:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8006128:	2c00      	cmp	r4, #0
 800612a:	d054      	beq.n	80061d6 <HAL_ADCEx_InjectedConfigChannel+0x61a>
  return __builtin_clz(value);
 800612c:	fab4 f484 	clz	r4, r4
 8006130:	3401      	adds	r4, #1
 8006132:	f004 041f 	and.w	r4, r4, #31
 8006136:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800613a:	0524      	lsls	r4, r4, #20
 800613c:	e7a7      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x4d2>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800613e:	6dd5      	ldr	r5, [r2, #92]	; 0x5c
 8006140:	f045 0520 	orr.w	r5, r5, #32
 8006144:	65d5      	str	r5, [r2, #92]	; 0x5c
        tmp_hal_status = HAL_ERROR;
 8006146:	e602      	b.n	8005d4e <HAL_ADCEx_InjectedConfigChannel+0x192>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8006148:	4928      	ldr	r1, [pc, #160]	; (80061ec <HAL_ADCEx_InjectedConfigChannel+0x630>)
 800614a:	e5ba      	b.n	8005cc2 <HAL_ADCEx_InjectedConfigChannel+0x106>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800614c:	4c27      	ldr	r4, [pc, #156]	; (80061ec <HAL_ADCEx_InjectedConfigChannel+0x630>)
 800614e:	e5ce      	b.n	8005cee <HAL_ADCEx_InjectedConfigChannel+0x132>
  MODIFY_REG(*preg,
 8006150:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8006152:	461d      	mov	r5, r3
 8006154:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8006158:	f845 4f60 	str.w	r4, [r5, #96]!
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800615c:	6e5c      	ldr	r4, [r3, #100]	; 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800615e:	680c      	ldr	r4, [r1, #0]
 8006160:	6e5f      	ldr	r7, [r3, #100]	; 0x64
 8006162:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8006166:	f3c7 6784 	ubfx	r7, r7, #26, #5
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800616a:	f103 0c64 	add.w	ip, r3, #100	; 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800616e:	2e00      	cmp	r6, #0
 8006170:	f47f aefe 	bne.w	8005f70 <HAL_ADCEx_InjectedConfigChannel+0x3b4>
 8006174:	f3c4 6684 	ubfx	r6, r4, #26, #5
 8006178:	e7ad      	b.n	80060d6 <HAL_ADCEx_InjectedConfigChannel+0x51a>
  MODIFY_REG(*preg,
 800617a:	f8dc 4000 	ldr.w	r4, [ip]
 800617e:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8006182:	f8cc 4000 	str.w	r4, [ip]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8006186:	68ac      	ldr	r4, [r5, #8]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006188:	680c      	ldr	r4, [r1, #0]
 800618a:	68af      	ldr	r7, [r5, #8]
 800618c:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8006190:	f3c7 6784 	ubfx	r7, r7, #26, #5
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8006194:	f105 0c08 	add.w	ip, r5, #8
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006198:	2e00      	cmp	r6, #0
 800619a:	f47f aef7 	bne.w	8005f8c <HAL_ADCEx_InjectedConfigChannel+0x3d0>
 800619e:	f3c4 6684 	ubfx	r6, r4, #26, #5
 80061a2:	e7a0      	b.n	80060e6 <HAL_ADCEx_InjectedConfigChannel+0x52a>
  MODIFY_REG(*preg,
 80061a4:	f8dc 4000 	ldr.w	r4, [ip]
 80061a8:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 80061ac:	f8cc 4000 	str.w	r4, [ip]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80061b0:	68ec      	ldr	r4, [r5, #12]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80061b2:	680c      	ldr	r4, [r1, #0]
 80061b4:	68ef      	ldr	r7, [r5, #12]
 80061b6:	f3c4 0612 	ubfx	r6, r4, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80061ba:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80061bc:	f3c7 6784 	ubfx	r7, r7, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80061c0:	2e00      	cmp	r6, #0
 80061c2:	f47f aef0 	bne.w	8005fa6 <HAL_ADCEx_InjectedConfigChannel+0x3ea>
 80061c6:	f3c4 6684 	ubfx	r6, r4, #26, #5
 80061ca:	e6f3      	b.n	8005fb4 <HAL_ADCEx_InjectedConfigChannel+0x3f8>
 80061cc:	2602      	movs	r6, #2
 80061ce:	e7a8      	b.n	8006122 <HAL_ADCEx_InjectedConfigChannel+0x566>
 80061d0:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 80061d4:	e799      	b.n	800610a <HAL_ADCEx_InjectedConfigChannel+0x54e>
 80061d6:	f44f 1440 	mov.w	r4, #3145728	; 0x300000
 80061da:	e758      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x4d2>
 80061dc:	4c04      	ldr	r4, [pc, #16]	; (80061f0 <HAL_ADCEx_InjectedConfigChannel+0x634>)
 80061de:	e756      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x4d2>
 80061e0:	2602      	movs	r6, #2
 80061e2:	e730      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x48a>
 80061e4:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 80061e8:	e720      	b.n	800602c <HAL_ADCEx_InjectedConfigChannel+0x470>
 80061ea:	bf00      	nop
 80061ec:	50000300 	.word	0x50000300
 80061f0:	fe500000 	.word	0xfe500000

080061f4 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 80061f4:	b470      	push	{r4, r5, r6}
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(multimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80061f6:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80061fa:	680e      	ldr	r6, [r1, #0]
  __HAL_LOCK(hadc);
 80061fc:	2a01      	cmp	r2, #1
{
 80061fe:	b09d      	sub	sp, #116	; 0x74
  __HAL_LOCK(hadc);
 8006200:	d056      	beq.n	80062b0 <HAL_ADCEx_MultiModeConfigChannel+0xbc>

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8006202:	6802      	ldr	r2, [r0, #0]
 8006204:	4603      	mov	r3, r0
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
 8006206:	2400      	movs	r4, #0
  __HAL_LOCK(hadc);
 8006208:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 800620a:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
 800620e:	9418      	str	r4, [sp, #96]	; 0x60
  __HAL_LOCK(hadc);
 8006210:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);
 8006214:	9419      	str	r4, [sp, #100]	; 0x64
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8006216:	d00b      	beq.n	8006230 <HAL_ADCEx_MultiModeConfigChannel+0x3c>
 8006218:	4d48      	ldr	r5, [pc, #288]	; (800633c <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 800621a:	42aa      	cmp	r2, r5
 800621c:	d046      	beq.n	80062ac <HAL_ADCEx_MultiModeConfigChannel+0xb8>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800621e:	6dda      	ldr	r2, [r3, #92]	; 0x5c

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8006220:	f883 4058 	strb.w	r4, [r3, #88]	; 0x58
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8006224:	f042 0220 	orr.w	r2, r2, #32
 8006228:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 800622a:	b01d      	add	sp, #116	; 0x74
 800622c:	bc70      	pop	{r4, r5, r6}
 800622e:	4770      	bx	lr
 8006230:	4843      	ldr	r0, [pc, #268]	; (8006340 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8006232:	6880      	ldr	r0, [r0, #8]
 8006234:	0740      	lsls	r0, r0, #29
 8006236:	d50b      	bpl.n	8006250 <HAL_ADCEx_MultiModeConfigChannel+0x5c>
 8006238:	6892      	ldr	r2, [r2, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800623a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800623c:	f042 0220 	orr.w	r2, r2, #32
    tmp_hal_status = HAL_ERROR;
 8006240:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8006242:	65da      	str	r2, [r3, #92]	; 0x5c
  __HAL_UNLOCK(hadc);
 8006244:	2200      	movs	r2, #0
 8006246:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
}
 800624a:	b01d      	add	sp, #116	; 0x74
 800624c:	bc70      	pop	{r4, r5, r6}
 800624e:	4770      	bx	lr
 8006250:	6890      	ldr	r0, [r2, #8]
 8006252:	0744      	lsls	r4, r0, #29
 8006254:	d4f1      	bmi.n	800623a <HAL_ADCEx_MultiModeConfigChannel+0x46>
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 8006256:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 800625a:	d02d      	beq.n	80062b8 <HAL_ADCEx_MultiModeConfigChannel+0xc4>
 800625c:	4838      	ldr	r0, [pc, #224]	; (8006340 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 800625e:	4282      	cmp	r2, r0
 8006260:	d02a      	beq.n	80062b8 <HAL_ADCEx_MultiModeConfigChannel+0xc4>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8006262:	2e00      	cmp	r6, #0
 8006264:	d058      	beq.n	8006318 <HAL_ADCEx_MultiModeConfigChannel+0x124>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 8006266:	4837      	ldr	r0, [pc, #220]	; (8006344 <HAL_ADCEx_MultiModeConfigChannel+0x150>)
 8006268:	684c      	ldr	r4, [r1, #4]
 800626a:	6882      	ldr	r2, [r0, #8]
 800626c:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8006270:	4322      	orrs	r2, r4
 8006272:	f893 4038 	ldrb.w	r4, [r3, #56]	; 0x38
 8006276:	ea42 3244 	orr.w	r2, r2, r4, lsl #13
 800627a:	6082      	str	r2, [r0, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800627c:	4a2f      	ldr	r2, [pc, #188]	; (800633c <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 800627e:	6894      	ldr	r4, [r2, #8]
 8006280:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8006284:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8006286:	4322      	orrs	r2, r4
 8006288:	4c2f      	ldr	r4, [pc, #188]	; (8006348 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
 800628a:	68a4      	ldr	r4, [r4, #8]
 800628c:	4322      	orrs	r2, r4
 800628e:	43d2      	mvns	r2, r2
 8006290:	f002 0201 	and.w	r2, r2, #1
 8006294:	b142      	cbz	r2, 80062a8 <HAL_ADCEx_MultiModeConfigChannel+0xb4>
        MODIFY_REG(tmpADC_Common->CCR,
 8006296:	6884      	ldr	r4, [r0, #8]
 8006298:	688a      	ldr	r2, [r1, #8]
 800629a:	f424 6171 	bic.w	r1, r4, #3856	; 0xf10
 800629e:	4332      	orrs	r2, r6
 80062a0:	f021 010f 	bic.w	r1, r1, #15
 80062a4:	430a      	orrs	r2, r1
 80062a6:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80062a8:	2000      	movs	r0, #0
 80062aa:	e7cb      	b.n	8006244 <HAL_ADCEx_MultiModeConfigChannel+0x50>
 80062ac:	4827      	ldr	r0, [pc, #156]	; (800634c <HAL_ADCEx_MultiModeConfigChannel+0x158>)
 80062ae:	e7c0      	b.n	8006232 <HAL_ADCEx_MultiModeConfigChannel+0x3e>
  __HAL_LOCK(hadc);
 80062b0:	2002      	movs	r0, #2
}
 80062b2:	b01d      	add	sp, #116	; 0x74
 80062b4:	bc70      	pop	{r4, r5, r6}
 80062b6:	4770      	bx	lr
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80062b8:	b1ae      	cbz	r6, 80062e6 <HAL_ADCEx_MultiModeConfigChannel+0xf2>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 80062ba:	4825      	ldr	r0, [pc, #148]	; (8006350 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062bc:	684c      	ldr	r4, [r1, #4]
 80062be:	6882      	ldr	r2, [r0, #8]
 80062c0:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80062c4:	4322      	orrs	r2, r4
 80062c6:	f893 4038 	ldrb.w	r4, [r3, #56]	; 0x38
 80062ca:	ea42 3244 	orr.w	r2, r2, r4, lsl #13
 80062ce:	6082      	str	r2, [r0, #8]
 80062d0:	4a1b      	ldr	r2, [pc, #108]	; (8006340 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 80062d2:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80062d6:	6880      	ldr	r0, [r0, #8]
 80062d8:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80062da:	4302      	orrs	r2, r0
 80062dc:	43d2      	mvns	r2, r2
 80062de:	481c      	ldr	r0, [pc, #112]	; (8006350 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062e0:	f002 0201 	and.w	r2, r2, #1
 80062e4:	e7d6      	b.n	8006294 <HAL_ADCEx_MultiModeConfigChannel+0xa0>
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 80062e6:	491a      	ldr	r1, [pc, #104]	; (8006350 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062e8:	688a      	ldr	r2, [r1, #8]
 80062ea:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80062ee:	608a      	str	r2, [r1, #8]
 80062f0:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80062f4:	4a12      	ldr	r2, [pc, #72]	; (8006340 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 80062f6:	6880      	ldr	r0, [r0, #8]
 80062f8:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80062fa:	4915      	ldr	r1, [pc, #84]	; (8006350 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062fc:	4302      	orrs	r2, r0
 80062fe:	43d2      	mvns	r2, r2
 8006300:	f002 0201 	and.w	r2, r2, #1
 8006304:	2a00      	cmp	r2, #0
 8006306:	d0cf      	beq.n	80062a8 <HAL_ADCEx_MultiModeConfigChannel+0xb4>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8006308:	688a      	ldr	r2, [r1, #8]
 800630a:	f422 6271 	bic.w	r2, r2, #3856	; 0xf10
 800630e:	f022 020f 	bic.w	r2, r2, #15
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8006312:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8006314:	608a      	str	r2, [r1, #8]
 8006316:	e795      	b.n	8006244 <HAL_ADCEx_MultiModeConfigChannel+0x50>
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 8006318:	490a      	ldr	r1, [pc, #40]	; (8006344 <HAL_ADCEx_MultiModeConfigChannel+0x150>)
 800631a:	4808      	ldr	r0, [pc, #32]	; (800633c <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 800631c:	688a      	ldr	r2, [r1, #8]
 800631e:	4c0b      	ldr	r4, [pc, #44]	; (800634c <HAL_ADCEx_MultiModeConfigChannel+0x158>)
 8006320:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8006324:	608a      	str	r2, [r1, #8]
 8006326:	6880      	ldr	r0, [r0, #8]
 8006328:	68a2      	ldr	r2, [r4, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800632a:	4302      	orrs	r2, r0
 800632c:	4806      	ldr	r0, [pc, #24]	; (8006348 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
 800632e:	6880      	ldr	r0, [r0, #8]
 8006330:	4302      	orrs	r2, r0
 8006332:	43d2      	mvns	r2, r2
 8006334:	f002 0201 	and.w	r2, r2, #1
 8006338:	e7e4      	b.n	8006304 <HAL_ADCEx_MultiModeConfigChannel+0x110>
 800633a:	bf00      	nop
 800633c:	50000400 	.word	0x50000400
 8006340:	50000100 	.word	0x50000100
 8006344:	50000700 	.word	0x50000700
 8006348:	50000600 	.word	0x50000600
 800634c:	50000500 	.word	0x50000500
 8006350:	50000300 	.word	0x50000300

08006354 <HAL_CORDIC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CORDIC_Init(CORDIC_HandleTypeDef *hcordic)
{
  /* Check the CORDIC handle allocation */
  if (hcordic == NULL)
 8006354:	b1b0      	cbz	r0, 8006384 <HAL_CORDIC_Init+0x30>
{
 8006356:	b510      	push	{r4, lr}

    /* Initialize the low level hardware */
    hcordic->MspInitCallback(hcordic);
  }
#else
  if (hcordic->State == HAL_CORDIC_STATE_RESET)
 8006358:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 800635c:	4604      	mov	r4, r0
 800635e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8006362:	b153      	cbz	r3, 800637a <HAL_CORDIC_Init+0x26>
    HAL_CORDIC_MspInit(hcordic);
  }
#endif /* (USE_HAL_CORDIC_REGISTER_CALLBACKS) */

  /* Set CORDIC error code to none */
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8006364:	2000      	movs	r0, #0

  /* Reset DMADirection */
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;

  /* Change CORDIC peripheral state */
  hcordic->State = HAL_CORDIC_STATE_READY;
 8006366:	2301      	movs	r3, #1
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8006368:	6260      	str	r0, [r4, #36]	; 0x24
  hcordic->State = HAL_CORDIC_STATE_READY;
 800636a:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  hcordic->pOutBuff = NULL;
 800636e:	e9c4 0001 	strd	r0, r0, [r4, #4]
  hcordic->NbCalcToGet = 0U;
 8006372:	e9c4 0003 	strd	r0, r0, [r4, #12]
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;
 8006376:	6160      	str	r0, [r4, #20]

  /* Return function status */
  return HAL_OK;
}
 8006378:	bd10      	pop	{r4, pc}
    hcordic->Lock = HAL_UNLOCKED;
 800637a:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_CORDIC_MspInit(hcordic);
 800637e:	f7fb fa5b 	bl	8001838 <HAL_CORDIC_MspInit>
 8006382:	e7ef      	b.n	8006364 <HAL_CORDIC_Init+0x10>
    return HAL_ERROR;
 8006384:	2001      	movs	r0, #1
}
 8006386:	4770      	bx	lr

08006388 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006388:	4907      	ldr	r1, [pc, #28]	; (80063a8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800638a:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800638c:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800638e:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8006392:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006396:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8006398:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800639a:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800639e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80063a2:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80063a4:	4770      	bx	lr
 80063a6:	bf00      	nop
 80063a8:	e000ed00 	.word	0xe000ed00

080063ac <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80063ac:	4b1c      	ldr	r3, [pc, #112]	; (8006420 <HAL_NVIC_SetPriority+0x74>)
 80063ae:	68db      	ldr	r3, [r3, #12]
 80063b0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80063b4:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80063b6:	f1c3 0e07 	rsb	lr, r3, #7
 80063ba:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80063be:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80063c2:	bf28      	it	cs
 80063c4:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80063c8:	f1bc 0f06 	cmp.w	ip, #6
 80063cc:	d91b      	bls.n	8006406 <HAL_NVIC_SetPriority+0x5a>
 80063ce:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80063d0:	f04f 3cff 	mov.w	ip, #4294967295
 80063d4:	fa0c fc03 	lsl.w	ip, ip, r3
 80063d8:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80063dc:	f04f 3cff 	mov.w	ip, #4294967295
 80063e0:	fa0c fc0e 	lsl.w	ip, ip, lr
 80063e4:	ea21 010c 	bic.w	r1, r1, ip
 80063e8:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 80063ea:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80063ec:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 80063f0:	db0c      	blt.n	800640c <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80063f2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80063f6:	0109      	lsls	r1, r1, #4
 80063f8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80063fc:	b2c9      	uxtb	r1, r1
 80063fe:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8006402:	f85d fb04 	ldr.w	pc, [sp], #4
 8006406:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8006408:	4613      	mov	r3, r2
 800640a:	e7e7      	b.n	80063dc <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800640c:	4b05      	ldr	r3, [pc, #20]	; (8006424 <HAL_NVIC_SetPriority+0x78>)
 800640e:	f000 000f 	and.w	r0, r0, #15
 8006412:	0109      	lsls	r1, r1, #4
 8006414:	4403      	add	r3, r0
 8006416:	b2c9      	uxtb	r1, r1
 8006418:	7619      	strb	r1, [r3, #24]
 800641a:	f85d fb04 	ldr.w	pc, [sp], #4
 800641e:	bf00      	nop
 8006420:	e000ed00 	.word	0xe000ed00
 8006424:	e000ecfc 	.word	0xe000ecfc

08006428 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8006428:	2800      	cmp	r0, #0
 800642a:	db07      	blt.n	800643c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800642c:	4a04      	ldr	r2, [pc, #16]	; (8006440 <HAL_NVIC_EnableIRQ+0x18>)
 800642e:	0941      	lsrs	r1, r0, #5
 8006430:	2301      	movs	r3, #1
 8006432:	f000 001f 	and.w	r0, r0, #31
 8006436:	4083      	lsls	r3, r0
 8006438:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800643c:	4770      	bx	lr
 800643e:	bf00      	nop
 8006440:	e000e100 	.word	0xe000e100

08006444 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8006444:	3801      	subs	r0, #1
 8006446:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800644a:	d210      	bcs.n	800646e <HAL_SYSTICK_Config+0x2a>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800644c:	b410      	push	{r4}
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800644e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006452:	4c08      	ldr	r4, [pc, #32]	; (8006474 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8006454:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006456:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
 800645a:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800645e:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8006460:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8006462:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8006464:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 8006466:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800646a:	6119      	str	r1, [r3, #16]
 800646c:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 800646e:	2001      	movs	r0, #1
 8006470:	4770      	bx	lr
 8006472:	bf00      	nop
 8006474:	e000ed00 	.word	0xe000ed00

08006478 <HAL_SYSTICK_Callback>:
__weak void HAL_SYSTICK_Callback(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8006478:	4770      	bx	lr
 800647a:	bf00      	nop

0800647c <HAL_SYSTICK_IRQHandler>:
{
 800647c:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800647e:	f7ff fffb 	bl	8006478 <HAL_SYSTICK_Callback>
}
 8006482:	bd08      	pop	{r3, pc}

08006484 <HAL_CRC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 8006484:	2800      	cmp	r0, #0
 8006486:	d036      	beq.n	80064f6 <HAL_CRC_Init+0x72>
{
 8006488:	b510      	push	{r4, lr}
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 800648a:	7f43      	ldrb	r3, [r0, #29]
 800648c:	4604      	mov	r4, r0
 800648e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8006492:	b363      	cbz	r3, 80064ee <HAL_CRC_Init+0x6a>
  hcrc->State = HAL_CRC_STATE_BUSY;

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8006494:	7923      	ldrb	r3, [r4, #4]
  hcrc->State = HAL_CRC_STATE_BUSY;
 8006496:	2202      	movs	r2, #2
 8006498:	7762      	strb	r2, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800649a:	b9f3      	cbnz	r3, 80064da <HAL_CRC_Init+0x56>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800649c:	6823      	ldr	r3, [r4, #0]
 800649e:	4a17      	ldr	r2, [pc, #92]	; (80064fc <HAL_CRC_Init+0x78>)
 80064a0:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 80064a2:	689a      	ldr	r2, [r3, #8]
 80064a4:	f022 0218 	bic.w	r2, r2, #24
 80064a8:	609a      	str	r2, [r3, #8]
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 80064aa:	7962      	ldrb	r2, [r4, #5]
 80064ac:	b18a      	cbz	r2, 80064d2 <HAL_CRC_Init+0x4e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80064ae:	6922      	ldr	r2, [r4, #16]
 80064b0:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 80064b2:	689a      	ldr	r2, [r3, #8]
 80064b4:	6961      	ldr	r1, [r4, #20]
 80064b6:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 80064ba:	430a      	orrs	r2, r1
 80064bc:	609a      	str	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 80064be:	689a      	ldr	r2, [r3, #8]
 80064c0:	69a1      	ldr	r1, [r4, #24]
 80064c2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80064c6:	430a      	orrs	r2, r1
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 80064c8:	2101      	movs	r1, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 80064ca:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 80064cc:	7761      	strb	r1, [r4, #29]

  /* Return function status */
  return HAL_OK;
 80064ce:	2000      	movs	r0, #0
}
 80064d0:	bd10      	pop	{r4, pc}
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 80064d2:	f04f 32ff 	mov.w	r2, #4294967295
 80064d6:	611a      	str	r2, [r3, #16]
 80064d8:	e7eb      	b.n	80064b2 <HAL_CRC_Init+0x2e>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 80064da:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 80064de:	4620      	mov	r0, r4
 80064e0:	f000 f80e 	bl	8006500 <HAL_CRCEx_Polynomial_Set>
 80064e4:	b908      	cbnz	r0, 80064ea <HAL_CRC_Init+0x66>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 80064e6:	6823      	ldr	r3, [r4, #0]
 80064e8:	e7df      	b.n	80064aa <HAL_CRC_Init+0x26>
    return HAL_ERROR;
 80064ea:	2001      	movs	r0, #1
}
 80064ec:	bd10      	pop	{r4, pc}
    hcrc->Lock = HAL_UNLOCKED;
 80064ee:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 80064f0:	f7fb f9d0 	bl	8001894 <HAL_CRC_MspInit>
 80064f4:	e7ce      	b.n	8006494 <HAL_CRC_Init+0x10>
    return HAL_ERROR;
 80064f6:	2001      	movs	r0, #1
}
 80064f8:	4770      	bx	lr
 80064fa:	bf00      	nop
 80064fc:	04c11db7 	.word	0x04c11db7

08006500 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 8006500:	b410      	push	{r4}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 8006502:	231e      	movs	r3, #30
 8006504:	e001      	b.n	800650a <HAL_CRCEx_Polynomial_Set+0xa>
 8006506:	3b01      	subs	r3, #1
 8006508:	d315      	bcc.n	8006536 <HAL_CRCEx_Polynomial_Set+0x36>
 800650a:	fa21 fc03 	lsr.w	ip, r1, r3
 800650e:	f01c 0f01 	tst.w	ip, #1
 8006512:	d0f8      	beq.n	8006506 <HAL_CRCEx_Polynomial_Set+0x6>
  {
  }

  switch (PolyLength)
 8006514:	2a18      	cmp	r2, #24
 8006516:	d80f      	bhi.n	8006538 <HAL_CRCEx_Polynomial_Set+0x38>
 8006518:	e8df f002 	tbb	[pc, r2]
 800651c:	0e0e0e14 	.word	0x0e0e0e14
 8006520:	0e0e0e0e 	.word	0x0e0e0e0e
 8006524:	0e0e0e1f 	.word	0x0e0e0e1f
 8006528:	0e0e0e0e 	.word	0x0e0e0e0e
 800652c:	0e0e0e22 	.word	0x0e0e0e22
 8006530:	0e0e0e0e 	.word	0x0e0e0e0e
 8006534:	12          	.byte	0x12
 8006535:	00          	.byte	0x00
 8006536:	b12a      	cbz	r2, 8006544 <HAL_CRCEx_Polynomial_Set+0x44>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 8006538:	2001      	movs	r0, #1
    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
}
 800653a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800653e:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_7B)
 8006540:	2b06      	cmp	r3, #6
 8006542:	d8f9      	bhi.n	8006538 <HAL_CRCEx_Polynomial_Set+0x38>
    WRITE_REG(hcrc->Instance->POL, Pol);
 8006544:	6804      	ldr	r4, [r0, #0]
 8006546:	6161      	str	r1, [r4, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 8006548:	68a3      	ldr	r3, [r4, #8]
 800654a:	f023 0318 	bic.w	r3, r3, #24
 800654e:	4313      	orrs	r3, r2
 8006550:	2000      	movs	r0, #0
 8006552:	60a3      	str	r3, [r4, #8]
}
 8006554:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006558:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_16B)
 800655a:	2b0f      	cmp	r3, #15
 800655c:	d9f2      	bls.n	8006544 <HAL_CRCEx_Polynomial_Set+0x44>
 800655e:	e7eb      	b.n	8006538 <HAL_CRCEx_Polynomial_Set+0x38>
      if (msb >= HAL_CRC_LENGTH_8B)
 8006560:	2b07      	cmp	r3, #7
 8006562:	d9ef      	bls.n	8006544 <HAL_CRCEx_Polynomial_Set+0x44>
 8006564:	e7e8      	b.n	8006538 <HAL_CRCEx_Polynomial_Set+0x38>
 8006566:	bf00      	nop

08006568 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8006568:	2800      	cmp	r0, #0
 800656a:	d078      	beq.n	800665e <HAL_DMA_Init+0xf6>
{
 800656c:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800656e:	4b3d      	ldr	r3, [pc, #244]	; (8006664 <HAL_DMA_Init+0xfc>)
 8006570:	6804      	ldr	r4, [r0, #0]
 8006572:	429c      	cmp	r4, r3
 8006574:	d95f      	bls.n	8006636 <HAL_DMA_Init+0xce>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8006576:	4a3c      	ldr	r2, [pc, #240]	; (8006668 <HAL_DMA_Init+0x100>)
 8006578:	4b3c      	ldr	r3, [pc, #240]	; (800666c <HAL_DMA_Init+0x104>)
    hdma->DmaBaseAddress = DMA2;
 800657a:	493d      	ldr	r1, [pc, #244]	; (8006670 <HAL_DMA_Init+0x108>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 800657c:	4422      	add	r2, r4
 800657e:	fba3 3202 	umull	r3, r2, r3, r2
 8006582:	0912      	lsrs	r2, r2, #4
 8006584:	0092      	lsls	r2, r2, #2
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8006586:	2302      	movs	r3, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8006588:	6885      	ldr	r5, [r0, #8]
  hdma->State = HAL_DMA_STATE_BUSY;
 800658a:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  tmp |=  hdma->Init.Direction        |
 800658e:	68c3      	ldr	r3, [r0, #12]
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8006590:	4e36      	ldr	r6, [pc, #216]	; (800666c <HAL_DMA_Init+0x104>)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8006592:	4f34      	ldr	r7, [pc, #208]	; (8006664 <HAL_DMA_Init+0xfc>)
 8006594:	e9c0 1210 	strd	r1, r2, [r0, #64]	; 0x40
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8006598:	6901      	ldr	r1, [r0, #16]
  tmp |=  hdma->Init.Direction        |
 800659a:	432b      	orrs	r3, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800659c:	430b      	orrs	r3, r1
 800659e:	6941      	ldr	r1, [r0, #20]
 80065a0:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80065a2:	6981      	ldr	r1, [r0, #24]
 80065a4:	430b      	orrs	r3, r1
  tmp = hdma->Instance->CCR;
 80065a6:	6821      	ldr	r1, [r4, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80065a8:	f421 4cff 	bic.w	ip, r1, #32640	; 0x7f80
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80065ac:	69c1      	ldr	r1, [r0, #28]
 80065ae:	430b      	orrs	r3, r1
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 80065b0:	b2e1      	uxtb	r1, r4
 80065b2:	3908      	subs	r1, #8
 80065b4:	fba6 6101 	umull	r6, r1, r6, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 80065b8:	6a06      	ldr	r6, [r0, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80065ba:	f02c 0c70 	bic.w	ip, ip, #112	; 0x70
          hdma->Init.Mode                | hdma->Init.Priority;
 80065be:	4333      	orrs	r3, r6
  tmp |=  hdma->Init.Direction        |
 80065c0:	ea43 030c 	orr.w	r3, r3, ip
  hdma->Instance->CCR = tmp;
 80065c4:	6023      	str	r3, [r4, #0]
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80065c6:	4e2b      	ldr	r6, [pc, #172]	; (8006674 <HAL_DMA_Init+0x10c>)
 80065c8:	4b2b      	ldr	r3, [pc, #172]	; (8006678 <HAL_DMA_Init+0x110>)
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80065ca:	f3c1 1104 	ubfx	r1, r1, #4, #5
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80065ce:	42bc      	cmp	r4, r7
 80065d0:	bf98      	it	ls
 80065d2:	4633      	movls	r3, r6
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80065d4:	f04f 0c01 	mov.w	ip, #1
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80065d8:	4c28      	ldr	r4, [pc, #160]	; (800667c <HAL_DMA_Init+0x114>)
 80065da:	64c4      	str	r4, [r0, #76]	; 0x4c
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80065dc:	fa0c f101 	lsl.w	r1, ip, r1
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 80065e0:	18d4      	adds	r4, r2, r3
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80065e2:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80065e6:	6501      	str	r1, [r0, #80]	; 0x50
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 80065e8:	6484      	str	r4, [r0, #72]	; 0x48
 80065ea:	ea4f 0292 	mov.w	r2, r2, lsr #2
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80065ee:	d02b      	beq.n	8006648 <HAL_DMA_Init+0xe0>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80065f0:	6845      	ldr	r5, [r0, #4]
 80065f2:	b2ec      	uxtb	r4, r5
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80065f4:	3d01      	subs	r5, #1
 80065f6:	2d03      	cmp	r5, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80065f8:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80065fc:	f8c6 1084 	str.w	r1, [r6, #132]	; 0x84
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8006600:	d828      	bhi.n	8006654 <HAL_DMA_Init+0xec>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8006602:	4b1f      	ldr	r3, [pc, #124]	; (8006680 <HAL_DMA_Init+0x118>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8006604:	4d1f      	ldr	r5, [pc, #124]	; (8006684 <HAL_DMA_Init+0x11c>)
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8006606:	4a20      	ldr	r2, [pc, #128]	; (8006688 <HAL_DMA_Init+0x120>)
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8006608:	4423      	add	r3, r4

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 800660a:	3c01      	subs	r4, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800660c:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 800660e:	f004 041f 	and.w	r4, r4, #31
 8006612:	fa0c f404 	lsl.w	r4, ip, r4
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8006616:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8006618:	e9c0 3515 	strd	r3, r5, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 800661c:	65c4      	str	r4, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800661e:	6019      	str	r1, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8006620:	6454      	str	r4, [r2, #68]	; 0x44
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8006622:	2300      	movs	r3, #0
  hdma->State  = HAL_DMA_STATE_READY;
 8006624:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8006626:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->Lock = HAL_UNLOCKED;
 8006628:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State  = HAL_DMA_STATE_READY;
 800662c:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
}
 8006630:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_OK;
 8006632:	4618      	mov	r0, r3
}
 8006634:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8006636:	4a15      	ldr	r2, [pc, #84]	; (800668c <HAL_DMA_Init+0x124>)
 8006638:	4b0c      	ldr	r3, [pc, #48]	; (800666c <HAL_DMA_Init+0x104>)
    hdma->DmaBaseAddress = DMA1;
 800663a:	4915      	ldr	r1, [pc, #84]	; (8006690 <HAL_DMA_Init+0x128>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 800663c:	4422      	add	r2, r4
 800663e:	fba3 3202 	umull	r3, r2, r3, r2
 8006642:	0912      	lsrs	r2, r2, #4
 8006644:	0092      	lsls	r2, r2, #2
    hdma->DmaBaseAddress = DMA1;
 8006646:	e79e      	b.n	8006586 <HAL_DMA_Init+0x1e>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8006648:	2400      	movs	r4, #0
 800664a:	6044      	str	r4, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800664c:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8006650:	f8c6 1084 	str.w	r1, [r6, #132]	; 0x84
    hdma->DMAmuxRequestGen = 0U;
 8006654:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 8006656:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800665a:	65c3      	str	r3, [r0, #92]	; 0x5c
 800665c:	e7e1      	b.n	8006622 <HAL_DMA_Init+0xba>
    return HAL_ERROR;
 800665e:	2001      	movs	r0, #1
}
 8006660:	4770      	bx	lr
 8006662:	bf00      	nop
 8006664:	40020407 	.word	0x40020407
 8006668:	bffdfbf8 	.word	0xbffdfbf8
 800666c:	cccccccd 	.word	0xcccccccd
 8006670:	40020400 	.word	0x40020400
 8006674:	40020800 	.word	0x40020800
 8006678:	40020820 	.word	0x40020820
 800667c:	40020880 	.word	0x40020880
 8006680:	1000823f 	.word	0x1000823f
 8006684:	40020940 	.word	0x40020940
 8006688:	40020900 	.word	0x40020900
 800668c:	bffdfff8 	.word	0xbffdfff8
 8006690:	40020000 	.word	0x40020000

08006694 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8006694:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 8006698:	680c      	ldr	r4, [r1, #0]
{
 800669a:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0U)
 800669c:	2c00      	cmp	r4, #0
 800669e:	d07d      	beq.n	800679c <HAL_GPIO_Init+0x108>
 80066a0:	f04f 0c00 	mov.w	ip, #0
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80066a4:	4e71      	ldr	r6, [pc, #452]	; (800686c <HAL_GPIO_Init+0x1d8>)
  uint32_t position = 0x00U;
 80066a6:	4663      	mov	r3, ip
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80066a8:	f04f 0b01 	mov.w	fp, #1
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80066ac:	468e      	mov	lr, r1
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80066ae:	fa0b f703 	lsl.w	r7, fp, r3
    if (iocurrent != 0x00u)
 80066b2:	ea17 0a04 	ands.w	sl, r7, r4
 80066b6:	d06b      	beq.n	8006790 <HAL_GPIO_Init+0xfc>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80066b8:	f8de 1004 	ldr.w	r1, [lr, #4]
 80066bc:	f001 0203 	and.w	r2, r1, #3
 80066c0:	1e55      	subs	r5, r2, #1
 80066c2:	2d01      	cmp	r5, #1
 80066c4:	d96d      	bls.n	80067a2 <HAL_GPIO_Init+0x10e>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80066c6:	2a03      	cmp	r2, #3
 80066c8:	f040 80b1 	bne.w	800682e <HAL_GPIO_Init+0x19a>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80066cc:	fa02 f20c 	lsl.w	r2, r2, ip
 80066d0:	43d5      	mvns	r5, r2
      temp = GPIOx->MODER;
 80066d2:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 80066d4:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80066d6:	432a      	orrs	r2, r5
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80066d8:	f411 3f40 	tst.w	r1, #196608	; 0x30000
      GPIOx->MODER = temp;
 80066dc:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80066de:	d057      	beq.n	8006790 <HAL_GPIO_Init+0xfc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80066e0:	4d63      	ldr	r5, [pc, #396]	; (8006870 <HAL_GPIO_Init+0x1dc>)
 80066e2:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 80066e4:	f042 0201 	orr.w	r2, r2, #1
 80066e8:	662a      	str	r2, [r5, #96]	; 0x60
 80066ea:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 80066ec:	f002 0201 	and.w	r2, r2, #1
 80066f0:	9203      	str	r2, [sp, #12]
 80066f2:	9a03      	ldr	r2, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2U];
 80066f4:	f023 0203 	bic.w	r2, r3, #3
 80066f8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80066fc:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006700:	f003 0703 	and.w	r7, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8006704:	6895      	ldr	r5, [r2, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006706:	00bf      	lsls	r7, r7, #2
 8006708:	f04f 080f 	mov.w	r8, #15
 800670c:	fa08 f807 	lsl.w	r8, r8, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8006710:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006714:	ea25 0908 	bic.w	r9, r5, r8
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8006718:	d01a      	beq.n	8006750 <HAL_GPIO_Init+0xbc>
 800671a:	4d56      	ldr	r5, [pc, #344]	; (8006874 <HAL_GPIO_Init+0x1e0>)
 800671c:	42a8      	cmp	r0, r5
 800671e:	f000 8092 	beq.w	8006846 <HAL_GPIO_Init+0x1b2>
 8006722:	4d55      	ldr	r5, [pc, #340]	; (8006878 <HAL_GPIO_Init+0x1e4>)
 8006724:	42a8      	cmp	r0, r5
 8006726:	f000 8093 	beq.w	8006850 <HAL_GPIO_Init+0x1bc>
 800672a:	4d54      	ldr	r5, [pc, #336]	; (800687c <HAL_GPIO_Init+0x1e8>)
 800672c:	42a8      	cmp	r0, r5
 800672e:	f000 8083 	beq.w	8006838 <HAL_GPIO_Init+0x1a4>
 8006732:	4d53      	ldr	r5, [pc, #332]	; (8006880 <HAL_GPIO_Init+0x1ec>)
 8006734:	42a8      	cmp	r0, r5
 8006736:	f000 8092 	beq.w	800685e <HAL_GPIO_Init+0x1ca>
 800673a:	4d52      	ldr	r5, [pc, #328]	; (8006884 <HAL_GPIO_Init+0x1f0>)
 800673c:	42a8      	cmp	r0, r5
 800673e:	bf0c      	ite	eq
 8006740:	f04f 0805 	moveq.w	r8, #5
 8006744:	f04f 0806 	movne.w	r8, #6
 8006748:	fa08 f707 	lsl.w	r7, r8, r7
 800674c:	ea49 0907 	orr.w	r9, r9, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8006750:	f8c2 9008 	str.w	r9, [r2, #8]
        temp = EXTI->RTSR1;
 8006754:	68b2      	ldr	r2, [r6, #8]
        temp &= ~(iocurrent);
 8006756:	ea6f 050a 	mvn.w	r5, sl
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800675a:	02cf      	lsls	r7, r1, #11
        temp &= ~(iocurrent);
 800675c:	bf54      	ite	pl
 800675e:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 8006760:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->RTSR1 = temp;
 8006764:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR1;
 8006766:	68f2      	ldr	r2, [r6, #12]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8006768:	028f      	lsls	r7, r1, #10
        temp &= ~(iocurrent);
 800676a:	bf54      	ite	pl
 800676c:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 800676e:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->FTSR1 = temp;
 8006772:	60f2      	str	r2, [r6, #12]

        temp = EXTI->EMR1;
 8006774:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8006776:	038f      	lsls	r7, r1, #14
        temp &= ~(iocurrent);
 8006778:	bf54      	ite	pl
 800677a:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 800677c:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->EMR1 = temp;
 8006780:	6072      	str	r2, [r6, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8006782:	6832      	ldr	r2, [r6, #0]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8006784:	03c9      	lsls	r1, r1, #15
        temp &= ~(iocurrent);
 8006786:	bf54      	ite	pl
 8006788:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 800678a:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->IMR1 = temp;
 800678e:	6032      	str	r2, [r6, #0]
      }
    }

    position++;
 8006790:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 8006792:	fa34 f203 	lsrs.w	r2, r4, r3
 8006796:	f10c 0c02 	add.w	ip, ip, #2
 800679a:	d188      	bne.n	80066ae <HAL_GPIO_Init+0x1a>
  }
}
 800679c:	b005      	add	sp, #20
 800679e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 80067a2:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80067a6:	f8de 500c 	ldr.w	r5, [lr, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80067aa:	f04f 0803 	mov.w	r8, #3
 80067ae:	fa08 f80c 	lsl.w	r8, r8, ip
 80067b2:	ea29 0908 	bic.w	r9, r9, r8
        temp |= (GPIO_Init->Speed << (position * 2U));
 80067b6:	fa05 f50c 	lsl.w	r5, r5, ip
 80067ba:	ea45 0509 	orr.w	r5, r5, r9
        GPIOx->OSPEEDR = temp;
 80067be:	6085      	str	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80067c0:	ea6f 0508 	mvn.w	r5, r8
        temp = GPIOx->OTYPER;
 80067c4:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80067c8:	ea28 0807 	bic.w	r8, r8, r7
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80067cc:	f3c1 1700 	ubfx	r7, r1, #4, #1
 80067d0:	409f      	lsls	r7, r3
 80067d2:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 80067d6:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 80067d8:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80067da:	ea07 0805 	and.w	r8, r7, r5
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80067de:	f8de 7008 	ldr.w	r7, [lr, #8]
 80067e2:	fa07 f70c 	lsl.w	r7, r7, ip
 80067e6:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80067ea:	2a02      	cmp	r2, #2
        GPIOx->PUPDR = temp;
 80067ec:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80067ee:	fa02 f20c 	lsl.w	r2, r2, ip
 80067f2:	f47f af6e 	bne.w	80066d2 <HAL_GPIO_Init+0x3e>
        temp = GPIOx->AFR[position >> 3U];
 80067f6:	ea4f 09d3 	mov.w	r9, r3, lsr #3
 80067fa:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80067fe:	f003 0807 	and.w	r8, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8006802:	f8d9 7020 	ldr.w	r7, [r9, #32]
 8006806:	9700      	str	r7, [sp, #0]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006808:	f8de 7010 	ldr.w	r7, [lr, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800680c:	ea4f 0888 	mov.w	r8, r8, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006810:	fa07 f708 	lsl.w	r7, r7, r8
 8006814:	9701      	str	r7, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8006816:	270f      	movs	r7, #15
 8006818:	fa07 f808 	lsl.w	r8, r7, r8
 800681c:	9f00      	ldr	r7, [sp, #0]
 800681e:	ea27 0808 	bic.w	r8, r7, r8
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006822:	9f01      	ldr	r7, [sp, #4]
 8006824:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->AFR[position >> 3U] = temp;
 8006828:	f8c9 7020 	str.w	r7, [r9, #32]
 800682c:	e751      	b.n	80066d2 <HAL_GPIO_Init+0x3e>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800682e:	2503      	movs	r5, #3
 8006830:	fa05 f50c 	lsl.w	r5, r5, ip
 8006834:	43ed      	mvns	r5, r5
 8006836:	e7cf      	b.n	80067d8 <HAL_GPIO_Init+0x144>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8006838:	f04f 0803 	mov.w	r8, #3
 800683c:	fa08 f707 	lsl.w	r7, r8, r7
 8006840:	ea49 0907 	orr.w	r9, r9, r7
 8006844:	e784      	b.n	8006750 <HAL_GPIO_Init+0xbc>
 8006846:	fa0b f707 	lsl.w	r7, fp, r7
 800684a:	ea49 0907 	orr.w	r9, r9, r7
 800684e:	e77f      	b.n	8006750 <HAL_GPIO_Init+0xbc>
 8006850:	f04f 0802 	mov.w	r8, #2
 8006854:	fa08 f707 	lsl.w	r7, r8, r7
 8006858:	ea49 0907 	orr.w	r9, r9, r7
 800685c:	e778      	b.n	8006750 <HAL_GPIO_Init+0xbc>
 800685e:	f04f 0804 	mov.w	r8, #4
 8006862:	fa08 f707 	lsl.w	r7, r8, r7
 8006866:	ea49 0907 	orr.w	r9, r9, r7
 800686a:	e771      	b.n	8006750 <HAL_GPIO_Init+0xbc>
 800686c:	40010400 	.word	0x40010400
 8006870:	40021000 	.word	0x40021000
 8006874:	48000400 	.word	0x48000400
 8006878:	48000800 	.word	0x48000800
 800687c:	48000c00 	.word	0x48000c00
 8006880:	48001000 	.word	0x48001000
 8006884:	48001400 	.word	0x48001400

08006888 <HAL_PWREx_ControlVoltageScaling>:
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006888:	4a37      	ldr	r2, [pc, #220]	; (8006968 <HAL_PWREx_ControlVoltageScaling+0xe0>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 800688a:	b960      	cbnz	r0, 80068a6 <HAL_PWREx_ControlVoltageScaling+0x1e>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800688c:	6813      	ldr	r3, [r2, #0]
 800688e:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8006892:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006896:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800689a:	d01d      	beq.n	80068d8 <HAL_PWREx_ControlVoltageScaling+0x50>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800689c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80068a0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 80068a4:	4770      	bx	lr
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80068a6:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80068aa:	d007      	beq.n	80068bc <HAL_PWREx_ControlVoltageScaling+0x34>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80068ac:	6813      	ldr	r3, [r2, #0]
 80068ae:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80068b2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 80068b6:	2000      	movs	r0, #0
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80068b8:	6013      	str	r3, [r2, #0]
}
 80068ba:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80068bc:	6813      	ldr	r3, [r2, #0]
 80068be:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80068c2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80068c6:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 80068ca:	d02b      	beq.n	8006924 <HAL_PWREx_ControlVoltageScaling+0x9c>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80068cc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  return HAL_OK;
 80068d0:	2000      	movs	r0, #0
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80068d2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 80068d6:	4770      	bx	lr
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80068d8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80068dc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80068e0:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068e2:	4822      	ldr	r0, [pc, #136]	; (800696c <HAL_PWREx_ControlVoltageScaling+0xe4>)
 80068e4:	4922      	ldr	r1, [pc, #136]	; (8006970 <HAL_PWREx_ControlVoltageScaling+0xe8>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80068e6:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80068ea:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80068ee:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068f0:	6803      	ldr	r3, [r0, #0]
 80068f2:	2032      	movs	r0, #50	; 0x32
 80068f4:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068f8:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068fa:	fba1 1303 	umull	r1, r3, r1, r3
 80068fe:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006900:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8006902:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006906:	d506      	bpl.n	8006916 <HAL_PWREx_ControlVoltageScaling+0x8e>
 8006908:	e000      	b.n	800690c <HAL_PWREx_ControlVoltageScaling+0x84>
 800690a:	b123      	cbz	r3, 8006916 <HAL_PWREx_ControlVoltageScaling+0x8e>
 800690c:	6951      	ldr	r1, [r2, #20]
 800690e:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8006910:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006914:	d4f9      	bmi.n	800690a <HAL_PWREx_ControlVoltageScaling+0x82>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8006916:	4b14      	ldr	r3, [pc, #80]	; (8006968 <HAL_PWREx_ControlVoltageScaling+0xe0>)
 8006918:	695b      	ldr	r3, [r3, #20]
 800691a:	055b      	lsls	r3, r3, #21
  return HAL_OK;
 800691c:	bf54      	ite	pl
 800691e:	2000      	movpl	r0, #0
        return HAL_TIMEOUT;
 8006920:	2003      	movmi	r0, #3
 8006922:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006924:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006928:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800692c:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800692e:	480f      	ldr	r0, [pc, #60]	; (800696c <HAL_PWREx_ControlVoltageScaling+0xe4>)
 8006930:	490f      	ldr	r1, [pc, #60]	; (8006970 <HAL_PWREx_ControlVoltageScaling+0xe8>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8006932:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8006936:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800693a:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800693c:	6803      	ldr	r3, [r0, #0]
 800693e:	2032      	movs	r0, #50	; 0x32
 8006940:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006944:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8006946:	fba1 1303 	umull	r1, r3, r1, r3
 800694a:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800694c:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800694e:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006952:	d5e0      	bpl.n	8006916 <HAL_PWREx_ControlVoltageScaling+0x8e>
 8006954:	e001      	b.n	800695a <HAL_PWREx_ControlVoltageScaling+0xd2>
 8006956:	2b00      	cmp	r3, #0
 8006958:	d0dd      	beq.n	8006916 <HAL_PWREx_ControlVoltageScaling+0x8e>
 800695a:	6951      	ldr	r1, [r2, #20]
 800695c:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 800695e:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006962:	d5d8      	bpl.n	8006916 <HAL_PWREx_ControlVoltageScaling+0x8e>
 8006964:	e7f7      	b.n	8006956 <HAL_PWREx_ControlVoltageScaling+0xce>
 8006966:	bf00      	nop
 8006968:	40007000 	.word	0x40007000
 800696c:	200014a4 	.word	0x200014a4
 8006970:	431bde83 	.word	0x431bde83

08006974 <HAL_PWREx_DisableUCPDDeadBattery>:
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 8006974:	4a02      	ldr	r2, [pc, #8]	; (8006980 <HAL_PWREx_DisableUCPDDeadBattery+0xc>)
 8006976:	6893      	ldr	r3, [r2, #8]
 8006978:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800697c:	6093      	str	r3, [r2, #8]
}
 800697e:	4770      	bx	lr
 8006980:	40007000 	.word	0x40007000

08006984 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8006984:	2800      	cmp	r0, #0
 8006986:	f000 81c3 	beq.w	8006d10 <HAL_RCC_OscConfig+0x38c>
{
 800698a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800698e:	6803      	ldr	r3, [r0, #0]
 8006990:	07d9      	lsls	r1, r3, #31
{
 8006992:	b082      	sub	sp, #8
 8006994:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8006996:	d52d      	bpl.n	80069f4 <HAL_RCC_OscConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006998:	49a6      	ldr	r1, [pc, #664]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 800699a:	688a      	ldr	r2, [r1, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 800699c:	68c9      	ldr	r1, [r1, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800699e:	f002 020c 	and.w	r2, r2, #12

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 80069a2:	2a0c      	cmp	r2, #12
 80069a4:	f000 810a 	beq.w	8006bbc <HAL_RCC_OscConfig+0x238>
 80069a8:	2a08      	cmp	r2, #8
 80069aa:	f000 810c 	beq.w	8006bc6 <HAL_RCC_OscConfig+0x242>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80069ae:	6863      	ldr	r3, [r4, #4]
 80069b0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80069b4:	f000 8133 	beq.w	8006c1e <HAL_RCC_OscConfig+0x29a>
 80069b8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80069bc:	f000 819b 	beq.w	8006cf6 <HAL_RCC_OscConfig+0x372>
 80069c0:	4d9c      	ldr	r5, [pc, #624]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 80069c2:	682a      	ldr	r2, [r5, #0]
 80069c4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80069c8:	602a      	str	r2, [r5, #0]
 80069ca:	682a      	ldr	r2, [r5, #0]
 80069cc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80069d0:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80069d2:	2b00      	cmp	r3, #0
 80069d4:	f040 8128 	bne.w	8006c28 <HAL_RCC_OscConfig+0x2a4>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80069d8:	f7fe fd38 	bl	800544c <HAL_GetTick>
 80069dc:	4606      	mov	r6, r0

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80069de:	e005      	b.n	80069ec <HAL_RCC_OscConfig+0x68>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80069e0:	f7fe fd34 	bl	800544c <HAL_GetTick>
 80069e4:	1b80      	subs	r0, r0, r6
 80069e6:	2864      	cmp	r0, #100	; 0x64
 80069e8:	f200 8142 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80069ec:	682b      	ldr	r3, [r5, #0]
 80069ee:	039f      	lsls	r7, r3, #14
 80069f0:	d4f6      	bmi.n	80069e0 <HAL_RCC_OscConfig+0x5c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80069f2:	6823      	ldr	r3, [r4, #0]
 80069f4:	079e      	lsls	r6, r3, #30
 80069f6:	d528      	bpl.n	8006a4a <HAL_RCC_OscConfig+0xc6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80069f8:	4a8e      	ldr	r2, [pc, #568]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 80069fa:	6893      	ldr	r3, [r2, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80069fc:	68d2      	ldr	r2, [r2, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80069fe:	f003 030c 	and.w	r3, r3, #12
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8006a02:	2b0c      	cmp	r3, #12
 8006a04:	f000 80ec 	beq.w	8006be0 <HAL_RCC_OscConfig+0x25c>
 8006a08:	2b04      	cmp	r3, #4
 8006a0a:	f000 80ee 	beq.w	8006bea <HAL_RCC_OscConfig+0x266>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8006a0e:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8006a10:	4d88      	ldr	r5, [pc, #544]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8006a12:	2b00      	cmp	r3, #0
 8006a14:	f000 811d 	beq.w	8006c52 <HAL_RCC_OscConfig+0x2ce>
        __HAL_RCC_HSI_ENABLE();
 8006a18:	682b      	ldr	r3, [r5, #0]
 8006a1a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006a1e:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006a20:	f7fe fd14 	bl	800544c <HAL_GetTick>
 8006a24:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8006a26:	e005      	b.n	8006a34 <HAL_RCC_OscConfig+0xb0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8006a28:	f7fe fd10 	bl	800544c <HAL_GetTick>
 8006a2c:	1b80      	subs	r0, r0, r6
 8006a2e:	2802      	cmp	r0, #2
 8006a30:	f200 811e 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8006a34:	682b      	ldr	r3, [r5, #0]
 8006a36:	0558      	lsls	r0, r3, #21
 8006a38:	d5f6      	bpl.n	8006a28 <HAL_RCC_OscConfig+0xa4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006a3a:	686b      	ldr	r3, [r5, #4]
 8006a3c:	6922      	ldr	r2, [r4, #16]
 8006a3e:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8006a42:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8006a46:	606b      	str	r3, [r5, #4]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006a48:	6823      	ldr	r3, [r4, #0]
 8006a4a:	071a      	lsls	r2, r3, #28
 8006a4c:	d519      	bpl.n	8006a82 <HAL_RCC_OscConfig+0xfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006a4e:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8006a50:	4d78      	ldr	r5, [pc, #480]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006a52:	2b00      	cmp	r3, #0
 8006a54:	f000 809e 	beq.w	8006b94 <HAL_RCC_OscConfig+0x210>
      __HAL_RCC_LSI_ENABLE();
 8006a58:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006a5c:	f043 0301 	orr.w	r3, r3, #1
 8006a60:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006a64:	f7fe fcf2 	bl	800544c <HAL_GetTick>
 8006a68:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8006a6a:	e005      	b.n	8006a78 <HAL_RCC_OscConfig+0xf4>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8006a6c:	f7fe fcee 	bl	800544c <HAL_GetTick>
 8006a70:	1b80      	subs	r0, r0, r6
 8006a72:	2802      	cmp	r0, #2
 8006a74:	f200 80fc 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8006a78:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006a7c:	079f      	lsls	r7, r3, #30
 8006a7e:	d5f5      	bpl.n	8006a6c <HAL_RCC_OscConfig+0xe8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8006a80:	6823      	ldr	r3, [r4, #0]
 8006a82:	0759      	lsls	r1, r3, #29
 8006a84:	d541      	bpl.n	8006b0a <HAL_RCC_OscConfig+0x186>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8006a86:	4b6b      	ldr	r3, [pc, #428]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006a88:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006a8a:	00d2      	lsls	r2, r2, #3
 8006a8c:	f100 80f4 	bmi.w	8006c78 <HAL_RCC_OscConfig+0x2f4>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8006a90:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006a92:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8006a96:	659a      	str	r2, [r3, #88]	; 0x58
 8006a98:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006a9a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006a9e:	9301      	str	r3, [sp, #4]
 8006aa0:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8006aa2:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8006aa4:	4e64      	ldr	r6, [pc, #400]	; (8006c38 <HAL_RCC_OscConfig+0x2b4>)
 8006aa6:	6833      	ldr	r3, [r6, #0]
 8006aa8:	05df      	lsls	r7, r3, #23
 8006aaa:	f140 8113 	bpl.w	8006cd4 <HAL_RCC_OscConfig+0x350>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006aae:	68a3      	ldr	r3, [r4, #8]
 8006ab0:	2b01      	cmp	r3, #1
 8006ab2:	f000 80e3 	beq.w	8006c7c <HAL_RCC_OscConfig+0x2f8>
 8006ab6:	2b05      	cmp	r3, #5
 8006ab8:	f000 8169 	beq.w	8006d8e <HAL_RCC_OscConfig+0x40a>
 8006abc:	4e5d      	ldr	r6, [pc, #372]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006abe:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8006ac2:	f022 0201 	bic.w	r2, r2, #1
 8006ac6:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
 8006aca:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8006ace:	f022 0204 	bic.w	r2, r2, #4
 8006ad2:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8006ad6:	2b00      	cmp	r3, #0
 8006ad8:	f040 80d7 	bne.w	8006c8a <HAL_RCC_OscConfig+0x306>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006adc:	f7fe fcb6 	bl	800544c <HAL_GetTick>

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006ae0:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8006ae4:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8006ae6:	e005      	b.n	8006af4 <HAL_RCC_OscConfig+0x170>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006ae8:	f7fe fcb0 	bl	800544c <HAL_GetTick>
 8006aec:	1bc0      	subs	r0, r0, r7
 8006aee:	4540      	cmp	r0, r8
 8006af0:	f200 80be 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8006af4:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8006af8:	079a      	lsls	r2, r3, #30
 8006afa:	d4f5      	bmi.n	8006ae8 <HAL_RCC_OscConfig+0x164>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8006afc:	b125      	cbz	r5, 8006b08 <HAL_RCC_OscConfig+0x184>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8006afe:	4a4d      	ldr	r2, [pc, #308]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006b00:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8006b02:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006b06:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8006b08:	6823      	ldr	r3, [r4, #0]
 8006b0a:	069b      	lsls	r3, r3, #26
 8006b0c:	d518      	bpl.n	8006b40 <HAL_RCC_OscConfig+0x1bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8006b0e:	69a3      	ldr	r3, [r4, #24]
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8006b10:	4d48      	ldr	r5, [pc, #288]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8006b12:	2b00      	cmp	r3, #0
 8006b14:	f000 80ca 	beq.w	8006cac <HAL_RCC_OscConfig+0x328>
      __HAL_RCC_HSI48_ENABLE();
 8006b18:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006b1c:	f043 0301 	orr.w	r3, r3, #1
 8006b20:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006b24:	f7fe fc92 	bl	800544c <HAL_GetTick>
 8006b28:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8006b2a:	e005      	b.n	8006b38 <HAL_RCC_OscConfig+0x1b4>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8006b2c:	f7fe fc8e 	bl	800544c <HAL_GetTick>
 8006b30:	1b80      	subs	r0, r0, r6
 8006b32:	2802      	cmp	r0, #2
 8006b34:	f200 809c 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8006b38:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006b3c:	079f      	lsls	r7, r3, #30
 8006b3e:	d5f5      	bpl.n	8006b2c <HAL_RCC_OscConfig+0x1a8>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8006b40:	69e0      	ldr	r0, [r4, #28]
 8006b42:	b318      	cbz	r0, 8006b8c <HAL_RCC_OscConfig+0x208>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006b44:	4d3b      	ldr	r5, [pc, #236]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006b46:	68ab      	ldr	r3, [r5, #8]
 8006b48:	f003 030c 	and.w	r3, r3, #12
 8006b4c:	2b0c      	cmp	r3, #12
 8006b4e:	f000 812c 	beq.w	8006daa <HAL_RCC_OscConfig+0x426>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8006b52:	682b      	ldr	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8006b54:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8006b56:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8006b5a:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8006b5c:	f000 80da 	beq.w	8006d14 <HAL_RCC_OscConfig+0x390>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8006b60:	68eb      	ldr	r3, [r5, #12]
 8006b62:	f023 0303 	bic.w	r3, r3, #3
 8006b66:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 8006b68:	68eb      	ldr	r3, [r5, #12]
 8006b6a:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8006b6e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8006b72:	60eb      	str	r3, [r5, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006b74:	f7fe fc6a 	bl	800544c <HAL_GetTick>
 8006b78:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006b7a:	e004      	b.n	8006b86 <HAL_RCC_OscConfig+0x202>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006b7c:	f7fe fc66 	bl	800544c <HAL_GetTick>
 8006b80:	1b00      	subs	r0, r0, r4
 8006b82:	2802      	cmp	r0, #2
 8006b84:	d874      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006b86:	682b      	ldr	r3, [r5, #0]
 8006b88:	019b      	lsls	r3, r3, #6
 8006b8a:	d4f7      	bmi.n	8006b7c <HAL_RCC_OscConfig+0x1f8>
      }
    }
  }
  }

  return HAL_OK;
 8006b8c:	2000      	movs	r0, #0
}
 8006b8e:	b002      	add	sp, #8
 8006b90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8006b94:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006b98:	f023 0301 	bic.w	r3, r3, #1
 8006b9c:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 8006ba0:	f7fe fc54 	bl	800544c <HAL_GetTick>
 8006ba4:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8006ba6:	e004      	b.n	8006bb2 <HAL_RCC_OscConfig+0x22e>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8006ba8:	f7fe fc50 	bl	800544c <HAL_GetTick>
 8006bac:	1b80      	subs	r0, r0, r6
 8006bae:	2802      	cmp	r0, #2
 8006bb0:	d85e      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8006bb2:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006bb6:	0798      	lsls	r0, r3, #30
 8006bb8:	d4f6      	bmi.n	8006ba8 <HAL_RCC_OscConfig+0x224>
 8006bba:	e761      	b.n	8006a80 <HAL_RCC_OscConfig+0xfc>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006bbc:	f001 0103 	and.w	r1, r1, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8006bc0:	2903      	cmp	r1, #3
 8006bc2:	f47f aef4 	bne.w	80069ae <HAL_RCC_OscConfig+0x2a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8006bc6:	4a1b      	ldr	r2, [pc, #108]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006bc8:	6812      	ldr	r2, [r2, #0]
 8006bca:	0392      	lsls	r2, r2, #14
 8006bcc:	f57f af12 	bpl.w	80069f4 <HAL_RCC_OscConfig+0x70>
 8006bd0:	6862      	ldr	r2, [r4, #4]
 8006bd2:	2a00      	cmp	r2, #0
 8006bd4:	f47f af0e 	bne.w	80069f4 <HAL_RCC_OscConfig+0x70>
        return HAL_ERROR;
 8006bd8:	2001      	movs	r0, #1
}
 8006bda:	b002      	add	sp, #8
 8006bdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006be0:	f002 0203 	and.w	r2, r2, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8006be4:	2a02      	cmp	r2, #2
 8006be6:	f47f af12 	bne.w	8006a0e <HAL_RCC_OscConfig+0x8a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8006bea:	4b12      	ldr	r3, [pc, #72]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006bec:	681b      	ldr	r3, [r3, #0]
 8006bee:	055d      	lsls	r5, r3, #21
 8006bf0:	d502      	bpl.n	8006bf8 <HAL_RCC_OscConfig+0x274>
 8006bf2:	68e3      	ldr	r3, [r4, #12]
 8006bf4:	2b00      	cmp	r3, #0
 8006bf6:	d0ef      	beq.n	8006bd8 <HAL_RCC_OscConfig+0x254>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006bf8:	4a0e      	ldr	r2, [pc, #56]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006bfa:	6920      	ldr	r0, [r4, #16]
 8006bfc:	6853      	ldr	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8006bfe:	490f      	ldr	r1, [pc, #60]	; (8006c3c <HAL_RCC_OscConfig+0x2b8>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006c00:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8006c04:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8006c08:	6053      	str	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8006c0a:	6808      	ldr	r0, [r1, #0]
 8006c0c:	f7fe fbd4 	bl	80053b8 <HAL_InitTick>
 8006c10:	2800      	cmp	r0, #0
 8006c12:	d1e1      	bne.n	8006bd8 <HAL_RCC_OscConfig+0x254>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006c14:	6823      	ldr	r3, [r4, #0]
 8006c16:	071a      	lsls	r2, r3, #28
 8006c18:	f57f af33 	bpl.w	8006a82 <HAL_RCC_OscConfig+0xfe>
 8006c1c:	e717      	b.n	8006a4e <HAL_RCC_OscConfig+0xca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006c1e:	4a05      	ldr	r2, [pc, #20]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
 8006c20:	6813      	ldr	r3, [r2, #0]
 8006c22:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006c26:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8006c28:	f7fe fc10 	bl	800544c <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006c2c:	4e01      	ldr	r6, [pc, #4]	; (8006c34 <HAL_RCC_OscConfig+0x2b0>)
        tickstart = HAL_GetTick();
 8006c2e:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006c30:	e00b      	b.n	8006c4a <HAL_RCC_OscConfig+0x2c6>
 8006c32:	bf00      	nop
 8006c34:	40021000 	.word	0x40021000
 8006c38:	40007000 	.word	0x40007000
 8006c3c:	200014ac 	.word	0x200014ac
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006c40:	f7fe fc04 	bl	800544c <HAL_GetTick>
 8006c44:	1b40      	subs	r0, r0, r5
 8006c46:	2864      	cmp	r0, #100	; 0x64
 8006c48:	d812      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006c4a:	6833      	ldr	r3, [r6, #0]
 8006c4c:	039b      	lsls	r3, r3, #14
 8006c4e:	d5f7      	bpl.n	8006c40 <HAL_RCC_OscConfig+0x2bc>
 8006c50:	e6cf      	b.n	80069f2 <HAL_RCC_OscConfig+0x6e>
        __HAL_RCC_HSI_DISABLE();
 8006c52:	682b      	ldr	r3, [r5, #0]
 8006c54:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006c58:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8006c5a:	f7fe fbf7 	bl	800544c <HAL_GetTick>
 8006c5e:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8006c60:	682b      	ldr	r3, [r5, #0]
 8006c62:	0559      	lsls	r1, r3, #21
 8006c64:	d5d6      	bpl.n	8006c14 <HAL_RCC_OscConfig+0x290>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8006c66:	f7fe fbf1 	bl	800544c <HAL_GetTick>
 8006c6a:	1b80      	subs	r0, r0, r6
 8006c6c:	2802      	cmp	r0, #2
 8006c6e:	d9f7      	bls.n	8006c60 <HAL_RCC_OscConfig+0x2dc>
            return HAL_TIMEOUT;
 8006c70:	2003      	movs	r0, #3
}
 8006c72:	b002      	add	sp, #8
 8006c74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FlagStatus       pwrclkchanged = RESET;
 8006c78:	2500      	movs	r5, #0
 8006c7a:	e713      	b.n	8006aa4 <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006c7c:	4a65      	ldr	r2, [pc, #404]	; (8006e14 <HAL_RCC_OscConfig+0x490>)
 8006c7e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8006c82:	f043 0301 	orr.w	r3, r3, #1
 8006c86:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      tickstart = HAL_GetTick();
 8006c8a:	f7fe fbdf 	bl	800544c <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006c8e:	4f61      	ldr	r7, [pc, #388]	; (8006e14 <HAL_RCC_OscConfig+0x490>)
      tickstart = HAL_GetTick();
 8006c90:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006c92:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006c96:	e004      	b.n	8006ca2 <HAL_RCC_OscConfig+0x31e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006c98:	f7fe fbd8 	bl	800544c <HAL_GetTick>
 8006c9c:	1b80      	subs	r0, r0, r6
 8006c9e:	4540      	cmp	r0, r8
 8006ca0:	d8e6      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006ca2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006ca6:	0799      	lsls	r1, r3, #30
 8006ca8:	d5f6      	bpl.n	8006c98 <HAL_RCC_OscConfig+0x314>
 8006caa:	e727      	b.n	8006afc <HAL_RCC_OscConfig+0x178>
      __HAL_RCC_HSI48_DISABLE();
 8006cac:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006cb0:	f023 0301 	bic.w	r3, r3, #1
 8006cb4:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 8006cb8:	f7fe fbc8 	bl	800544c <HAL_GetTick>
 8006cbc:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8006cbe:	e004      	b.n	8006cca <HAL_RCC_OscConfig+0x346>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8006cc0:	f7fe fbc4 	bl	800544c <HAL_GetTick>
 8006cc4:	1b80      	subs	r0, r0, r6
 8006cc6:	2802      	cmp	r0, #2
 8006cc8:	d8d2      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8006cca:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006cce:	0798      	lsls	r0, r3, #30
 8006cd0:	d4f6      	bmi.n	8006cc0 <HAL_RCC_OscConfig+0x33c>
 8006cd2:	e735      	b.n	8006b40 <HAL_RCC_OscConfig+0x1bc>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8006cd4:	6833      	ldr	r3, [r6, #0]
 8006cd6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006cda:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8006cdc:	f7fe fbb6 	bl	800544c <HAL_GetTick>
 8006ce0:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8006ce2:	6833      	ldr	r3, [r6, #0]
 8006ce4:	05d8      	lsls	r0, r3, #23
 8006ce6:	f53f aee2 	bmi.w	8006aae <HAL_RCC_OscConfig+0x12a>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8006cea:	f7fe fbaf 	bl	800544c <HAL_GetTick>
 8006cee:	1bc0      	subs	r0, r0, r7
 8006cf0:	2802      	cmp	r0, #2
 8006cf2:	d9f6      	bls.n	8006ce2 <HAL_RCC_OscConfig+0x35e>
 8006cf4:	e7bc      	b.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006cf6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8006cfa:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8006cfe:	681a      	ldr	r2, [r3, #0]
 8006d00:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8006d04:	601a      	str	r2, [r3, #0]
 8006d06:	681a      	ldr	r2, [r3, #0]
 8006d08:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006d0c:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8006d0e:	e78b      	b.n	8006c28 <HAL_RCC_OscConfig+0x2a4>
    return HAL_ERROR;
 8006d10:	2001      	movs	r0, #1
}
 8006d12:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8006d14:	f7fe fb9a 	bl	800544c <HAL_GetTick>
 8006d18:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006d1a:	e004      	b.n	8006d26 <HAL_RCC_OscConfig+0x3a2>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006d1c:	f7fe fb96 	bl	800544c <HAL_GetTick>
 8006d20:	1b80      	subs	r0, r0, r6
 8006d22:	2802      	cmp	r0, #2
 8006d24:	d8a4      	bhi.n	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006d26:	682b      	ldr	r3, [r5, #0]
 8006d28:	0199      	lsls	r1, r3, #6
 8006d2a:	d4f7      	bmi.n	8006d1c <HAL_RCC_OscConfig+0x398>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8006d2c:	68e9      	ldr	r1, [r5, #12]
 8006d2e:	4b3a      	ldr	r3, [pc, #232]	; (8006e18 <HAL_RCC_OscConfig+0x494>)
 8006d30:	6a22      	ldr	r2, [r4, #32]
 8006d32:	6a60      	ldr	r0, [r4, #36]	; 0x24
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006d34:	4e37      	ldr	r6, [pc, #220]	; (8006e14 <HAL_RCC_OscConfig+0x490>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8006d36:	400b      	ands	r3, r1
 8006d38:	4313      	orrs	r3, r2
 8006d3a:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
 8006d3e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8006d42:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 8006d46:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	; 0x30
 8006d4a:	3801      	subs	r0, #1
 8006d4c:	0849      	lsrs	r1, r1, #1
 8006d4e:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8006d52:	3901      	subs	r1, #1
 8006d54:	0852      	lsrs	r2, r2, #1
 8006d56:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8006d5a:	3a01      	subs	r2, #1
 8006d5c:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8006d60:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8006d62:	682b      	ldr	r3, [r5, #0]
 8006d64:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006d68:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8006d6a:	68eb      	ldr	r3, [r5, #12]
 8006d6c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006d70:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8006d72:	f7fe fb6b 	bl	800544c <HAL_GetTick>
 8006d76:	4604      	mov	r4, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006d78:	e005      	b.n	8006d86 <HAL_RCC_OscConfig+0x402>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006d7a:	f7fe fb67 	bl	800544c <HAL_GetTick>
 8006d7e:	1b00      	subs	r0, r0, r4
 8006d80:	2802      	cmp	r0, #2
 8006d82:	f63f af75 	bhi.w	8006c70 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006d86:	6833      	ldr	r3, [r6, #0]
 8006d88:	019a      	lsls	r2, r3, #6
 8006d8a:	d5f6      	bpl.n	8006d7a <HAL_RCC_OscConfig+0x3f6>
 8006d8c:	e6fe      	b.n	8006b8c <HAL_RCC_OscConfig+0x208>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006d8e:	4b21      	ldr	r3, [pc, #132]	; (8006e14 <HAL_RCC_OscConfig+0x490>)
 8006d90:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8006d94:	f042 0204 	orr.w	r2, r2, #4
 8006d98:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8006d9c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8006da0:	f042 0201 	orr.w	r2, r2, #1
 8006da4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8006da8:	e76f      	b.n	8006c8a <HAL_RCC_OscConfig+0x306>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8006daa:	2801      	cmp	r0, #1
 8006dac:	f43f aeef 	beq.w	8006b8e <HAL_RCC_OscConfig+0x20a>
      temp_pllckcfg = RCC->PLLCFGR;
 8006db0:	68eb      	ldr	r3, [r5, #12]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8006db2:	6a22      	ldr	r2, [r4, #32]
 8006db4:	f003 0103 	and.w	r1, r3, #3
 8006db8:	4291      	cmp	r1, r2
 8006dba:	f47f af0d 	bne.w	8006bd8 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8006dbe:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006dc0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8006dc4:	3901      	subs	r1, #1
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8006dc6:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8006dca:	f47f af05 	bne.w	8006bd8 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8006dce:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006dd0:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8006dd4:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8006dd8:	f47f aefe 	bne.w	8006bd8 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8006ddc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8006dde:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8006de2:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8006de6:	f47f aef7 	bne.w	8006bd8 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8006dea:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006dec:	0852      	lsrs	r2, r2, #1
 8006dee:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8006df2:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8006df4:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8006df8:	f47f aeee 	bne.w	8006bd8 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8006dfc:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006dfe:	0852      	lsrs	r2, r2, #1
 8006e00:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8006e04:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8006e06:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
    return HAL_ERROR;
 8006e0a:	bf14      	ite	ne
 8006e0c:	2001      	movne	r0, #1
 8006e0e:	2000      	moveq	r0, #0
 8006e10:	e6bd      	b.n	8006b8e <HAL_RCC_OscConfig+0x20a>
 8006e12:	bf00      	nop
 8006e14:	40021000 	.word	0x40021000
 8006e18:	019f800c 	.word	0x019f800c

08006e1c <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8006e1c:	4b18      	ldr	r3, [pc, #96]	; (8006e80 <HAL_RCC_GetSysClockFreq+0x64>)
 8006e1e:	689a      	ldr	r2, [r3, #8]
 8006e20:	f002 020c 	and.w	r2, r2, #12
 8006e24:	2a04      	cmp	r2, #4
 8006e26:	d026      	beq.n	8006e76 <HAL_RCC_GetSysClockFreq+0x5a>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8006e28:	689a      	ldr	r2, [r3, #8]
 8006e2a:	f002 020c 	and.w	r2, r2, #12
 8006e2e:	2a08      	cmp	r2, #8
 8006e30:	d023      	beq.n	8006e7a <HAL_RCC_GetSysClockFreq+0x5e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8006e32:	689a      	ldr	r2, [r3, #8]
 8006e34:	f002 020c 	and.w	r2, r2, #12
 8006e38:	2a0c      	cmp	r2, #12
 8006e3a:	d001      	beq.n	8006e40 <HAL_RCC_GetSysClockFreq+0x24>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }
  else
  {
    sysclockfreq = 0U;
 8006e3c:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 8006e3e:	4770      	bx	lr
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006e40:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006e42:	68da      	ldr	r2, [r3, #12]
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e44:	68d8      	ldr	r0, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006e46:	f001 0103 	and.w	r1, r1, #3
    switch (pllsource)
 8006e4a:	2903      	cmp	r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006e4c:	f3c2 1203 	ubfx	r2, r2, #4, #4
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e50:	f3c0 2006 	ubfx	r0, r0, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e54:	bf0c      	ite	eq
 8006e56:	4b0b      	ldreq	r3, [pc, #44]	; (8006e84 <HAL_RCC_GetSysClockFreq+0x68>)
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e58:	4b0b      	ldrne	r3, [pc, #44]	; (8006e88 <HAL_RCC_GetSysClockFreq+0x6c>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006e5a:	3201      	adds	r2, #1
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e5c:	fbb3 f3f2 	udiv	r3, r3, r2
 8006e60:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006e64:	4b06      	ldr	r3, [pc, #24]	; (8006e80 <HAL_RCC_GetSysClockFreq+0x64>)
 8006e66:	68db      	ldr	r3, [r3, #12]
 8006e68:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8006e6c:	3301      	adds	r3, #1
 8006e6e:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8006e70:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8006e74:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 8006e76:	4804      	ldr	r0, [pc, #16]	; (8006e88 <HAL_RCC_GetSysClockFreq+0x6c>)
 8006e78:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 8006e7a:	4802      	ldr	r0, [pc, #8]	; (8006e84 <HAL_RCC_GetSysClockFreq+0x68>)
 8006e7c:	4770      	bx	lr
 8006e7e:	bf00      	nop
 8006e80:	40021000 	.word	0x40021000
 8006e84:	016e3600 	.word	0x016e3600
 8006e88:	00f42400 	.word	0x00f42400

08006e8c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8006e8c:	2800      	cmp	r0, #0
 8006e8e:	f000 80ee 	beq.w	800706e <HAL_RCC_ClockConfig+0x1e2>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8006e92:	4a78      	ldr	r2, [pc, #480]	; (8007074 <HAL_RCC_ClockConfig+0x1e8>)
{
 8006e94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8006e98:	6813      	ldr	r3, [r2, #0]
 8006e9a:	f003 030f 	and.w	r3, r3, #15
 8006e9e:	428b      	cmp	r3, r1
 8006ea0:	460d      	mov	r5, r1
 8006ea2:	4604      	mov	r4, r0
 8006ea4:	d20c      	bcs.n	8006ec0 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006ea6:	6813      	ldr	r3, [r2, #0]
 8006ea8:	f023 030f 	bic.w	r3, r3, #15
 8006eac:	430b      	orrs	r3, r1
 8006eae:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8006eb0:	6813      	ldr	r3, [r2, #0]
 8006eb2:	f003 030f 	and.w	r3, r3, #15
 8006eb6:	428b      	cmp	r3, r1
 8006eb8:	d002      	beq.n	8006ec0 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8006eba:	2001      	movs	r0, #1
}
 8006ebc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8006ec0:	6823      	ldr	r3, [r4, #0]
 8006ec2:	07df      	lsls	r7, r3, #31
 8006ec4:	d569      	bpl.n	8006f9a <HAL_RCC_ClockConfig+0x10e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8006ec6:	6867      	ldr	r7, [r4, #4]
 8006ec8:	2f03      	cmp	r7, #3
 8006eca:	f000 80a0 	beq.w	800700e <HAL_RCC_ClockConfig+0x182>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006ece:	4b6a      	ldr	r3, [pc, #424]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006ed0:	2f02      	cmp	r7, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006ed2:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006ed4:	f000 8097 	beq.w	8007006 <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8006ed8:	055b      	lsls	r3, r3, #21
 8006eda:	d5ee      	bpl.n	8006eba <HAL_RCC_ClockConfig+0x2e>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8006edc:	f7ff ff9e 	bl	8006e1c <HAL_RCC_GetSysClockFreq>
      if(pllfreq > 80000000U)
 8006ee0:	4b66      	ldr	r3, [pc, #408]	; (800707c <HAL_RCC_ClockConfig+0x1f0>)
 8006ee2:	4298      	cmp	r0, r3
 8006ee4:	f240 80c0 	bls.w	8007068 <HAL_RCC_ClockConfig+0x1dc>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8006ee8:	4a63      	ldr	r2, [pc, #396]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006eea:	6893      	ldr	r3, [r2, #8]
 8006eec:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006ef0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006ef4:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 8006ef6:	f04f 0980 	mov.w	r9, #128	; 0x80
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8006efa:	4e5f      	ldr	r6, [pc, #380]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006efc:	68b3      	ldr	r3, [r6, #8]
 8006efe:	f023 0303 	bic.w	r3, r3, #3
 8006f02:	433b      	orrs	r3, r7
 8006f04:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8006f06:	f7fe faa1 	bl	800544c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006f0a:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8006f0e:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8006f10:	e004      	b.n	8006f1c <HAL_RCC_ClockConfig+0x90>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006f12:	f7fe fa9b 	bl	800544c <HAL_GetTick>
 8006f16:	1bc0      	subs	r0, r0, r7
 8006f18:	4540      	cmp	r0, r8
 8006f1a:	d871      	bhi.n	8007000 <HAL_RCC_ClockConfig+0x174>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8006f1c:	68b3      	ldr	r3, [r6, #8]
 8006f1e:	6862      	ldr	r2, [r4, #4]
 8006f20:	f003 030c 	and.w	r3, r3, #12
 8006f24:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8006f28:	d1f3      	bne.n	8006f12 <HAL_RCC_ClockConfig+0x86>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006f2a:	6823      	ldr	r3, [r4, #0]
 8006f2c:	079f      	lsls	r7, r3, #30
 8006f2e:	d436      	bmi.n	8006f9e <HAL_RCC_ClockConfig+0x112>
    if(hpre == RCC_SYSCLK_DIV2)
 8006f30:	f1b9 0f00 	cmp.w	r9, #0
 8006f34:	d003      	beq.n	8006f3e <HAL_RCC_ClockConfig+0xb2>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8006f36:	68b3      	ldr	r3, [r6, #8]
 8006f38:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006f3c:	60b3      	str	r3, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006f3e:	4e4d      	ldr	r6, [pc, #308]	; (8007074 <HAL_RCC_ClockConfig+0x1e8>)
 8006f40:	6833      	ldr	r3, [r6, #0]
 8006f42:	f003 030f 	and.w	r3, r3, #15
 8006f46:	42ab      	cmp	r3, r5
 8006f48:	d846      	bhi.n	8006fd8 <HAL_RCC_ClockConfig+0x14c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006f4a:	6823      	ldr	r3, [r4, #0]
 8006f4c:	075a      	lsls	r2, r3, #29
 8006f4e:	d506      	bpl.n	8006f5e <HAL_RCC_ClockConfig+0xd2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8006f50:	4949      	ldr	r1, [pc, #292]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006f52:	68e0      	ldr	r0, [r4, #12]
 8006f54:	688a      	ldr	r2, [r1, #8]
 8006f56:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8006f5a:	4302      	orrs	r2, r0
 8006f5c:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006f5e:	071b      	lsls	r3, r3, #28
 8006f60:	d507      	bpl.n	8006f72 <HAL_RCC_ClockConfig+0xe6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8006f62:	4a45      	ldr	r2, [pc, #276]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006f64:	6921      	ldr	r1, [r4, #16]
 8006f66:	6893      	ldr	r3, [r2, #8]
 8006f68:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8006f6c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8006f70:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8006f72:	f7ff ff53 	bl	8006e1c <HAL_RCC_GetSysClockFreq>
 8006f76:	4a40      	ldr	r2, [pc, #256]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006f78:	4c41      	ldr	r4, [pc, #260]	; (8007080 <HAL_RCC_ClockConfig+0x1f4>)
 8006f7a:	6892      	ldr	r2, [r2, #8]
 8006f7c:	4941      	ldr	r1, [pc, #260]	; (8007084 <HAL_RCC_ClockConfig+0x1f8>)
 8006f7e:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8006f82:	4603      	mov	r3, r0
 8006f84:	5ca2      	ldrb	r2, [r4, r2]
  return HAL_InitTick(uwTickPrio);
 8006f86:	4840      	ldr	r0, [pc, #256]	; (8007088 <HAL_RCC_ClockConfig+0x1fc>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8006f88:	f002 021f 	and.w	r2, r2, #31
 8006f8c:	40d3      	lsrs	r3, r2
 8006f8e:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8006f90:	6800      	ldr	r0, [r0, #0]
}
 8006f92:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 8006f96:	f7fe ba0f 	b.w	80053b8 <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006f9a:	079e      	lsls	r6, r3, #30
 8006f9c:	d5cf      	bpl.n	8006f3e <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006f9e:	0758      	lsls	r0, r3, #29
 8006fa0:	d504      	bpl.n	8006fac <HAL_RCC_ClockConfig+0x120>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8006fa2:	4935      	ldr	r1, [pc, #212]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006fa4:	688a      	ldr	r2, [r1, #8]
 8006fa6:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 8006faa:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006fac:	0719      	lsls	r1, r3, #28
 8006fae:	d506      	bpl.n	8006fbe <HAL_RCC_ClockConfig+0x132>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 8006fb0:	4a31      	ldr	r2, [pc, #196]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006fb2:	6893      	ldr	r3, [r2, #8]
 8006fb4:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8006fb8:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 8006fbc:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006fbe:	4a2e      	ldr	r2, [pc, #184]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8006fc0:	68a1      	ldr	r1, [r4, #8]
 8006fc2:	6893      	ldr	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006fc4:	4e2b      	ldr	r6, [pc, #172]	; (8007074 <HAL_RCC_ClockConfig+0x1e8>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006fc6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006fca:	430b      	orrs	r3, r1
 8006fcc:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006fce:	6833      	ldr	r3, [r6, #0]
 8006fd0:	f003 030f 	and.w	r3, r3, #15
 8006fd4:	42ab      	cmp	r3, r5
 8006fd6:	d9b8      	bls.n	8006f4a <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006fd8:	6833      	ldr	r3, [r6, #0]
 8006fda:	f023 030f 	bic.w	r3, r3, #15
 8006fde:	432b      	orrs	r3, r5
 8006fe0:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8006fe2:	f7fe fa33 	bl	800544c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006fe6:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8006fea:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8006fec:	6833      	ldr	r3, [r6, #0]
 8006fee:	f003 030f 	and.w	r3, r3, #15
 8006ff2:	42ab      	cmp	r3, r5
 8006ff4:	d0a9      	beq.n	8006f4a <HAL_RCC_ClockConfig+0xbe>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006ff6:	f7fe fa29 	bl	800544c <HAL_GetTick>
 8006ffa:	1bc0      	subs	r0, r0, r7
 8006ffc:	4540      	cmp	r0, r8
 8006ffe:	d9f5      	bls.n	8006fec <HAL_RCC_ClockConfig+0x160>
        return HAL_TIMEOUT;
 8007000:	2003      	movs	r0, #3
}
 8007002:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007006:	039a      	lsls	r2, r3, #14
 8007008:	f53f af68 	bmi.w	8006edc <HAL_RCC_ClockConfig+0x50>
 800700c:	e755      	b.n	8006eba <HAL_RCC_ClockConfig+0x2e>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800700e:	4a1a      	ldr	r2, [pc, #104]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
 8007010:	6811      	ldr	r1, [r2, #0]
 8007012:	0188      	lsls	r0, r1, #6
 8007014:	f57f af51 	bpl.w	8006eba <HAL_RCC_ClockConfig+0x2e>
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8007018:	68d0      	ldr	r0, [r2, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800701a:	68d1      	ldr	r1, [r2, #12]
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800701c:	68d2      	ldr	r2, [r2, #12]
      if(pllfreq > 80000000U)
 800701e:	4e17      	ldr	r6, [pc, #92]	; (800707c <HAL_RCC_ClockConfig+0x1f0>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8007020:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 8007024:	2803      	cmp	r0, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8007026:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800702a:	bf0c      	ite	eq
 800702c:	4817      	ldreq	r0, [pc, #92]	; (800708c <HAL_RCC_ClockConfig+0x200>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 800702e:	4818      	ldrne	r0, [pc, #96]	; (8007090 <HAL_RCC_ClockConfig+0x204>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8007030:	3101      	adds	r1, #1
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8007032:	fbb0 f1f1 	udiv	r1, r0, r1
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8007036:	4810      	ldr	r0, [pc, #64]	; (8007078 <HAL_RCC_ClockConfig+0x1ec>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8007038:	f3c2 2206 	ubfx	r2, r2, #8, #7
 800703c:	fb01 f202 	mul.w	r2, r1, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8007040:	68c1      	ldr	r1, [r0, #12]
 8007042:	f3c1 6141 	ubfx	r1, r1, #25, #2
 8007046:	3101      	adds	r1, #1
 8007048:	0049      	lsls	r1, r1, #1
  sysclockfreq = pllvco/pllr;
 800704a:	fbb2 f2f1 	udiv	r2, r2, r1
      if(pllfreq > 80000000U)
 800704e:	42b2      	cmp	r2, r6
 8007050:	d90a      	bls.n	8007068 <HAL_RCC_ClockConfig+0x1dc>
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 8007052:	6882      	ldr	r2, [r0, #8]
 8007054:	f012 0ff0 	tst.w	r2, #240	; 0xf0
 8007058:	f43f af46 	beq.w	8006ee8 <HAL_RCC_ClockConfig+0x5c>
 800705c:	0799      	lsls	r1, r3, #30
 800705e:	d503      	bpl.n	8007068 <HAL_RCC_ClockConfig+0x1dc>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 8007060:	68a3      	ldr	r3, [r4, #8]
 8007062:	2b00      	cmp	r3, #0
 8007064:	f43f af40 	beq.w	8006ee8 <HAL_RCC_ClockConfig+0x5c>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8007068:	f04f 0900 	mov.w	r9, #0
 800706c:	e745      	b.n	8006efa <HAL_RCC_ClockConfig+0x6e>
    return HAL_ERROR;
 800706e:	2001      	movs	r0, #1
}
 8007070:	4770      	bx	lr
 8007072:	bf00      	nop
 8007074:	40022000 	.word	0x40022000
 8007078:	40021000 	.word	0x40021000
 800707c:	04c4b400 	.word	0x04c4b400
 8007080:	0801a1c4 	.word	0x0801a1c4
 8007084:	200014a4 	.word	0x200014a4
 8007088:	200014ac 	.word	0x200014ac
 800708c:	016e3600 	.word	0x016e3600
 8007090:	00f42400 	.word	0x00f42400

08007094 <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 8007094:	4b01      	ldr	r3, [pc, #4]	; (800709c <HAL_RCC_GetHCLKFreq+0x8>)
}
 8007096:	6818      	ldr	r0, [r3, #0]
 8007098:	4770      	bx	lr
 800709a:	bf00      	nop
 800709c:	200014a4 	.word	0x200014a4

080070a0 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 80070a0:	4b05      	ldr	r3, [pc, #20]	; (80070b8 <HAL_RCC_GetPCLK1Freq+0x18>)
 80070a2:	4a06      	ldr	r2, [pc, #24]	; (80070bc <HAL_RCC_GetPCLK1Freq+0x1c>)
 80070a4:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 80070a6:	4906      	ldr	r1, [pc, #24]	; (80070c0 <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 80070a8:	f3c3 2302 	ubfx	r3, r3, #8, #3
 80070ac:	6808      	ldr	r0, [r1, #0]
 80070ae:	5cd3      	ldrb	r3, [r2, r3]
 80070b0:	f003 031f 	and.w	r3, r3, #31
}
 80070b4:	40d8      	lsrs	r0, r3
 80070b6:	4770      	bx	lr
 80070b8:	40021000 	.word	0x40021000
 80070bc:	0801a1d4 	.word	0x0801a1d4
 80070c0:	200014a4 	.word	0x200014a4

080070c4 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 80070c4:	4b05      	ldr	r3, [pc, #20]	; (80070dc <HAL_RCC_GetPCLK2Freq+0x18>)
 80070c6:	4a06      	ldr	r2, [pc, #24]	; (80070e0 <HAL_RCC_GetPCLK2Freq+0x1c>)
 80070c8:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 80070ca:	4906      	ldr	r1, [pc, #24]	; (80070e4 <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 80070cc:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 80070d0:	6808      	ldr	r0, [r1, #0]
 80070d2:	5cd3      	ldrb	r3, [r2, r3]
 80070d4:	f003 031f 	and.w	r3, r3, #31
}
 80070d8:	40d8      	lsrs	r0, r3
 80070da:	4770      	bx	lr
 80070dc:	40021000 	.word	0x40021000
 80070e0:	0801a1d4 	.word	0x0801a1d4
 80070e4:	200014a4 	.word	0x200014a4

080070e8 <HAL_RCC_EnableCSS>:
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 80070e8:	4a02      	ldr	r2, [pc, #8]	; (80070f4 <HAL_RCC_EnableCSS+0xc>)
 80070ea:	6813      	ldr	r3, [r2, #0]
 80070ec:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80070f0:	6013      	str	r3, [r2, #0]
}
 80070f2:	4770      	bx	lr
 80070f4:	40021000 	.word	0x40021000

080070f8 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80070f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80070fc:	6803      	ldr	r3, [r0, #0]
{
 80070fe:	4604      	mov	r4, r0
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8007100:	f413 2000 	ands.w	r0, r3, #524288	; 0x80000
{
 8007104:	b082      	sub	sp, #8
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8007106:	d056      	beq.n	80071b6 <HAL_RCCEx_PeriphCLKConfig+0xbe>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8007108:	4bac      	ldr	r3, [pc, #688]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800710a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800710c:	00d5      	lsls	r5, r2, #3
 800710e:	f140 813e 	bpl.w	800738e <HAL_RCCEx_PeriphCLKConfig+0x296>
    FlagStatus       pwrclkchanged = RESET;
 8007112:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8007114:	4daa      	ldr	r5, [pc, #680]	; (80073c0 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8007116:	682b      	ldr	r3, [r5, #0]
 8007118:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800711c:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800711e:	f7fe f995 	bl	800544c <HAL_GetTick>
 8007122:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8007124:	e005      	b.n	8007132 <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8007126:	f7fe f991 	bl	800544c <HAL_GetTick>
 800712a:	1b83      	subs	r3, r0, r6
 800712c:	2b02      	cmp	r3, #2
 800712e:	f200 8139 	bhi.w	80073a4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8007132:	682b      	ldr	r3, [r5, #0]
 8007134:	05d8      	lsls	r0, r3, #23
 8007136:	d5f6      	bpl.n	8007126 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    }

    if(ret == HAL_OK)
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8007138:	4da0      	ldr	r5, [pc, #640]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800713a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 800713e:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8007142:	d027      	beq.n	8007194 <HAL_RCCEx_PeriphCLKConfig+0x9c>
 8007144:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8007146:	429a      	cmp	r2, r3
 8007148:	d025      	beq.n	8007196 <HAL_RCCEx_PeriphCLKConfig+0x9e>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800714a:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 800714e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8007152:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8007156:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 800715a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800715e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007162:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8007166:	f421 7340 	bic.w	r3, r1, #768	; 0x300
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 800716a:	07c9      	lsls	r1, r1, #31
        RCC->BDCR = tmpregister;
 800716c:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8007170:	f140 8148 	bpl.w	8007404 <HAL_RCCEx_PeriphCLKConfig+0x30c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007174:	f7fe f96a 	bl	800544c <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007178:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 800717c:	4606      	mov	r6, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800717e:	e005      	b.n	800718c <HAL_RCCEx_PeriphCLKConfig+0x94>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007180:	f7fe f964 	bl	800544c <HAL_GetTick>
 8007184:	1b80      	subs	r0, r0, r6
 8007186:	4540      	cmp	r0, r8
 8007188:	f200 810c 	bhi.w	80073a4 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800718c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8007190:	079b      	lsls	r3, r3, #30
 8007192:	d5f5      	bpl.n	8007180 <HAL_RCCEx_PeriphCLKConfig+0x88>
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8007194:	6d23      	ldr	r3, [r4, #80]	; 0x50
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8007196:	4989      	ldr	r1, [pc, #548]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007198:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800719c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80071a0:	4313      	orrs	r3, r2
 80071a2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 80071a6:	2000      	movs	r0, #0
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80071a8:	b127      	cbz	r7, 80071b4 <HAL_RCCEx_PeriphCLKConfig+0xbc>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80071aa:	4a84      	ldr	r2, [pc, #528]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071ac:	6d93      	ldr	r3, [r2, #88]	; 0x58
 80071ae:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80071b2:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80071b4:	6823      	ldr	r3, [r4, #0]
 80071b6:	07dd      	lsls	r5, r3, #31
 80071b8:	d508      	bpl.n	80071cc <HAL_RCCEx_PeriphCLKConfig+0xd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80071ba:	4980      	ldr	r1, [pc, #512]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071bc:	6865      	ldr	r5, [r4, #4]
 80071be:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071c2:	f022 0203 	bic.w	r2, r2, #3
 80071c6:	432a      	orrs	r2, r5
 80071c8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80071cc:	0799      	lsls	r1, r3, #30
 80071ce:	d508      	bpl.n	80071e2 <HAL_RCCEx_PeriphCLKConfig+0xea>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80071d0:	497a      	ldr	r1, [pc, #488]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071d2:	68a5      	ldr	r5, [r4, #8]
 80071d4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071d8:	f022 020c 	bic.w	r2, r2, #12
 80071dc:	432a      	orrs	r2, r5
 80071de:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80071e2:	075a      	lsls	r2, r3, #29
 80071e4:	d508      	bpl.n	80071f8 <HAL_RCCEx_PeriphCLKConfig+0x100>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80071e6:	4975      	ldr	r1, [pc, #468]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071e8:	68e5      	ldr	r5, [r4, #12]
 80071ea:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071ee:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 80071f2:	432a      	orrs	r2, r5
 80071f4:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80071f8:	071f      	lsls	r7, r3, #28
 80071fa:	d508      	bpl.n	800720e <HAL_RCCEx_PeriphCLKConfig+0x116>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80071fc:	496f      	ldr	r1, [pc, #444]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071fe:	6925      	ldr	r5, [r4, #16]
 8007200:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007204:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8007208:	432a      	orrs	r2, r5
 800720a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800720e:	06de      	lsls	r6, r3, #27
 8007210:	d508      	bpl.n	8007224 <HAL_RCCEx_PeriphCLKConfig+0x12c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8007212:	496a      	ldr	r1, [pc, #424]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007214:	6965      	ldr	r5, [r4, #20]
 8007216:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800721a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800721e:	432a      	orrs	r2, r5
 8007220:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8007224:	069d      	lsls	r5, r3, #26
 8007226:	d508      	bpl.n	800723a <HAL_RCCEx_PeriphCLKConfig+0x142>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8007228:	4964      	ldr	r1, [pc, #400]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800722a:	69a5      	ldr	r5, [r4, #24]
 800722c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007230:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8007234:	432a      	orrs	r2, r5
 8007236:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800723a:	0659      	lsls	r1, r3, #25
 800723c:	d508      	bpl.n	8007250 <HAL_RCCEx_PeriphCLKConfig+0x158>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800723e:	495f      	ldr	r1, [pc, #380]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007240:	69e5      	ldr	r5, [r4, #28]
 8007242:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007246:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800724a:	432a      	orrs	r2, r5
 800724c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8007250:	061a      	lsls	r2, r3, #24
 8007252:	d508      	bpl.n	8007266 <HAL_RCCEx_PeriphCLKConfig+0x16e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8007254:	4959      	ldr	r1, [pc, #356]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007256:	6a25      	ldr	r5, [r4, #32]
 8007258:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800725c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8007260:	432a      	orrs	r2, r5
 8007262:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8007266:	05df      	lsls	r7, r3, #23
 8007268:	d508      	bpl.n	800727c <HAL_RCCEx_PeriphCLKConfig+0x184>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800726a:	4954      	ldr	r1, [pc, #336]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800726c:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800726e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007272:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8007276:	432a      	orrs	r2, r5
 8007278:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#if defined(I2C4)  

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800727c:	039e      	lsls	r6, r3, #14
 800727e:	d508      	bpl.n	8007292 <HAL_RCCEx_PeriphCLKConfig+0x19a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8007280:	494e      	ldr	r1, [pc, #312]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007282:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8007284:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007288:	f022 0203 	bic.w	r2, r2, #3
 800728c:	432a      	orrs	r2, r5
 800728e:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8007292:	059d      	lsls	r5, r3, #22
 8007294:	d508      	bpl.n	80072a8 <HAL_RCCEx_PeriphCLKConfig+0x1b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8007296:	4949      	ldr	r1, [pc, #292]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007298:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 800729a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800729e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 80072a2:	432a      	orrs	r2, r5
 80072a4:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 80072a8:	0559      	lsls	r1, r3, #21
 80072aa:	d50b      	bpl.n	80072c4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80072ac:	4943      	ldr	r1, [pc, #268]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072ae:	6b25      	ldr	r5, [r4, #48]	; 0x30
 80072b0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072b4:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80072b8:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 80072ba:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80072be:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 80072c2:	d071      	beq.n	80073a8 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 80072c4:	051a      	lsls	r2, r3, #20
 80072c6:	d50b      	bpl.n	80072e0 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80072c8:	493c      	ldr	r1, [pc, #240]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072ca:	6b65      	ldr	r5, [r4, #52]	; 0x34
 80072cc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072d0:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 80072d4:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 80072d6:	f5b5 0f80 	cmp.w	r5, #4194304	; 0x400000
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80072da:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 80072de:	d068      	beq.n	80073b2 <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    }
  }

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 80072e0:	04df      	lsls	r7, r3, #19
 80072e2:	d50b      	bpl.n	80072fc <HAL_RCCEx_PeriphCLKConfig+0x204>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 80072e4:	4935      	ldr	r1, [pc, #212]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072e6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80072e8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072ec:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80072f0:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 80072f2:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 80072f6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 80072fa:	d063      	beq.n	80073c4 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 80072fc:	049e      	lsls	r6, r3, #18
 80072fe:	d50b      	bpl.n	8007318 <HAL_RCCEx_PeriphCLKConfig+0x220>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8007300:	492e      	ldr	r1, [pc, #184]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007302:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8007304:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007308:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 800730c:	432a      	orrs	r2, r5

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800730e:	f1b5 6f00 	cmp.w	r5, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8007312:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8007316:	d05a      	beq.n	80073ce <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8007318:	045d      	lsls	r5, r3, #17
 800731a:	d50b      	bpl.n	8007334 <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800731c:	4927      	ldr	r1, [pc, #156]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800731e:	6c25      	ldr	r5, [r4, #64]	; 0x40
 8007320:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007324:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8007328:	432a      	orrs	r2, r5

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800732a:	f1b5 6f00 	cmp.w	r5, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800732e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8007332:	d051      	beq.n	80073d8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8007334:	0419      	lsls	r1, r3, #16
 8007336:	d50b      	bpl.n	8007350 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8007338:	4920      	ldr	r1, [pc, #128]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800733a:	6c65      	ldr	r5, [r4, #68]	; 0x44
 800733c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007340:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8007344:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 8007346:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 800734a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 800734e:	d048      	beq.n	80073e2 <HAL_RCCEx_PeriphCLKConfig+0x2ea>
    }
  }
  
#if defined(ADC345_COMMON)
  /*-------------------------- ADC345 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345)
 8007350:	03da      	lsls	r2, r3, #15
 8007352:	d50b      	bpl.n	800736c <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC345CLKSOURCE(PeriphClkInit->Adc345ClockSelection));

    /* Configure the ADC345 interface clock source */
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 8007354:	4919      	ldr	r1, [pc, #100]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007356:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8007358:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800735c:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 8007360:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 8007362:	f1b5 4f80 	cmp.w	r5, #1073741824	; 0x40000000
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 8007366:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 800736a:	d03f      	beq.n	80073ec <HAL_RCCEx_PeriphCLKConfig+0x2f4>
#endif /* ADC345_COMMON */

#if defined(QUADSPI)

  /*-------------------------- QuadSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800736c:	035b      	lsls	r3, r3, #13
 800736e:	d50b      	bpl.n	8007388 <HAL_RCCEx_PeriphCLKConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    /* Configure the QuadSPI clock source */
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8007370:	4a12      	ldr	r2, [pc, #72]	; (80073bc <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007372:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8007374:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8007378:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800737c:	430b      	orrs	r3, r1

    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 800737e:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8007382:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 8007386:	d036      	beq.n	80073f6 <HAL_RCCEx_PeriphCLKConfig+0x2fe>
  }

#endif /* QUADSPI */

  return status;
}
 8007388:	b002      	add	sp, #8
 800738a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 800738e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007390:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007394:	659a      	str	r2, [r3, #88]	; 0x58
 8007396:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007398:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800739c:	9301      	str	r3, [sp, #4]
 800739e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80073a0:	2701      	movs	r7, #1
 80073a2:	e6b7      	b.n	8007114 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      status = ret;
 80073a4:	2003      	movs	r0, #3
 80073a6:	e6ff      	b.n	80071a8 <HAL_RCCEx_PeriphCLKConfig+0xb0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073a8:	68ca      	ldr	r2, [r1, #12]
 80073aa:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80073ae:	60ca      	str	r2, [r1, #12]
 80073b0:	e788      	b.n	80072c4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073b2:	68ca      	ldr	r2, [r1, #12]
 80073b4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80073b8:	60ca      	str	r2, [r1, #12]
 80073ba:	e791      	b.n	80072e0 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 80073bc:	40021000 	.word	0x40021000
 80073c0:	40007000 	.word	0x40007000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073c4:	68ca      	ldr	r2, [r1, #12]
 80073c6:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80073ca:	60ca      	str	r2, [r1, #12]
 80073cc:	e796      	b.n	80072fc <HAL_RCCEx_PeriphCLKConfig+0x204>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073ce:	68ca      	ldr	r2, [r1, #12]
 80073d0:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80073d4:	60ca      	str	r2, [r1, #12]
 80073d6:	e79f      	b.n	8007318 <HAL_RCCEx_PeriphCLKConfig+0x220>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073d8:	68ca      	ldr	r2, [r1, #12]
 80073da:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80073de:	60ca      	str	r2, [r1, #12]
 80073e0:	e7a8      	b.n	8007334 <HAL_RCCEx_PeriphCLKConfig+0x23c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80073e2:	68ca      	ldr	r2, [r1, #12]
 80073e4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80073e8:	60ca      	str	r2, [r1, #12]
 80073ea:	e7b1      	b.n	8007350 <HAL_RCCEx_PeriphCLKConfig+0x258>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80073ec:	68ca      	ldr	r2, [r1, #12]
 80073ee:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80073f2:	60ca      	str	r2, [r1, #12]
 80073f4:	e7ba      	b.n	800736c <HAL_RCCEx_PeriphCLKConfig+0x274>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073f6:	68d3      	ldr	r3, [r2, #12]
 80073f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80073fc:	60d3      	str	r3, [r2, #12]
}
 80073fe:	b002      	add	sp, #8
 8007400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007404:	4613      	mov	r3, r2
 8007406:	e6c6      	b.n	8007196 <HAL_RCCEx_PeriphCLKConfig+0x9e>

08007408 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007408:	6a03      	ldr	r3, [r0, #32]
 800740a:	f023 0301 	bic.w	r3, r3, #1
 800740e:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007410:	6a03      	ldr	r3, [r0, #32]
{
 8007412:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007414:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8007416:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8007418:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800741a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800741e:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 8007422:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8007424:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 8007426:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 800742a:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800742c:	4d15      	ldr	r5, [pc, #84]	; (8007484 <TIM_OC1_SetConfig+0x7c>)
 800742e:	42a8      	cmp	r0, r5
 8007430:	d013      	beq.n	800745a <TIM_OC1_SetConfig+0x52>
 8007432:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007436:	42a8      	cmp	r0, r5
 8007438:	d00f      	beq.n	800745a <TIM_OC1_SetConfig+0x52>
 800743a:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 800743e:	42a8      	cmp	r0, r5
 8007440:	d00b      	beq.n	800745a <TIM_OC1_SetConfig+0x52>
 8007442:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007446:	42a8      	cmp	r0, r5
 8007448:	d007      	beq.n	800745a <TIM_OC1_SetConfig+0x52>
 800744a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800744e:	42a8      	cmp	r0, r5
 8007450:	d003      	beq.n	800745a <TIM_OC1_SetConfig+0x52>
 8007452:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007456:	42a8      	cmp	r0, r5
 8007458:	d10d      	bne.n	8007476 <TIM_OC1_SetConfig+0x6e>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800745a:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 800745c:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8007460:	432b      	orrs	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8007462:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8007466:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 800746a:	ea46 0c05 	orr.w	ip, r6, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 800746e:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8007472:	ea4c 0404 	orr.w	r4, ip, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8007476:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8007478:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 800747a:	6182      	str	r2, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800747c:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR1 = OC_Config->Pulse;
 800747e:	6341      	str	r1, [r0, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8007480:	6203      	str	r3, [r0, #32]
}
 8007482:	4770      	bx	lr
 8007484:	40012c00 	.word	0x40012c00

08007488 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8007488:	6a03      	ldr	r3, [r0, #32]
 800748a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800748e:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007490:	6a03      	ldr	r3, [r0, #32]
{
 8007492:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007494:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8007496:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8007498:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800749a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800749e:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80074a2:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80074a4:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 80074a6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 80074aa:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 80074ae:	4d1c      	ldr	r5, [pc, #112]	; (8007520 <TIM_OC3_SetConfig+0x98>)
 80074b0:	42a8      	cmp	r0, r5
 80074b2:	d017      	beq.n	80074e4 <TIM_OC3_SetConfig+0x5c>
 80074b4:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80074b8:	42a8      	cmp	r0, r5
 80074ba:	d013      	beq.n	80074e4 <TIM_OC3_SetConfig+0x5c>
 80074bc:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 80074c0:	42a8      	cmp	r0, r5
 80074c2:	d025      	beq.n	8007510 <TIM_OC3_SetConfig+0x88>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80074c4:	4d17      	ldr	r5, [pc, #92]	; (8007524 <TIM_OC3_SetConfig+0x9c>)
 80074c6:	42a8      	cmp	r0, r5
 80074c8:	d013      	beq.n	80074f2 <TIM_OC3_SetConfig+0x6a>
 80074ca:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80074ce:	42a8      	cmp	r0, r5
 80074d0:	d00f      	beq.n	80074f2 <TIM_OC3_SetConfig+0x6a>
 80074d2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80074d6:	42a8      	cmp	r0, r5
 80074d8:	d00b      	beq.n	80074f2 <TIM_OC3_SetConfig+0x6a>
 80074da:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80074de:	42a8      	cmp	r0, r5
 80074e0:	d10f      	bne.n	8007502 <TIM_OC3_SetConfig+0x7a>
 80074e2:	e006      	b.n	80074f2 <TIM_OC3_SetConfig+0x6a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80074e4:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 80074e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80074ea:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80074ee:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80074f2:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80074f6:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80074fa:	ea46 0c05 	orr.w	ip, r6, r5
 80074fe:	ea44 140c 	orr.w	r4, r4, ip, lsl #4

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8007502:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8007504:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 8007506:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8007508:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR3 = OC_Config->Pulse;
 800750a:	63c1      	str	r1, [r0, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 800750c:	6203      	str	r3, [r0, #32]
}
 800750e:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8007510:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 8007512:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8007516:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 800751a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800751e:	e7d1      	b.n	80074c4 <TIM_OC3_SetConfig+0x3c>
 8007520:	40012c00 	.word	0x40012c00
 8007524:	40014000 	.word	0x40014000

08007528 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8007528:	6a03      	ldr	r3, [r0, #32]
 800752a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800752e:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007530:	6a03      	ldr	r3, [r0, #32]
{
 8007532:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007534:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8007536:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007538:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800753a:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800753e:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007542:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8007546:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 8007548:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800754c:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 8007550:	4d1c      	ldr	r5, [pc, #112]	; (80075c4 <TIM_OC4_SetConfig+0x9c>)
 8007552:	42a8      	cmp	r0, r5
 8007554:	d017      	beq.n	8007586 <TIM_OC4_SetConfig+0x5e>
 8007556:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800755a:	42a8      	cmp	r0, r5
 800755c:	d013      	beq.n	8007586 <TIM_OC4_SetConfig+0x5e>
 800755e:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 8007562:	42a8      	cmp	r0, r5
 8007564:	d025      	beq.n	80075b2 <TIM_OC4_SetConfig+0x8a>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007566:	4d18      	ldr	r5, [pc, #96]	; (80075c8 <TIM_OC4_SetConfig+0xa0>)
 8007568:	42a8      	cmp	r0, r5
 800756a:	d013      	beq.n	8007594 <TIM_OC4_SetConfig+0x6c>
 800756c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007570:	42a8      	cmp	r0, r5
 8007572:	d00f      	beq.n	8007594 <TIM_OC4_SetConfig+0x6c>
 8007574:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007578:	42a8      	cmp	r0, r5
 800757a:	d00b      	beq.n	8007594 <TIM_OC4_SetConfig+0x6c>
 800757c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007580:	42a8      	cmp	r0, r5
 8007582:	d10f      	bne.n	80075a4 <TIM_OC4_SetConfig+0x7c>
 8007584:	e006      	b.n	8007594 <TIM_OC4_SetConfig+0x6c>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 8007586:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 8007588:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 800758c:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 8007590:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    tmpcr2 &= ~TIM_CR2_OIS4N;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 8007594:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4N;
 8007598:	f424 4440 	bic.w	r4, r4, #49152	; 0xc000
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 800759c:	ea46 0c05 	orr.w	ip, r6, r5
 80075a0:	ea44 148c 	orr.w	r4, r4, ip, lsl #6

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80075a4:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80075a6:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 80075a8:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80075aa:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR4 = OC_Config->Pulse;
 80075ac:	6401      	str	r1, [r0, #64]	; 0x40
  TIMx->CCER = tmpccer;
 80075ae:	6203      	str	r3, [r0, #32]
}
 80075b0:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 80075b2:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 80075b4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 80075b8:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 80075bc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80075c0:	e7d1      	b.n	8007566 <TIM_OC4_SetConfig+0x3e>
 80075c2:	bf00      	nop
 80075c4:	40012c00 	.word	0x40012c00
 80075c8:	40014000 	.word	0x40014000

080075cc <HAL_TIM_Base_Init>:
  if (htim == NULL)
 80075cc:	2800      	cmp	r0, #0
 80075ce:	f000 808c 	beq.w	80076ea <HAL_TIM_Base_Init+0x11e>
{
 80075d2:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80075d4:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80075d8:	4604      	mov	r4, r0
 80075da:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80075de:	2b00      	cmp	r3, #0
 80075e0:	d078      	beq.n	80076d4 <HAL_TIM_Base_Init+0x108>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80075e2:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80075e4:	4944      	ldr	r1, [pc, #272]	; (80076f8 <HAL_TIM_Base_Init+0x12c>)
  htim->State = HAL_TIM_STATE_BUSY;
 80075e6:	2302      	movs	r3, #2
 80075e8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80075ec:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 80075ee:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80075f0:	d05c      	beq.n	80076ac <HAL_TIM_Base_Init+0xe0>
 80075f2:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80075f6:	d02c      	beq.n	8007652 <HAL_TIM_Base_Init+0x86>
 80075f8:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 80075fc:	428a      	cmp	r2, r1
 80075fe:	d028      	beq.n	8007652 <HAL_TIM_Base_Init+0x86>
 8007600:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007604:	428a      	cmp	r2, r1
 8007606:	d024      	beq.n	8007652 <HAL_TIM_Base_Init+0x86>
 8007608:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800760c:	428a      	cmp	r2, r1
 800760e:	d020      	beq.n	8007652 <HAL_TIM_Base_Init+0x86>
 8007610:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 8007614:	428a      	cmp	r2, r1
 8007616:	d049      	beq.n	80076ac <HAL_TIM_Base_Init+0xe0>
 8007618:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 800761c:	428a      	cmp	r2, r1
 800761e:	d066      	beq.n	80076ee <HAL_TIM_Base_Init+0x122>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007620:	4936      	ldr	r1, [pc, #216]	; (80076fc <HAL_TIM_Base_Init+0x130>)
 8007622:	428a      	cmp	r2, r1
 8007624:	d05b      	beq.n	80076de <HAL_TIM_Base_Init+0x112>
 8007626:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800762a:	428a      	cmp	r2, r1
 800762c:	d057      	beq.n	80076de <HAL_TIM_Base_Init+0x112>
 800762e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007632:	428a      	cmp	r2, r1
 8007634:	d053      	beq.n	80076de <HAL_TIM_Base_Init+0x112>
 8007636:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800763a:	428a      	cmp	r2, r1
 800763c:	d04f      	beq.n	80076de <HAL_TIM_Base_Init+0x112>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800763e:	69a0      	ldr	r0, [r4, #24]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007640:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007642:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007646:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 8007648:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 800764a:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800764c:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800764e:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8007650:	e010      	b.n	8007674 <HAL_TIM_Base_Init+0xa8>
    tmpcr1 |= Structure->CounterMode;
 8007652:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007654:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007656:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800765a:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 800765c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007660:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007662:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007664:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007668:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800766a:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 800766c:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 800766e:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007670:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007672:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 8007674:	2301      	movs	r3, #1
 8007676:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8007678:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800767c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8007680:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007684:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8007688:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800768c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8007690:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8007694:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8007698:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800769c:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 80076a0:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 80076a4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80076a8:	2000      	movs	r0, #0
}
 80076aa:	bd10      	pop	{r4, pc}
    tmpcr1 |= Structure->CounterMode;
 80076ac:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80076ae:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80076b0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80076b4:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 80076b6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80076ba:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80076bc:	69a1      	ldr	r1, [r4, #24]
 80076be:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80076c2:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 80076c4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80076c6:	68e3      	ldr	r3, [r4, #12]
 80076c8:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80076ca:	6863      	ldr	r3, [r4, #4]
 80076cc:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80076ce:	6963      	ldr	r3, [r4, #20]
 80076d0:	6313      	str	r3, [r2, #48]	; 0x30
 80076d2:	e7cf      	b.n	8007674 <HAL_TIM_Base_Init+0xa8>
    htim->Lock = HAL_UNLOCKED;
 80076d4:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80076d8:	f7fd fb8c 	bl	8004df4 <HAL_TIM_Base_MspInit>
 80076dc:	e781      	b.n	80075e2 <HAL_TIM_Base_Init+0x16>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80076de:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80076e0:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 80076e2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80076e6:	4303      	orrs	r3, r0
 80076e8:	e7e9      	b.n	80076be <HAL_TIM_Base_Init+0xf2>
    return HAL_ERROR;
 80076ea:	2001      	movs	r0, #1
}
 80076ec:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 80076ee:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80076f0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80076f4:	430b      	orrs	r3, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80076f6:	e793      	b.n	8007620 <HAL_TIM_Base_Init+0x54>
 80076f8:	40012c00 	.word	0x40012c00
 80076fc:	40014000 	.word	0x40014000

08007700 <HAL_TIM_Base_Start>:
  if (htim->State != HAL_TIM_STATE_READY)
 8007700:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8007704:	2b01      	cmp	r3, #1
 8007706:	d12f      	bne.n	8007768 <HAL_TIM_Base_Start+0x68>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007708:	6803      	ldr	r3, [r0, #0]
 800770a:	4a19      	ldr	r2, [pc, #100]	; (8007770 <HAL_TIM_Base_Start+0x70>)
  htim->State = HAL_TIM_STATE_BUSY;
 800770c:	2102      	movs	r1, #2
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800770e:	4293      	cmp	r3, r2
  htim->State = HAL_TIM_STATE_BUSY;
 8007710:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007714:	d01a      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 8007716:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800771a:	d017      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 800771c:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8007720:	4293      	cmp	r3, r2
 8007722:	d013      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 8007724:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8007728:	4293      	cmp	r3, r2
 800772a:	d00f      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 800772c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8007730:	4293      	cmp	r3, r2
 8007732:	d00b      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 8007734:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 8007738:	4293      	cmp	r3, r2
 800773a:	d007      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 800773c:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 8007740:	4293      	cmp	r3, r2
 8007742:	d003      	beq.n	800774c <HAL_TIM_Base_Start+0x4c>
 8007744:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8007748:	4293      	cmp	r3, r2
 800774a:	d107      	bne.n	800775c <HAL_TIM_Base_Start+0x5c>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800774c:	6899      	ldr	r1, [r3, #8]
 800774e:	4a09      	ldr	r2, [pc, #36]	; (8007774 <HAL_TIM_Base_Start+0x74>)
 8007750:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007752:	2a06      	cmp	r2, #6
 8007754:	d00a      	beq.n	800776c <HAL_TIM_Base_Start+0x6c>
 8007756:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800775a:	d007      	beq.n	800776c <HAL_TIM_Base_Start+0x6c>
    __HAL_TIM_ENABLE(htim);
 800775c:	681a      	ldr	r2, [r3, #0]
 800775e:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 8007762:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 8007764:	601a      	str	r2, [r3, #0]
 8007766:	4770      	bx	lr
    return HAL_ERROR;
 8007768:	2001      	movs	r0, #1
 800776a:	4770      	bx	lr
  return HAL_OK;
 800776c:	2000      	movs	r0, #0
}
 800776e:	4770      	bx	lr
 8007770:	40012c00 	.word	0x40012c00
 8007774:	00010007 	.word	0x00010007

08007778 <HAL_TIM_Base_Stop>:
  __HAL_TIM_DISABLE(htim);
 8007778:	6803      	ldr	r3, [r0, #0]
 800777a:	6a19      	ldr	r1, [r3, #32]
 800777c:	f241 1211 	movw	r2, #4369	; 0x1111
 8007780:	4211      	tst	r1, r2
 8007782:	d108      	bne.n	8007796 <HAL_TIM_Base_Stop+0x1e>
 8007784:	6a19      	ldr	r1, [r3, #32]
 8007786:	f244 4244 	movw	r2, #17476	; 0x4444
 800778a:	4211      	tst	r1, r2
 800778c:	d103      	bne.n	8007796 <HAL_TIM_Base_Stop+0x1e>
 800778e:	681a      	ldr	r2, [r3, #0]
 8007790:	f022 0201 	bic.w	r2, r2, #1
 8007794:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8007796:	2301      	movs	r3, #1
 8007798:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 800779c:	2000      	movs	r0, #0
 800779e:	4770      	bx	lr

080077a0 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 80077a0:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80077a4:	2b01      	cmp	r3, #1
 80077a6:	d132      	bne.n	800780e <HAL_TIM_Base_Start_IT+0x6e>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80077a8:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80077aa:	491b      	ldr	r1, [pc, #108]	; (8007818 <HAL_TIM_Base_Start_IT+0x78>)
  htim->State = HAL_TIM_STATE_BUSY;
 80077ac:	2202      	movs	r2, #2
 80077ae:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80077b2:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80077b4:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80077b6:	f042 0201 	orr.w	r2, r2, #1
 80077ba:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80077bc:	d019      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80077c2:	d016      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077c4:	4a15      	ldr	r2, [pc, #84]	; (800781c <HAL_TIM_Base_Start_IT+0x7c>)
 80077c6:	4293      	cmp	r3, r2
 80077c8:	d013      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077ca:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80077ce:	4293      	cmp	r3, r2
 80077d0:	d00f      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077d2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80077d6:	4293      	cmp	r3, r2
 80077d8:	d00b      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077da:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 80077de:	4293      	cmp	r3, r2
 80077e0:	d007      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077e2:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 80077e6:	4293      	cmp	r3, r2
 80077e8:	d003      	beq.n	80077f2 <HAL_TIM_Base_Start_IT+0x52>
 80077ea:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80077ee:	4293      	cmp	r3, r2
 80077f0:	d107      	bne.n	8007802 <HAL_TIM_Base_Start_IT+0x62>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80077f2:	6899      	ldr	r1, [r3, #8]
 80077f4:	4a0a      	ldr	r2, [pc, #40]	; (8007820 <HAL_TIM_Base_Start_IT+0x80>)
 80077f6:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80077f8:	2a06      	cmp	r2, #6
 80077fa:	d00a      	beq.n	8007812 <HAL_TIM_Base_Start_IT+0x72>
 80077fc:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007800:	d007      	beq.n	8007812 <HAL_TIM_Base_Start_IT+0x72>
    __HAL_TIM_ENABLE(htim);
 8007802:	681a      	ldr	r2, [r3, #0]
 8007804:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 8007808:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 800780a:	601a      	str	r2, [r3, #0]
 800780c:	4770      	bx	lr
    return HAL_ERROR;
 800780e:	2001      	movs	r0, #1
 8007810:	4770      	bx	lr
  return HAL_OK;
 8007812:	2000      	movs	r0, #0
}
 8007814:	4770      	bx	lr
 8007816:	bf00      	nop
 8007818:	40012c00 	.word	0x40012c00
 800781c:	40000400 	.word	0x40000400
 8007820:	00010007 	.word	0x00010007

08007824 <HAL_TIM_PWM_MspInit>:
 8007824:	4770      	bx	lr
 8007826:	bf00      	nop

08007828 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8007828:	2800      	cmp	r0, #0
 800782a:	f000 808c 	beq.w	8007946 <HAL_TIM_PWM_Init+0x11e>
{
 800782e:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8007830:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8007834:	4604      	mov	r4, r0
 8007836:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800783a:	2b00      	cmp	r3, #0
 800783c:	d078      	beq.n	8007930 <HAL_TIM_PWM_Init+0x108>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800783e:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007840:	4944      	ldr	r1, [pc, #272]	; (8007954 <HAL_TIM_PWM_Init+0x12c>)
  htim->State = HAL_TIM_STATE_BUSY;
 8007842:	2302      	movs	r3, #2
 8007844:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007848:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 800784a:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800784c:	d05c      	beq.n	8007908 <HAL_TIM_PWM_Init+0xe0>
 800784e:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8007852:	d02c      	beq.n	80078ae <HAL_TIM_PWM_Init+0x86>
 8007854:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 8007858:	428a      	cmp	r2, r1
 800785a:	d028      	beq.n	80078ae <HAL_TIM_PWM_Init+0x86>
 800785c:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007860:	428a      	cmp	r2, r1
 8007862:	d024      	beq.n	80078ae <HAL_TIM_PWM_Init+0x86>
 8007864:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007868:	428a      	cmp	r2, r1
 800786a:	d020      	beq.n	80078ae <HAL_TIM_PWM_Init+0x86>
 800786c:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 8007870:	428a      	cmp	r2, r1
 8007872:	d049      	beq.n	8007908 <HAL_TIM_PWM_Init+0xe0>
 8007874:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 8007878:	428a      	cmp	r2, r1
 800787a:	d066      	beq.n	800794a <HAL_TIM_PWM_Init+0x122>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800787c:	4936      	ldr	r1, [pc, #216]	; (8007958 <HAL_TIM_PWM_Init+0x130>)
 800787e:	428a      	cmp	r2, r1
 8007880:	d05b      	beq.n	800793a <HAL_TIM_PWM_Init+0x112>
 8007882:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007886:	428a      	cmp	r2, r1
 8007888:	d057      	beq.n	800793a <HAL_TIM_PWM_Init+0x112>
 800788a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800788e:	428a      	cmp	r2, r1
 8007890:	d053      	beq.n	800793a <HAL_TIM_PWM_Init+0x112>
 8007892:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8007896:	428a      	cmp	r2, r1
 8007898:	d04f      	beq.n	800793a <HAL_TIM_PWM_Init+0x112>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800789a:	69a0      	ldr	r0, [r4, #24]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800789c:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800789e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80078a2:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 80078a4:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 80078a6:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80078a8:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80078aa:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80078ac:	e010      	b.n	80078d0 <HAL_TIM_PWM_Init+0xa8>
    tmpcr1 |= Structure->CounterMode;
 80078ae:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078b0:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80078b2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80078b6:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 80078b8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80078bc:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078be:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80078c0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 80078c4:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80078c6:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 80078c8:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 80078ca:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80078cc:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80078ce:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 80078d0:	2301      	movs	r3, #1
 80078d2:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80078d4:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80078d8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 80078dc:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80078e0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80078e4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80078e8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80078ec:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80078f0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80078f4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80078f8:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 80078fc:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 8007900:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8007904:	2000      	movs	r0, #0
}
 8007906:	bd10      	pop	{r4, pc}
    tmpcr1 |= Structure->CounterMode;
 8007908:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800790a:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800790c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007910:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8007912:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007916:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007918:	69a1      	ldr	r1, [r4, #24]
 800791a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800791e:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 8007920:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007922:	68e3      	ldr	r3, [r4, #12]
 8007924:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007926:	6863      	ldr	r3, [r4, #4]
 8007928:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 800792a:	6963      	ldr	r3, [r4, #20]
 800792c:	6313      	str	r3, [r2, #48]	; 0x30
 800792e:	e7cf      	b.n	80078d0 <HAL_TIM_PWM_Init+0xa8>
    htim->Lock = HAL_UNLOCKED;
 8007930:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8007934:	f7ff ff76 	bl	8007824 <HAL_TIM_PWM_MspInit>
 8007938:	e781      	b.n	800783e <HAL_TIM_PWM_Init+0x16>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800793a:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800793c:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 800793e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007942:	4303      	orrs	r3, r0
 8007944:	e7e9      	b.n	800791a <HAL_TIM_PWM_Init+0xf2>
    return HAL_ERROR;
 8007946:	2001      	movs	r0, #1
}
 8007948:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 800794a:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800794c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007950:	430b      	orrs	r3, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007952:	e793      	b.n	800787c <HAL_TIM_PWM_Init+0x54>
 8007954:	40012c00 	.word	0x40012c00
 8007958:	40014000 	.word	0x40014000

0800795c <HAL_TIM_Encoder_Init>:
  if (htim == NULL)
 800795c:	2800      	cmp	r0, #0
 800795e:	f000 80a1 	beq.w	8007aa4 <HAL_TIM_Encoder_Init+0x148>
{
 8007962:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8007964:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8007968:	460d      	mov	r5, r1
 800796a:	4604      	mov	r4, r0
 800796c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8007970:	2b00      	cmp	r3, #0
 8007972:	f000 8092 	beq.w	8007a9a <HAL_TIM_Encoder_Init+0x13e>
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 8007976:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007978:	494e      	ldr	r1, [pc, #312]	; (8007ab4 <HAL_TIM_Encoder_Init+0x158>)
  htim->State = HAL_TIM_STATE_BUSY;
 800797a:	2202      	movs	r2, #2
 800797c:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 8007980:	689a      	ldr	r2, [r3, #8]
 8007982:	f422 32a0 	bic.w	r2, r2, #81920	; 0x14000
 8007986:	f022 0207 	bic.w	r2, r2, #7
 800798a:	609a      	str	r2, [r3, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800798c:	428b      	cmp	r3, r1
  tmpcr1 = TIMx->CR1;
 800798e:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007990:	d06f      	beq.n	8007a72 <HAL_TIM_Encoder_Init+0x116>
 8007992:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007996:	d023      	beq.n	80079e0 <HAL_TIM_Encoder_Init+0x84>
 8007998:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 800799c:	428b      	cmp	r3, r1
 800799e:	d01f      	beq.n	80079e0 <HAL_TIM_Encoder_Init+0x84>
 80079a0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80079a4:	428b      	cmp	r3, r1
 80079a6:	d01b      	beq.n	80079e0 <HAL_TIM_Encoder_Init+0x84>
 80079a8:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80079ac:	428b      	cmp	r3, r1
 80079ae:	d017      	beq.n	80079e0 <HAL_TIM_Encoder_Init+0x84>
 80079b0:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 80079b4:	428b      	cmp	r3, r1
 80079b6:	d05c      	beq.n	8007a72 <HAL_TIM_Encoder_Init+0x116>
 80079b8:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 80079bc:	428b      	cmp	r3, r1
 80079be:	d073      	beq.n	8007aa8 <HAL_TIM_Encoder_Init+0x14c>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80079c0:	493d      	ldr	r1, [pc, #244]	; (8007ab8 <HAL_TIM_Encoder_Init+0x15c>)
 80079c2:	428b      	cmp	r3, r1
 80079c4:	d059      	beq.n	8007a7a <HAL_TIM_Encoder_Init+0x11e>
 80079c6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80079ca:	428b      	cmp	r3, r1
 80079cc:	d055      	beq.n	8007a7a <HAL_TIM_Encoder_Init+0x11e>
 80079ce:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80079d2:	428b      	cmp	r3, r1
 80079d4:	d051      	beq.n	8007a7a <HAL_TIM_Encoder_Init+0x11e>
 80079d6:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80079da:	428b      	cmp	r3, r1
 80079dc:	d108      	bne.n	80079f0 <HAL_TIM_Encoder_Init+0x94>
 80079de:	e04c      	b.n	8007a7a <HAL_TIM_Encoder_Init+0x11e>
    tmpcr1 |= Structure->CounterMode;
 80079e0:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80079e2:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80079e6:	430a      	orrs	r2, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80079e8:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80079ea:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80079ee:	430a      	orrs	r2, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80079f0:	69a1      	ldr	r1, [r4, #24]
 80079f2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80079f6:	430a      	orrs	r2, r1
  TIMx->ARR = (uint32_t)Structure->Period ;
 80079f8:	68e1      	ldr	r1, [r4, #12]
  TIMx->CR1 = tmpcr1;
 80079fa:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80079fc:	62d9      	str	r1, [r3, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80079fe:	6862      	ldr	r2, [r4, #4]
 8007a00:	629a      	str	r2, [r3, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 8007a02:	2601      	movs	r6, #1
 8007a04:	615e      	str	r6, [r3, #20]
  tmpsmcr = htim->Instance->SMCR;
 8007a06:	6898      	ldr	r0, [r3, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 8007a08:	699a      	ldr	r2, [r3, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8007a0a:	69af      	ldr	r7, [r5, #24]
 8007a0c:	68a9      	ldr	r1, [r5, #8]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 8007a0e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8007a12:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8007a16:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 8007a1a:	4311      	orrs	r1, r2
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8007a1c:	692a      	ldr	r2, [r5, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 8007a1e:	69ef      	ldr	r7, [r5, #28]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8007a20:	0112      	lsls	r2, r2, #4
 8007a22:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 8007a26:	68ef      	ldr	r7, [r5, #12]
 8007a28:	433a      	orrs	r2, r7
  tmpccer = htim->Instance->CCER;
 8007a2a:	6a1f      	ldr	r7, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 8007a2c:	f027 0caa 	bic.w	ip, r7, #170	; 0xaa
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8007a30:	6a2f      	ldr	r7, [r5, #32]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 8007a32:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
 8007a36:	f021 01fc 	bic.w	r1, r1, #252	; 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8007a3a:	ea42 3207 	orr.w	r2, r2, r7, lsl #12
 8007a3e:	430a      	orrs	r2, r1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8007a40:	696f      	ldr	r7, [r5, #20]
 8007a42:	6869      	ldr	r1, [r5, #4]
  tmpsmcr |= sConfig->EncoderMode;
 8007a44:	682d      	ldr	r5, [r5, #0]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8007a46:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  tmpsmcr |= sConfig->EncoderMode;
 8007a4a:	4328      	orrs	r0, r5
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8007a4c:	ea41 010c 	orr.w	r1, r1, ip
  htim->Instance->SMCR = tmpsmcr;
 8007a50:	6098      	str	r0, [r3, #8]
  htim->Instance->CCMR1 = tmpccmr1;
 8007a52:	619a      	str	r2, [r3, #24]
  htim->Instance->CCER = tmpccer;
 8007a54:	6219      	str	r1, [r3, #32]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8007a56:	f884 6048 	strb.w	r6, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a5a:	f884 603e 	strb.w	r6, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a5e:	f884 603f 	strb.w	r6, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a62:	f884 6044 	strb.w	r6, [r4, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a66:	f884 6045 	strb.w	r6, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8007a6a:	f884 603d 	strb.w	r6, [r4, #61]	; 0x3d
  return HAL_OK;
 8007a6e:	2000      	movs	r0, #0
}
 8007a70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpcr1 |= Structure->CounterMode;
 8007a72:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007a74:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007a78:	430a      	orrs	r2, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007a7a:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8007a7c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007a80:	430a      	orrs	r2, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007a82:	69a1      	ldr	r1, [r4, #24]
 8007a84:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8007a88:	430a      	orrs	r2, r1
  TIMx->CR1 = tmpcr1;
 8007a8a:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007a8c:	68e2      	ldr	r2, [r4, #12]
 8007a8e:	62da      	str	r2, [r3, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007a90:	6862      	ldr	r2, [r4, #4]
 8007a92:	629a      	str	r2, [r3, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8007a94:	6962      	ldr	r2, [r4, #20]
 8007a96:	631a      	str	r2, [r3, #48]	; 0x30
 8007a98:	e7b3      	b.n	8007a02 <HAL_TIM_Encoder_Init+0xa6>
    htim->Lock = HAL_UNLOCKED;
 8007a9a:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Encoder_MspInit(htim);
 8007a9e:	f7fd f9ef 	bl	8004e80 <HAL_TIM_Encoder_MspInit>
 8007aa2:	e768      	b.n	8007976 <HAL_TIM_Encoder_Init+0x1a>
    return HAL_ERROR;
 8007aa4:	2001      	movs	r0, #1
}
 8007aa6:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8007aa8:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007aaa:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007aae:	430a      	orrs	r2, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007ab0:	e786      	b.n	80079c0 <HAL_TIM_Encoder_Init+0x64>
 8007ab2:	bf00      	nop
 8007ab4:	40012c00 	.word	0x40012c00
 8007ab8:	40014000 	.word	0x40014000

08007abc <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8007abc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8007ac0:	2b01      	cmp	r3, #1
 8007ac2:	f000 8094 	beq.w	8007bee <HAL_TIM_ConfigClockSource+0x132>
 8007ac6:	4602      	mov	r2, r0
{
 8007ac8:	b430      	push	{r4, r5}
  htim->State = HAL_TIM_STATE_BUSY;
 8007aca:	2302      	movs	r3, #2
  tmpsmcr = htim->Instance->SMCR;
 8007acc:	6804      	ldr	r4, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8007ace:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
  __HAL_LOCK(htim);
 8007ad2:	2001      	movs	r0, #1
 8007ad4:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 8007ad8:	68a5      	ldr	r5, [r4, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007ada:	4b64      	ldr	r3, [pc, #400]	; (8007c6c <HAL_TIM_ConfigClockSource+0x1b0>)
 8007adc:	402b      	ands	r3, r5
  htim->Instance->SMCR = tmpsmcr;
 8007ade:	60a3      	str	r3, [r4, #8]
  switch (sClockSourceConfig->ClockSource)
 8007ae0:	680b      	ldr	r3, [r1, #0]
 8007ae2:	2b70      	cmp	r3, #112	; 0x70
 8007ae4:	f000 80b1 	beq.w	8007c4a <HAL_TIM_ConfigClockSource+0x18e>
 8007ae8:	d828      	bhi.n	8007b3c <HAL_TIM_ConfigClockSource+0x80>
 8007aea:	2b50      	cmp	r3, #80	; 0x50
 8007aec:	f000 8081 	beq.w	8007bf2 <HAL_TIM_ConfigClockSource+0x136>
 8007af0:	d93f      	bls.n	8007b72 <HAL_TIM_ConfigClockSource+0xb6>
 8007af2:	2b60      	cmp	r3, #96	; 0x60
 8007af4:	d11a      	bne.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007af6:	6a23      	ldr	r3, [r4, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8007af8:	6848      	ldr	r0, [r1, #4]
 8007afa:	68cd      	ldr	r5, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007afc:	f023 0310 	bic.w	r3, r3, #16
 8007b00:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007b02:	69a1      	ldr	r1, [r4, #24]
  tmpccer = TIMx->CCER;
 8007b04:	6a23      	ldr	r3, [r4, #32]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8007b06:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8007b0a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8007b0e:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8007b12:	ea41 3105 	orr.w	r1, r1, r5, lsl #12

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007b16:	61a1      	str	r1, [r4, #24]
  TIMx->CCER = tmpccer;
 8007b18:	6223      	str	r3, [r4, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007b1a:	68a3      	ldr	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8007b1c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007b20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007b24:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  HAL_StatusTypeDef status = HAL_OK;
 8007b28:	2000      	movs	r0, #0
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007b2a:	60a3      	str	r3, [r4, #8]
  htim->State = HAL_TIM_STATE_READY;
 8007b2c:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8007b2e:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8007b30:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8007b34:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8007b38:	bc30      	pop	{r4, r5}
 8007b3a:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8007b3c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8007b40:	d072      	beq.n	8007c28 <HAL_TIM_ConfigClockSource+0x16c>
 8007b42:	d943      	bls.n	8007bcc <HAL_TIM_ConfigClockSource+0x110>
 8007b44:	494a      	ldr	r1, [pc, #296]	; (8007c70 <HAL_TIM_ConfigClockSource+0x1b4>)
 8007b46:	428b      	cmp	r3, r1
 8007b48:	d008      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007b4a:	d92f      	bls.n	8007bac <HAL_TIM_ConfigClockSource+0xf0>
 8007b4c:	4949      	ldr	r1, [pc, #292]	; (8007c74 <HAL_TIM_ConfigClockSource+0x1b8>)
 8007b4e:	428b      	cmp	r3, r1
 8007b50:	d004      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007b52:	f023 0c20 	bic.w	ip, r3, #32
 8007b56:	3910      	subs	r1, #16
 8007b58:	458c      	cmp	ip, r1
 8007b5a:	d1e7      	bne.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  tmpsmcr = TIMx->SMCR;
 8007b5c:	68a1      	ldr	r1, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007b5e:	f421 1140 	bic.w	r1, r1, #3145728	; 0x300000
 8007b62:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007b66:	4319      	orrs	r1, r3
 8007b68:	f041 0107 	orr.w	r1, r1, #7
  HAL_StatusTypeDef status = HAL_OK;
 8007b6c:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007b6e:	60a1      	str	r1, [r4, #8]
}
 8007b70:	e7dc      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007b72:	2b40      	cmp	r3, #64	; 0x40
 8007b74:	d12f      	bne.n	8007bd6 <HAL_TIM_ConfigClockSource+0x11a>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007b76:	684b      	ldr	r3, [r1, #4]
 8007b78:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
 8007b7a:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007b7c:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8007b80:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007b82:	6a23      	ldr	r3, [r4, #32]
 8007b84:	f023 0301 	bic.w	r3, r3, #1
 8007b88:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007b8a:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007b8c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007b90:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007b94:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8007b96:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8007b98:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007b9a:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007b9e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007ba2:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  HAL_StatusTypeDef status = HAL_OK;
 8007ba6:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007ba8:	60a3      	str	r3, [r4, #8]
}
 8007baa:	e7bf      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007bac:	3920      	subs	r1, #32
 8007bae:	428b      	cmp	r3, r1
 8007bb0:	d0d4      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007bb2:	d904      	bls.n	8007bbe <HAL_TIM_ConfigClockSource+0x102>
 8007bb4:	4930      	ldr	r1, [pc, #192]	; (8007c78 <HAL_TIM_ConfigClockSource+0x1bc>)
 8007bb6:	428b      	cmp	r3, r1
 8007bb8:	d0d0      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007bba:	2001      	movs	r0, #1
 8007bbc:	e7b6      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
 8007bbe:	f023 0110 	bic.w	r1, r3, #16
 8007bc2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8007bc6:	d0c9      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007bc8:	2001      	movs	r0, #1
 8007bca:	e7af      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  HAL_StatusTypeDef status = HAL_OK;
 8007bcc:	f5b3 5080 	subs.w	r0, r3, #4096	; 0x1000
 8007bd0:	bf18      	it	ne
 8007bd2:	2001      	movne	r0, #1
 8007bd4:	e7aa      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007bd6:	d8a9      	bhi.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
 8007bd8:	2b20      	cmp	r3, #32
 8007bda:	d0bf      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007bdc:	d903      	bls.n	8007be6 <HAL_TIM_ConfigClockSource+0x12a>
 8007bde:	2b30      	cmp	r3, #48	; 0x30
 8007be0:	d0bc      	beq.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
 8007be2:	2001      	movs	r0, #1
 8007be4:	e7a2      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
 8007be6:	f033 0110 	bics.w	r1, r3, #16
 8007bea:	d19f      	bne.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
 8007bec:	e7b6      	b.n	8007b5c <HAL_TIM_ConfigClockSource+0xa0>
  __HAL_LOCK(htim);
 8007bee:	2002      	movs	r0, #2
}
 8007bf0:	4770      	bx	lr
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007bf2:	684b      	ldr	r3, [r1, #4]
 8007bf4:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
 8007bf6:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007bf8:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8007bfc:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007bfe:	6a23      	ldr	r3, [r4, #32]
 8007c00:	f023 0301 	bic.w	r3, r3, #1
 8007c04:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007c06:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007c08:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007c0c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007c10:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8007c12:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8007c14:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007c16:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007c1a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007c1e:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  HAL_StatusTypeDef status = HAL_OK;
 8007c22:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007c24:	60a3      	str	r3, [r4, #8]
}
 8007c26:	e781      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c28:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8007c2c:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c2e:	432b      	orrs	r3, r5
 8007c30:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007c32:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c36:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8007c3a:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007c3c:	60a3      	str	r3, [r4, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8007c3e:	68a3      	ldr	r3, [r4, #8]
 8007c40:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  HAL_StatusTypeDef status = HAL_OK;
 8007c44:	2000      	movs	r0, #0
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8007c46:	60a3      	str	r3, [r4, #8]
      break;
 8007c48:	e770      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c4a:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8007c4e:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c50:	432b      	orrs	r3, r5
 8007c52:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007c54:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c58:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8007c5c:	430b      	orrs	r3, r1
  TIMx->SMCR = tmpsmcr;
 8007c5e:	60a3      	str	r3, [r4, #8]
      tmpsmcr = htim->Instance->SMCR;
 8007c60:	68a3      	ldr	r3, [r4, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8007c62:	f043 0377 	orr.w	r3, r3, #119	; 0x77
  HAL_StatusTypeDef status = HAL_OK;
 8007c66:	2000      	movs	r0, #0
      htim->Instance->SMCR = tmpsmcr;
 8007c68:	60a3      	str	r3, [r4, #8]
      break;
 8007c6a:	e75f      	b.n	8007b2c <HAL_TIM_ConfigClockSource+0x70>
 8007c6c:	ffce0088 	.word	0xffce0088
 8007c70:	00100040 	.word	0x00100040
 8007c74:	00100060 	.word	0x00100060
 8007c78:	00100030 	.word	0x00100030

08007c7c <HAL_TIM_SlaveConfigSynchro>:
  __HAL_LOCK(htim);
 8007c7c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8007c80:	2b01      	cmp	r3, #1
 8007c82:	d072      	beq.n	8007d6a <HAL_TIM_SlaveConfigSynchro+0xee>
 8007c84:	4684      	mov	ip, r0
 8007c86:	2201      	movs	r2, #1
  tmpsmcr = htim->Instance->SMCR;
 8007c88:	6800      	ldr	r0, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8007c8a:	2302      	movs	r3, #2
{
 8007c8c:	b410      	push	{r4}
  __HAL_LOCK(htim);
 8007c8e:	f88c 203c 	strb.w	r2, [ip, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 8007c92:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 8007c96:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8007c98:	684b      	ldr	r3, [r1, #4]
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8007c9a:	680c      	ldr	r4, [r1, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007c9c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8007ca0:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8007ca4:	431a      	orrs	r2, r3
  tmpsmcr &= ~TIM_SMCR_SMS;
 8007ca6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8007caa:	f022 0207 	bic.w	r2, r2, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8007cae:	4322      	orrs	r2, r4
  switch (sSlaveConfig->InputTrigger)
 8007cb0:	2b60      	cmp	r3, #96	; 0x60
  htim->Instance->SMCR = tmpsmcr;
 8007cb2:	6082      	str	r2, [r0, #8]
  switch (sSlaveConfig->InputTrigger)
 8007cb4:	d067      	beq.n	8007d86 <HAL_TIM_SlaveConfigSynchro+0x10a>
 8007cb6:	d816      	bhi.n	8007ce6 <HAL_TIM_SlaveConfigSynchro+0x6a>
 8007cb8:	2b40      	cmp	r3, #64	; 0x40
 8007cba:	d077      	beq.n	8007dac <HAL_TIM_SlaveConfigSynchro+0x130>
 8007cbc:	d935      	bls.n	8007d2a <HAL_TIM_SlaveConfigSynchro+0xae>
 8007cbe:	2b50      	cmp	r3, #80	; 0x50
 8007cc0:	d144      	bne.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
  tmpccer = TIMx->CCER;
 8007cc2:	6a03      	ldr	r3, [r0, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007cc4:	688a      	ldr	r2, [r1, #8]
 8007cc6:	6909      	ldr	r1, [r1, #16]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007cc8:	f023 030a 	bic.w	r3, r3, #10
  tmpccer |= TIM_ICPolarity;
 8007ccc:	431a      	orrs	r2, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007cce:	6a03      	ldr	r3, [r0, #32]
 8007cd0:	f023 0301 	bic.w	r3, r3, #1
 8007cd4:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007cd6:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007cd8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007cdc:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007ce0:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007ce2:	6202      	str	r2, [r0, #32]
 8007ce4:	e00f      	b.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
  switch (sSlaveConfig->InputTrigger)
 8007ce6:	2b70      	cmp	r3, #112	; 0x70
 8007ce8:	d041      	beq.n	8007d6e <HAL_TIM_SlaveConfigSynchro+0xf2>
 8007cea:	2b6f      	cmp	r3, #111	; 0x6f
 8007cec:	d92e      	bls.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007cee:	4a34      	ldr	r2, [pc, #208]	; (8007dc0 <HAL_TIM_SlaveConfigSynchro+0x144>)
 8007cf0:	4293      	cmp	r3, r2
 8007cf2:	d008      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cf4:	d91f      	bls.n	8007d36 <HAL_TIM_SlaveConfigSynchro+0xba>
 8007cf6:	4a33      	ldr	r2, [pc, #204]	; (8007dc4 <HAL_TIM_SlaveConfigSynchro+0x148>)
 8007cf8:	4293      	cmp	r3, r2
 8007cfa:	d004      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cfc:	3a10      	subs	r2, #16
 8007cfe:	f023 0320 	bic.w	r3, r3, #32
 8007d02:	4293      	cmp	r3, r2
 8007d04:	d122      	bne.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
 8007d06:	68c3      	ldr	r3, [r0, #12]
 8007d08:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007d0c:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8007d0e:	68c3      	ldr	r3, [r0, #12]
  __HAL_UNLOCK(htim);
 8007d10:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8007d12:	2101      	movs	r1, #1
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8007d14:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007d18:	60c3      	str	r3, [r0, #12]
  htim->State = HAL_TIM_STATE_READY;
 8007d1a:	f88c 103d 	strb.w	r1, [ip, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8007d1e:	f88c 203c 	strb.w	r2, [ip, #60]	; 0x3c
  return HAL_OK;
 8007d22:	4610      	mov	r0, r2
}
 8007d24:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007d28:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 8007d2a:	2b20      	cmp	r3, #32
 8007d2c:	d0eb      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007d2e:	d90a      	bls.n	8007d46 <HAL_TIM_SlaveConfigSynchro+0xca>
 8007d30:	2b30      	cmp	r3, #48	; 0x30
 8007d32:	d10b      	bne.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007d34:	e7e7      	b.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007d36:	3a20      	subs	r2, #32
 8007d38:	4293      	cmp	r3, r2
 8007d3a:	d0e4      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007d3c:	d90f      	bls.n	8007d5e <HAL_TIM_SlaveConfigSynchro+0xe2>
 8007d3e:	4a22      	ldr	r2, [pc, #136]	; (8007dc8 <HAL_TIM_SlaveConfigSynchro+0x14c>)
 8007d40:	4293      	cmp	r3, r2
 8007d42:	d0e0      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007d44:	e002      	b.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007d46:	f033 0310 	bics.w	r3, r3, #16
 8007d4a:	d0dc      	beq.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
    htim->State = HAL_TIM_STATE_READY;
 8007d4c:	2001      	movs	r0, #1
    __HAL_UNLOCK(htim);
 8007d4e:	2300      	movs	r3, #0
    htim->State = HAL_TIM_STATE_READY;
 8007d50:	f88c 003d 	strb.w	r0, [ip, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 8007d54:	f88c 303c 	strb.w	r3, [ip, #60]	; 0x3c
}
 8007d58:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007d5c:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 8007d5e:	f023 0310 	bic.w	r3, r3, #16
 8007d62:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8007d66:	d1f1      	bne.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007d68:	e7cd      	b.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
  __HAL_LOCK(htim);
 8007d6a:	2002      	movs	r0, #2
}
 8007d6c:	4770      	bx	lr
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d6e:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
  tmpsmcr = TIMx->SMCR;
 8007d72:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d74:	6909      	ldr	r1, [r1, #16]
 8007d76:	4323      	orrs	r3, r4
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007d78:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d7c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007d80:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 8007d82:	6083      	str	r3, [r0, #8]
 8007d84:	e7bf      	b.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007d86:	6a03      	ldr	r3, [r0, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8007d88:	688c      	ldr	r4, [r1, #8]
 8007d8a:	6909      	ldr	r1, [r1, #16]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007d8c:	f023 0310 	bic.w	r3, r3, #16
 8007d90:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007d92:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 8007d94:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8007d96:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8007d9a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8007d9e:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 8007da2:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 8007da6:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8007da8:	6203      	str	r3, [r0, #32]
 8007daa:	e7ac      	b.n	8007d06 <HAL_TIM_SlaveConfigSynchro+0x8a>
      if ((sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED) || \
 8007dac:	2c05      	cmp	r4, #5
 8007dae:	d0cd      	beq.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007db0:	f1b4 1f01 	cmp.w	r4, #65537	; 0x10001
 8007db4:	d0ca      	beq.n	8007d4c <HAL_TIM_SlaveConfigSynchro+0xd0>
      tmpccer = htim->Instance->CCER;
 8007db6:	6a02      	ldr	r2, [r0, #32]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 8007db8:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 8007dba:	6a03      	ldr	r3, [r0, #32]
 8007dbc:	e788      	b.n	8007cd0 <HAL_TIM_SlaveConfigSynchro+0x54>
 8007dbe:	bf00      	nop
 8007dc0:	00100040 	.word	0x00100040
 8007dc4:	00100060 	.word	0x00100060
 8007dc8:	00100030 	.word	0x00100030

08007dcc <HAL_TIM_PeriodElapsedCallback>:
 8007dcc:	4770      	bx	lr
 8007dce:	bf00      	nop

08007dd0 <HAL_TIM_OC_DelayElapsedCallback>:
 8007dd0:	4770      	bx	lr
 8007dd2:	bf00      	nop

08007dd4 <HAL_TIM_IC_CaptureCallback>:
 8007dd4:	4770      	bx	lr
 8007dd6:	bf00      	nop

08007dd8 <HAL_TIM_PWM_PulseFinishedCallback>:
 8007dd8:	4770      	bx	lr
 8007dda:	bf00      	nop

08007ddc <HAL_TIM_TriggerCallback>:
 8007ddc:	4770      	bx	lr
 8007dde:	bf00      	nop

08007de0 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8007de0:	6803      	ldr	r3, [r0, #0]
 8007de2:	691a      	ldr	r2, [r3, #16]
 8007de4:	0791      	lsls	r1, r2, #30
{
 8007de6:	b510      	push	{r4, lr}
 8007de8:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8007dea:	d503      	bpl.n	8007df4 <HAL_TIM_IRQHandler+0x14>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8007dec:	68da      	ldr	r2, [r3, #12]
 8007dee:	0792      	lsls	r2, r2, #30
 8007df0:	f100 808a 	bmi.w	8007f08 <HAL_TIM_IRQHandler+0x128>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007df4:	691a      	ldr	r2, [r3, #16]
 8007df6:	0752      	lsls	r2, r2, #29
 8007df8:	d502      	bpl.n	8007e00 <HAL_TIM_IRQHandler+0x20>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8007dfa:	68da      	ldr	r2, [r3, #12]
 8007dfc:	0750      	lsls	r0, r2, #29
 8007dfe:	d470      	bmi.n	8007ee2 <HAL_TIM_IRQHandler+0x102>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8007e00:	691a      	ldr	r2, [r3, #16]
 8007e02:	0711      	lsls	r1, r2, #28
 8007e04:	d502      	bpl.n	8007e0c <HAL_TIM_IRQHandler+0x2c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8007e06:	68da      	ldr	r2, [r3, #12]
 8007e08:	0712      	lsls	r2, r2, #28
 8007e0a:	d458      	bmi.n	8007ebe <HAL_TIM_IRQHandler+0xde>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8007e0c:	691a      	ldr	r2, [r3, #16]
 8007e0e:	06d1      	lsls	r1, r2, #27
 8007e10:	d502      	bpl.n	8007e18 <HAL_TIM_IRQHandler+0x38>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8007e12:	68da      	ldr	r2, [r3, #12]
 8007e14:	06d2      	lsls	r2, r2, #27
 8007e16:	d43e      	bmi.n	8007e96 <HAL_TIM_IRQHandler+0xb6>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8007e18:	691a      	ldr	r2, [r3, #16]
 8007e1a:	07d0      	lsls	r0, r2, #31
 8007e1c:	d503      	bpl.n	8007e26 <HAL_TIM_IRQHandler+0x46>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8007e1e:	68da      	ldr	r2, [r3, #12]
 8007e20:	07d1      	lsls	r1, r2, #31
 8007e22:	f100 808a 	bmi.w	8007f3a <HAL_TIM_IRQHandler+0x15a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007e26:	691a      	ldr	r2, [r3, #16]
 8007e28:	0612      	lsls	r2, r2, #24
 8007e2a:	d503      	bpl.n	8007e34 <HAL_TIM_IRQHandler+0x54>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8007e2c:	68da      	ldr	r2, [r3, #12]
 8007e2e:	0610      	lsls	r0, r2, #24
 8007e30:	f100 808b 	bmi.w	8007f4a <HAL_TIM_IRQHandler+0x16a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8007e34:	691a      	ldr	r2, [r3, #16]
 8007e36:	05d1      	lsls	r1, r2, #23
 8007e38:	d503      	bpl.n	8007e42 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8007e3a:	68da      	ldr	r2, [r3, #12]
 8007e3c:	0612      	lsls	r2, r2, #24
 8007e3e:	f100 808c 	bmi.w	8007f5a <HAL_TIM_IRQHandler+0x17a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8007e42:	691a      	ldr	r2, [r3, #16]
 8007e44:	0650      	lsls	r0, r2, #25
 8007e46:	d503      	bpl.n	8007e50 <HAL_TIM_IRQHandler+0x70>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8007e48:	68da      	ldr	r2, [r3, #12]
 8007e4a:	0651      	lsls	r1, r2, #25
 8007e4c:	f100 808d 	bmi.w	8007f6a <HAL_TIM_IRQHandler+0x18a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8007e50:	691a      	ldr	r2, [r3, #16]
 8007e52:	0692      	lsls	r2, r2, #26
 8007e54:	d503      	bpl.n	8007e5e <HAL_TIM_IRQHandler+0x7e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8007e56:	68da      	ldr	r2, [r3, #12]
 8007e58:	0690      	lsls	r0, r2, #26
 8007e5a:	f100 808e 	bmi.w	8007f7a <HAL_TIM_IRQHandler+0x19a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IDX) != RESET)
 8007e5e:	691a      	ldr	r2, [r3, #16]
 8007e60:	02d1      	lsls	r1, r2, #11
 8007e62:	d503      	bpl.n	8007e6c <HAL_TIM_IRQHandler+0x8c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IDX) != RESET)
 8007e64:	68da      	ldr	r2, [r3, #12]
 8007e66:	02d2      	lsls	r2, r2, #11
 8007e68:	f100 808f 	bmi.w	8007f8a <HAL_TIM_IRQHandler+0x1aa>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_DIR) != RESET)
 8007e6c:	691a      	ldr	r2, [r3, #16]
 8007e6e:	0290      	lsls	r0, r2, #10
 8007e70:	d503      	bpl.n	8007e7a <HAL_TIM_IRQHandler+0x9a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_DIR) != RESET)
 8007e72:	68da      	ldr	r2, [r3, #12]
 8007e74:	0291      	lsls	r1, r2, #10
 8007e76:	f100 8090 	bmi.w	8007f9a <HAL_TIM_IRQHandler+0x1ba>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IERR) != RESET)
 8007e7a:	691a      	ldr	r2, [r3, #16]
 8007e7c:	0252      	lsls	r2, r2, #9
 8007e7e:	d503      	bpl.n	8007e88 <HAL_TIM_IRQHandler+0xa8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IERR) != RESET)
 8007e80:	68da      	ldr	r2, [r3, #12]
 8007e82:	0250      	lsls	r0, r2, #9
 8007e84:	f100 8091 	bmi.w	8007faa <HAL_TIM_IRQHandler+0x1ca>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TERR) != RESET)
 8007e88:	691a      	ldr	r2, [r3, #16]
 8007e8a:	0211      	lsls	r1, r2, #8
 8007e8c:	d502      	bpl.n	8007e94 <HAL_TIM_IRQHandler+0xb4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TERR) != RESET)
 8007e8e:	68da      	ldr	r2, [r3, #12]
 8007e90:	0212      	lsls	r2, r2, #8
 8007e92:	d44a      	bmi.n	8007f2a <HAL_TIM_IRQHandler+0x14a>
}
 8007e94:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8007e96:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8007e9a:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8007e9c:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8007e9e:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8007ea0:	69db      	ldr	r3, [r3, #28]
 8007ea2:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8007ea6:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8007ea8:	f040 8090 	bne.w	8007fcc <HAL_TIM_IRQHandler+0x1ec>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007eac:	f7ff ff90 	bl	8007dd0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007eb0:	4620      	mov	r0, r4
 8007eb2:	f7ff ff91 	bl	8007dd8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007eb6:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8007eb8:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007eba:	7722      	strb	r2, [r4, #28]
 8007ebc:	e7ac      	b.n	8007e18 <HAL_TIM_IRQHandler+0x38>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8007ebe:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8007ec2:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8007ec4:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8007ec6:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8007ec8:	69db      	ldr	r3, [r3, #28]
 8007eca:	079b      	lsls	r3, r3, #30
        HAL_TIM_IC_CaptureCallback(htim);
 8007ecc:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8007ece:	d17a      	bne.n	8007fc6 <HAL_TIM_IRQHandler+0x1e6>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007ed0:	f7ff ff7e 	bl	8007dd0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007ed4:	4620      	mov	r0, r4
 8007ed6:	f7ff ff7f 	bl	8007dd8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007eda:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8007edc:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007ede:	7722      	strb	r2, [r4, #28]
 8007ee0:	e794      	b.n	8007e0c <HAL_TIM_IRQHandler+0x2c>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8007ee2:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8007ee6:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8007ee8:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8007eea:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8007eec:	699b      	ldr	r3, [r3, #24]
 8007eee:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8007ef2:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8007ef4:	d164      	bne.n	8007fc0 <HAL_TIM_IRQHandler+0x1e0>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007ef6:	f7ff ff6b 	bl	8007dd0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007efa:	4620      	mov	r0, r4
 8007efc:	f7ff ff6c 	bl	8007dd8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007f00:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8007f02:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007f04:	7722      	strb	r2, [r4, #28]
 8007f06:	e77b      	b.n	8007e00 <HAL_TIM_IRQHandler+0x20>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007f08:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8007f0c:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007f0e:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8007f10:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8007f12:	699b      	ldr	r3, [r3, #24]
 8007f14:	0799      	lsls	r1, r3, #30
 8007f16:	d150      	bne.n	8007fba <HAL_TIM_IRQHandler+0x1da>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8007f18:	f7ff ff5a 	bl	8007dd0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007f1c:	4620      	mov	r0, r4
 8007f1e:	f7ff ff5b 	bl	8007dd8 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007f22:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007f24:	6823      	ldr	r3, [r4, #0]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007f26:	7722      	strb	r2, [r4, #28]
 8007f28:	e764      	b.n	8007df4 <HAL_TIM_IRQHandler+0x14>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_TERR);
 8007f2a:	f46f 0200 	mvn.w	r2, #8388608	; 0x800000
      HAL_TIMEx_TransitionErrorCallback(htim);
 8007f2e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_TERR);
 8007f30:	611a      	str	r2, [r3, #16]
}
 8007f32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_TransitionErrorCallback(htim);
 8007f36:	f000 ba63 	b.w	8008400 <HAL_TIMEx_TransitionErrorCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8007f3a:	f06f 0201 	mvn.w	r2, #1
 8007f3e:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8007f40:	4620      	mov	r0, r4
 8007f42:	f7ff ff43 	bl	8007dcc <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007f46:	6823      	ldr	r3, [r4, #0]
 8007f48:	e76d      	b.n	8007e26 <HAL_TIM_IRQHandler+0x46>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8007f4a:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8007f4e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8007f50:	4620      	mov	r0, r4
 8007f52:	f000 fa4b 	bl	80083ec <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8007f56:	6823      	ldr	r3, [r4, #0]
 8007f58:	e76c      	b.n	8007e34 <HAL_TIM_IRQHandler+0x54>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8007f5a:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8007f5e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8007f60:	4620      	mov	r0, r4
 8007f62:	f000 fa45 	bl	80083f0 <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8007f66:	6823      	ldr	r3, [r4, #0]
 8007f68:	e76b      	b.n	8007e42 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8007f6a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8007f6e:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8007f70:	4620      	mov	r0, r4
 8007f72:	f7ff ff33 	bl	8007ddc <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8007f76:	6823      	ldr	r3, [r4, #0]
 8007f78:	e76a      	b.n	8007e50 <HAL_TIM_IRQHandler+0x70>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8007f7a:	f06f 0220 	mvn.w	r2, #32
 8007f7e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8007f80:	4620      	mov	r0, r4
 8007f82:	f000 fa31 	bl	80083e8 <HAL_TIMEx_CommutCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IDX) != RESET)
 8007f86:	6823      	ldr	r3, [r4, #0]
 8007f88:	e769      	b.n	8007e5e <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IDX);
 8007f8a:	f46f 1280 	mvn.w	r2, #1048576	; 0x100000
 8007f8e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_EncoderIndexCallback(htim);
 8007f90:	4620      	mov	r0, r4
 8007f92:	f000 fa2f 	bl	80083f4 <HAL_TIMEx_EncoderIndexCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_DIR) != RESET)
 8007f96:	6823      	ldr	r3, [r4, #0]
 8007f98:	e768      	b.n	8007e6c <HAL_TIM_IRQHandler+0x8c>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_DIR);
 8007f9a:	f46f 1200 	mvn.w	r2, #2097152	; 0x200000
 8007f9e:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_DirectionChangeCallback(htim);
 8007fa0:	4620      	mov	r0, r4
 8007fa2:	f000 fa29 	bl	80083f8 <HAL_TIMEx_DirectionChangeCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IERR) != RESET)
 8007fa6:	6823      	ldr	r3, [r4, #0]
 8007fa8:	e767      	b.n	8007e7a <HAL_TIM_IRQHandler+0x9a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IERR);
 8007faa:	f46f 0280 	mvn.w	r2, #4194304	; 0x400000
 8007fae:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_IndexErrorCallback(htim);
 8007fb0:	4620      	mov	r0, r4
 8007fb2:	f000 fa23 	bl	80083fc <HAL_TIMEx_IndexErrorCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TERR) != RESET)
 8007fb6:	6823      	ldr	r3, [r4, #0]
 8007fb8:	e766      	b.n	8007e88 <HAL_TIM_IRQHandler+0xa8>
          HAL_TIM_IC_CaptureCallback(htim);
 8007fba:	f7ff ff0b 	bl	8007dd4 <HAL_TIM_IC_CaptureCallback>
 8007fbe:	e7b0      	b.n	8007f22 <HAL_TIM_IRQHandler+0x142>
        HAL_TIM_IC_CaptureCallback(htim);
 8007fc0:	f7ff ff08 	bl	8007dd4 <HAL_TIM_IC_CaptureCallback>
 8007fc4:	e79c      	b.n	8007f00 <HAL_TIM_IRQHandler+0x120>
        HAL_TIM_IC_CaptureCallback(htim);
 8007fc6:	f7ff ff05 	bl	8007dd4 <HAL_TIM_IC_CaptureCallback>
 8007fca:	e786      	b.n	8007eda <HAL_TIM_IRQHandler+0xfa>
        HAL_TIM_IC_CaptureCallback(htim);
 8007fcc:	f7ff ff02 	bl	8007dd4 <HAL_TIM_IC_CaptureCallback>
 8007fd0:	e771      	b.n	8007eb6 <HAL_TIM_IRQHandler+0xd6>
 8007fd2:	bf00      	nop

08007fd4 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007fd4:	6a03      	ldr	r3, [r0, #32]
 8007fd6:	f023 0310 	bic.w	r3, r3, #16
 8007fda:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8007fdc:	6a03      	ldr	r3, [r0, #32]
{
 8007fde:	b470      	push	{r4, r5, r6}
  tmpcr2 =  TIMx->CR2;
 8007fe0:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8007fe2:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007fe4:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8007fe6:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8007fea:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007fee:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8007ff2:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 8007ff4:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8007ff8:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8007ffc:	4d1c      	ldr	r5, [pc, #112]	; (8008070 <TIM_OC2_SetConfig+0x9c>)
 8007ffe:	42a8      	cmp	r0, r5
 8008000:	d017      	beq.n	8008032 <TIM_OC2_SetConfig+0x5e>
 8008002:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8008006:	42a8      	cmp	r0, r5
 8008008:	d013      	beq.n	8008032 <TIM_OC2_SetConfig+0x5e>
 800800a:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 800800e:	42a8      	cmp	r0, r5
 8008010:	d025      	beq.n	800805e <TIM_OC2_SetConfig+0x8a>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8008012:	4d18      	ldr	r5, [pc, #96]	; (8008074 <TIM_OC2_SetConfig+0xa0>)
 8008014:	42a8      	cmp	r0, r5
 8008016:	d013      	beq.n	8008040 <TIM_OC2_SetConfig+0x6c>
 8008018:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800801c:	42a8      	cmp	r0, r5
 800801e:	d00f      	beq.n	8008040 <TIM_OC2_SetConfig+0x6c>
 8008020:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8008024:	42a8      	cmp	r0, r5
 8008026:	d00b      	beq.n	8008040 <TIM_OC2_SetConfig+0x6c>
 8008028:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800802c:	42a8      	cmp	r0, r5
 800802e:	d10f      	bne.n	8008050 <TIM_OC2_SetConfig+0x7c>
 8008030:	e006      	b.n	8008040 <TIM_OC2_SetConfig+0x6c>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008032:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8008034:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008038:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800803c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008040:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008044:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008048:	ea46 0c05 	orr.w	ip, r6, r5
 800804c:	ea44 048c 	orr.w	r4, r4, ip, lsl #2
  TIMx->CCR2 = OC_Config->Pulse;
 8008050:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8008052:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008054:	6182      	str	r2, [r0, #24]
}
 8008056:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR2 = OC_Config->Pulse;
 8008058:	6381      	str	r1, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 800805a:	6203      	str	r3, [r0, #32]
}
 800805c:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800805e:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8008060:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008064:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8008068:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800806c:	e7d1      	b.n	8008012 <TIM_OC2_SetConfig+0x3e>
 800806e:	bf00      	nop
 8008070:	40012c00 	.word	0x40012c00
 8008074:	40014000 	.word	0x40014000

08008078 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8008078:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800807c:	2b01      	cmp	r3, #1
 800807e:	f000 80ff 	beq.w	8008280 <HAL_TIM_PWM_ConfigChannel+0x208>
 8008082:	2301      	movs	r3, #1
{
 8008084:	b570      	push	{r4, r5, r6, lr}
 8008086:	4604      	mov	r4, r0
 8008088:	460d      	mov	r5, r1
  __HAL_LOCK(htim);
 800808a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 800808e:	2a14      	cmp	r2, #20
 8008090:	d80c      	bhi.n	80080ac <HAL_TIM_PWM_ConfigChannel+0x34>
 8008092:	e8df f002 	tbb	[pc, r2]
 8008096:	0b59      	.short	0x0b59
 8008098:	0b6e0b0b 	.word	0x0b6e0b0b
 800809c:	0b840b0b 	.word	0x0b840b0b
 80080a0:	0b990b0b 	.word	0x0b990b0b
 80080a4:	0baf0b0b 	.word	0x0baf0b0b
 80080a8:	0b0b      	.short	0x0b0b
 80080aa:	11          	.byte	0x11
 80080ab:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 80080ac:	2300      	movs	r3, #0
  switch (Channel)
 80080ae:	2201      	movs	r2, #1
  __HAL_UNLOCK(htim);
 80080b0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80080b4:	4610      	mov	r0, r2
 80080b6:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80080b8:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80080ba:	682e      	ldr	r6, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80080bc:	6a1a      	ldr	r2, [r3, #32]
 80080be:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80080c2:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80080c4:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80080c6:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 80080c8:	6d19      	ldr	r1, [r3, #80]	; 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 80080ca:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 80080ce:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80080d2:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80080d6:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 80080d8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80080dc:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80080e0:	4e69      	ldr	r6, [pc, #420]	; (8008288 <HAL_TIM_PWM_ConfigChannel+0x210>)
 80080e2:	42b3      	cmp	r3, r6
 80080e4:	d013      	beq.n	800810e <HAL_TIM_PWM_ConfigChannel+0x96>
 80080e6:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80080ea:	42b3      	cmp	r3, r6
 80080ec:	d00f      	beq.n	800810e <HAL_TIM_PWM_ConfigChannel+0x96>
 80080ee:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 80080f2:	42b3      	cmp	r3, r6
 80080f4:	d00b      	beq.n	800810e <HAL_TIM_PWM_ConfigChannel+0x96>
 80080f6:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80080fa:	42b3      	cmp	r3, r6
 80080fc:	d007      	beq.n	800810e <HAL_TIM_PWM_ConfigChannel+0x96>
 80080fe:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8008102:	42b3      	cmp	r3, r6
 8008104:	d003      	beq.n	800810e <HAL_TIM_PWM_ConfigChannel+0x96>
 8008106:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 800810a:	42b3      	cmp	r3, r6
 800810c:	d104      	bne.n	8008118 <HAL_TIM_PWM_ConfigChannel+0xa0>
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800810e:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 8008110:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8008114:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
  TIMx->CR2 = tmpcr2;
 8008118:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800811a:	6519      	str	r1, [r3, #80]	; 0x50
  TIMx->CCR6 = OC_Config->Pulse;
 800811c:	6869      	ldr	r1, [r5, #4]
 800811e:	64d9      	str	r1, [r3, #76]	; 0x4c
  TIMx->CCER = tmpccer;
 8008120:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8008122:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8008124:	6928      	ldr	r0, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8008126:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800812a:	651a      	str	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800812c:	6d19      	ldr	r1, [r3, #80]	; 0x50
 800812e:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8008132:	6519      	str	r1, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8008134:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8008136:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800813a:	6519      	str	r1, [r3, #80]	; 0x50
  __HAL_UNLOCK(htim);
 800813c:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 800813e:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008140:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8008144:	4610      	mov	r0, r2
 8008146:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008148:	6800      	ldr	r0, [r0, #0]
 800814a:	f7ff f95d 	bl	8007408 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800814e:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8008150:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8008152:	f043 0308 	orr.w	r3, r3, #8
 8008156:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8008158:	6983      	ldr	r3, [r0, #24]
 800815a:	f023 0304 	bic.w	r3, r3, #4
 800815e:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8008160:	6983      	ldr	r3, [r0, #24]
 8008162:	430b      	orrs	r3, r1
 8008164:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 8008166:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8008168:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 800816a:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800816e:	4610      	mov	r0, r2
 8008170:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8008172:	6800      	ldr	r0, [r0, #0]
 8008174:	f7ff ff2e 	bl	8007fd4 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8008178:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800817a:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800817c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8008180:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8008182:	6983      	ldr	r3, [r0, #24]
 8008184:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008188:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800818a:	6983      	ldr	r3, [r0, #24]
 800818c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008190:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 8008192:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8008194:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008196:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800819a:	4610      	mov	r0, r2
 800819c:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800819e:	6800      	ldr	r0, [r0, #0]
 80081a0:	f7ff f972 	bl	8007488 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80081a4:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80081a6:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80081a8:	f043 0308 	orr.w	r3, r3, #8
 80081ac:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80081ae:	69c3      	ldr	r3, [r0, #28]
 80081b0:	f023 0304 	bic.w	r3, r3, #4
 80081b4:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80081b6:	69c3      	ldr	r3, [r0, #28]
 80081b8:	430b      	orrs	r3, r1
 80081ba:	61c3      	str	r3, [r0, #28]
  __HAL_UNLOCK(htim);
 80081bc:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 80081be:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 80081c0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80081c4:	4610      	mov	r0, r2
 80081c6:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80081c8:	6800      	ldr	r0, [r0, #0]
 80081ca:	f7ff f9ad 	bl	8007528 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80081ce:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80081d0:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80081d2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80081d6:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80081d8:	69c3      	ldr	r3, [r0, #28]
 80081da:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80081de:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80081e0:	69c3      	ldr	r3, [r0, #28]
 80081e2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80081e6:	61c3      	str	r3, [r0, #28]
  __HAL_UNLOCK(htim);
 80081e8:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 80081ea:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 80081ec:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80081f0:	4610      	mov	r0, r2
 80081f2:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 80081f4:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 80081f6:	682e      	ldr	r6, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80081f8:	6a1a      	ldr	r2, [r3, #32]
 80081fa:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80081fe:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 8008200:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 8008202:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8008204:	6d19      	ldr	r1, [r3, #80]	; 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8008206:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800820a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 800820e:	4331      	orrs	r1, r6
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8008210:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 8008212:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8008216:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800821a:	4e1b      	ldr	r6, [pc, #108]	; (8008288 <HAL_TIM_PWM_ConfigChannel+0x210>)
 800821c:	42b3      	cmp	r3, r6
 800821e:	d013      	beq.n	8008248 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 8008220:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 8008224:	42b3      	cmp	r3, r6
 8008226:	d00f      	beq.n	8008248 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 8008228:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 800822c:	42b3      	cmp	r3, r6
 800822e:	d00b      	beq.n	8008248 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 8008230:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8008234:	42b3      	cmp	r3, r6
 8008236:	d007      	beq.n	8008248 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 8008238:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800823c:	42b3      	cmp	r3, r6
 800823e:	d003      	beq.n	8008248 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 8008240:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 8008244:	42b3      	cmp	r3, r6
 8008246:	d104      	bne.n	8008252 <HAL_TIM_PWM_ConfigChannel+0x1da>
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8008248:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 800824a:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800824e:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  TIMx->CR2 = tmpcr2;
 8008252:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 8008254:	6519      	str	r1, [r3, #80]	; 0x50
  TIMx->CCR5 = OC_Config->Pulse;
 8008256:	6869      	ldr	r1, [r5, #4]
 8008258:	6499      	str	r1, [r3, #72]	; 0x48
  TIMx->CCER = tmpccer;
 800825a:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800825c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 800825e:	6928      	ldr	r0, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8008260:	f042 0208 	orr.w	r2, r2, #8
 8008264:	651a      	str	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8008266:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8008268:	f021 0104 	bic.w	r1, r1, #4
 800826c:	6519      	str	r1, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 800826e:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8008270:	4301      	orrs	r1, r0
 8008272:	6519      	str	r1, [r3, #80]	; 0x50
  __HAL_UNLOCK(htim);
 8008274:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8008276:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008278:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800827c:	4610      	mov	r0, r2
 800827e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(htim);
 8008280:	2202      	movs	r2, #2
}
 8008282:	4610      	mov	r0, r2
 8008284:	4770      	bx	lr
 8008286:	bf00      	nop
 8008288:	40012c00 	.word	0x40012c00

0800828c <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800828c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8008290:	2b01      	cmp	r3, #1
 8008292:	d051      	beq.n	8008338 <HAL_TIMEx_MasterConfigSynchronization+0xac>
{
 8008294:	b430      	push	{r4, r5}

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8008296:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8008298:	4d28      	ldr	r5, [pc, #160]	; (800833c <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
  htim->State = HAL_TIM_STATE_BUSY;
 800829a:	2302      	movs	r3, #2
 800829c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80082a0:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 80082a2:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 80082a4:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80082a6:	d03b      	beq.n	8008320 <HAL_TIMEx_MasterConfigSynchronization+0x94>
 80082a8:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80082ac:	42aa      	cmp	r2, r5
 80082ae:	d032      	beq.n	8008316 <HAL_TIMEx_MasterConfigSynchronization+0x8a>
 80082b0:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 80082b4:	42aa      	cmp	r2, r5
 80082b6:	d02e      	beq.n	8008316 <HAL_TIMEx_MasterConfigSynchronization+0x8a>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80082b8:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 80082ba:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80082be:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80082c2:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80082c4:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->Instance->CR2 = tmpcr2;
 80082c8:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80082ca:	d016      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082cc:	4b1c      	ldr	r3, [pc, #112]	; (8008340 <HAL_TIMEx_MasterConfigSynchronization+0xb4>)
 80082ce:	429a      	cmp	r2, r3
 80082d0:	d013      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082d2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80082d6:	429a      	cmp	r2, r3
 80082d8:	d00f      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082da:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80082de:	429a      	cmp	r2, r3
 80082e0:	d00b      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082e2:	f503 3394 	add.w	r3, r3, #75776	; 0x12800
 80082e6:	429a      	cmp	r2, r3
 80082e8:	d007      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082ea:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 80082ee:	429a      	cmp	r2, r3
 80082f0:	d003      	beq.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80082f6:	429a      	cmp	r2, r3
 80082f8:	d104      	bne.n	8008304 <HAL_TIMEx_MasterConfigSynchronization+0x78>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80082fa:	688b      	ldr	r3, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 80082fc:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8008300:	431c      	orrs	r4, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8008302:	6094      	str	r4, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8008304:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8008306:	2201      	movs	r2, #1
 8008308:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800830c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
}
 8008310:	bc30      	pop	{r4, r5}
  return HAL_OK;
 8008312:	4618      	mov	r0, r3
}
 8008314:	4770      	bx	lr
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8008316:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8008318:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800831c:	432b      	orrs	r3, r5
 800831e:	e7cb      	b.n	80082b8 <HAL_TIMEx_MasterConfigSynchronization+0x2c>
 8008320:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8008322:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8008326:	432b      	orrs	r3, r5
  tmpcr2 &= ~TIM_CR2_MMS;
 8008328:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800832c:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 800832e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8008332:	432b      	orrs	r3, r5
  htim->Instance->CR2 = tmpcr2;
 8008334:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008336:	e7e0      	b.n	80082fa <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  __HAL_LOCK(htim);
 8008338:	2002      	movs	r0, #2
}
 800833a:	4770      	bx	lr
 800833c:	40012c00 	.word	0x40012c00
 8008340:	40000400 	.word	0x40000400

08008344 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 8008344:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8008348:	2b01      	cmp	r3, #1
 800834a:	d048      	beq.n	80083de <HAL_TIMEx_ConfigBreakDeadTime+0x9a>
{
 800834c:	b410      	push	{r4}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 800834e:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
 8008352:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8008356:	4602      	mov	r2, r0
 8008358:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 800835a:	6848      	ldr	r0, [r1, #4]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800835c:	680c      	ldr	r4, [r1, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 800835e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008362:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8008364:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008368:	6908      	ldr	r0, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800836a:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800836c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008370:	694c      	ldr	r4, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008372:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008374:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008378:	6b08      	ldr	r0, [r1, #48]	; 0x30
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800837a:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800837c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8008380:	698c      	ldr	r4, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008382:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8008384:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 8008388:	6810      	ldr	r0, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800838a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 800838e:	4c15      	ldr	r4, [pc, #84]	; (80083e4 <HAL_TIMEx_ConfigBreakDeadTime+0xa0>)
 8008390:	42a0      	cmp	r0, r4
 8008392:	d007      	beq.n	80083a4 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
 8008394:	f504 6400 	add.w	r4, r4, #2048	; 0x800
 8008398:	42a0      	cmp	r0, r4
 800839a:	d003      	beq.n	80083a4 <HAL_TIMEx_ConfigBreakDeadTime+0x60>
 800839c:	f504 54e0 	add.w	r4, r4, #7168	; 0x1c00
 80083a0:	42a0      	cmp	r0, r4
 80083a2:	d114      	bne.n	80083ce <HAL_TIMEx_ConfigBreakDeadTime+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));

    /* Set BREAK AF mode */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 80083a4:	69cc      	ldr	r4, [r1, #28]
 80083a6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80083aa:	4323      	orrs	r3, r4
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 80083ac:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 80083ae:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80083b2:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 80083b6:	6a0c      	ldr	r4, [r1, #32]
 80083b8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80083bc:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 80083be:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    {
      /* Check the parameters */
      assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));

      /* Set BREAK2 AF mode */
      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 80083c0:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 80083c2:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80083c6:	4323      	orrs	r3, r4
      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 80083c8:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 80083cc:	430b      	orrs	r3, r1
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 80083ce:	2100      	movs	r1, #0
  htim->Instance->BDTR = tmpbdtr;
 80083d0:	6443      	str	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(htim);
 80083d2:	f882 103c 	strb.w	r1, [r2, #60]	; 0x3c

  return HAL_OK;
 80083d6:	4608      	mov	r0, r1
}
 80083d8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80083dc:	4770      	bx	lr
  __HAL_LOCK(htim);
 80083de:	2002      	movs	r0, #2
}
 80083e0:	4770      	bx	lr
 80083e2:	bf00      	nop
 80083e4:	40012c00 	.word	0x40012c00

080083e8 <HAL_TIMEx_CommutCallback>:
 80083e8:	4770      	bx	lr
 80083ea:	bf00      	nop

080083ec <HAL_TIMEx_BreakCallback>:
 80083ec:	4770      	bx	lr
 80083ee:	bf00      	nop

080083f0 <HAL_TIMEx_Break2Callback>:
 80083f0:	4770      	bx	lr
 80083f2:	bf00      	nop

080083f4 <HAL_TIMEx_EncoderIndexCallback>:
 80083f4:	4770      	bx	lr
 80083f6:	bf00      	nop

080083f8 <HAL_TIMEx_DirectionChangeCallback>:
 80083f8:	4770      	bx	lr
 80083fa:	bf00      	nop

080083fc <HAL_TIMEx_IndexErrorCallback>:
 80083fc:	4770      	bx	lr
 80083fe:	bf00      	nop

08008400 <HAL_TIMEx_TransitionErrorCallback>:
 8008400:	4770      	bx	lr
 8008402:	bf00      	nop

08008404 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8008404:	b538      	push	{r3, r4, r5, lr}
 8008406:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8008408:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800840a:	6882      	ldr	r2, [r0, #8]
 800840c:	6900      	ldr	r0, [r0, #16]
 800840e:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8008410:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8008412:	4302      	orrs	r2, r0
 8008414:	430a      	orrs	r2, r1
 8008416:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8008418:	49b2      	ldr	r1, [pc, #712]	; (80086e4 <UART_SetConfig+0x2e0>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800841a:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800841c:	4029      	ands	r1, r5
 800841e:	430a      	orrs	r2, r1
 8008420:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8008422:	685a      	ldr	r2, [r3, #4]
 8008424:	68e1      	ldr	r1, [r4, #12]
 8008426:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800842a:	430a      	orrs	r2, r1
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800842c:	49ae      	ldr	r1, [pc, #696]	; (80086e8 <UART_SetConfig+0x2e4>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800842e:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8008430:	428b      	cmp	r3, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8008432:	69a2      	ldr	r2, [r4, #24]
  {
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8008434:	6899      	ldr	r1, [r3, #8]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8008436:	f000 8081 	beq.w	800853c <UART_SetConfig+0x138>
    tmpreg |= huart->Init.OneBitSampling;
 800843a:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800843c:	f021 416e 	bic.w	r1, r1, #3992977408	; 0xee000000
 8008440:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
    tmpreg |= huart->Init.OneBitSampling;
 8008444:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8008446:	430a      	orrs	r2, r1
 8008448:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800844a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800844c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800844e:	f022 020f 	bic.w	r2, r2, #15
 8008452:	430a      	orrs	r2, r1
 8008454:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008456:	4aa5      	ldr	r2, [pc, #660]	; (80086ec <UART_SetConfig+0x2e8>)
 8008458:	4293      	cmp	r3, r2
 800845a:	d027      	beq.n	80084ac <UART_SetConfig+0xa8>
 800845c:	4aa4      	ldr	r2, [pc, #656]	; (80086f0 <UART_SetConfig+0x2ec>)
 800845e:	4293      	cmp	r3, r2
 8008460:	d04b      	beq.n	80084fa <UART_SetConfig+0xf6>
 8008462:	4aa4      	ldr	r2, [pc, #656]	; (80086f4 <UART_SetConfig+0x2f0>)
 8008464:	4293      	cmp	r3, r2
 8008466:	f000 8111 	beq.w	800868c <UART_SetConfig+0x288>
 800846a:	4aa3      	ldr	r2, [pc, #652]	; (80086f8 <UART_SetConfig+0x2f4>)
 800846c:	4293      	cmp	r3, r2
 800846e:	f000 80b9 	beq.w	80085e4 <UART_SetConfig+0x1e0>
 8008472:	4aa2      	ldr	r2, [pc, #648]	; (80086fc <UART_SetConfig+0x2f8>)
 8008474:	4293      	cmp	r3, r2
 8008476:	d111      	bne.n	800849c <UART_SetConfig+0x98>
 8008478:	4ba1      	ldr	r3, [pc, #644]	; (8008700 <UART_SetConfig+0x2fc>)
 800847a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800847e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008482:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008486:	f000 8126 	beq.w	80086d6 <UART_SetConfig+0x2d2>
 800848a:	f200 80d5 	bhi.w	8008638 <UART_SetConfig+0x234>
 800848e:	2b00      	cmp	r3, #0
 8008490:	f000 80d9 	beq.w	8008646 <UART_SetConfig+0x242>
 8008494:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008498:	f000 80b0 	beq.w	80085fc <UART_SetConfig+0x1f8>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
        break;
      default:
        pclk = 0U;
        ret = HAL_ERROR;
 800849c:	2001      	movs	r0, #1
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800849e:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 80084a0:	f04f 1201 	mov.w	r2, #65537	; 0x10001
  huart->TxISR = NULL;
 80084a4:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
  huart->NbRxDataToProcess = 1;
 80084a8:	66a2      	str	r2, [r4, #104]	; 0x68

  return ret;
}
 80084aa:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 80084ac:	4b94      	ldr	r3, [pc, #592]	; (8008700 <UART_SetConfig+0x2fc>)
 80084ae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80084b2:	f003 0303 	and.w	r3, r3, #3
 80084b6:	3b01      	subs	r3, #1
 80084b8:	2b02      	cmp	r3, #2
 80084ba:	f240 808d 	bls.w	80085d8 <UART_SetConfig+0x1d4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80084be:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80084c2:	f000 8103 	beq.w	80086cc <UART_SetConfig+0x2c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 80084c6:	f7fe fdfd 	bl	80070c4 <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 80084ca:	2800      	cmp	r0, #0
 80084cc:	f000 80dc 	beq.w	8008688 <UART_SetConfig+0x284>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80084d0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80084d2:	6862      	ldr	r2, [r4, #4]
 80084d4:	4b8b      	ldr	r3, [pc, #556]	; (8008704 <UART_SetConfig+0x300>)
 80084d6:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 80084da:	fbb0 f3f3 	udiv	r3, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80084de:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80084e2:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80084e6:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80084ea:	f1a3 0210 	sub.w	r2, r3, #16
 80084ee:	428a      	cmp	r2, r1
 80084f0:	d8d4      	bhi.n	800849c <UART_SetConfig+0x98>
        huart->Instance->BRR = (uint16_t)usartdiv;
 80084f2:	6822      	ldr	r2, [r4, #0]
 80084f4:	2000      	movs	r0, #0
 80084f6:	60d3      	str	r3, [r2, #12]
 80084f8:	e7d1      	b.n	800849e <UART_SetConfig+0x9a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80084fa:	4b81      	ldr	r3, [pc, #516]	; (8008700 <UART_SetConfig+0x2fc>)
 80084fc:	4a82      	ldr	r2, [pc, #520]	; (8008708 <UART_SetConfig+0x304>)
 80084fe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8008502:	f003 030c 	and.w	r3, r3, #12
 8008506:	5cd3      	ldrb	r3, [r2, r3]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8008508:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800850c:	d07c      	beq.n	8008608 <UART_SetConfig+0x204>
    switch (clocksource)
 800850e:	2b08      	cmp	r3, #8
 8008510:	d8c4      	bhi.n	800849c <UART_SetConfig+0x98>
 8008512:	a201      	add	r2, pc, #4	; (adr r2, 8008518 <UART_SetConfig+0x114>)
 8008514:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008518:	08008641 	.word	0x08008641
 800851c:	080084c7 	.word	0x080084c7
 8008520:	080086c3 	.word	0x080086c3
 8008524:	0800849d 	.word	0x0800849d
 8008528:	08008603 	.word	0x08008603
 800852c:	0800849d 	.word	0x0800849d
 8008530:	0800849d 	.word	0x0800849d
 8008534:	0800849d 	.word	0x0800849d
 8008538:	080086b3 	.word	0x080086b3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800853c:	f021 416e 	bic.w	r1, r1, #3992977408	; 0xee000000
 8008540:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 8008544:	4311      	orrs	r1, r2
 8008546:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8008548:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800854a:	6a61      	ldr	r1, [r4, #36]	; 0x24
  UART_GETCLOCKSOURCE(huart, clocksource);
 800854c:	486c      	ldr	r0, [pc, #432]	; (8008700 <UART_SetConfig+0x2fc>)
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800854e:	f022 020f 	bic.w	r2, r2, #15
 8008552:	430a      	orrs	r2, r1
 8008554:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008556:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 800855a:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800855e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8008562:	f000 80ac 	beq.w	80086be <UART_SetConfig+0x2ba>
 8008566:	d80b      	bhi.n	8008580 <UART_SetConfig+0x17c>
 8008568:	2b00      	cmp	r3, #0
 800856a:	d038      	beq.n	80085de <UART_SetConfig+0x1da>
 800856c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8008570:	d194      	bne.n	800849c <UART_SetConfig+0x98>
        pclk = HAL_RCC_GetSysClockFreq();
 8008572:	f7fe fc53 	bl	8006e1c <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 8008576:	2800      	cmp	r0, #0
 8008578:	f000 8086 	beq.w	8008688 <UART_SetConfig+0x284>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800857c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800857e:	e004      	b.n	800858a <UART_SetConfig+0x186>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008580:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8008584:	d18a      	bne.n	800849c <UART_SetConfig+0x98>
        pclk = (uint32_t) LSE_VALUE;
 8008586:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800858a:	4b5e      	ldr	r3, [pc, #376]	; (8008704 <UART_SetConfig+0x300>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800858c:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800858e:	f833 2011 	ldrh.w	r2, [r3, r1, lsl #1]
 8008592:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8008596:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 800859a:	4299      	cmp	r1, r3
 800859c:	f63f af7e 	bhi.w	800849c <UART_SetConfig+0x98>
 80085a0:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 80085a4:	f63f af7a 	bhi.w	800849c <UART_SetConfig+0x98>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80085a8:	2300      	movs	r3, #0
 80085aa:	4619      	mov	r1, r3
 80085ac:	f7f8 faa6 	bl	8000afc <__aeabi_uldivmod>
 80085b0:	086a      	lsrs	r2, r5, #1
 80085b2:	0203      	lsls	r3, r0, #8
 80085b4:	0209      	lsls	r1, r1, #8
 80085b6:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 80085ba:	1898      	adds	r0, r3, r2
 80085bc:	f141 0100 	adc.w	r1, r1, #0
 80085c0:	462a      	mov	r2, r5
 80085c2:	2300      	movs	r3, #0
 80085c4:	f7f8 fa9a 	bl	8000afc <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80085c8:	4a50      	ldr	r2, [pc, #320]	; (800870c <UART_SetConfig+0x308>)
 80085ca:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 80085ce:	4291      	cmp	r1, r2
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80085d0:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80085d2:	f63f af63 	bhi.w	800849c <UART_SetConfig+0x98>
 80085d6:	e78c      	b.n	80084f2 <UART_SetConfig+0xee>
 80085d8:	4a4d      	ldr	r2, [pc, #308]	; (8008710 <UART_SetConfig+0x30c>)
 80085da:	5cd3      	ldrb	r3, [r2, r3]
  if (UART_INSTANCE_LOWPOWER(huart))
 80085dc:	e794      	b.n	8008508 <UART_SetConfig+0x104>
        pclk = HAL_RCC_GetPCLK1Freq();
 80085de:	f7fe fd5f 	bl	80070a0 <HAL_RCC_GetPCLK1Freq>
        break;
 80085e2:	e7c8      	b.n	8008576 <UART_SetConfig+0x172>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80085e4:	4b46      	ldr	r3, [pc, #280]	; (8008700 <UART_SetConfig+0x2fc>)
 80085e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80085ea:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80085ee:	2b80      	cmp	r3, #128	; 0x80
 80085f0:	d071      	beq.n	80086d6 <UART_SetConfig+0x2d2>
 80085f2:	d861      	bhi.n	80086b8 <UART_SetConfig+0x2b4>
 80085f4:	b33b      	cbz	r3, 8008646 <UART_SetConfig+0x242>
 80085f6:	2b40      	cmp	r3, #64	; 0x40
 80085f8:	f47f af50 	bne.w	800849c <UART_SetConfig+0x98>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80085fc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8008600:	d061      	beq.n	80086c6 <UART_SetConfig+0x2c2>
        pclk = HAL_RCC_GetSysClockFreq();
 8008602:	f7fe fc0b 	bl	8006e1c <HAL_RCC_GetSysClockFreq>
        break;
 8008606:	e760      	b.n	80084ca <UART_SetConfig+0xc6>
    switch (clocksource)
 8008608:	2b08      	cmp	r3, #8
 800860a:	f63f af47 	bhi.w	800849c <UART_SetConfig+0x98>
 800860e:	a201      	add	r2, pc, #4	; (adr r2, 8008614 <UART_SetConfig+0x210>)
 8008610:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008614:	0800864d 	.word	0x0800864d
 8008618:	080086cd 	.word	0x080086cd
 800861c:	080086d3 	.word	0x080086d3
 8008620:	0800849d 	.word	0x0800849d
 8008624:	080086c7 	.word	0x080086c7
 8008628:	0800849d 	.word	0x0800849d
 800862c:	0800849d 	.word	0x0800849d
 8008630:	0800849d 	.word	0x0800849d
 8008634:	08008655 	.word	0x08008655
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008638:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800863c:	d036      	beq.n	80086ac <UART_SetConfig+0x2a8>
 800863e:	e72d      	b.n	800849c <UART_SetConfig+0x98>
        pclk = HAL_RCC_GetPCLK1Freq();
 8008640:	f7fe fd2e 	bl	80070a0 <HAL_RCC_GetPCLK1Freq>
        break;
 8008644:	e741      	b.n	80084ca <UART_SetConfig+0xc6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8008646:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800864a:	d1f9      	bne.n	8008640 <UART_SetConfig+0x23c>
        pclk = HAL_RCC_GetPCLK1Freq();
 800864c:	f7fe fd28 	bl	80070a0 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8008650:	b1d0      	cbz	r0, 8008688 <UART_SetConfig+0x284>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8008652:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008654:	6862      	ldr	r2, [r4, #4]
 8008656:	4b2b      	ldr	r3, [pc, #172]	; (8008704 <UART_SetConfig+0x300>)
 8008658:	f833 1011 	ldrh.w	r1, [r3, r1, lsl #1]
 800865c:	fbb0 f0f1 	udiv	r0, r0, r1
 8008660:	0853      	lsrs	r3, r2, #1
 8008662:	eb03 0340 	add.w	r3, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8008666:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800866a:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800866e:	f1a3 0210 	sub.w	r2, r3, #16
 8008672:	428a      	cmp	r2, r1
 8008674:	f63f af12 	bhi.w	800849c <UART_SetConfig+0x98>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8008678:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 800867c:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800867e:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8008680:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8008684:	4313      	orrs	r3, r2
 8008686:	60cb      	str	r3, [r1, #12]
 8008688:	2000      	movs	r0, #0
 800868a:	e708      	b.n	800849e <UART_SetConfig+0x9a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800868c:	4b1c      	ldr	r3, [pc, #112]	; (8008700 <UART_SetConfig+0x2fc>)
 800868e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8008692:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8008696:	2b20      	cmp	r3, #32
 8008698:	d01d      	beq.n	80086d6 <UART_SetConfig+0x2d2>
 800869a:	d804      	bhi.n	80086a6 <UART_SetConfig+0x2a2>
 800869c:	2b00      	cmp	r3, #0
 800869e:	d0d2      	beq.n	8008646 <UART_SetConfig+0x242>
 80086a0:	2b10      	cmp	r3, #16
 80086a2:	d0ab      	beq.n	80085fc <UART_SetConfig+0x1f8>
 80086a4:	e6fa      	b.n	800849c <UART_SetConfig+0x98>
 80086a6:	2b30      	cmp	r3, #48	; 0x30
 80086a8:	f47f aef8 	bne.w	800849c <UART_SetConfig+0x98>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80086ac:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80086b0:	d0d0      	beq.n	8008654 <UART_SetConfig+0x250>
    switch (clocksource)
 80086b2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80086b6:	e70c      	b.n	80084d2 <UART_SetConfig+0xce>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80086b8:	2bc0      	cmp	r3, #192	; 0xc0
 80086ba:	d0f7      	beq.n	80086ac <UART_SetConfig+0x2a8>
 80086bc:	e6ee      	b.n	800849c <UART_SetConfig+0x98>
 80086be:	4815      	ldr	r0, [pc, #84]	; (8008714 <UART_SetConfig+0x310>)
 80086c0:	e763      	b.n	800858a <UART_SetConfig+0x186>
        pclk = (uint32_t) HSI_VALUE;
 80086c2:	4814      	ldr	r0, [pc, #80]	; (8008714 <UART_SetConfig+0x310>)
 80086c4:	e705      	b.n	80084d2 <UART_SetConfig+0xce>
        pclk = HAL_RCC_GetSysClockFreq();
 80086c6:	f7fe fba9 	bl	8006e1c <HAL_RCC_GetSysClockFreq>
        break;
 80086ca:	e7c1      	b.n	8008650 <UART_SetConfig+0x24c>
        pclk = HAL_RCC_GetPCLK2Freq();
 80086cc:	f7fe fcfa 	bl	80070c4 <HAL_RCC_GetPCLK2Freq>
        break;
 80086d0:	e7be      	b.n	8008650 <UART_SetConfig+0x24c>
        pclk = (uint32_t) HSI_VALUE;
 80086d2:	4810      	ldr	r0, [pc, #64]	; (8008714 <UART_SetConfig+0x310>)
 80086d4:	e7be      	b.n	8008654 <UART_SetConfig+0x250>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80086d6:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
        pclk = (uint32_t) HSI_VALUE;
 80086da:	480e      	ldr	r0, [pc, #56]	; (8008714 <UART_SetConfig+0x310>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80086dc:	f47f aef9 	bne.w	80084d2 <UART_SetConfig+0xce>
 80086e0:	e7b8      	b.n	8008654 <UART_SetConfig+0x250>
 80086e2:	bf00      	nop
 80086e4:	cfff69f3 	.word	0xcfff69f3
 80086e8:	40008000 	.word	0x40008000
 80086ec:	40013800 	.word	0x40013800
 80086f0:	40004400 	.word	0x40004400
 80086f4:	40004800 	.word	0x40004800
 80086f8:	40004c00 	.word	0x40004c00
 80086fc:	40005000 	.word	0x40005000
 8008700:	40021000 	.word	0x40021000
 8008704:	0801a1f0 	.word	0x0801a1f0
 8008708:	0801a1e0 	.word	0x0801a1e0
 800870c:	000ffcff 	.word	0x000ffcff
 8008710:	0801a1dc 	.word	0x0801a1dc
 8008714:	00f42400 	.word	0x00f42400

08008718 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8008718:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800871a:	07da      	lsls	r2, r3, #31
{
 800871c:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800871e:	d506      	bpl.n	800872e <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8008720:	6801      	ldr	r1, [r0, #0]
 8008722:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8008724:	684a      	ldr	r2, [r1, #4]
 8008726:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800872a:	4322      	orrs	r2, r4
 800872c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800872e:	079c      	lsls	r4, r3, #30
 8008730:	d506      	bpl.n	8008740 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8008732:	6801      	ldr	r1, [r0, #0]
 8008734:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8008736:	684a      	ldr	r2, [r1, #4]
 8008738:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800873c:	4322      	orrs	r2, r4
 800873e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8008740:	0759      	lsls	r1, r3, #29
 8008742:	d506      	bpl.n	8008752 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8008744:	6801      	ldr	r1, [r0, #0]
 8008746:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8008748:	684a      	ldr	r2, [r1, #4]
 800874a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800874e:	4322      	orrs	r2, r4
 8008750:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8008752:	071a      	lsls	r2, r3, #28
 8008754:	d506      	bpl.n	8008764 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8008756:	6801      	ldr	r1, [r0, #0]
 8008758:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800875a:	684a      	ldr	r2, [r1, #4]
 800875c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008760:	4322      	orrs	r2, r4
 8008762:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8008764:	06dc      	lsls	r4, r3, #27
 8008766:	d506      	bpl.n	8008776 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8008768:	6801      	ldr	r1, [r0, #0]
 800876a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800876c:	688a      	ldr	r2, [r1, #8]
 800876e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8008772:	4322      	orrs	r2, r4
 8008774:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8008776:	0699      	lsls	r1, r3, #26
 8008778:	d506      	bpl.n	8008788 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800877a:	6801      	ldr	r1, [r0, #0]
 800877c:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800877e:	688a      	ldr	r2, [r1, #8]
 8008780:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8008784:	4322      	orrs	r2, r4
 8008786:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8008788:	065a      	lsls	r2, r3, #25
 800878a:	d509      	bpl.n	80087a0 <UART_AdvFeatureConfig+0x88>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800878c:	6801      	ldr	r1, [r0, #0]
 800878e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8008790:	684a      	ldr	r2, [r1, #4]
 8008792:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8008796:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8008798:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800879c:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800879e:	d00b      	beq.n	80087b8 <UART_AdvFeatureConfig+0xa0>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80087a0:	061b      	lsls	r3, r3, #24
 80087a2:	d506      	bpl.n	80087b2 <UART_AdvFeatureConfig+0x9a>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80087a4:	6802      	ldr	r2, [r0, #0]
 80087a6:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80087a8:	6853      	ldr	r3, [r2, #4]
 80087aa:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80087ae:	430b      	orrs	r3, r1
 80087b0:	6053      	str	r3, [r2, #4]
  }
}
 80087b2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80087b6:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80087b8:	684a      	ldr	r2, [r1, #4]
 80087ba:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80087bc:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80087c0:	4322      	orrs	r2, r4
 80087c2:	604a      	str	r2, [r1, #4]
 80087c4:	e7ec      	b.n	80087a0 <UART_AdvFeatureConfig+0x88>
 80087c6:	bf00      	nop

080087c8 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 80087c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80087cc:	f8dd 8020 	ldr.w	r8, [sp, #32]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80087d0:	6804      	ldr	r4, [r0, #0]
{
 80087d2:	4607      	mov	r7, r0
 80087d4:	460e      	mov	r6, r1
 80087d6:	4615      	mov	r5, r2
 80087d8:	4699      	mov	r9, r3
 80087da:	f1b8 3fff 	cmp.w	r8, #4294967295
 80087de:	d10a      	bne.n	80087f6 <UART_WaitOnFlagUntilTimeout+0x2e>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80087e0:	69e3      	ldr	r3, [r4, #28]
 80087e2:	ea36 0303 	bics.w	r3, r6, r3
 80087e6:	bf0c      	ite	eq
 80087e8:	2301      	moveq	r3, #1
 80087ea:	2300      	movne	r3, #0
 80087ec:	429d      	cmp	r5, r3
 80087ee:	d0f7      	beq.n	80087e0 <UART_WaitOnFlagUntilTimeout+0x18>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 80087f0:	2000      	movs	r0, #0
}
 80087f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80087f6:	69e2      	ldr	r2, [r4, #28]
 80087f8:	ea36 0202 	bics.w	r2, r6, r2
 80087fc:	bf0c      	ite	eq
 80087fe:	2301      	moveq	r3, #1
 8008800:	2300      	movne	r3, #0
 8008802:	42ab      	cmp	r3, r5
 8008804:	d1f4      	bne.n	80087f0 <UART_WaitOnFlagUntilTimeout+0x28>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8008806:	f7fc fe21 	bl	800544c <HAL_GetTick>
 800880a:	eba0 0009 	sub.w	r0, r0, r9
 800880e:	4540      	cmp	r0, r8
 8008810:	d833      	bhi.n	800887a <UART_WaitOnFlagUntilTimeout+0xb2>
 8008812:	f1b8 0f00 	cmp.w	r8, #0
 8008816:	d030      	beq.n	800887a <UART_WaitOnFlagUntilTimeout+0xb2>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8008818:	683c      	ldr	r4, [r7, #0]
 800881a:	6823      	ldr	r3, [r4, #0]
 800881c:	0758      	lsls	r0, r3, #29
 800881e:	4622      	mov	r2, r4
 8008820:	d5db      	bpl.n	80087da <UART_WaitOnFlagUntilTimeout+0x12>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8008822:	69e3      	ldr	r3, [r4, #28]
 8008824:	0519      	lsls	r1, r3, #20
 8008826:	d5d8      	bpl.n	80087da <UART_WaitOnFlagUntilTimeout+0x12>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8008828:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800882c:	6223      	str	r3, [r4, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800882e:	e854 3f00 	ldrex	r3, [r4]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8008832:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008836:	e844 3100 	strex	r1, r3, [r4]
 800883a:	b139      	cbz	r1, 800884c <UART_WaitOnFlagUntilTimeout+0x84>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800883c:	e852 3f00 	ldrex	r3, [r2]
 8008840:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008844:	e842 3100 	strex	r1, r3, [r2]
 8008848:	2900      	cmp	r1, #0
 800884a:	d1f7      	bne.n	800883c <UART_WaitOnFlagUntilTimeout+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800884c:	f102 0308 	add.w	r3, r2, #8
 8008850:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008854:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008858:	f102 0008 	add.w	r0, r2, #8
 800885c:	e840 3100 	strex	r1, r3, [r0]
 8008860:	2900      	cmp	r1, #0
 8008862:	d1f3      	bne.n	800884c <UART_WaitOnFlagUntilTimeout+0x84>
          huart->gState = HAL_UART_STATE_READY;
 8008864:	2320      	movs	r3, #32
 8008866:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
          __HAL_UNLOCK(huart);
 800886a:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 800886e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
          return HAL_TIMEOUT;
 8008872:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8008874:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          return HAL_TIMEOUT;
 8008878:	e7bb      	b.n	80087f2 <UART_WaitOnFlagUntilTimeout+0x2a>
 800887a:	683a      	ldr	r2, [r7, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800887c:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8008880:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008884:	e842 3100 	strex	r1, r3, [r2]
 8008888:	2900      	cmp	r1, #0
 800888a:	d1f7      	bne.n	800887c <UART_WaitOnFlagUntilTimeout+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800888c:	f102 0308 	add.w	r3, r2, #8
 8008890:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008894:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008898:	f102 0008 	add.w	r0, r2, #8
 800889c:	e840 3100 	strex	r1, r3, [r0]
 80088a0:	2900      	cmp	r1, #0
 80088a2:	d1f3      	bne.n	800888c <UART_WaitOnFlagUntilTimeout+0xc4>
        huart->gState = HAL_UART_STATE_READY;
 80088a4:	2320      	movs	r3, #32
 80088a6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        __HAL_UNLOCK(huart);
 80088aa:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 80088ae:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        return HAL_TIMEOUT;
 80088b2:	2003      	movs	r0, #3
 80088b4:	e79d      	b.n	80087f2 <UART_WaitOnFlagUntilTimeout+0x2a>
 80088b6:	bf00      	nop

080088b8 <HAL_UART_Init>:
  if (huart == NULL)
 80088b8:	2800      	cmp	r0, #0
 80088ba:	d066      	beq.n	800898a <HAL_UART_Init+0xd2>
{
 80088bc:	b570      	push	{r4, r5, r6, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 80088be:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 80088c2:	b082      	sub	sp, #8
 80088c4:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 80088c6:	2b00      	cmp	r3, #0
 80088c8:	d04c      	beq.n	8008964 <HAL_UART_Init+0xac>
  __HAL_UART_DISABLE(huart);
 80088ca:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80088cc:	2324      	movs	r3, #36	; 0x24
 80088ce:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 80088d2:	6813      	ldr	r3, [r2, #0]
 80088d4:	f023 0301 	bic.w	r3, r3, #1
  if (UART_SetConfig(huart) == HAL_ERROR)
 80088d8:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 80088da:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80088dc:	f7ff fd92 	bl	8008404 <UART_SetConfig>
 80088e0:	2801      	cmp	r0, #1
 80088e2:	d03c      	beq.n	800895e <HAL_UART_Init+0xa6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80088e4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d135      	bne.n	8008956 <HAL_UART_Init+0x9e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80088ea:	6823      	ldr	r3, [r4, #0]
 80088ec:	6859      	ldr	r1, [r3, #4]
 80088ee:	f421 4190 	bic.w	r1, r1, #18432	; 0x4800
 80088f2:	6059      	str	r1, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80088f4:	6899      	ldr	r1, [r3, #8]
 80088f6:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 80088fa:	6099      	str	r1, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80088fc:	6819      	ldr	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80088fe:	2500      	movs	r5, #0
  __HAL_UART_ENABLE(huart);
 8008900:	f041 0101 	orr.w	r1, r1, #1
 8008904:	6019      	str	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008906:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  tickstart = HAL_GetTick();
 800890a:	f7fc fd9f 	bl	800544c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800890e:	6823      	ldr	r3, [r4, #0]
 8008910:	681a      	ldr	r2, [r3, #0]
 8008912:	0712      	lsls	r2, r2, #28
  tickstart = HAL_GetTick();
 8008914:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8008916:	d40e      	bmi.n	8008936 <HAL_UART_Init+0x7e>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8008918:	681b      	ldr	r3, [r3, #0]
 800891a:	075b      	lsls	r3, r3, #29
 800891c:	d427      	bmi.n	800896e <HAL_UART_Init+0xb6>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800891e:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 8008920:	2220      	movs	r2, #32
 8008922:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8008926:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 800892a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
  return HAL_OK;
 800892e:	4618      	mov	r0, r3
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008930:	66e3      	str	r3, [r4, #108]	; 0x6c
}
 8008932:	b002      	add	sp, #8
 8008934:	bd70      	pop	{r4, r5, r6, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8008936:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800893a:	9300      	str	r3, [sp, #0]
 800893c:	462a      	mov	r2, r5
 800893e:	4603      	mov	r3, r0
 8008940:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8008944:	4620      	mov	r0, r4
 8008946:	f7ff ff3f 	bl	80087c8 <UART_WaitOnFlagUntilTimeout>
 800894a:	b9e0      	cbnz	r0, 8008986 <HAL_UART_Init+0xce>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800894c:	6823      	ldr	r3, [r4, #0]
 800894e:	681b      	ldr	r3, [r3, #0]
 8008950:	075b      	lsls	r3, r3, #29
 8008952:	d40c      	bmi.n	800896e <HAL_UART_Init+0xb6>
 8008954:	e7e3      	b.n	800891e <HAL_UART_Init+0x66>
    UART_AdvFeatureConfig(huart);
 8008956:	4620      	mov	r0, r4
 8008958:	f7ff fede 	bl	8008718 <UART_AdvFeatureConfig>
 800895c:	e7c5      	b.n	80088ea <HAL_UART_Init+0x32>
    return HAL_ERROR;
 800895e:	2001      	movs	r0, #1
}
 8008960:	b002      	add	sp, #8
 8008962:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8008964:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8008968:	f7fc fc14 	bl	8005194 <HAL_UART_MspInit>
 800896c:	e7ad      	b.n	80088ca <HAL_UART_Init+0x12>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800896e:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8008972:	9300      	str	r3, [sp, #0]
 8008974:	2200      	movs	r2, #0
 8008976:	4633      	mov	r3, r6
 8008978:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800897c:	4620      	mov	r0, r4
 800897e:	f7ff ff23 	bl	80087c8 <UART_WaitOnFlagUntilTimeout>
 8008982:	2800      	cmp	r0, #0
 8008984:	d0cb      	beq.n	800891e <HAL_UART_Init+0x66>
      return HAL_TIMEOUT;
 8008986:	2003      	movs	r0, #3
 8008988:	e7d3      	b.n	8008932 <HAL_UART_Init+0x7a>
    return HAL_ERROR;
 800898a:	2001      	movs	r0, #1
}
 800898c:	4770      	bx	lr
 800898e:	bf00      	nop

08008990 <HAL_UARTEx_DisableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8008990:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8008994:	2b01      	cmp	r3, #1
 8008996:	d017      	beq.n	80089c8 <HAL_UARTEx_DisableFifoMode+0x38>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008998:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800899a:	2324      	movs	r3, #36	; 0x24
{
 800899c:	b410      	push	{r4}
  huart->gState = HAL_UART_STATE_BUSY;
 800899e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80089a2:	6811      	ldr	r1, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80089a4:	6814      	ldr	r4, [r2, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 80089a6:	2300      	movs	r3, #0
  __HAL_UART_DISABLE(huart);
 80089a8:	f024 0401 	bic.w	r4, r4, #1
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 80089ac:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
  __HAL_UART_DISABLE(huart);
 80089b0:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 80089b2:	6643      	str	r3, [r0, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80089b4:	6011      	str	r1, [r2, #0]

  huart->gState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 80089b6:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_READY;
 80089ba:	2220      	movs	r2, #32
 80089bc:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84

  return HAL_OK;
}
 80089c0:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 80089c4:	4618      	mov	r0, r3
}
 80089c6:	4770      	bx	lr
  __HAL_LOCK(huart);
 80089c8:	2002      	movs	r0, #2
}
 80089ca:	4770      	bx	lr

080089cc <HAL_UARTEx_SetTxFifoThreshold>:
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 80089cc:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 80089d0:	2a01      	cmp	r2, #1
 80089d2:	d037      	beq.n	8008a44 <HAL_UARTEx_SetTxFifoThreshold+0x78>

  huart->gState = HAL_UART_STATE_BUSY;
 80089d4:	4603      	mov	r3, r0

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80089d6:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80089d8:	2024      	movs	r0, #36	; 0x24
{
 80089da:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 80089dc:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80089e0:	6814      	ldr	r4, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80089e2:	6810      	ldr	r0, [r2, #0]
 80089e4:	f020 0001 	bic.w	r0, r0, #1
 80089e8:	6010      	str	r0, [r2, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80089ea:	6890      	ldr	r0, [r2, #8]
 80089ec:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
 80089f0:	4301      	orrs	r1, r0
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80089f2:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80089f4:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80089f6:	b310      	cbz	r0, 8008a3e <HAL_UARTEx_SetTxFifoThreshold+0x72>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80089f8:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80089fa:	6890      	ldr	r0, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
 80089fc:	4d12      	ldr	r5, [pc, #72]	; (8008a48 <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80089fe:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8008a02:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a06:	4911      	ldr	r1, [pc, #68]	; (8008a4c <HAL_UARTEx_SetTxFifoThreshold+0x80>)
 8008a08:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a0c:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8008a10:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8008a14:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a18:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a1a:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a1c:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a20:	fbb1 f1f5 	udiv	r1, r1, r5
 8008a24:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 8008a28:	2100      	movs	r1, #0
 8008a2a:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 8008a2e:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8008a30:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8008a32:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
  return HAL_OK;
 8008a36:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8008a38:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
}
 8008a3c:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8008a3e:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8008a40:	4608      	mov	r0, r1
 8008a42:	e7ef      	b.n	8008a24 <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8008a44:	2002      	movs	r0, #2
}
 8008a46:	4770      	bx	lr
 8008a48:	0801a208 	.word	0x0801a208
 8008a4c:	0801a210 	.word	0x0801a210

08008a50 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 8008a50:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8008a54:	2a01      	cmp	r2, #1
 8008a56:	d037      	beq.n	8008ac8 <HAL_UARTEx_SetRxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 8008a58:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008a5a:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8008a5c:	2024      	movs	r0, #36	; 0x24
{
 8008a5e:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8008a60:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008a64:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8008a66:	6810      	ldr	r0, [r2, #0]
 8008a68:	f020 0001 	bic.w	r0, r0, #1
 8008a6c:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8008a6e:	6890      	ldr	r0, [r2, #8]
 8008a70:	f020 6060 	bic.w	r0, r0, #234881024	; 0xe000000
 8008a74:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8008a76:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8008a78:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8008a7a:	b310      	cbz	r0, 8008ac2 <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8008a7c:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8008a7e:	6890      	ldr	r0, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 8008a80:	4d12      	ldr	r5, [pc, #72]	; (8008acc <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a82:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8008a86:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a8a:	4911      	ldr	r1, [pc, #68]	; (8008ad0 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
 8008a8c:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a90:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8008a94:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8008a98:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a9c:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a9e:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008aa0:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008aa4:	fbb1 f1f5 	udiv	r1, r1, r5
 8008aa8:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 8008aac:	2100      	movs	r1, #0
 8008aae:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 8008ab2:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8008ab4:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8008ab6:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
  return HAL_OK;
 8008aba:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8008abc:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
}
 8008ac0:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8008ac2:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8008ac4:	4608      	mov	r0, r1
 8008ac6:	e7ef      	b.n	8008aa8 <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8008ac8:	2002      	movs	r0, #2
}
 8008aca:	4770      	bx	lr
 8008acc:	0801a208 	.word	0x0801a208
 8008ad0:	0801a210 	.word	0x0801a210

08008ad4 <VBS_GetAvBusVoltage_d>:
  }
  return (temp_avBusVoltage_d);
#else
  return (pHandle->AvBusVoltage_d);
#endif
}
 8008ad4:	88c0      	ldrh	r0, [r0, #6]
 8008ad6:	4770      	bx	lr

08008ad8 <VBS_GetAvBusVoltage_V>:
    temp = 0U;
  }
  else
  {
#endif
    temp = (uint32_t)(pHandle->AvBusVoltage_d);
 8008ad8:	88c3      	ldrh	r3, [r0, #6]
    temp *= pHandle->ConversionFactor;
 8008ada:	8840      	ldrh	r0, [r0, #2]
 8008adc:	fb03 f000 	mul.w	r0, r3, r0
    temp /= 65536U;
#ifdef NULL_PTR_CHECK_BUS_VOLT
  }
#endif
  return ((uint16_t)temp);
}
 8008ae0:	0c00      	lsrs	r0, r0, #16
 8008ae2:	4770      	bx	lr

08008ae4 <Circle_Limitation>:
  *  @f$v_q = \sqrt(MaxModule^2-v_d^2\ ) @f$

  *
  */
__weak qd_t Circle_Limitation(const CircleLimitation_Handle_t *pHandle, qd_t Vqd)
{
 8008ae4:	b570      	push	{r4, r5, r6, lr}
    int32_t square_limit;
    int32_t vd_square_limit;
    int32_t new_q;
    int32_t new_d;

    maxModule = (int32_t)pHandle->MaxModule;
 8008ae6:	8803      	ldrh	r3, [r0, #0]
 8008ae8:	140d      	asrs	r5, r1, #16
{
 8008aea:	b084      	sub	sp, #16
 8008aec:	b20c      	sxth	r4, r1

    square_q = ((int32_t)(Vqd.q)) * Vqd.q;
    square_d = ((int32_t)(Vqd.d)) * Vqd.d;
 8008aee:	fb05 f205 	mul.w	r2, r5, r5
    square_limit = maxModule * maxModule;
 8008af2:	fb03 f303 	mul.w	r3, r3, r3
{
 8008af6:	9101      	str	r1, [sp, #4]
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
    square_sum = square_q + square_d;
 8008af8:	fb04 2104 	mla	r1, r4, r4, r2

    if (square_sum > square_limit)
 8008afc:	428b      	cmp	r3, r1
 8008afe:	da10      	bge.n	8008b22 <Circle_Limitation+0x3e>
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
 8008b00:	8846      	ldrh	r6, [r0, #2]
 8008b02:	fb06 f006 	mul.w	r0, r6, r6
    {
      if (square_d <= vd_square_limit)
 8008b06:	4282      	cmp	r2, r0
 8008b08:	dd14      	ble.n	8008b34 <Circle_Limitation+0x50>
        new_d = Vqd.d;
      }
      else
      {
        new_d = (int32_t)pHandle->MaxVd;
        if (Vqd.d < 0)
 8008b0a:	2d00      	cmp	r5, #0
#if defined CIRCLE_LIMITATION_SQRT_M0
        square_temp = (square_limit - vd_square_limit) / 1048576;
        new_q = SqrtTable[square_temp];
#else
        square_temp = square_limit - vd_square_limit;
        new_q = MCM_Sqrt(square_temp);
 8008b0c:	eba3 0000 	sub.w	r0, r3, r0
          new_d = -new_d;
 8008b10:	bfb8      	it	lt
 8008b12:	4276      	neglt	r6, r6
        new_q = MCM_Sqrt(square_temp);
 8008b14:	f7f9 fade 	bl	80020d4 <MCM_Sqrt>
#endif
        if (Vqd.q < 0)
 8008b18:	2c00      	cmp	r4, #0
        {
          new_q = - new_q;
 8008b1a:	bfb8      	it	lt
 8008b1c:	4240      	neglt	r0, r0
        {
          /* Nothing to do */
        }
      }
      local_vqd.q = (int16_t)new_q;
      local_vqd.d = (int16_t)new_d;
 8008b1e:	b235      	sxth	r5, r6
      local_vqd.q = (int16_t)new_q;
 8008b20:	b204      	sxth	r4, r0
    }
#ifdef NULL_PTR_CHECK_CRC_LIM
  }
#endif
  return (local_vqd);
 8008b22:	b2a4      	uxth	r4, r4
 8008b24:	2000      	movs	r0, #0
 8008b26:	f364 000f 	bfi	r0, r4, #0, #16
 8008b2a:	b2ad      	uxth	r5, r5
 8008b2c:	f365 401f 	bfi	r0, r5, #16, #16
}
 8008b30:	b004      	add	sp, #16
 8008b32:	bd70      	pop	{r4, r5, r6, pc}
        new_q = MCM_Sqrt(square_temp);
 8008b34:	1a98      	subs	r0, r3, r2
 8008b36:	f7f9 facd 	bl	80020d4 <MCM_Sqrt>
        if (Vqd.q < 0)
 8008b3a:	2c00      	cmp	r4, #0
 8008b3c:	daf0      	bge.n	8008b20 <Circle_Limitation+0x3c>
          new_q = -new_q;
 8008b3e:	4240      	negs	r0, r0
 8008b40:	e7ee      	b.n	8008b20 <Circle_Limitation+0x3c>
 8008b42:	bf00      	nop

08008b44 <EAC_Init>:
  {
#endif
    pHandle->pSTC = pSTC;
    pHandle->pVSS = pVSS;
    pHandle->pENC = pENC;
    pHandle->EncAligned = false;
 8008b44:	f04f 0c00 	mov.w	ip, #0
    pHandle->pVSS = pVSS;
 8008b48:	e9c0 1200 	strd	r1, r2, [r0]
    pHandle->pENC = pENC;
 8008b4c:	6083      	str	r3, [r0, #8]
    pHandle->EncAligned = false;
 8008b4e:	f8a0 c00e 	strh.w	ip, [r0, #14]
    pHandle->EncRestart = false;
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008b52:	4770      	bx	lr

08008b54 <EAC_StartAlignment>:
  * It configures the VSS (Virtual Speed Sensor) with the required angle and sets the
  * STC (Speed and Torque Controller) to execute the required torque ramp.
  * @param  pHandle: handler of the current instance of the EncAlignCtrl component.
  */
__weak void EAC_StartAlignment(EncAlign_Handle_t *pHandle)
{
 8008b54:	b510      	push	{r4, lr}
  {
#endif
    uint32_t wAux;

    /* Set pVSS mechanical speed to zero */
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 8008b56:	2200      	movs	r2, #0
{
 8008b58:	4604      	mov	r4, r0
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 8008b5a:	4611      	mov	r1, r2
 8008b5c:	6840      	ldr	r0, [r0, #4]
 8008b5e:	f001 ff65 	bl	800aa2c <VSS_SetMecAcceleration>

    /* Set pVSS mechanical angle */
    VSS_SetMecAngle(pHandle->pVSS, pHandle->hElAngle);
 8008b62:	f9b4 1014 	ldrsh.w	r1, [r4, #20]
 8008b66:	6860      	ldr	r0, [r4, #4]
 8008b68:	f001 ff58 	bl	800aa1c <VSS_SetMecAngle>

    /* Set pSTC in MCM_TORQUE_MODE */
    STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 8008b6c:	6820      	ldr	r0, [r4, #0]
 8008b6e:	2104      	movs	r1, #4
 8008b70:	f001 fc52 	bl	800a418 <STC_SetControlMode>

    /* Set starting torque to Zero */
    (void)STC_ExecRamp(pHandle->pSTC, 0, 0U);
 8008b74:	2200      	movs	r2, #0
 8008b76:	4611      	mov	r1, r2
 8008b78:	6820      	ldr	r0, [r4, #0]
 8008b7a:	f001 fc51 	bl	800a420 <STC_ExecRamp>

    /* Execute the torque ramp */
    (void)STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, (uint32_t)pHandle->hDurationms);
 8008b7e:	8ae2      	ldrh	r2, [r4, #22]
 8008b80:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8008b84:	6820      	ldr	r0, [r4, #0]
 8008b86:	f001 fc4b 	bl	800a420 <STC_ExecRamp>
    /* Compute hRemainingTicks, the number of thick of alignment phase */
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 8008b8a:	8ae3      	ldrh	r3, [r4, #22]
 8008b8c:	8a21      	ldrh	r1, [r4, #16]
    wAux /= 1000U;
 8008b8e:	4a04      	ldr	r2, [pc, #16]	; (8008ba0 <EAC_StartAlignment+0x4c>)
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 8008b90:	fb01 f303 	mul.w	r3, r1, r3
    wAux /= 1000U;
 8008b94:	fba2 2303 	umull	r2, r3, r2, r3
 8008b98:	099b      	lsrs	r3, r3, #6
    pHandle->hRemainingTicks = (uint16_t)wAux;
    pHandle->hRemainingTicks++;
 8008b9a:	3301      	adds	r3, #1
 8008b9c:	81a3      	strh	r3, [r4, #12]
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008b9e:	bd10      	pop	{r4, pc}
 8008ba0:	10624dd3 	.word	0x10624dd3

08008ba4 <EAC_Exec>:
    retVal = false;
  }
  else
  {
#endif
    if (pHandle->hRemainingTicks > 0U)
 8008ba4:	8983      	ldrh	r3, [r0, #12]
 8008ba6:	b13b      	cbz	r3, 8008bb8 <EAC_Exec+0x14>
    {
      pHandle->hRemainingTicks--;
 8008ba8:	3b01      	subs	r3, #1
 8008baa:	b29b      	uxth	r3, r3
{
 8008bac:	b510      	push	{r4, lr}
 8008bae:	4604      	mov	r4, r0
      pHandle->hRemainingTicks--;
 8008bb0:	8183      	strh	r3, [r0, #12]

      if (0U == pHandle->hRemainingTicks)
 8008bb2:	b11b      	cbz	r3, 8008bbc <EAC_Exec+0x18>
        pHandle->EncAligned = true;
        retVal = true;
      }
      else
      {
        retVal = false;
 8008bb4:	2000      	movs	r0, #0
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif

  return (retVal);
}
 8008bb6:	bd10      	pop	{r4, pc}
  bool retVal = true;
 8008bb8:	2001      	movs	r0, #1
}
 8008bba:	4770      	bx	lr
        ENC_SetMecAngle(pHandle->pENC, pHandle->hElAngle / ((int16_t)pHandle->bElToMecRatio));
 8008bbc:	7e03      	ldrb	r3, [r0, #24]
 8008bbe:	f9b0 1014 	ldrsh.w	r1, [r0, #20]
 8008bc2:	6880      	ldr	r0, [r0, #8]
 8008bc4:	fb91 f1f3 	sdiv	r1, r1, r3
 8008bc8:	f000 f942 	bl	8008e50 <ENC_SetMecAngle>
        pHandle->EncAligned = true;
 8008bcc:	2001      	movs	r0, #1
 8008bce:	73a0      	strb	r0, [r4, #14]
}
 8008bd0:	bd10      	pop	{r4, pc}
 8008bd2:	bf00      	nop

08008bd4 <EAC_IsAligned>:
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  return ((NULL == pHandle) ? false : pHandle->EncAligned);
#else
  return (pHandle->EncAligned);
#endif
}
 8008bd4:	7b80      	ldrb	r0, [r0, #14]
 8008bd6:	4770      	bx	lr

08008bd8 <EAC_SetRestartState>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->EncRestart = restart;
 8008bd8:	73c1      	strb	r1, [r0, #15]
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008bda:	4770      	bx	lr

08008bdc <ENC_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008bdc:	6a03      	ldr	r3, [r0, #32]
#endif
    /* Reset counter */
    LL_TIM_SetCounter(TIMx, 0);

    /*Calculations of convenience*/
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008bde:	f8b0 c06e 	ldrh.w	ip, [r0, #110]	; 0x6e
  SET_BIT(TIMx->CR1, TIM_CR1_UIFREMAP);
 8008be2:	681a      	ldr	r2, [r3, #0]
 8008be4:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
{
 8008be8:	b410      	push	{r4}
 8008bea:	601a      	str	r2, [r3, #0]
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 8008bec:	f8b0 206c 	ldrh.w	r2, [r0, #108]	; 0x6c
 8008bf0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008bf4:	0052      	lsls	r2, r2, #1
  WRITE_REG(TIMx->CNT, Counter);
 8008bf6:	2100      	movs	r1, #0
 8008bf8:	6259      	str	r1, [r3, #36]	; 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008bfa:	f04f 34ff 	mov.w	r4, #4294967295
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 8008bfe:	6242      	str	r2, [r0, #36]	; 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008c00:	fbb4 f4fc 	udiv	r4, r4, ip
 8008c04:	6684      	str	r4, [r0, #104]	; 0x68
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008c06:	699c      	ldr	r4, [r3, #24]
 8008c08:	f8b0 207a 	ldrh.w	r2, [r0, #122]	; 0x7a
 8008c0c:	f024 0cf0 	bic.w	ip, r4, #240	; 0xf0
 8008c10:	ea42 020c 	orr.w	r2, r2, ip
 8008c14:	619a      	str	r2, [r3, #24]
 8008c16:	699a      	ldr	r2, [r3, #24]
 8008c18:	f8b0 407a 	ldrh.w	r4, [r0, #122]	; 0x7a
 8008c1c:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8008c20:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008c24:	f06f 0401 	mvn.w	r4, #1
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008c28:	619a      	str	r2, [r3, #24]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008c2a:	611c      	str	r4, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008c2c:	68da      	ldr	r2, [r3, #12]
 8008c2e:	f042 0201 	orr.w	r2, r2, #1
 8008c32:	60da      	str	r2, [r3, #12]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8008c34:	681a      	ldr	r2, [r3, #0]
 8008c36:	f042 0201 	orr.w	r2, r2, #1
 8008c3a:	601a      	str	r2, [r3, #0]

    /* Enable the counting timer */
    LL_TIM_EnableCounter(TIMx);

    /* Erase speed buffer */
    bufferSize = pHandle->SpeedBufferSize;
 8008c3c:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74

    for (index = 0U; index < bufferSize; index++)
 8008c40:	b12a      	cbz	r2, 8008c4e <ENC_Init+0x72>
      pHandle->DeltaCapturesBuffer[index] = 0;
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008c42:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->DeltaCapturesBuffer[index] = 0;
 8008c46:	0092      	lsls	r2, r2, #2
 8008c48:	3028      	adds	r0, #40	; 0x28
 8008c4a:	f004 bd5f 	b.w	800d70c <memset>
}
 8008c4e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008c52:	4770      	bx	lr

08008c54 <ENC_Clear>:
  *         This function must be called before starting the motor to initialize
  *         the speed measurement process.
  * @param  pHandle: handler of the current instance of the encoder component
  */
__weak void ENC_Clear(ENCODER_Handle_t *pHandle)
{
 8008c54:	b510      	push	{r4, lr}
  else
  {
#endif
    uint8_t index;

    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 8008c56:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
{
 8008c5a:	4604      	mov	r4, r0
    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 8008c5c:	b122      	cbz	r2, 8008c68 <ENC_Clear+0x14>
    {
      pHandle->DeltaCapturesBuffer[index] = 0;
 8008c5e:	0092      	lsls	r2, r2, #2
 8008c60:	2100      	movs	r1, #0
 8008c62:	3028      	adds	r0, #40	; 0x28
 8008c64:	f004 fd52 	bl	800d70c <memset>
    }
    pHandle->SensorIsReliable = true;
 8008c68:	2301      	movs	r3, #1
 8008c6a:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008c6e:	bd10      	pop	{r4, pc}

08008c70 <ENC_CalcAngle>:
  *         of the instantaneous value of the timer counter.
  * @param  pHandle: handler of the current instance of the encoder component
  * @retval Measured electrical angle in [s16degree](measurement_units.md) format.
  */
__weak int16_t ENC_CalcAngle(ENCODER_Handle_t *pHandle)
{
 8008c70:	b410      	push	{r4}
    int16_t mecAngle; /* s16degree format */
    uint32_t uwtemp1;
    int32_t wtemp1;
    /* PR 52926 We need to keep only the 16 LSB, bit 31 could be at 1
     if the overflow occurs just after the entry in the High frequency task */
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 8008c72:	6a03      	ldr	r3, [r0, #32]
 8008c74:	6e84      	ldr	r4, [r0, #104]	; 0x68
  return (uint32_t)(READ_REG(TIMx->CNT));
 8008c76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    wtemp1 = (int32_t)uwtemp1 / 65536;
#endif
    /* Computes and stores the rotor mechanical angle */
    mecAngle = (int16_t)wtemp1;

    int16_t hMecAnglePrev = pHandle->_Super.hMecAngle;
 8008c78:	f9b0 1006 	ldrsh.w	r1, [r0, #6]

    pHandle->_Super.hMecAngle = mecAngle;

    /* Computes and stores the rotor electrical angle */
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c7c:	7842      	ldrb	r2, [r0, #1]
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 8008c7e:	b29b      	uxth	r3, r3
 8008c80:	fb04 f303 	mul.w	r3, r4, r3
    wtemp1 = (int32_t)uwtemp1 >> 16U;  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8008c84:	141b      	asrs	r3, r3, #16
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c86:	fb03 f202 	mul.w	r2, r3, r2

    pHandle->_Super.hElAngle = elAngle;

    int16_t hMecSpeedDpp = mecAngle - hMecAnglePrev;
 8008c8a:	1a59      	subs	r1, r3, r1
    mecAngle = (int16_t)wtemp1;
 8008c8c:	80c3      	strh	r3, [r0, #6]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c8e:	6883      	ldr	r3, [r0, #8]
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  /*Returns rotor electrical angle*/
  return (elAngle);
}
 8008c90:	f85d 4b04 	ldr.w	r4, [sp], #4
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c94:	b212      	sxth	r2, r2
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c96:	fa03 f381 	sxtah	r3, r3, r1
    pHandle->_Super.hElAngle = elAngle;
 8008c9a:	8082      	strh	r2, [r0, #4]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c9c:	6083      	str	r3, [r0, #8]
}
 8008c9e:	4610      	mov	r0, r2
 8008ca0:	4770      	bx	lr
 8008ca2:	bf00      	nop

08008ca4 <ENC_CalcAvrgMecSpeedUnit>:
  * @param  pMecSpeedUnit pointer used to return the rotor average mechanical speed
  *         expressed in the unit defined by #SPEED_UNIT
  * @retval true = sensor information is reliable. false = sensor information is not reliable
  */
__weak bool ENC_CalcAvrgMecSpeedUnit(ENCODER_Handle_t *pHandle, int16_t *pMecSpeedUnit)
{
 8008ca4:	b5f0      	push	{r4, r5, r6, r7, lr}
    int32_t wtemp2;
    uint32_t OverflowCntSample;
    uint32_t CntCapture;
    uint32_t directionSample;
    int32_t wOverallAngleVariation = 0;
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008ca6:	6a03      	ldr	r3, [r0, #32]
    uint8_t bBufferSize = pHandle->SpeedBufferSize;
 8008ca8:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008cac:	68dc      	ldr	r4, [r3, #12]
 8008cae:	f024 0401 	bic.w	r4, r4, #1
 8008cb2:	60dc      	str	r4, [r3, #12]
  return (uint32_t)(READ_REG(TIMx->CNT));
 8008cb4:	6a5c      	ldr	r4, [r3, #36]	; 0x24
#ifdef TIM_CNT_UIFCPY
    /* disable Interrupt generation */
    LL_TIM_DisableIT_UPDATE(TIMx);
#endif
    CntCapture = LL_TIM_GetCounter(TIMx);
    OverflowCntSample = pHandle->TimerOverflowNb;
 8008cb6:	f8b0 c070 	ldrh.w	ip, [r0, #112]	; 0x70
    pHandle->TimerOverflowNb = 0;
 8008cba:	2500      	movs	r5, #0
 8008cbc:	f8a0 5070 	strh.w	r5, [r0, #112]	; 0x70
    directionSample = LL_TIM_GetDirection(TIMx);
#ifdef TIM_CNT_UIFCPY
    OFbit = __LL_TIM_GETFLAG_UIFCPY(CntCapture);
    if (0U == OFbit)
 8008cc0:	0fe5      	lsrs	r5, r4, #31
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008cc2:	bf18      	it	ne
 8008cc4:	f06f 0701 	mvnne.w	r7, #1
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 8008cc8:	681e      	ldr	r6, [r3, #0]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008cca:	bf18      	it	ne
 8008ccc:	611f      	strne	r7, [r3, #16]
    OverflowCntSample = pHandle->TimerOverflowNb;
 8008cce:	fa1f fc8c 	uxth.w	ip, ip

    /* If UIFCPY is not present, OverflowCntSample can not be used safely for
    speed computation, but we still use it to check that we do not exceed one overflow
    (sample frequency not less than mechanical motor speed */

    if ((OverflowCntSample + OFbit) > ENC_MAX_OVERFLOW_NB)
 8008cd2:	4465      	add	r5, ip
    CLEAR_BIT(CntCapture, TIM_CNT_UIFCPY);
 8008cd4:	f024 4c00 	bic.w	ip, r4, #2147483648	; 0x80000000
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008cd8:	68dc      	ldr	r4, [r3, #12]
    if ((OverflowCntSample + OFbit) > ENC_MAX_OVERFLOW_NB)
 8008cda:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8008cde:	f044 0401 	orr.w	r4, r4, #1
 8008ce2:	60dc      	str	r4, [r3, #12]
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 8008ce4:	f006 0610 	and.w	r6, r6, #16
    {
      pHandle->TimerOverflowError = true;
 8008ce8:	bf8a      	itet	hi
 8008cea:	2401      	movhi	r4, #1
    {
      /* Nothing to do */
    }

    /* Checks the reliability status, then stores and returns it */
    if (pHandle->TimerOverflowError)
 8008cec:	f890 407d 	ldrbls.w	r4, [r0, #125]	; 0x7d
      pHandle->TimerOverflowError = true;
 8008cf0:	f880 407d 	strbhi.w	r4, [r0, #125]	; 0x7d
    if (LL_TIM_COUNTERDIRECTION_DOWN == directionSample)
 8008cf4:	2e00      	cmp	r6, #0
 8008cf6:	f000 8093 	beq.w	8008e20 <ENC_CalcAvrgMecSpeedUnit+0x17c>
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008cfa:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008cfe:	f8b0 3072 	ldrh.w	r3, [r0, #114]	; 0x72
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008d02:	f8b0 e06e 	ldrh.w	lr, [r0, #110]	; 0x6e
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008d06:	360a      	adds	r6, #10
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008d08:	ebac 0303 	sub.w	r3, ip, r3
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008d0c:	fb0e 3315 	mls	r3, lr, r5, r3
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008d10:	f840 3026 	str.w	r3, [r0, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d14:	2a00      	cmp	r2, #0
 8008d16:	f000 8093 	beq.w	8008e40 <ENC_CalcAvrgMecSpeedUnit+0x19c>
 8008d1a:	2a01      	cmp	r2, #1
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d1c:	6a83      	ldr	r3, [r0, #40]	; 0x28
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d1e:	d039      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d20:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d22:	2a02      	cmp	r2, #2
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d24:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d26:	d035      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d28:	6b05      	ldr	r5, [r0, #48]	; 0x30
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d2a:	2a03      	cmp	r2, #3
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d2c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d2e:	d031      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d30:	6b45      	ldr	r5, [r0, #52]	; 0x34
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d32:	2a04      	cmp	r2, #4
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d34:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d36:	d02d      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d38:	6b85      	ldr	r5, [r0, #56]	; 0x38
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d3a:	2a05      	cmp	r2, #5
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d3c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d3e:	d029      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d40:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d42:	2a06      	cmp	r2, #6
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d44:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d46:	d025      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d48:	6c05      	ldr	r5, [r0, #64]	; 0x40
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d4a:	2a07      	cmp	r2, #7
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d4c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d4e:	d021      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d50:	6c45      	ldr	r5, [r0, #68]	; 0x44
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d52:	2a08      	cmp	r2, #8
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d54:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d56:	d01d      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d58:	6c85      	ldr	r5, [r0, #72]	; 0x48
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d5a:	2a09      	cmp	r2, #9
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d5c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d5e:	d019      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d60:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d62:	2a0a      	cmp	r2, #10
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d64:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d66:	d015      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d68:	6d05      	ldr	r5, [r0, #80]	; 0x50
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d6a:	2a0b      	cmp	r2, #11
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d6c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d6e:	d011      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d70:	6d45      	ldr	r5, [r0, #84]	; 0x54
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d72:	2a0c      	cmp	r2, #12
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d74:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d76:	d00d      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d78:	6d85      	ldr	r5, [r0, #88]	; 0x58
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d7a:	2a0d      	cmp	r2, #13
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d7c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d7e:	d009      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d80:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d82:	2a0e      	cmp	r2, #14
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d84:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d86:	d005      	beq.n	8008d94 <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d88:	6e05      	ldr	r5, [r0, #96]	; 0x60
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d8a:	2a0f      	cmp	r2, #15
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d8c:	442b      	add	r3, r5
 8008d8e:	bf1c      	itt	ne
 8008d90:	6e45      	ldrne	r5, [r0, #100]	; 0x64
 8008d92:	195b      	addne	r3, r3, r5
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 8008d94:	6a46      	ldr	r6, [r0, #36]	; 0x24
    wtemp2 = ((int32_t)pHandle->PulseNumber) * ((int32_t)pHandle->SpeedBufferSize);
 8008d96:	fb0e f502 	mul.w	r5, lr, r2
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 8008d9a:	fb06 f303 	mul.w	r3, r6, r3
    wtemp1 = ((0 == wtemp2) ? wtemp1 : (wtemp1 / wtemp2));
 8008d9e:	b10d      	cbz	r5, 8008da4 <ENC_CalcAvrgMecSpeedUnit+0x100>
 8008da0:	fb93 f3f5 	sdiv	r3, r3, r5
    *pMecSpeedUnit = (int16_t)wtemp1;
 8008da4:	b21e      	sxth	r6, r3
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008da6:	b29b      	uxth	r3, r3
    *pMecSpeedUnit = (int16_t)wtemp1;
 8008da8:	800e      	strh	r6, [r1, #0]
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008daa:	f890 507c 	ldrb.w	r5, [r0, #124]	; 0x7c
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008dae:	8987      	ldrh	r7, [r0, #12]
    pHandle->DeltaCapturesIndex++;
 8008db0:	f890 e07c 	ldrb.w	lr, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008db4:	350a      	adds	r5, #10
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008db6:	1bdb      	subs	r3, r3, r7
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008db8:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008dbc:	8243      	strh	r3, [r0, #18]
    pHandle->DeltaCapturesIndex++;
 8008dbe:	f10e 0e01 	add.w	lr, lr, #1
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008dc2:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wtemp1;
 8008dc6:	8186      	strh	r6, [r0, #12]
    pHandle->DeltaCapturesIndex++;
 8008dc8:	fa5f fe8e 	uxtb.w	lr, lr
 8008dcc:	f880 e07c 	strb.w	lr, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008dd0:	fb05 f303 	mul.w	r3, r5, r3
             * ((int32_t)pHandle->_Super.bElToMecRatio);
 8008dd4:	7845      	ldrb	r5, [r0, #1]
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 8008dd6:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008dda:	fb05 f303 	mul.w	r3, r5, r3
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008dde:	f64f 77fe 	movw	r7, #65534	; 0xfffe
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008de2:	69c5      	ldr	r5, [r0, #28]
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008de4:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8008de8:	45bc      	cmp	ip, r7
 8008dea:	bf88      	it	hi
 8008dec:	46f4      	movhi	ip, lr
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 8008dee:	4296      	cmp	r6, r2
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008df0:	f8a0 c072 	strh.w	ip, [r0, #114]	; 0x72
    wtemp1 /= ((int32_t)pHandle->PulseNumber);
 8008df4:	f8b0 c06e 	ldrh.w	ip, [r0, #110]	; 0x6e
 8008df8:	fb93 f3fc 	sdiv	r3, r3, ip
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008dfc:	fb05 f303 	mul.w	r3, r5, r3
    wtemp1 /= ((int32_t)pHandle->_Super.hMeasurementFrequency);
 8008e00:	8b45      	ldrh	r5, [r0, #26]
 8008e02:	fb93 f3f5 	sdiv	r3, r3, r5
    pHandle->_Super.hElSpeedDpp = (int16_t)wtemp1;
 8008e06:	81c3      	strh	r3, [r0, #14]
      pHandle->DeltaCapturesIndex = 0U;
 8008e08:	bf24      	itt	cs
 8008e0a:	2300      	movcs	r3, #0
 8008e0c:	f880 307c 	strbcs.w	r3, [r0, #124]	; 0x7c
    if (pHandle->TimerOverflowError)
 8008e10:	b1cc      	cbz	r4, 8008e46 <ENC_CalcAvrgMecSpeedUnit+0x1a2>
    {
      bReliability = false;
      pHandle->SensorIsReliable = false;
      pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 8008e12:	78c2      	ldrb	r2, [r0, #3]
 8008e14:	7002      	strb	r2, [r0, #0]
      pHandle->SensorIsReliable = false;
 8008e16:	2300      	movs	r3, #0
 8008e18:	f880 3075 	strb.w	r3, [r0, #117]	; 0x75
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  return (bReliability);
}
 8008e1c:	4618      	mov	r0, r3
 8008e1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008e20:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008e24:	f8b0 3072 	ldrh.w	r3, [r0, #114]	; 0x72
        + ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008e28:	f8b0 e06e 	ldrh.w	lr, [r0, #110]	; 0x6e
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008e2c:	360a      	adds	r6, #10
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008e2e:	ebac 0303 	sub.w	r3, ip, r3
        + ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008e32:	fb0e 3305 	mla	r3, lr, r5, r3
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008e36:	f840 3026 	str.w	r3, [r0, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008e3a:	2a00      	cmp	r2, #0
 8008e3c:	f47f af6d 	bne.w	8008d1a <ENC_CalcAvrgMecSpeedUnit+0x76>
 8008e40:	4613      	mov	r3, r2
 8008e42:	4616      	mov	r6, r2
 8008e44:	e7b0      	b.n	8008da8 <ENC_CalcAvrgMecSpeedUnit+0x104>
}
 8008e46:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      bReliability = SPD_IsMecSpeedReliable(&pHandle->_Super, pMecSpeedUnit);
 8008e4a:	f001 ba83 	b.w	800a354 <SPD_IsMecSpeedReliable>
 8008e4e:	bf00      	nop

08008e50 <ENC_SetMecAngle>:
    uint16_t hAngleCounts;
    uint16_t hMecAngleuint;
    int16_t localhMecAngle = hMecAngle;

    pHandle->_Super.hMecAngle = localhMecAngle;
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e50:	7843      	ldrb	r3, [r0, #1]
    pHandle->_Super.hMecAngle = localhMecAngle;
 8008e52:	80c1      	strh	r1, [r0, #6]
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e54:	b28a      	uxth	r2, r1
 8008e56:	fb01 f303 	mul.w	r3, r1, r3
    if (localhMecAngle < 0)
 8008e5a:	2900      	cmp	r1, #0
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e5c:	8083      	strh	r3, [r0, #4]
 8008e5e:	bfb8      	it	lt
 8008e60:	f102 32ff 	addlt.w	r2, r2, #4294967295
    else
    {
      hMecAngleuint = (uint16_t)localhMecAngle;
    }

    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e64:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
 8008e68:	4906      	ldr	r1, [pc, #24]	; (8008e84 <ENC_SetMecAngle+0x34>)
 8008e6a:	bfb8      	it	lt
 8008e6c:	b292      	uxthlt	r2, r2
 8008e6e:	fb02 f303 	mul.w	r3, r2, r3
{
 8008e72:	b410      	push	{r4}
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e74:	fba1 1303 	umull	r1, r3, r1, r3
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008e78:	6a04      	ldr	r4, [r0, #32]
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e7a:	0bdb      	lsrs	r3, r3, #15

    TIMx->CNT = (uint16_t)hAngleCounts;
 8008e7c:	6263      	str	r3, [r4, #36]	; 0x24
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008e7e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008e82:	4770      	bx	lr
 8008e84:	80008001 	.word	0x80008001

08008e88 <ENC_IRQHandler>:
/**
  * @brief  TIMER ENCODER Overflow interrupt counter update
  * @param  pHandleVoid: handler of the current instance of the encoder component
  */
__weak void *ENC_IRQHandler(void *pHandleVoid)
{
 8008e88:	4602      	mov	r2, r0
  /* Updates the number of overflows occurred */
  /* The handling of overflow error is done in ENC_CalcAvrgMecSpeedUnit */
  pHandle->TimerOverflowNb += 1U;

  return (MC_NULL);
}
 8008e8a:	2000      	movs	r0, #0
  pHandle->TimerOverflowNb += 1U;
 8008e8c:	f8b2 3070 	ldrh.w	r3, [r2, #112]	; 0x70
 8008e90:	3301      	adds	r3, #1
 8008e92:	b29b      	uxth	r3, r3
 8008e94:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
}
 8008e98:	4770      	bx	lr
 8008e9a:	bf00      	nop

08008e9c <MCPA_dataLog>:
  * @brief  Allocates and fills buffer with asynchronous data to be sent to controller
  *
  * @param  *pHandle Pointer to the MCPA Handle
  */
void MCPA_dataLog(MCPA_Handle_t *pHandle)
{
 8008e9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8008e9e:	7fc3      	ldrb	r3, [r0, #31]
 8008ea0:	f890 2022 	ldrb.w	r2, [r0, #34]	; 0x22
 8008ea4:	429a      	cmp	r2, r3
{
 8008ea6:	4604      	mov	r4, r0
    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8008ea8:	d002      	beq.n	8008eb0 <MCPA_dataLog+0x14>
      }
    }
    else
    {
      /* Nothing to log just waiting next call to MCPA_datalog */
      pHandle->HFIndex++;
 8008eaa:	3301      	adds	r3, #1
 8008eac:	77c3      	strb	r3, [r0, #31]
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 8008eae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (0U == pHandle->bufferIndex)
 8008eb0:	8b05      	ldrh	r5, [r0, #24]
      pHandle->HFIndex = 0U;
 8008eb2:	2300      	movs	r3, #0
 8008eb4:	77c3      	strb	r3, [r0, #31]
      if (0U == pHandle->bufferIndex)
 8008eb6:	b1a5      	cbz	r5, 8008ee2 <MCPA_dataLog+0x46>
 8008eb8:	6961      	ldr	r1, [r4, #20]
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008eba:	8ba2      	ldrh	r2, [r4, #28]
 8008ebc:	42aa      	cmp	r2, r5
 8008ebe:	d24e      	bcs.n	8008f5e <MCPA_dataLog+0xc2>
 8008ec0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
        if (pHandle->MFRateBuff == 254U) /* MFRateBuff = 254 means we dump MF data once per buffer */
 8008ec4:	2bfe      	cmp	r3, #254	; 0xfe
 8008ec6:	d066      	beq.n	8008f96 <MCPA_dataLog+0xfa>
        *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8008ec8:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 8008ecc:	534b      	strh	r3, [r1, r5]
        pHandle->pTransportLayer->fSendPacket(pHandle->pTransportLayer, pHandle->currentBuffer,
 8008ece:	8b22      	ldrh	r2, [r4, #24]
 8008ed0:	6820      	ldr	r0, [r4, #0]
 8008ed2:	3202      	adds	r2, #2
 8008ed4:	2309      	movs	r3, #9
 8008ed6:	6845      	ldr	r5, [r0, #4]
 8008ed8:	b292      	uxth	r2, r2
 8008eda:	47a8      	blx	r5
        pHandle->bufferIndex = 0U;
 8008edc:	2300      	movs	r3, #0
 8008ede:	8323      	strh	r3, [r4, #24]
}
 8008ee0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (0U == pHandle->pTransportLayer->fGetBuffer (pHandle->pTransportLayer,
 8008ee2:	4601      	mov	r1, r0
 8008ee4:	2209      	movs	r2, #9
 8008ee6:	f851 0b14 	ldr.w	r0, [r1], #20
 8008eea:	6803      	ldr	r3, [r0, #0]
 8008eec:	4798      	blx	r3
 8008eee:	b390      	cbz	r0, 8008f56 <MCPA_dataLog+0xba>
          *logValue = GLOBAL_TIMESTAMP; /* 32 first bits is used to store Timestamp */
 8008ef0:	4b4b      	ldr	r3, [pc, #300]	; (8009020 <MCPA_dataLog+0x184>)
 8008ef2:	6961      	ldr	r1, [r4, #20]
 8008ef4:	681b      	ldr	r3, [r3, #0]
 8008ef6:	600b      	str	r3, [r1, #0]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008ef8:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
 8008efc:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
          pHandle->MFIndex = 0U; /* Restart the motif from scratch at each buffer */
 8008f00:	f884 5020 	strb.w	r5, [r4, #32]
          pHandle->bufferIndex = 4U;
 8008f04:	2304      	movs	r3, #4
          if (pHandle->Mark == pHandle->MarkBuff)
 8008f06:	4282      	cmp	r2, r0
          pHandle->bufferIndex = 4U;
 8008f08:	8323      	strh	r3, [r4, #24]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008f0a:	d101      	bne.n	8008f10 <MCPA_dataLog+0x74>
 8008f0c:	461d      	mov	r5, r3
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008f0e:	e7d4      	b.n	8008eba <MCPA_dataLog+0x1e>
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008f10:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008f14:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008f18:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008f1c:	f894 5021 	ldrb.w	r5, [r4, #33]	; 0x21
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008f20:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008f24:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                         ((uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum) * 4U); /* We store pointer here,
 8008f28:	441a      	add	r2, r3
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008f2a:	8b63      	ldrh	r3, [r4, #26]
            pHandle->MarkBuff            = pHandle->Mark;
 8008f2c:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008f30:	0092      	lsls	r2, r2, #2
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008f32:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008f36:	83a3      	strh	r3, [r4, #28]
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008f38:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008f3c:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008f40:	f004 fc6f 	bl	800d822 <memcpy>
                         (uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum); /* 1 size byte per ID */
 8008f44:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
 8008f48:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
            (void)memcpy(pHandle->dataSizeTableBuff, pHandle->dataSizeTable,
 8008f4c:	e9d4 1003 	ldrd	r1, r0, [r4, #12]
 8008f50:	441a      	add	r2, r3
 8008f52:	f004 fc66 	bl	800d822 <memcpy>
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008f56:	8b25      	ldrh	r5, [r4, #24]
 8008f58:	2d00      	cmp	r5, #0
 8008f5a:	d1ad      	bne.n	8008eb8 <MCPA_dataLog+0x1c>
}
 8008f5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f5e:	f894 6024 	ldrb.w	r6, [r4, #36]	; 0x24
        logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8008f62:	194b      	adds	r3, r1, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f64:	b36e      	cbz	r6, 8008fc2 <MCPA_dataLog+0x126>
 8008f66:	68a2      	ldr	r2, [r4, #8]
 8008f68:	eb03 0c46 	add.w	ip, r3, r6, lsl #1
 8008f6c:	3a04      	subs	r2, #4
          *logValue16 = *((uint16_t *) pHandle->dataPtrTableBuff[i]) ; //cstat !MISRAC2012-Rule-11.5
 8008f6e:	f852 0f04 	ldr.w	r0, [r2, #4]!
 8008f72:	8800      	ldrh	r0, [r0, #0]
 8008f74:	f823 0b02 	strh.w	r0, [r3], #2
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 8008f78:	8b25      	ldrh	r5, [r4, #24]
 8008f7a:	3502      	adds	r5, #2
 8008f7c:	b2ad      	uxth	r5, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f7e:	4563      	cmp	r3, ip
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 8008f80:	8325      	strh	r5, [r4, #24]
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f82:	d1f4      	bne.n	8008f6e <MCPA_dataLog+0xd2>
        if (pHandle->MFRateBuff < 254U)
 8008f84:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f88:	8ba2      	ldrh	r2, [r4, #28]
        if (pHandle->MFRateBuff < 254U)
 8008f8a:	2bfd      	cmp	r3, #253	; 0xfd
 8008f8c:	4618      	mov	r0, r3
 8008f8e:	d91d      	bls.n	8008fcc <MCPA_dataLog+0x130>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f90:	4295      	cmp	r5, r2
 8008f92:	d897      	bhi.n	8008ec4 <MCPA_dataLog+0x28>
}
 8008f94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f96:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8008f9a:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 8008f9e:	4418      	add	r0, r3
 8008fa0:	4298      	cmp	r0, r3
 8008fa2:	dd91      	ble.n	8008ec8 <MCPA_dataLog+0x2c>
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008fa4:	68a7      	ldr	r7, [r4, #8]
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008fa6:	6926      	ldr	r6, [r4, #16]
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008fa8:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8008fac:	6812      	ldr	r2, [r2, #0]
 8008fae:	514a      	str	r2, [r1, r5]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fb0:	1c5a      	adds	r2, r3, #1
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008fb2:	5cf3      	ldrb	r3, [r6, r3]
 8008fb4:	442b      	add	r3, r5
 8008fb6:	b29d      	uxth	r5, r3
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fb8:	b2d3      	uxtb	r3, r2
 8008fba:	4283      	cmp	r3, r0
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008fbc:	8325      	strh	r5, [r4, #24]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fbe:	dbf3      	blt.n	8008fa8 <MCPA_dataLog+0x10c>
 8008fc0:	e782      	b.n	8008ec8 <MCPA_dataLog+0x2c>
        if (pHandle->MFRateBuff < 254U)
 8008fc2:	f894 0026 	ldrb.w	r0, [r4, #38]	; 0x26
 8008fc6:	28fd      	cmp	r0, #253	; 0xfd
 8008fc8:	f63f af71 	bhi.w	8008eae <MCPA_dataLog+0x12>
          if (pHandle->MFIndex == pHandle->MFRateBuff)
 8008fcc:	f894 3020 	ldrb.w	r3, [r4, #32]
 8008fd0:	4283      	cmp	r3, r0
 8008fd2:	d007      	beq.n	8008fe4 <MCPA_dataLog+0x148>
            pHandle->MFIndex ++;
 8008fd4:	3301      	adds	r3, #1
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008fd6:	8b25      	ldrh	r5, [r4, #24]
            pHandle->MFIndex ++;
 8008fd8:	f884 3020 	strb.w	r3, [r4, #32]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008fdc:	42aa      	cmp	r2, r5
 8008fde:	f4ff af73 	bcc.w	8008ec8 <MCPA_dataLog+0x2c>
}
 8008fe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fe4:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
 8008fe8:	4437      	add	r7, r6
            pHandle->MFIndex = 0U;
 8008fea:	2300      	movs	r3, #0
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fec:	42b7      	cmp	r7, r6
            pHandle->MFIndex = 0U;
 8008fee:	f884 3020 	strb.w	r3, [r4, #32]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008ff2:	dd12      	ble.n	800901a <MCPA_dataLog+0x17e>
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008ff4:	f8d4 e008 	ldr.w	lr, [r4, #8]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008ff8:	f8d4 c010 	ldr.w	ip, [r4, #16]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008ffc:	8b25      	ldrh	r5, [r4, #24]
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008ffe:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 8009002:	681b      	ldr	r3, [r3, #0]
 8009004:	514b      	str	r3, [r1, r5]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009006:	f81c 3006 	ldrb.w	r3, [ip, r6]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800900a:	1c70      	adds	r0, r6, #1
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800900c:	442b      	add	r3, r5
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800900e:	b2c6      	uxtb	r6, r0
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009010:	b29d      	uxth	r5, r3
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009012:	42be      	cmp	r6, r7
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009014:	8325      	strh	r5, [r4, #24]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009016:	dbf2      	blt.n	8008ffe <MCPA_dataLog+0x162>
 8009018:	e7e0      	b.n	8008fdc <MCPA_dataLog+0x140>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 800901a:	8b25      	ldrh	r5, [r4, #24]
 800901c:	e7de      	b.n	8008fdc <MCPA_dataLog+0x140>
 800901e:	bf00      	nop
 8009020:	200030a8 	.word	0x200030a8

08009024 <MCPA_flushDataLog>:
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->bufferIndex > 0U)
 8009024:	8b03      	ldrh	r3, [r0, #24]
 8009026:	b19b      	cbz	r3, 8009050 <MCPA_flushDataLog+0x2c>
{
 8009028:	b570      	push	{r4, r5, r6, lr}
    {  /* If buffer is allocated, we must send it */
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 800902a:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
 800902e:	2afe      	cmp	r2, #254	; 0xfe
 8009030:	4604      	mov	r4, r0
 8009032:	d00e      	beq.n	8009052 <MCPA_flushDataLog+0x2e>
                                          proper decoding */
      {
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
        {
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8009034:	6941      	ldr	r1, [r0, #20]
      else
      {
        /* Nothing to do */
      }
      logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
      *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8009036:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 800903a:	52ca      	strh	r2, [r1, r3]
                                          the MARK */
      pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 800903c:	8b22      	ldrh	r2, [r4, #24]
 800903e:	6820      	ldr	r0, [r4, #0]
 8009040:	3202      	adds	r2, #2
 8009042:	2309      	movs	r3, #9
 8009044:	6845      	ldr	r5, [r0, #4]
 8009046:	b292      	uxth	r2, r2
 8009048:	47a8      	blx	r5
                                             pHandle->bufferIndex + 2U, MCTL_ASYNC);
      pHandle->bufferIndex = 0U;
 800904a:	2300      	movs	r3, #0
 800904c:	8323      	strh	r3, [r4, #24]
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 800904e:	bd70      	pop	{r4, r5, r6, pc}
 8009050:	4770      	bx	lr
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009052:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8009056:	f890 c028 	ldrb.w	ip, [r0, #40]	; 0x28
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 800905a:	6941      	ldr	r1, [r0, #20]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800905c:	4494      	add	ip, r2
 800905e:	4562      	cmp	r2, ip
 8009060:	dae9      	bge.n	8009036 <MCPA_flushDataLog+0x12>
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8009062:	6886      	ldr	r6, [r0, #8]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009064:	6905      	ldr	r5, [r0, #16]
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8009066:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
 800906a:	6800      	ldr	r0, [r0, #0]
 800906c:	50c8      	str	r0, [r1, r3]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800906e:	5ca8      	ldrb	r0, [r5, r2]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009070:	3201      	adds	r2, #1
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009072:	4403      	add	r3, r0
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009074:	b2d2      	uxtb	r2, r2
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009076:	b29b      	uxth	r3, r3
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009078:	4562      	cmp	r2, ip
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800907a:	8323      	strh	r3, [r4, #24]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800907c:	dbf3      	blt.n	8009066 <MCPA_flushDataLog+0x42>
 800907e:	e7da      	b.n	8009036 <MCPA_flushDataLog+0x12>

08009080 <MCPA_cfgLog>:
  *
  * @param  *pHandle Pointer to the MCPA Handle
  * @param  *cfgdata Configuration of the Async communication
  */
uint8_t MCPA_cfgLog(MCPA_Handle_t *pHandle, uint8_t *cfgdata)
{
 8009080:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
    uint16_t newID, buffSize;
    uint8_t *pCfgData = cfgdata;

    buffSize = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 8009084:	880f      	ldrh	r7, [r1, #0]
{
 8009086:	4604      	mov	r4, r0

    if (buffSize == 0U)
 8009088:	2f00      	cmp	r7, #0
 800908a:	d044      	beq.n	8009116 <MCPA_cfgLog+0x96>
    { 
      /* Switch Off condition */
      MCPA_stopDataLog(pHandle);
    }
    else if (buffSize > pHandle->pTransportLayer->txAsyncMaxPayload)
 800908c:	6803      	ldr	r3, [r0, #0]
 800908e:	89db      	ldrh	r3, [r3, #14]
 8009090:	42bb      	cmp	r3, r7
 8009092:	d33d      	bcc.n	8009110 <MCPA_cfgLog+0x90>
    {
      result = MCP_ERROR_NO_TXASYNC_SPACE;
    }
    else
    {
      pHandle->HFRate = *((uint8_t *)&pCfgData[2]);
 8009094:	788b      	ldrb	r3, [r1, #2]
 8009096:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
      pHandle->HFNum  = *((uint8_t *)&pCfgData[3]);
 800909a:	78ce      	ldrb	r6, [r1, #3]
 800909c:	f880 6023 	strb.w	r6, [r0, #35]	; 0x23
      pHandle->MFRate = *((uint8_t *)&pCfgData[4]);
 80090a0:	790b      	ldrb	r3, [r1, #4]
 80090a2:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 80090a6:	794b      	ldrb	r3, [r1, #5]
 80090a8:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */

      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 80090ac:	441e      	add	r6, r3
 80090ae:	7f83      	ldrb	r3, [r0, #30]
 80090b0:	429e      	cmp	r6, r3
 80090b2:	dc52      	bgt.n	800915a <MCPA_cfgLog+0xda>
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */
 80090b4:	3106      	adds	r1, #6
      {
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090b6:	2e00      	cmp	r6, #0
 80090b8:	d056      	beq.n	8009168 <MCPA_cfgLog+0xe8>
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 80090ba:	2600      	movs	r6, #0
 80090bc:	4688      	mov	r8, r1
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090be:	4635      	mov	r5, r6
 80090c0:	e011      	b.n	80090e6 <MCPA_cfgLog+0x66>
        {
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
          /* HF Data are fixed to 2 bytes */
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 80090c2:	68e3      	ldr	r3, [r4, #12]
 80090c4:	5558      	strb	r0, [r3, r5]
          pCfgData++; /* Point to the next UID */
          pCfgData++;
          logSize = logSize+pHandle->dataSizeTable[i];
 80090c6:	68e2      	ldr	r2, [r4, #12]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090c8:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 80090cc:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
          logSize = logSize+pHandle->dataSizeTable[i];
 80090d0:	5d52      	ldrb	r2, [r2, r5]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090d2:	f105 0c01 	add.w	ip, r5, #1
 80090d6:	fa5f f58c 	uxtb.w	r5, ip
 80090da:	4403      	add	r3, r0
          logSize = logSize+pHandle->dataSizeTable[i];
 80090dc:	4432      	add	r2, r6
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090de:	429d      	cmp	r5, r3
          pCfgData++;
 80090e0:	4641      	mov	r1, r8
          logSize = logSize+pHandle->dataSizeTable[i];
 80090e2:	b296      	uxth	r6, r2
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 80090e4:	da11      	bge.n	800910a <MCPA_cfgLog+0x8a>
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 80090e6:	f838 9b02 	ldrh.w	r9, [r8], #2
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
 80090ea:	6861      	ldr	r1, [r4, #4]
 80090ec:	4648      	mov	r0, r9
 80090ee:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 80090f2:	f7fb f94f 	bl	8004394 <RI_GetPtrReg>
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 80090f6:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 80090fa:	42ab      	cmp	r3, r5
 80090fc:	f04f 0002 	mov.w	r0, #2
 8009100:	d8df      	bhi.n	80090c2 <MCPA_cfgLog+0x42>
 8009102:	4648      	mov	r0, r9
 8009104:	f7fb f93a 	bl	800437c <RI_GetIDSize>
 8009108:	e7db      	b.n	80090c2 <MCPA_cfgLog+0x42>
        }

        /* Smallest packet must be able to contain logSize Markbyte AsyncID and TimeStamp */
        if (buffSize < (logSize + 2U + 4U))
 800910a:	1db3      	adds	r3, r6, #6
 800910c:	429f      	cmp	r7, r3
 800910e:	d21a      	bcs.n	8009146 <MCPA_cfgLog+0xc6>
      result = MCP_ERROR_NO_TXASYNC_SPACE;
 8009110:	2009      	movs	r0, #9
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
  return (result);
}
 8009112:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 8009116:	8b03      	ldrh	r3, [r0, #24]
  pHandle->Mark = 0U;
 8009118:	f880 7029 	strb.w	r7, [r0, #41]	; 0x29
  if (pHandle->bufferIndex > 0U)
 800911c:	b153      	cbz	r3, 8009134 <MCPA_cfgLog+0xb4>
    logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 800911e:	6961      	ldr	r1, [r4, #20]
    *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8009120:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 8009124:	52ca      	strh	r2, [r1, r3]
    pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 8009126:	8b22      	ldrh	r2, [r4, #24]
 8009128:	6820      	ldr	r0, [r4, #0]
 800912a:	3202      	adds	r2, #2
 800912c:	6845      	ldr	r5, [r0, #4]
 800912e:	b292      	uxth	r2, r2
 8009130:	2309      	movs	r3, #9
 8009132:	47a8      	blx	r5
  pHandle->bufferIndex = 0U;
 8009134:	2000      	movs	r0, #0
  pHandle->MarkBuff    = 0U;
 8009136:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
  pHandle->HFIndex     = 0U;
 800913a:	77e0      	strb	r0, [r4, #31]
  pHandle->HFRateBuff  = 0U; /* We do not want to miss any sample at the restart */
 800913c:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
  pHandle->bufferIndex = 0U;
 8009140:	8320      	strh	r0, [r4, #24]
}
 8009142:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          pHandle->bufferTxTrigger = buffSize-logSize - 2U; /* 2 is required to add the last Mark byte and NUL
 8009146:	3f02      	subs	r7, #2
 8009148:	1bbf      	subs	r7, r7, r6
 800914a:	8367      	strh	r7, [r4, #26]
          pHandle->Mark = *((uint8_t *)pCfgData);
 800914c:	780b      	ldrb	r3, [r1, #0]
 800914e:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
          if (0U == pHandle->Mark)
 8009152:	b12b      	cbz	r3, 8009160 <MCPA_cfgLog+0xe0>
  uint8_t result = MCP_CMD_OK;
 8009154:	2000      	movs	r0, #0
}
 8009156:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        result = MCP_ERROR_BAD_RAW_FORMAT;
 800915a:	200a      	movs	r0, #10
}
 800915c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 8009160:	8b23      	ldrh	r3, [r4, #24]
 8009162:	2b00      	cmp	r3, #0
 8009164:	d0e6      	beq.n	8009134 <MCPA_cfgLog+0xb4>
 8009166:	e7da      	b.n	800911e <MCPA_cfgLog+0x9e>
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8009168:	2306      	movs	r3, #6
 800916a:	e7cf      	b.n	800910c <MCPA_cfgLog+0x8c>

0800916c <NTC_Clear>:
    /* nothing to do */
  }
  else
  {
#endif
    pHandle->hAvTemp_d = 0U;
 800916c:	2300      	movs	r3, #0
 800916e:	8043      	strh	r3, [r0, #2]
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
}
 8009170:	4770      	bx	lr
 8009172:	bf00      	nop

08009174 <NTC_Init>:
    if (REAL_SENSOR == pHandle->bSensorType)
 8009174:	7802      	ldrb	r2, [r0, #0]
{
 8009176:	b508      	push	{r3, lr}
    if (REAL_SENSOR == pHandle->bSensorType)
 8009178:	b122      	cbz	r2, 8009184 <NTC_Init+0x10>
      pHandle->hAvTemp_d = pHandle->hExpectedTemp_d;
 800917a:	8882      	ldrh	r2, [r0, #4]
 800917c:	8042      	strh	r2, [r0, #2]
      pHandle->hFaultState = MC_NO_ERROR;
 800917e:	2100      	movs	r1, #0
 8009180:	8101      	strh	r1, [r0, #8]
}
 8009182:	bd08      	pop	{r3, pc}
      NTC_Clear(pHandle);
 8009184:	f7ff fff2 	bl	800916c <NTC_Clear>
}
 8009188:	bd08      	pop	{r3, pc}
 800918a:	bf00      	nop

0800918c <NTC_GetAvTemp_C>:
  else
  {
#endif
    int32_t wTemp;

    if (REAL_SENSOR == pHandle->bSensorType)
 800918c:	7803      	ldrb	r3, [r0, #0]
 800918e:	b95b      	cbnz	r3, 80091a8 <NTC_GetAvTemp_C+0x1c>
    {
      wTemp = (int32_t)pHandle->hAvTemp_d;
 8009190:	8842      	ldrh	r2, [r0, #2]
      wTemp -= ((int32_t)pHandle->wV0);
 8009192:	6941      	ldr	r1, [r0, #20]
      wTemp *= pHandle->hSensitivity;
 8009194:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
#ifndef FULL_MISRA_C_COMPLIANCY_NTC_TEMP
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8009198:	8b00      	ldrh	r0, [r0, #24]
      wTemp -= ((int32_t)pHandle->wV0);
 800919a:	1a52      	subs	r2, r2, r1
      wTemp *= pHandle->hSensitivity;
 800919c:	fb02 f303 	mul.w	r3, r2, r3
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 80091a0:	eb00 4023 	add.w	r0, r0, r3, asr #16
    returnValue = (int16_t)wTemp;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 80091a4:	b200      	sxth	r0, r0
 80091a6:	4770      	bx	lr
      wTemp = (int32_t)pHandle->hExpectedTemp_C;
 80091a8:	88c0      	ldrh	r0, [r0, #6]
}
 80091aa:	b200      	sxth	r0, r0
 80091ac:	4770      	bx	lr
 80091ae:	bf00      	nop

080091b0 <PID_HandleInit>:
  {
#endif
    pHandle->hKpGain =  pHandle->hDefKpGain;
    pHandle->hKiGain =  pHandle->hDefKiGain;
    pHandle->hKdGain =  pHandle->hDefKdGain;
    pHandle->wIntegralTerm = 0;
 80091b0:	2300      	movs	r3, #0
    pHandle->hKpGain =  pHandle->hDefKpGain;
 80091b2:	6801      	ldr	r1, [r0, #0]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 80091b4:	8c02      	ldrh	r2, [r0, #32]
    pHandle->hKpGain =  pHandle->hDefKpGain;
 80091b6:	6041      	str	r1, [r0, #4]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 80091b8:	8442      	strh	r2, [r0, #34]	; 0x22
    pHandle->wIntegralTerm = 0;
 80091ba:	6083      	str	r3, [r0, #8]
    pHandle->wPrevProcessVarError = 0;
 80091bc:	6283      	str	r3, [r0, #40]	; 0x28
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091be:	4770      	bx	lr

080091c0 <PID_SetKP>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKpGain = hKpGain;
 80091c0:	8081      	strh	r1, [r0, #4]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091c2:	4770      	bx	lr

080091c4 <PID_SetKI>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKiGain = hKiGain;
 80091c4:	80c1      	strh	r1, [r0, #6]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091c6:	4770      	bx	lr

080091c8 <PID_GetKP>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKpGain);
#else
  return (pHandle->hKpGain);
#endif
}
 80091c8:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 80091cc:	4770      	bx	lr
 80091ce:	bf00      	nop

080091d0 <PID_GetKI>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKiGain);
#else
  return (pHandle->hKiGain);
#endif
}
 80091d0:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 80091d4:	4770      	bx	lr
 80091d6:	bf00      	nop

080091d8 <PID_SetIntegralTerm>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wIntegralTerm = wIntegralTermValue;
 80091d8:	6081      	str	r1, [r0, #8]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return;
}
 80091da:	4770      	bx	lr

080091dc <PID_GetKPDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKpDivisorPOW2);
#else
  return (pHandle->hKpDivisorPOW2);
#endif
}
 80091dc:	8b80      	ldrh	r0, [r0, #28]
 80091de:	4770      	bx	lr

080091e0 <PID_SetKPDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 80091e0:	2301      	movs	r3, #1
 80091e2:	408b      	lsls	r3, r1
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
 80091e4:	8381      	strh	r1, [r0, #28]
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 80091e6:	8303      	strh	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091e8:	4770      	bx	lr
 80091ea:	bf00      	nop

080091ec <PID_GetKIDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKiDivisorPOW2);
#else
  return (pHandle->hKiDivisorPOW2);
#endif
}
 80091ec:	8bc0      	ldrh	r0, [r0, #30]
 80091ee:	4770      	bx	lr

080091f0 <PID_SetLowerIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wLowerIntegralLimit = wLowerLimit;
 80091f0:	6101      	str	r1, [r0, #16]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091f2:	4770      	bx	lr

080091f4 <PID_SetUpperIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wUpperIntegralLimit = wUpperLimit;
 80091f4:	60c1      	str	r1, [r0, #12]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091f6:	4770      	bx	lr

080091f8 <PID_SetKIDivisorPOW2>:
{
 80091f8:	b538      	push	{r3, r4, r5, lr}
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80091fa:	2301      	movs	r3, #1
{
 80091fc:	460c      	mov	r4, r1
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80091fe:	408b      	lsls	r3, r1
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 8009200:	f647 71ff 	movw	r1, #32767	; 0x7fff
 8009204:	40a1      	lsls	r1, r4
    pHandle->hKiDivisorPOW2 = hKiDivisorPOW2;
 8009206:	83c4      	strh	r4, [r0, #30]
    pHandle->hKiDivisor = (uint16_t)wKiDiv;
 8009208:	8343      	strh	r3, [r0, #26]
{
 800920a:	4605      	mov	r5, r0
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 800920c:	f7ff fff2 	bl	80091f4 <PID_SetUpperIntegralTermLimit>
    PID_SetLowerIntegralTermLimit(pHandle, (int32_t)(-INT16_MAX) * (int32_t)wKiDiv);
 8009210:	4902      	ldr	r1, [pc, #8]	; (800921c <PID_SetKIDivisorPOW2+0x24>)
 8009212:	4628      	mov	r0, r5
 8009214:	40a1      	lsls	r1, r4
 8009216:	f7ff ffeb 	bl	80091f0 <PID_SetLowerIntegralTermLimit>
}
 800921a:	bd38      	pop	{r3, r4, r5, pc}
 800921c:	ffff8001 	.word	0xffff8001

08009220 <PID_SetKD>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKdGain = hKdGain;
 8009220:	8441      	strh	r1, [r0, #34]	; 0x22
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8009222:	4770      	bx	lr

08009224 <PID_GetKD>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKdGain);
#else
  return (pHandle->hKdGain);
#endif
}
 8009224:	f9b0 0022 	ldrsh.w	r0, [r0, #34]	; 0x22
 8009228:	4770      	bx	lr
 800922a:	bf00      	nop

0800922c <PID_GetKDDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKdDivisorPOW2);
#else
  return (pHandle->hKdDivisorPOW2);
#endif
}
 800922c:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
 800922e:	4770      	bx	lr

08009230 <PID_SetKDDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 8009230:	2301      	movs	r3, #1
 8009232:	408b      	lsls	r3, r1
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
 8009234:	84c1      	strh	r1, [r0, #38]	; 0x26
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 8009236:	8483      	strh	r3, [r0, #36]	; 0x24
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8009238:	4770      	bx	lr
 800923a:	bf00      	nop

0800923c <PI_Controller>:
    int32_t wDischarge = 0;
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;

    /* Proportional term computation*/
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 800923c:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
{
 8009240:	4603      	mov	r3, r0
 8009242:	b510      	push	{r4, lr}

    /* Integral term computation */
    if (0 == pHandle->hKiGain)
 8009244:	f9b0 4006 	ldrsh.w	r4, [r0, #6]
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;
 8009248:	f9b3 c016 	ldrsh.w	ip, [r3, #22]
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
 800924c:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 8009250:	fb01 f202 	mul.w	r2, r1, r2
    if (0 == pHandle->hKiGain)
 8009254:	b18c      	cbz	r4, 800927a <PI_Controller+0x3e>
    {
      pHandle->wIntegralTerm = 0;
    }
    else
    {
      wIntegral_Term = pHandle->hKiGain * wProcessVarError;
 8009256:	fb04 f101 	mul.w	r1, r4, r1
      wIntegral_sum_temp = pHandle->wIntegralTerm + wIntegral_Term;
 800925a:	689c      	ldr	r4, [r3, #8]

      if (wIntegral_sum_temp < 0)
 800925c:	eb14 0e01 	adds.w	lr, r4, r1
 8009260:	d421      	bmi.n	80092a6 <PI_Controller+0x6a>
      {
        if (pHandle->wIntegralTerm < 0)
        {
          if (wIntegral_Term < 0)
          {
            wIntegral_sum_temp = -INT32_MAX;
 8009262:	420c      	tst	r4, r1
 8009264:	4916      	ldr	r1, [pc, #88]	; (80092c0 <PI_Controller+0x84>)
 8009266:	bf48      	it	mi
 8009268:	468e      	movmi	lr, r1
        {
          /* Nothing to do */
        }
      }

      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 800926a:	68d9      	ldr	r1, [r3, #12]
 800926c:	4571      	cmp	r1, lr
 800926e:	db05      	blt.n	800927c <PI_Controller+0x40>
      {
        pHandle->wIntegralTerm = pHandle->wUpperIntegralLimit;
      }
      else if (wIntegral_sum_temp < pHandle->wLowerIntegralLimit)
 8009270:	6919      	ldr	r1, [r3, #16]
 8009272:	4571      	cmp	r1, lr
 8009274:	dc02      	bgt.n	800927c <PI_Controller+0x40>
      {
        pHandle->wIntegralTerm = pHandle->wLowerIntegralLimit;
      }
      else
      {
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 8009276:	4671      	mov	r1, lr
 8009278:	e000      	b.n	800927c <PI_Controller+0x40>
 800927a:	4621      	mov	r1, r4
    /* WARNING: the below instruction is not MISRA compliant, user should verify
               that Cortex-M3 assembly instruction ASR (arithmetic shift right)
               is used by the compiler to perform the shifts (instead of LSR
               logical shift right)*/
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    wOutput_32 = (wProportional_Term >> pHandle->hKpDivisorPOW2) + (pHandle->wIntegralTerm >> pHandle->hKiDivisorPOW2);
 800927c:	8b9c      	ldrh	r4, [r3, #28]
 800927e:	4122      	asrs	r2, r4
 8009280:	8bdc      	ldrh	r4, [r3, #30]
 8009282:	fa41 f404 	asr.w	r4, r1, r4
 8009286:	4422      	add	r2, r4
#else
    wOutput_32 = (wProportional_Term / (int32_t)pHandle->hKpDivisor)
              + (pHandle->wIntegralTerm / (int32_t)pHandle->hKiDivisor);
#endif

    if (wOutput_32 > hUpperOutputLimit)
 8009288:	4290      	cmp	r0, r2
 800928a:	da03      	bge.n	8009294 <PI_Controller+0x58>
    {
      wDischarge = hUpperOutputLimit - wOutput_32;
 800928c:	1a82      	subs	r2, r0, r2
    else
    {
      /* Nothing to do here */
    }

    pHandle->wIntegralTerm += wDischarge;
 800928e:	4411      	add	r1, r2
 8009290:	6099      	str	r1, [r3, #8]
    returnValue = (int16_t)wOutput_32;
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return (returnValue);
}
 8009292:	bd10      	pop	{r4, pc}
    else if (wOutput_32 < hLowerOutputLimit)
 8009294:	4594      	cmp	ip, r2
      wDischarge = hLowerOutputLimit - wOutput_32;
 8009296:	bfc5      	ittet	gt
 8009298:	ebac 0202 	subgt.w	r2, ip, r2
    pHandle->wIntegralTerm += wDischarge;
 800929c:	1889      	addgt	r1, r1, r2
    returnValue = (int16_t)wOutput_32;
 800929e:	b210      	sxthle	r0, r2
      wOutput_32 = hLowerOutputLimit;
 80092a0:	4660      	movgt	r0, ip
    pHandle->wIntegralTerm += wDischarge;
 80092a2:	6099      	str	r1, [r3, #8]
}
 80092a4:	bd10      	pop	{r4, pc}
        if (pHandle->wIntegralTerm > 0)
 80092a6:	2c00      	cmp	r4, #0
 80092a8:	dddf      	ble.n	800926a <PI_Controller+0x2e>
          if (wIntegral_Term > 0)
 80092aa:	2900      	cmp	r1, #0
 80092ac:	dddd      	ble.n	800926a <PI_Controller+0x2e>
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 80092ae:	68d9      	ldr	r1, [r3, #12]
 80092b0:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 80092b4:	42a1      	cmp	r1, r4
 80092b6:	d1e1      	bne.n	800927c <PI_Controller+0x40>
            wIntegral_sum_temp = INT32_MAX;
 80092b8:	468e      	mov	lr, r1
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 80092ba:	4671      	mov	r1, lr
 80092bc:	e7de      	b.n	800927c <PI_Controller+0x40>
 80092be:	bf00      	nop
 80092c0:	80000001 	.word	0x80000001

080092c4 <PQD_CalcElMotorPower>:
  }
  else
  {
#endif
    int32_t wAux;
    qd_t Iqd = pHandle->pFOCVars->Iqd;
 80092c4:	6882      	ldr	r2, [r0, #8]
{
 80092c6:	b500      	push	{lr}
    qd_t Vqd = pHandle->pFOCVars->Vqd;

    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 80092c8:	89d1      	ldrh	r1, [r2, #14]
 80092ca:	f8b2 e018 	ldrh.w	lr, [r2, #24]
    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
 80092ce:	8993      	ldrh	r3, [r2, #12]
 80092d0:	f8b2 c016 	ldrh.w	ip, [r2, #22]
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 80092d4:	fb11 f20e 	smulbb	r2, r1, lr
    wAux /= 65536;
 80092d8:	fb13 230c 	smlabb	r3, r3, ip, r2
 80092dc:	2b00      	cmp	r3, #0

    /* pHandle->hAvrgElMotorPower += (wAux - pHandle->hAvrgElMotorPower) >> 4 */
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 80092de:	f9b0 2000 	ldrsh.w	r2, [r0]
    wAux /= 65536;
 80092e2:	bfbc      	itt	lt
 80092e4:	f503 437f 	addlt.w	r3, r3, #65280	; 0xff00
 80092e8:	33ff      	addlt	r3, #255	; 0xff
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 80092ea:	ebd2 4323 	rsbs	r3, r2, r3, asr #16
 80092ee:	bf48      	it	mi
 80092f0:	330f      	addmi	r3, #15
 80092f2:	eb02 1223 	add.w	r2, r2, r3, asr #4
 80092f6:	8002      	strh	r2, [r0, #0]

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
}
 80092f8:	f85d fb04 	ldr.w	pc, [sp], #4

080092fc <PQD_Clear>:
    /* nothing to do */
  }
  else
  {
#endif
    pHandle->hAvrgElMotorPower = 0;
 80092fc:	2300      	movs	r3, #0
 80092fe:	8003      	strh	r3, [r0, #0]
#ifdef NULL_PTR_CHECK_MOT_POW_MES
  }
#endif
}
 8009300:	4770      	bx	lr
 8009302:	bf00      	nop

08009304 <PQD_GetAvrgElMotorPowerW>:
  * 
  * @param pHandle pointer on the related component instance.
  * @retval float_t The average measured motor power expressed in Watts.
  */
__weak float_t PQD_GetAvrgElMotorPowerW(const PQD_MotorPowMeas_Handle_t *pHandle)
{
 8009304:	b510      	push	{r4, lr}
  else
  {
#endif

  /* First perform an integer multiplication, then a float one. */
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8009306:	f9b0 3000 	ldrsh.w	r3, [r0]
{
 800930a:	ed2d 8b02 	vpush	{d8}
 800930e:	4604      	mov	r4, r0
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 8009310:	68c0      	ldr	r0, [r0, #12]
 8009312:	ee08 3a10 	vmov	s16, r3
 8009316:	f7ff fbdf 	bl	8008ad8 <VBS_GetAvBusVoltage_V>
 800931a:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 800931e:	edd4 7a01 	vldr	s15, [r4, #4]
 8009322:	ee07 0a10 	vmov	s14, r0
 8009326:	ee28 8a27 	vmul.f32	s16, s16, s15
 800932a:	eeb8 0a47 	vcvt.f32.u32	s0, s14

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
  return (PowerW);
}
 800932e:	ee28 0a00 	vmul.f32	s0, s16, s0
 8009332:	ecbd 8b02 	vpop	{d8}
 8009336:	bd10      	pop	{r4, pc}

08009338 <startTimers>:
  * When this function is called, TIM1 and/or TIM8 must be in a frozen state
  * with CNT, ARR, REP RATE and trigger correctly set (these settings are
  * usually performed in the Init method accordingly with the configuration)
  */
__weak void startTimers(void)
{
 8009338:	b410      	push	{r4}
  *         (*) value not defined in all devices.
  * @retval State of Periphs (1 or 0).
  */
__STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
{
  return ((READ_BIT(RCC->APB1ENR1, Periphs) == Periphs) ? 1UL : 0UL);
 800933a:	4b19      	ldr	r3, [pc, #100]	; (80093a0 <startTimers+0x68>)
 800933c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800933e:	07d2      	lsls	r2, r2, #31
 8009340:	b083      	sub	sp, #12
 8009342:	d416      	bmi.n	8009372 <startTimers+0x3a>
  SET_BIT(RCC->APB1ENR1, Periphs);
 8009344:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8009346:	f042 0201 	orr.w	r2, r2, #1
 800934a:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800934c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800934e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8009352:	f002 0201 	and.w	r2, r2, #1
 8009356:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8009358:	9a01      	ldr	r2, [sp, #4]
 800935a:	694a      	ldr	r2, [r1, #20]
 800935c:	f042 0201 	orr.w	r2, r2, #1
 8009360:	614a      	str	r2, [r1, #20]
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8009362:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8009364:	f022 0201 	bic.w	r2, r2, #1
 8009368:	659a      	str	r2, [r3, #88]	; 0x58
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
    LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
    LL_TIM_GenerateEvent_UPDATE(TIM2);
    LL_TIM_SetTriggerOutput(TIM2, trigOut);
  }
}
 800936a:	b003      	add	sp, #12
 800936c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009370:	4770      	bx	lr
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
 8009372:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009376:	480b      	ldr	r0, [pc, #44]	; (80093a4 <startTimers+0x6c>)
 8009378:	685a      	ldr	r2, [r3, #4]
 800937a:	6859      	ldr	r1, [r3, #4]
 800937c:	4c0a      	ldr	r4, [pc, #40]	; (80093a8 <startTimers+0x70>)
 800937e:	4001      	ands	r1, r0
 8009380:	f041 0120 	orr.w	r1, r1, #32
 8009384:	6059      	str	r1, [r3, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009386:	6959      	ldr	r1, [r3, #20]
 8009388:	f041 0101 	orr.w	r1, r1, #1
 800938c:	6159      	str	r1, [r3, #20]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800938e:	6859      	ldr	r1, [r3, #4]
 8009390:	4022      	ands	r2, r4
 8009392:	4001      	ands	r1, r0
 8009394:	430a      	orrs	r2, r1
 8009396:	605a      	str	r2, [r3, #4]
}
 8009398:	b003      	add	sp, #12
 800939a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800939e:	4770      	bx	lr
 80093a0:	40021000 	.word	0x40021000
 80093a4:	fdffff8f 	.word	0xfdffff8f
 80093a8:	02000070 	.word	0x02000070

080093ac <waitForPolarizationEnd>:
  {
#endif
    uint16_t hCalibrationPeriodCounter;
    uint16_t hMaxPeriodsNumber;

    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80093ac:	3201      	adds	r2, #1
{
 80093ae:	b570      	push	{r4, r5, r6, lr}
    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 80093b0:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80093b2:	f06f 0602 	mvn.w	r6, #2
 80093b6:	0155      	lsls	r5, r2, #5
 80093b8:	6106      	str	r6, [r0, #16]

    /* Wait for NB_CONVERSIONS to be executed */
    LL_TIM_ClearFlag_CC1(TIMx);
    hCalibrationPeriodCounter = 0u;
 80093ba:	2200      	movs	r2, #0
    while (*cnt < NB_CONVERSIONS)
 80093bc:	f893 c000 	ldrb.w	ip, [r3]
 80093c0:	f1bc 0f0f 	cmp.w	ip, #15
    {
      if ((uint32_t)ERROR == LL_TIM_IsActiveFlag_CC1(TIMx))
      {
        LL_TIM_ClearFlag_CC1(TIMx);
        hCalibrationPeriodCounter++;
 80093c4:	f102 0e01 	add.w	lr, r2, #1
    while (*cnt < NB_CONVERSIONS)
 80093c8:	d80c      	bhi.n	80093e4 <waitForPolarizationEnd+0x38>
  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
 80093ca:	6904      	ldr	r4, [r0, #16]
 80093cc:	07a4      	lsls	r4, r4, #30
 80093ce:	d5f5      	bpl.n	80093bc <waitForPolarizationEnd+0x10>
        hCalibrationPeriodCounter++;
 80093d0:	fa1f f28e 	uxth.w	r2, lr
        if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
 80093d4:	4295      	cmp	r5, r2
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 80093d6:	6106      	str	r6, [r0, #16]
 80093d8:	d8f0      	bhi.n	80093bc <waitForPolarizationEnd+0x10>
        {
          if (*cnt < NB_CONVERSIONS)
 80093da:	781c      	ldrb	r4, [r3, #0]
 80093dc:	2c0f      	cmp	r4, #15
 80093de:	d8ed      	bhi.n	80093bc <waitForPolarizationEnd+0x10>
          {
            *SWerror = 1u;
 80093e0:	2301      	movs	r3, #1
 80093e2:	800b      	strh	r3, [r1, #0]
      }
    }
#ifdef NULL_PTR_CHECK_POW_COM
  }
#endif
  }
 80093e4:	bd70      	pop	{r4, r5, r6, pc}
 80093e6:	bf00      	nop

080093e8 <R3_1_GetPhaseCurrents>:
  * @brief  Computes and stores in the handler the latest converted motor phase currents in ab_t format.
  *
  */
__weak void R3_1_GetPhaseCurrents(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80093e8:	b1c1      	cbz	r1, 800941c <R3_1_GetPhaseCurrents+0x34>

    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl;  //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80093ea:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
{
 80093ee:	b470      	push	{r4, r5, r6}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80093f0:	e9d2 3400 	ldrd	r3, r4, [r2]
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint8_t Sector;

    Sector = (uint8_t)pHandle->_Super.Sector;
    ADCDataReg1 = ADCx->JDR1;
 80093f4:	f8d3 5080 	ldr.w	r5, [r3, #128]	; 0x80
    ADCDataReg2 = ADCx->JDR2;
 80093f8:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80093fc:	6863      	ldr	r3, [r4, #4]
    Sector = (uint8_t)pHandle->_Super.Sector;
 80093fe:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 8009402:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009406:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800940a:	6063      	str	r3, [r4, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    switch (Sector)
 800940c:	2a05      	cmp	r2, #5
 800940e:	f200 809b 	bhi.w	8009548 <R3_1_GetPhaseCurrents+0x160>
 8009412:	e8df f002 	tbb	[pc, r2]
 8009416:	3729      	.short	0x3729
 8009418:	29040437 	.word	0x29040437
 800941c:	4770      	bx	lr
      case SECTOR_4:
      case SECTOR_5:
      {
        /* Current on Phase C is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 800941e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 8009422:	4b4d      	ldr	r3, [pc, #308]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8009424:	1b52      	subs	r2, r2, r5
        if (Aux < -INT16_MAX)
 8009426:	429a      	cmp	r2, r3
 8009428:	db05      	blt.n	8009436 <R3_1_GetPhaseCurrents+0x4e>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 800942a:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
        {
          Iab->a = INT16_MAX;
        }
        else
        {
          Iab->a = (int16_t)Aux;
 800942e:	bfb4      	ite	lt
 8009430:	b213      	sxthlt	r3, r2
 8009432:	f647 73ff 	movwge	r3, #32767	; 0x7fff
        }

        /* Ib = PhaseBOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 8009436:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c

        /* Saturation of Ib */
        if (Aux < -INT16_MAX)
 800943a:	4a47      	ldr	r2, [pc, #284]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
          Iab->a = -INT16_MAX;
 800943c:	800b      	strh	r3, [r1, #0]
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 800943e:	1bad      	subs	r5, r5, r6
        if (Aux < -INT16_MAX)
 8009440:	4295      	cmp	r5, r2
      }

      default:
        break;
    }
    Iab->a = -Iab->a;
 8009442:	b29b      	uxth	r3, r3
        if (Aux < -INT16_MAX)
 8009444:	da2c      	bge.n	80094a0 <R3_1_GetPhaseCurrents+0xb8>
    Iab->a = -Iab->a;
 8009446:	425c      	negs	r4, r3
 8009448:	b224      	sxth	r4, r4
 800944a:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800944e:	f248 0501 	movw	r5, #32769	; 0x8001
    Iab->b = -Iab->b;
    pHandle->_Super.Ia = Iab->a;
    pHandle->_Super.Ib = Iab->b;
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8009452:	442b      	add	r3, r5
    Iab->a = -Iab->a;
 8009454:	800c      	strh	r4, [r1, #0]
    Iab->b = -Iab->b;
 8009456:	804a      	strh	r2, [r1, #2]
    pHandle->_Super.Ia = Iab->a;
 8009458:	f8a0 4062 	strh.w	r4, [r0, #98]	; 0x62
    pHandle->_Super.Ib = Iab->b;
 800945c:	f8a0 2064 	strh.w	r2, [r0, #100]	; 0x64
  }
}
 8009460:	bc70      	pop	{r4, r5, r6}
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 8009462:	f8a0 3066 	strh.w	r3, [r0, #102]	; 0x66
}
 8009466:	4770      	bx	lr
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8009468:	f8d0 408c 	ldr.w	r4, [r0, #140]	; 0x8c
        if (Aux < -INT16_MAX)
 800946c:	4a3a      	ldr	r2, [pc, #232]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 800946e:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 8009470:	4294      	cmp	r4, r2
 8009472:	db1d      	blt.n	80094b0 <R3_1_GetPhaseCurrents+0xc8>
        else  if (Aux > INT16_MAX)
 8009474:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 8009478:	db61      	blt.n	800953e <R3_1_GetPhaseCurrents+0x156>
 800947a:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800947e:	461d      	mov	r5, r3
 8009480:	461c      	mov	r4, r3
 8009482:	e01b      	b.n	80094bc <R3_1_GetPhaseCurrents+0xd4>
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8009484:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
        if (Aux < -INT16_MAX)
 8009488:	4c33      	ldr	r4, [pc, #204]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 800948a:	1b5d      	subs	r5, r3, r5
        if (Aux < -INT16_MAX)
 800948c:	42a5      	cmp	r5, r4
 800948e:	db25      	blt.n	80094dc <R3_1_GetPhaseCurrents+0xf4>
        else  if (Aux > INT16_MAX)
 8009490:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 8009494:	db4e      	blt.n	8009534 <R3_1_GetPhaseCurrents+0x14c>
 8009496:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800949a:	4613      	mov	r3, r2
 800949c:	4615      	mov	r5, r2
 800949e:	e023      	b.n	80094e8 <R3_1_GetPhaseCurrents+0x100>
        else  if (Aux > INT16_MAX)
 80094a0:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 80094a4:	db40      	blt.n	8009528 <R3_1_GetPhaseCurrents+0x140>
    Iab->a = -Iab->a;
 80094a6:	425c      	negs	r4, r3
 80094a8:	b224      	sxth	r4, r4
 80094aa:	f647 75ff 	movw	r5, #32767	; 0x7fff
 80094ae:	e7d0      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
 80094b0:	4613      	mov	r3, r2
 80094b2:	f248 0501 	movw	r5, #32769	; 0x8001
 80094b6:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80094ba:	461c      	mov	r4, r3
          Iab->b = -INT16_MAX;
 80094bc:	804b      	strh	r3, [r1, #2]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80094be:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 80094c2:	1af3      	subs	r3, r6, r3
        Aux -= (int32_t)Iab->b;             /* Ia  */
 80094c4:	1b1b      	subs	r3, r3, r4
        if (Aux > INT16_MAX)
 80094c6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80094ca:	da1d      	bge.n	8009508 <R3_1_GetPhaseCurrents+0x120>
        else  if (Aux < -INT16_MAX)
 80094cc:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 80094d0:	dc26      	bgt.n	8009520 <R3_1_GetPhaseCurrents+0x138>
 80094d2:	f647 74ff 	movw	r4, #32767	; 0x7fff
 80094d6:	f248 0301 	movw	r3, #32769	; 0x8001
 80094da:	e7ba      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
 80094dc:	4622      	mov	r2, r4
 80094de:	f248 0301 	movw	r3, #32769	; 0x8001
 80094e2:	f647 74ff 	movw	r4, #32767	; 0x7fff
 80094e6:	4615      	mov	r5, r2
          Iab->a = -INT16_MAX;
 80094e8:	800a      	strh	r2, [r1, #0]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80094ea:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 80094ee:	1ab2      	subs	r2, r6, r2
        Aux -= (int32_t)Iab->a;             /* Ib */
 80094f0:	1b52      	subs	r2, r2, r5
        if (Aux > INT16_MAX)
 80094f2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80094f6:	da0b      	bge.n	8009510 <R3_1_GetPhaseCurrents+0x128>
        else  if (Aux < -INT16_MAX)
 80094f8:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 80094fc:	dc0c      	bgt.n	8009518 <R3_1_GetPhaseCurrents+0x130>
 80094fe:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8009502:	f248 0501 	movw	r5, #32769	; 0x8001
 8009506:	e7a4      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
 8009508:	4c13      	ldr	r4, [pc, #76]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
 800950a:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800950e:	e7a0      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
 8009510:	4a11      	ldr	r2, [pc, #68]	; (8009558 <R3_1_GetPhaseCurrents+0x170>)
 8009512:	f647 75ff 	movw	r5, #32767	; 0x7fff
 8009516:	e79c      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
    Iab->b = -Iab->b;
 8009518:	b295      	uxth	r5, r2
 800951a:	426a      	negs	r2, r5
 800951c:	b212      	sxth	r2, r2
 800951e:	e798      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
    Iab->a = -Iab->a;
 8009520:	b29b      	uxth	r3, r3
 8009522:	425c      	negs	r4, r3
 8009524:	b224      	sxth	r4, r4
 8009526:	e794      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
    Iab->b = -Iab->b;
 8009528:	b2ad      	uxth	r5, r5
    Iab->a = -Iab->a;
 800952a:	425c      	negs	r4, r3
    Iab->b = -Iab->b;
 800952c:	426a      	negs	r2, r5
    Iab->a = -Iab->a;
 800952e:	b224      	sxth	r4, r4
    Iab->b = -Iab->b;
 8009530:	b212      	sxth	r2, r2
 8009532:	e78e      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
    Iab->a = -Iab->a;
 8009534:	b2ab      	uxth	r3, r5
 8009536:	425c      	negs	r4, r3
          Iab->a = (int16_t)Aux;
 8009538:	b22a      	sxth	r2, r5
    Iab->a = -Iab->a;
 800953a:	b224      	sxth	r4, r4
 800953c:	e7d4      	b.n	80094e8 <R3_1_GetPhaseCurrents+0x100>
    Iab->b = -Iab->b;
 800953e:	b2a5      	uxth	r5, r4
 8009540:	426a      	negs	r2, r5
          Iab->b = (int16_t)Aux;
 8009542:	b223      	sxth	r3, r4
    Iab->b = -Iab->b;
 8009544:	b212      	sxth	r2, r2
 8009546:	e7b9      	b.n	80094bc <R3_1_GetPhaseCurrents+0xd4>
    Iab->a = -Iab->a;
 8009548:	880b      	ldrh	r3, [r1, #0]
    Iab->b = -Iab->b;
 800954a:	884d      	ldrh	r5, [r1, #2]
    Iab->a = -Iab->a;
 800954c:	425c      	negs	r4, r3
    Iab->b = -Iab->b;
 800954e:	426a      	negs	r2, r5
    Iab->a = -Iab->a;
 8009550:	b224      	sxth	r4, r4
    Iab->b = -Iab->b;
 8009552:	b212      	sxth	r2, r2
 8009554:	e77d      	b.n	8009452 <R3_1_GetPhaseCurrents+0x6a>
 8009556:	bf00      	nop
 8009558:	ffff8001 	.word	0xffff8001

0800955c <R3_1_SetADCSampPointPolarization>:
  *
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns the return value of R3_1_WriteTIMRegisters.
  */
uint16_t R3_1_SetADCSampPointPolarization(PWMC_Handle_t *pHdl)
{
 800955c:	b410      	push	{r4}
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800955e:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  pHandle->_Super.Sector = pHandle->PolarizationSector;
 8009562:	f890 4099 	ldrb.w	r4, [r0, #153]	; 0x99
 8009566:	f880 407c 	strb.w	r4, [r0, #124]	; 0x7c
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 800956a:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800956e:	685b      	ldr	r3, [r3, #4]
  uint16_t Aux;


  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8009570:	f8b0 4050 	ldrh.w	r4, [r0, #80]	; 0x50
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009574:	635c      	str	r4, [r3, #52]	; 0x34
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8009576:	3a01      	subs	r2, #1
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8009578:	f8b0 4052 	ldrh.w	r4, [r0, #82]	; 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 800957c:	f8b0 0054 	ldrh.w	r0, [r0, #84]	; 0x54
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009580:	639c      	str	r4, [r3, #56]	; 0x38
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8009582:	b292      	uxth	r2, r2
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009584:	63d8      	str	r0, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009586:	641a      	str	r2, [r3, #64]	; 0x40
  LL_TIM_OC_SetCompareCH4(TIMx, (uint32_t) SamplingPoint);

  /* Limit for update event */

//  if ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 1u )
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009588:	4904      	ldr	r1, [pc, #16]	; (800959c <R3_1_SetADCSampPointPolarization+0x40>)
 800958a:	685b      	ldr	r3, [r3, #4]
}
 800958c:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009590:	420b      	tst	r3, r1
}
 8009592:	bf14      	ite	ne
 8009594:	2001      	movne	r0, #1
 8009596:	2000      	moveq	r0, #0
 8009598:	4770      	bx	lr
 800959a:	bf00      	nop
 800959c:	02000070 	.word	0x02000070

080095a0 <R3_1_HFCurrentsPolarizationAB>:
  * @param  Iab: Pointer to the structure that will receive motor current
  *         of phase A and B in ab_t format.
  */
static void R3_1_HFCurrentsPolarizationAB(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80095a0:	b321      	cbz	r1, 80095ec <R3_1_HFCurrentsPolarizationAB+0x4c>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80095a2:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 80095a6:	e9d2 3200 	ldrd	r3, r2, [r2]
{
 80095aa:	b430      	push	{r4, r5}
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint32_t ADCDataReg1 = ADCx->JDR1;
 80095ac:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
    uint32_t ADCDataReg2 = ADCx->JDR2;
 80095b0:	f8d3 5084 	ldr.w	r5, [r3, #132]	; 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80095b4:	6853      	ldr	r3, [r2, #4]
 80095b6:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80095ba:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80095be:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 80095c0:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 80095c4:	2b0f      	cmp	r3, #15
 80095c6:	d80d      	bhi.n	80095e4 <R3_1_HFCurrentsPolarizationAB+0x44>
    {
      pHandle-> PhaseAOffset += ADCDataReg1;
 80095c8:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
      pHandle-> PhaseBOffset += ADCDataReg2;
 80095cc:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
      pHandle-> PhaseAOffset += ADCDataReg1;
 80095d0:	441c      	add	r4, r3
      pHandle->PolarizationCounter++;
 80095d2:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
      pHandle-> PhaseBOffset += ADCDataReg2;
 80095d6:	442a      	add	r2, r5
      pHandle->PolarizationCounter++;
 80095d8:	3301      	adds	r3, #1
      pHandle-> PhaseBOffset += ADCDataReg2;
 80095da:	e9c0 4222 	strd	r4, r2, [r0, #136]	; 0x88
      pHandle->PolarizationCounter++;
 80095de:	b2db      	uxtb	r3, r3
 80095e0:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 80095e4:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 80095e6:	bc30      	pop	{r4, r5}
    Iab->a = 0;
 80095e8:	600b      	str	r3, [r1, #0]
}
 80095ea:	4770      	bx	lr
 80095ec:	4770      	bx	lr
 80095ee:	bf00      	nop

080095f0 <R3_1_HFCurrentsPolarizationC>:
  *                Min value: 0 (low sides ON)
  *                Max value: PWM_PERIOD_CYCLES/2 (low sides OFF)
  */
static void R3_1_HFCurrentsPolarizationC(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80095f0:	b301      	cbz	r1, 8009634 <R3_1_HFCurrentsPolarizationC+0x44>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80095f2:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
 80095f6:	e9d3 3200 	ldrd	r3, r2, [r3]
{
 80095fa:	b410      	push	{r4}
    uint32_t ADCDataReg2 = ADCx->JDR2;
 80095fc:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8009600:	6853      	ldr	r3, [r2, #4]
 8009602:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009606:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800960a:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 800960c:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 8009610:	2b0f      	cmp	r3, #15
 8009612:	d80a      	bhi.n	800962a <R3_1_HFCurrentsPolarizationC+0x3a>
    {
      /* Phase C is read from SECTOR_1, second value */
      pHandle-> PhaseCOffset += ADCDataReg2;
      pHandle->PolarizationCounter++;
 8009614:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
      pHandle-> PhaseCOffset += ADCDataReg2;
 8009618:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
      pHandle->PolarizationCounter++;
 800961c:	3301      	adds	r3, #1
      pHandle-> PhaseCOffset += ADCDataReg2;
 800961e:	4422      	add	r2, r4
      pHandle->PolarizationCounter++;
 8009620:	b2db      	uxtb	r3, r3
      pHandle-> PhaseCOffset += ADCDataReg2;
 8009622:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
      pHandle->PolarizationCounter++;
 8009626:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 800962a:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 800962c:	f85d 4b04 	ldr.w	r4, [sp], #4
    Iab->a = 0;
 8009630:	600b      	str	r3, [r1, #0]
}
 8009632:	4770      	bx	lr
 8009634:	4770      	bx	lr
 8009636:	bf00      	nop

08009638 <R3_1_SwitchOnPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009638:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  pHandle->ADCRegularLocked = true;

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Set all duty to 50% */
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 800963c:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009640:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 8009642:	f04f 0c01 	mov.w	ip, #1
{
 8009646:	b530      	push	{r4, r5, lr}
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 8009648:	fa22 f10c 	lsr.w	r1, r2, ip
  pHandle->_Super.TurnOnLowSidesAction = false;
 800964c:	f04f 0e00 	mov.w	lr, #0
 8009650:	f880 e07e 	strb.w	lr, [r0, #126]	; 0x7e
  pHandle->ADCRegularLocked = true;
 8009654:	f880 c0a0 	strb.w	ip, [r0, #160]	; 0xa0
  LL_TIM_OC_SetCompareCH2(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH3(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t)pHandle->Half_PWMPeriod - (uint32_t)5));
 8009658:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 800965a:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800965c:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 800965e:	63d9      	str	r1, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009660:	f06f 0101 	mvn.w	r1, #1
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009664:	641a      	str	r2, [r3, #64]	; 0x40
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009666:	6119      	str	r1, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009668:	691a      	ldr	r2, [r3, #16]
 800966a:	07d2      	lsls	r2, r2, #31
 800966c:	d5fc      	bpl.n	8009668 <R3_1_SwitchOnPWM+0x30>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800966e:	f06f 0201 	mvn.w	r2, #1
 8009672:	611a      	str	r2, [r3, #16]
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* Main PWM Output Enable */
  TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 8009674:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009676:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800967a:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800967c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800967e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009682:	645a      	str	r2, [r3, #68]	; 0x44
  LL_TIM_EnableAllOutputs(TIMx);

  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8009684:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 8009688:	2a02      	cmp	r2, #2
 800968a:	d007      	beq.n	800969c <R3_1_SwitchOnPWM+0x64>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800968c:	f06f 0201 	mvn.w	r2, #1
 8009690:	611a      	str	r2, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009692:	68da      	ldr	r2, [r3, #12]
 8009694:	f042 0201 	orr.w	r2, r2, #1
 8009698:	60da      	str	r2, [r3, #12]
  }
  /* Clear Update Flag */
  LL_TIM_ClearFlag_UPDATE(TIMx);
  /* Enable Update IRQ */
  LL_TIM_EnableIT_UPDATE(TIMx);
}
 800969a:	bd30      	pop	{r4, r5, pc}
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 800969c:	6a19      	ldr	r1, [r3, #32]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800969e:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 80096a2:	f240 5255 	movw	r2, #1365	; 0x555
 80096a6:	4211      	tst	r1, r2
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80096a8:	e9d0 140f 	ldrd	r1, r4, [r0, #60]	; 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80096ac:	6c42      	ldr	r2, [r0, #68]	; 0x44
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 80096ae:	d007      	beq.n	80096c0 <R3_1_SwitchOnPWM+0x88>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 80096b0:	618d      	str	r5, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80096b2:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80096b6:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 80096ba:	61a5      	str	r5, [r4, #24]
 80096bc:	6191      	str	r1, [r2, #24]
}
 80096be:	e7e5      	b.n	800968c <R3_1_SwitchOnPWM+0x54>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 80096c0:	628d      	str	r5, [r1, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80096c2:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80096c6:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 80096ca:	62a5      	str	r5, [r4, #40]	; 0x28
 80096cc:	6291      	str	r1, [r2, #40]	; 0x28
}
 80096ce:	e7dd      	b.n	800968c <R3_1_SwitchOnPWM+0x54>

080096d0 <R3_1_SwitchOffPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80096d0:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Main PWM Output Disable */
  LL_TIM_DisableAllOutputs(TIMx);
  if (true == pHandle->_Super.BrakeActionLock)
 80096d4:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80096d8:	685b      	ldr	r3, [r3, #4]
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 80096da:	68da      	ldr	r2, [r3, #12]
 80096dc:	f022 0201 	bic.w	r2, r2, #1
 80096e0:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80096e2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  pHandle->_Super.TurnOnLowSidesAction = false;
 80096e4:	f04f 0c00 	mov.w	ip, #0
 80096e8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80096ec:	f880 c07e 	strb.w	ip, [r0, #126]	; 0x7e
 80096f0:	645a      	str	r2, [r3, #68]	; 0x44
  if (true == pHandle->_Super.BrakeActionLock)
 80096f2:	b919      	cbnz	r1, 80096fc <R3_1_SwitchOffPWM+0x2c>
  {
    /* Nothing to do */
  }
  else
  {
    if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 80096f4:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 80096f8:	2a02      	cmp	r2, #2
 80096fa:	d00c      	beq.n	8009716 <R3_1_SwitchOffPWM+0x46>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80096fc:	f06f 0201 	mvn.w	r2, #1
 8009700:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009702:	691a      	ldr	r2, [r3, #16]
 8009704:	07d2      	lsls	r2, r2, #31
 8009706:	d5fc      	bpl.n	8009702 <R3_1_SwitchOffPWM+0x32>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009708:	f06f 0101 	mvn.w	r1, #1
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* We allow ADC usage for regular conversion on Systick*/
  pHandle->ADCRegularLocked = false;
 800970c:	2200      	movs	r2, #0
 800970e:	6119      	str	r1, [r3, #16]
 8009710:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
 8009714:	4770      	bx	lr
{
 8009716:	b430      	push	{r4, r5}
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009718:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	; 0x3c
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800971c:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009720:	6c42      	ldr	r2, [r0, #68]	; 0x44
  WRITE_REG(GPIOx->BRR, PinMask);
 8009722:	62a5      	str	r5, [r4, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009724:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 8009728:	628c      	str	r4, [r1, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800972a:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 800972e:	6291      	str	r1, [r2, #40]	; 0x28
 8009730:	f06f 0201 	mvn.w	r2, #1
 8009734:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009736:	691a      	ldr	r2, [r3, #16]
 8009738:	07d1      	lsls	r1, r2, #31
 800973a:	d5fc      	bpl.n	8009736 <R3_1_SwitchOffPWM+0x66>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800973c:	f06f 0101 	mvn.w	r1, #1
  pHandle->ADCRegularLocked = false;
 8009740:	2200      	movs	r2, #0
 8009742:	6119      	str	r1, [r3, #16]
}
 8009744:	bc30      	pop	{r4, r5}
  pHandle->ADCRegularLocked = false;
 8009746:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
}
 800974a:	4770      	bx	lr

0800974c <R3_1_RLGetPhaseCurrents>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800974c:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    int32_t wAux;

    /* Disable ADC trigger source */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    wAux = ((int32_t)pHandle->PhaseBOffset)
 8009750:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
{
 8009754:	b410      	push	{r4}
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009756:	e9d3 4200 	ldrd	r4, r2, [r3]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800975a:	6853      	ldr	r3, [r2, #4]
 800975c:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009760:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009764:	6053      	str	r3, [r2, #4]
         - (int32_t)ADCx->JDR2;
 8009766:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84

    /* Check saturation */
    if (wAux > -INT16_MAX)
 800976a:	4c0c      	ldr	r4, [pc, #48]	; (800979c <R3_1_RLGetPhaseCurrents+0x50>)
    wAux = ((int32_t)pHandle->PhaseBOffset)
 800976c:	1ac2      	subs	r2, r0, r3
    if (wAux > -INT16_MAX)
 800976e:	42a2      	cmp	r2, r4
 8009770:	db06      	blt.n	8009780 <R3_1_RLGetPhaseCurrents+0x34>
    {
      if (wAux < INT16_MAX)
 8009772:	f647 74fe 	movw	r4, #32766	; 0x7ffe
 8009776:	42a2      	cmp	r2, r4
 8009778:	dc0d      	bgt.n	8009796 <R3_1_RLGetPhaseCurrents+0x4a>
    }
    else
    {
      wAux = -INT16_MAX;
    }
    wAux = -wAux;
 800977a:	1a1b      	subs	r3, r3, r0
    pStator_Currents->a = (int16_t)wAux;
 800977c:	b21b      	sxth	r3, r3
 800977e:	e001      	b.n	8009784 <R3_1_RLGetPhaseCurrents+0x38>
 8009780:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8009784:	2200      	movs	r2, #0
 8009786:	f363 020f 	bfi	r2, r3, #0, #16
 800978a:	f363 421f 	bfi	r2, r3, #16, #16
    pStator_Currents->b = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800978e:	f85d 4b04 	ldr.w	r4, [sp], #4
    pStator_Currents->a = (int16_t)wAux;
 8009792:	600a      	str	r2, [r1, #0]
}
 8009794:	4770      	bx	lr
 8009796:	4b02      	ldr	r3, [pc, #8]	; (80097a0 <R3_1_RLGetPhaseCurrents+0x54>)
 8009798:	e7f4      	b.n	8009784 <R3_1_RLGetPhaseCurrents+0x38>
 800979a:	bf00      	nop
 800979c:	ffff8002 	.word	0xffff8002
 80097a0:	ffff8001 	.word	0xffff8001

080097a4 <R3_1_RLSwitchOnPWM>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80097a4:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 80097a8:	e9d2 1300 	ldrd	r1, r3, [r2]
{
 80097ac:	b430      	push	{r4, r5}
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80097ae:	f06f 0201 	mvn.w	r2, #1

    pHandle->ADCRegularLocked=true;
 80097b2:	2401      	movs	r4, #1
 80097b4:	f880 40a0 	strb.w	r4, [r0, #160]	; 0xa0
 80097b8:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80097ba:	691a      	ldr	r2, [r3, #16]
 80097bc:	07d4      	lsls	r4, r2, #31
 80097be:	d5fc      	bpl.n	80097ba <R3_1_RLSwitchOnPWM+0x16>
    }
    /* Clear Update Flag */
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 1U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 80097c0:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80097c4:	f06f 0401 	mvn.w	r4, #1
 80097c8:	611c      	str	r4, [r3, #16]
 80097ca:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 80097cc:	2401      	movs	r4, #1
 80097ce:	635c      	str	r4, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR4, CompareValue);
 80097d0:	641a      	str	r2, [r3, #64]	; 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80097d2:	691a      	ldr	r2, [r3, #16]
 80097d4:	07d2      	lsls	r2, r2, #31
 80097d6:	d5fc      	bpl.n	80097d2 <R3_1_RLSwitchOnPWM+0x2e>
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 80097d8:	68da      	ldr	r2, [r3, #12]
 80097da:	f042 0201 	orr.w	r2, r2, #1
 80097de:	60da      	str	r2, [r3, #12]

    /* Enable TIMx update interrupt */
    LL_TIM_EnableIT_UPDATE(TIMx);

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 80097e0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80097e2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80097e6:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80097e8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80097ea:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80097ee:	645a      	str	r2, [r3, #68]	; 0x44
    LL_TIM_EnableAllOutputs(TIMx);

    if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 80097f0:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 80097f4:	2a02      	cmp	r2, #2
 80097f6:	d00c      	beq.n	8009812 <R3_1_RLSwitchOnPWM+0x6e>
      /* Nothing to do */
    }

    /* Set the sector that correspond to Phase B and C sampling
     * B will be sampled by ADCx */
    pHdl->Sector = SECTOR_4;
 80097f8:	2303      	movs	r3, #3
 80097fa:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
  MODIFY_REG(ADCx->CR,
 80097fe:	688b      	ldr	r3, [r1, #8]
 8009800:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009804:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009808:	f043 0308 	orr.w	r3, r3, #8
    LL_ADC_INJ_StartConversion(ADCx);

#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800980c:	bc30      	pop	{r4, r5}
 800980e:	608b      	str	r3, [r1, #8]
 8009810:	4770      	bx	lr
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 8009812:	6a1a      	ldr	r2, [r3, #32]
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8009814:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8009816:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 800981a:	f240 5355 	movw	r3, #1365	; 0x555
 800981e:	421a      	tst	r2, r3
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009820:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 8009824:	d007      	beq.n	8009836 <R3_1_RLSwitchOnPWM+0x92>
  WRITE_REG(GPIOx->BSRR, PinMask);
 8009826:	61a5      	str	r5, [r4, #24]
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009828:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 800982c:	6194      	str	r4, [r2, #24]
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800982e:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 8009832:	629a      	str	r2, [r3, #40]	; 0x28
}
 8009834:	e7e0      	b.n	80097f8 <R3_1_RLSwitchOnPWM+0x54>
  WRITE_REG(GPIOx->BRR, PinMask);
 8009836:	62a5      	str	r5, [r4, #40]	; 0x28
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009838:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 800983c:	6294      	str	r4, [r2, #40]	; 0x28
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800983e:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 8009842:	629a      	str	r2, [r3, #40]	; 0x28
}
 8009844:	e7d8      	b.n	80097f8 <R3_1_RLSwitchOnPWM+0x54>
 8009846:	bf00      	nop

08009848 <R3_1_TurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009848:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 800984c:	685b      	ldr	r3, [r3, #4]
  pHandle->_Super.TurnOnLowSidesAction = true;
 800984e:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009852:	f06f 0201 	mvn.w	r2, #1
 8009856:	f880 c07e 	strb.w	ip, [r0, #126]	; 0x7e
 800985a:	611a      	str	r2, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800985c:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800985e:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009860:	63d9      	str	r1, [r3, #60]	; 0x3c
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009862:	691a      	ldr	r2, [r3, #16]
 8009864:	07d2      	lsls	r2, r2, #31
 8009866:	d5fc      	bpl.n	8009862 <R3_1_TurnOnLowSides+0x1a>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009868:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800986a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800986e:	645a      	str	r2, [r3, #68]	; 0x44
  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8009870:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 8009874:	2b02      	cmp	r3, #2
 8009876:	d000      	beq.n	800987a <R3_1_TurnOnLowSides+0x32>
 8009878:	4770      	bx	lr
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800987a:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	; 0x3c
{
 800987e:	b410      	push	{r4}
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009880:	6c43      	ldr	r3, [r0, #68]	; 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8009882:	f8b0 4048 	ldrh.w	r4, [r0, #72]	; 0x48
  WRITE_REG(GPIOx->BSRR, PinMask);
 8009886:	6194      	str	r4, [r2, #24]
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009888:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800988c:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 8009890:	618c      	str	r4, [r1, #24]
}
 8009892:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009896:	619a      	str	r2, [r3, #24]
 8009898:	4770      	bx	lr
 800989a:	bf00      	nop

0800989c <R3_1_SetAOReferenceVoltage>:
  * @param  Data Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_DAC_ConvertData12LeftAligned(DAC_TypeDef *DACx, uint32_t DAC_Channel, uint32_t Data)
{
  __IO uint32_t *preg = __DAC_PTR_REG_OFFSET(DACx->DHR12R1, (DAC_Channel >> DAC_REG_DHR12LX_REGOFFSET_BITOFFSET_POS)
 800989c:	ea4f 4c90 	mov.w	ip, r0, lsr #18
{
 80098a0:	b510      	push	{r4, lr}
 80098a2:	f00c 0c3c 	and.w	ip, ip, #60	; 0x3c
 80098a6:	f101 0e08 	add.w	lr, r1, #8
 80098aa:	b082      	sub	sp, #8
                                             & DAC_REG_DHR_REGOFFSET_MASK_POSBIT0);

  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 80098ac:	f85e 300c 	ldr.w	r3, [lr, ip]
 80098b0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80098b4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80098b8:	431a      	orrs	r2, r3
 80098ba:	f84e 200c 	str.w	r2, [lr, ip]
  SET_BIT(DACx->SWTRIGR,
 80098be:	684a      	ldr	r2, [r1, #4]
 80098c0:	f000 0303 	and.w	r3, r0, #3
 80098c4:	4313      	orrs	r3, r2
 80098c6:	604b      	str	r3, [r1, #4]
  return ((READ_BIT(DACx->CR,
 80098c8:	680a      	ldr	r2, [r1, #0]
 80098ca:	f000 0010 	and.w	r0, r0, #16
 80098ce:	2301      	movs	r3, #1
 80098d0:	4083      	lsls	r3, r0
           == (DAC_CR_EN1 << (DAC_Channel & DAC_CR_CHX_BITOFFSET_MASK))) ? 1UL : 0UL);
 80098d2:	ea33 0202 	bics.w	r2, r3, r2
 80098d6:	d014      	beq.n	8009902 <R3_1_SetAOReferenceVoltage+0x66>
                                         * (SystemCoreClock / (1000000UL * 2UL)));
 80098d8:	4a14      	ldr	r2, [pc, #80]	; (800992c <R3_1_SetAOReferenceVoltage+0x90>)
 80098da:	4815      	ldr	r0, [pc, #84]	; (8009930 <R3_1_SetAOReferenceVoltage+0x94>)
 80098dc:	6812      	ldr	r2, [r2, #0]
  SET_BIT(DACx->CR,
 80098de:	680c      	ldr	r4, [r1, #0]
 80098e0:	fba0 0202 	umull	r0, r2, r0, r2
 80098e4:	0cd2      	lsrs	r2, r2, #19
 80098e6:	4323      	orrs	r3, r4
 80098e8:	00d2      	lsls	r2, r2, #3
 80098ea:	600b      	str	r3, [r1, #0]
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US)
 80098ec:	9200      	str	r2, [sp, #0]
    while (wait_loop_index != 0UL)
 80098ee:	9b00      	ldr	r3, [sp, #0]
 80098f0:	b12b      	cbz	r3, 80098fe <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 80098f2:	9b00      	ldr	r3, [sp, #0]
 80098f4:	3b01      	subs	r3, #1
 80098f6:	9300      	str	r3, [sp, #0]
    while (wait_loop_index != 0UL)
 80098f8:	9b00      	ldr	r3, [sp, #0]
 80098fa:	2b00      	cmp	r3, #0
 80098fc:	d1f9      	bne.n	80098f2 <R3_1_SetAOReferenceVoltage+0x56>
}
 80098fe:	b002      	add	sp, #8
 8009900:	bd10      	pop	{r4, pc}
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));
 8009902:	4b0a      	ldr	r3, [pc, #40]	; (800992c <R3_1_SetAOReferenceVoltage+0x90>)
 8009904:	4a0a      	ldr	r2, [pc, #40]	; (8009930 <R3_1_SetAOReferenceVoltage+0x94>)
 8009906:	681b      	ldr	r3, [r3, #0]
 8009908:	fba2 2303 	umull	r2, r3, r2, r3
 800990c:	0cdb      	lsrs	r3, r3, #19
 800990e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8009912:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8009914:	9b01      	ldr	r3, [sp, #4]
 8009916:	2b00      	cmp	r3, #0
 8009918:	d0f1      	beq.n	80098fe <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 800991a:	9b01      	ldr	r3, [sp, #4]
 800991c:	3b01      	subs	r3, #1
 800991e:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8009920:	9b01      	ldr	r3, [sp, #4]
 8009922:	2b00      	cmp	r3, #0
 8009924:	d1f9      	bne.n	800991a <R3_1_SetAOReferenceVoltage+0x7e>
}
 8009926:	b002      	add	sp, #8
 8009928:	bd10      	pop	{r4, pc}
 800992a:	bf00      	nop
 800992c:	200014a4 	.word	0x200014a4
 8009930:	431bde83 	.word	0x431bde83

08009934 <R3_1_RLTurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009934:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 8009938:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 800993a:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 800993e:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009940:	f06f 0201 	mvn.w	r2, #1
 8009944:	f880 c0a0 	strb.w	ip, [r0, #160]	; 0xa0
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009948:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800994a:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800994c:	691a      	ldr	r2, [r3, #16]
 800994e:	07d2      	lsls	r2, r2, #31
 8009950:	d5fc      	bpl.n	800994c <R3_1_RLTurnOnLowSides+0x18>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009952:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009954:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009958:	645a      	str	r2, [r3, #68]	; 0x44
  if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 800995a:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 800995e:	2b02      	cmp	r3, #2
 8009960:	d000      	beq.n	8009964 <R3_1_RLTurnOnLowSides+0x30>
 8009962:	4770      	bx	lr
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009964:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	; 0x3c
{
 8009968:	b410      	push	{r4}
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800996a:	6c43      	ldr	r3, [r0, #68]	; 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800996c:	f8b0 4048 	ldrh.w	r4, [r0, #72]	; 0x48
 8009970:	6194      	str	r4, [r2, #24]
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009972:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009976:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 800997a:	628c      	str	r4, [r1, #40]	; 0x28
}
 800997c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009980:	629a      	str	r2, [r3, #40]	; 0x28
 8009982:	4770      	bx	lr

08009984 <R3_1_Init>:
  if (MC_NULL == pHandle)
 8009984:	2800      	cmp	r0, #0
 8009986:	f000 8140 	beq.w	8009c0a <R3_1_Init+0x286>
{
 800998a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    R3_3_OPAMPParams_t *OPAMPParams = pHandle->pParams_str->OPAMPParams;
 800998e:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009992:	682e      	ldr	r6, [r5, #0]
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 8009994:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 8009996:	6872      	ldr	r2, [r6, #4]
    COMP_TypeDef *COMP_OCPBx = pHandle->pParams_str->CompOCPBSelection;
 8009998:	f8d5 a010 	ldr.w	sl, [r5, #16]
{
 800999c:	b087      	sub	sp, #28
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 800999e:	f04f 0c04 	mov.w	ip, #4
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 80099a2:	f022 0204 	bic.w	r2, r2, #4
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 80099a6:	9401      	str	r4, [sp, #4]
    DAC_TypeDef *DAC_OVPx = pHandle->pParams_str->DAC_OVP_Selection;
 80099a8:	6aac      	ldr	r4, [r5, #40]	; 0x28
 80099aa:	9402      	str	r4, [sp, #8]
    COMP_TypeDef *COMP_OVPx = pHandle->pParams_str->CompOVPSelection;
 80099ac:	e9d5 9805 	ldrd	r9, r8, [r5, #20]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80099b0:	686c      	ldr	r4, [r5, #4]
    DAC_TypeDef *DAC_OCPBx = pHandle->pParams_str->DAC_OCP_BSelection;
 80099b2:	e9d5 1b07 	ldrd	r1, fp, [r5, #28]
 80099b6:	4607      	mov	r7, r0
    COMP_TypeDef *COMP_OCPAx = pHandle->pParams_str->CompOCPASelection;
 80099b8:	e9d5 0302 	ldrd	r0, r3, [r5, #8]
 80099bc:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80099be:	f8c6 c000 	str.w	ip, [r6]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 80099c2:	6872      	ldr	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 80099c4:	f04f 0c20 	mov.w	ip, #32
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 80099c8:	f022 0220 	bic.w	r2, r2, #32
 80099cc:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 80099ce:	f8c6 c000 	str.w	ip, [r6]
      if (TIM1 ==  TIMx)
 80099d2:	4aaa      	ldr	r2, [pc, #680]	; (8009c7c <R3_1_Init+0x2f8>)
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
{
  SET_BIT(DBGMCU->APB2FZ, Periphs);
 80099d4:	f8df c2b4 	ldr.w	ip, [pc, #692]	; 8009c8c <R3_1_Init+0x308>
 80099d8:	4294      	cmp	r4, r2
 80099da:	f8dc 2010 	ldr.w	r2, [ip, #16]
 80099de:	bf0c      	ite	eq
 80099e0:	f442 6200 	orreq.w	r2, r2, #2048	; 0x800
 80099e4:	f442 5200 	orrne.w	r2, r2, #8192	; 0x2000
 80099e8:	f8cc 2010 	str.w	r2, [ip, #16]
      if (OPAMPParams != NULL)
 80099ec:	b190      	cbz	r0, 8009a14 <R3_1_Init+0x90>
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_1[1]);
 80099ee:	e9d0 2c00 	ldrd	r2, ip, [r0]
  * @param  OPAMPx OPAMP instance
  * @retval None
  */
__STATIC_INLINE void LL_OPAMP_Enable(OPAMP_TypeDef *OPAMPx)
{
  SET_BIT(OPAMPx->CSR, OPAMP_CSR_OPAMPxEN);
 80099f2:	f8d2 e000 	ldr.w	lr, [r2]
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_2[0]);
 80099f6:	6980      	ldr	r0, [r0, #24]
 80099f8:	f04e 0e01 	orr.w	lr, lr, #1
 80099fc:	f8c2 e000 	str.w	lr, [r2]
 8009a00:	f8dc 2000 	ldr.w	r2, [ip]
 8009a04:	f042 0201 	orr.w	r2, r2, #1
 8009a08:	f8cc 2000 	str.w	r2, [ip]
 8009a0c:	6802      	ldr	r2, [r0, #0]
 8009a0e:	f042 0201 	orr.w	r2, r2, #1
 8009a12:	6002      	str	r2, [r0, #0]
      if (COMP_OCPAx != NULL)
 8009a14:	b19b      	cbz	r3, 8009a3e <R3_1_Init+0xba>
        if ((pHandle->pParams_str->CompOCPAInvInput_MODE != EXT_MODE) && (DAC_OCPAx != MC_NULL))
 8009a16:	f895 2063 	ldrb.w	r2, [r5, #99]	; 0x63
 8009a1a:	2a01      	cmp	r2, #1
 8009a1c:	d007      	beq.n	8009a2e <R3_1_Init+0xaa>
 8009a1e:	b131      	cbz	r1, 8009a2e <R3_1_Init+0xaa>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPA, DAC_OCPAx,
 8009a20:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 8009a24:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8009a26:	9303      	str	r3, [sp, #12]
 8009a28:	f7ff ff38 	bl	800989c <R3_1_SetAOReferenceVoltage>
 8009a2c:	9b03      	ldr	r3, [sp, #12]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Enable(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a2e:	681a      	ldr	r2, [r3, #0]
 8009a30:	f042 0201 	orr.w	r2, r2, #1
 8009a34:	601a      	str	r2, [r3, #0]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Lock(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009a36:	681a      	ldr	r2, [r3, #0]
 8009a38:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8009a3c:	601a      	str	r2, [r3, #0]
      if (COMP_OCPBx != NULL)
 8009a3e:	f1ba 0f00 	cmp.w	sl, #0
 8009a42:	d018      	beq.n	8009a76 <R3_1_Init+0xf2>
        if ((pHandle->pParams_str->CompOCPBInvInput_MODE != EXT_MODE) && (DAC_OCPBx != MC_NULL))
 8009a44:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
 8009a48:	2b01      	cmp	r3, #1
 8009a4a:	d008      	beq.n	8009a5e <R3_1_Init+0xda>
 8009a4c:	f1bb 0f00 	cmp.w	fp, #0
 8009a50:	d005      	beq.n	8009a5e <R3_1_Init+0xda>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPB, DAC_OCPBx,
 8009a52:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 8009a56:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8009a58:	4659      	mov	r1, fp
 8009a5a:	f7ff ff1f 	bl	800989c <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a5e:	f8da 3000 	ldr.w	r3, [sl]
 8009a62:	f043 0301 	orr.w	r3, r3, #1
 8009a66:	f8ca 3000 	str.w	r3, [sl]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009a6a:	f8da 3000 	ldr.w	r3, [sl]
 8009a6e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009a72:	f8ca 3000 	str.w	r3, [sl]
      if (COMP_OCPCx != NULL)
 8009a76:	f1b9 0f00 	cmp.w	r9, #0
 8009a7a:	d017      	beq.n	8009aac <R3_1_Init+0x128>
        if ((pHandle->pParams_str->CompOCPCInvInput_MODE != EXT_MODE)  && (DAC_OCPCx != MC_NULL))
 8009a7c:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8009a80:	2b01      	cmp	r3, #1
 8009a82:	d007      	beq.n	8009a94 <R3_1_Init+0x110>
 8009a84:	9b01      	ldr	r3, [sp, #4]
 8009a86:	b12b      	cbz	r3, 8009a94 <R3_1_Init+0x110>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPC, DAC_OCPCx,
 8009a88:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 8009a8c:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8009a8e:	4619      	mov	r1, r3
 8009a90:	f7ff ff04 	bl	800989c <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a94:	f8d9 3000 	ldr.w	r3, [r9]
 8009a98:	f043 0301 	orr.w	r3, r3, #1
 8009a9c:	f8c9 3000 	str.w	r3, [r9]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009aa0:	f8d9 3000 	ldr.w	r3, [r9]
 8009aa4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009aa8:	f8c9 3000 	str.w	r3, [r9]
      if (COMP_OVPx != NULL)
 8009aac:	f1b8 0f00 	cmp.w	r8, #0
 8009ab0:	d017      	beq.n	8009ae2 <R3_1_Init+0x15e>
        if ((pHandle->pParams_str->CompOVPInvInput_MODE != EXT_MODE) && (DAC_OVPx != MC_NULL))
 8009ab2:	f895 3066 	ldrb.w	r3, [r5, #102]	; 0x66
 8009ab6:	2b01      	cmp	r3, #1
 8009ab8:	d007      	beq.n	8009aca <R3_1_Init+0x146>
 8009aba:	9b02      	ldr	r3, [sp, #8]
 8009abc:	b12b      	cbz	r3, 8009aca <R3_1_Init+0x146>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OVP, DAC_OVPx,
 8009abe:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
 8009ac2:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8009ac4:	4619      	mov	r1, r3
 8009ac6:	f7ff fee9 	bl	800989c <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009aca:	f8d8 3000 	ldr.w	r3, [r8]
 8009ace:	f043 0301 	orr.w	r3, r3, #1
 8009ad2:	f8c8 3000 	str.w	r3, [r8]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009ad6:	f8d8 3000 	ldr.w	r3, [r8]
 8009ada:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009ade:	f8c8 3000 	str.w	r3, [r8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8009ae2:	68b3      	ldr	r3, [r6, #8]
 8009ae4:	07da      	lsls	r2, r3, #31
 8009ae6:	d45a      	bmi.n	8009b9e <R3_1_Init+0x21a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8009ae8:	68b3      	ldr	r3, [r6, #8]
 8009aea:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8009aee:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009af2:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8009af4:	68b3      	ldr	r3, [r6, #8]
 8009af6:	00db      	lsls	r3, r3, #3
 8009af8:	d418      	bmi.n	8009b2c <R3_1_Init+0x1a8>
  MODIFY_REG(ADCx->CR,
 8009afa:	68b3      	ldr	r3, [r6, #8]
                                         * (SystemCoreClock / (100000UL * 2UL)));
 8009afc:	4a60      	ldr	r2, [pc, #384]	; (8009c80 <R3_1_Init+0x2fc>)
 8009afe:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8009b02:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009b06:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009b0a:	60b3      	str	r3, [r6, #8]
 8009b0c:	4b5d      	ldr	r3, [pc, #372]	; (8009c84 <R3_1_Init+0x300>)
 8009b0e:	681b      	ldr	r3, [r3, #0]
 8009b10:	099b      	lsrs	r3, r3, #6
 8009b12:	fba2 2303 	umull	r2, r3, r2, r3
 8009b16:	099b      	lsrs	r3, r3, #6
 8009b18:	005b      	lsls	r3, r3, #1
    volatile uint32_t wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL)
 8009b1a:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8009b1c:	9b04      	ldr	r3, [sp, #16]
 8009b1e:	b12b      	cbz	r3, 8009b2c <R3_1_Init+0x1a8>
      wait_loop_index--;
 8009b20:	9b04      	ldr	r3, [sp, #16]
 8009b22:	3b01      	subs	r3, #1
 8009b24:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8009b26:	9b04      	ldr	r3, [sp, #16]
 8009b28:	2b00      	cmp	r3, #0
 8009b2a:	d1f9      	bne.n	8009b20 <R3_1_Init+0x19c>
  MODIFY_REG(ADCx->CR,
 8009b2c:	68b3      	ldr	r3, [r6, #8]
 8009b2e:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8009b32:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009b36:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009b3a:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8009b3c:	68b3      	ldr	r3, [r6, #8]
 8009b3e:	2b00      	cmp	r3, #0
 8009b40:	dbfc      	blt.n	8009b3c <R3_1_Init+0x1b8>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009b42:	6833      	ldr	r3, [r6, #0]
 8009b44:	07d8      	lsls	r0, r3, #31
 8009b46:	d408      	bmi.n	8009b5a <R3_1_Init+0x1d6>
  MODIFY_REG(ADCx->CR,
 8009b48:	4a4f      	ldr	r2, [pc, #316]	; (8009c88 <R3_1_Init+0x304>)
 8009b4a:	68b3      	ldr	r3, [r6, #8]
 8009b4c:	4013      	ands	r3, r2
 8009b4e:	f043 0301 	orr.w	r3, r3, #1
 8009b52:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009b54:	6833      	ldr	r3, [r6, #0]
 8009b56:	07d9      	lsls	r1, r3, #31
 8009b58:	d5f7      	bpl.n	8009b4a <R3_1_Init+0x1c6>
  MODIFY_REG(ADCx->CR,
 8009b5a:	68b3      	ldr	r3, [r6, #8]
 8009b5c:	4a4a      	ldr	r2, [pc, #296]	; (8009c88 <R3_1_Init+0x304>)
 8009b5e:	4013      	ands	r3, r2
 8009b60:	f043 0308 	orr.w	r3, r3, #8
 8009b64:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CR,
 8009b66:	68b3      	ldr	r3, [r6, #8]
 8009b68:	4013      	ands	r3, r2
 8009b6a:	f043 0320 	orr.w	r3, r3, #32
 8009b6e:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 8009b70:	68f3      	ldr	r3, [r6, #12]
 8009b72:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009b76:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8009b7a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8009b7e:	60f3      	str	r3, [r6, #12]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 8009b80:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8009b82:	f023 030f 	bic.w	r3, r3, #15
 8009b86:	6333      	str	r3, [r6, #48]	; 0x30
  MODIFY_REG(ADCx->CR,
 8009b88:	68b3      	ldr	r3, [r6, #8]
 8009b8a:	4013      	ands	r3, r2
 8009b8c:	f043 0304 	orr.w	r3, r3, #4
 8009b90:	60b3      	str	r3, [r6, #8]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 8009b92:	2340      	movs	r3, #64	; 0x40
 8009b94:	6033      	str	r3, [r6, #0]
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
 8009b96:	6873      	ldr	r3, [r6, #4]
 8009b98:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009b9c:	6073      	str	r3, [r6, #4]
  volatile uint32_t Brk2Timeout = 1000;
 8009b9e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009ba2:	9305      	str	r3, [sp, #20]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
 8009ba4:	6823      	ldr	r3, [r4, #0]
 8009ba6:	f023 0301 	bic.w	r3, r3, #1
 8009baa:	6023      	str	r3, [r4, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009bac:	6863      	ldr	r3, [r4, #4]
 8009bae:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009bb2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009bb6:	6063      	str	r3, [r4, #4]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009bb8:	69a3      	ldr	r3, [r4, #24]
 8009bba:	f043 0308 	orr.w	r3, r3, #8
 8009bbe:	61a3      	str	r3, [r4, #24]
 8009bc0:	69a3      	ldr	r3, [r4, #24]
 8009bc2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009bc6:	61a3      	str	r3, [r4, #24]
 8009bc8:	69e3      	ldr	r3, [r4, #28]
 8009bca:	f043 0308 	orr.w	r3, r3, #8
 8009bce:	61e3      	str	r3, [r4, #28]
 8009bd0:	69e3      	ldr	r3, [r4, #28]
 8009bd2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009bd6:	61e3      	str	r3, [r4, #28]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009bd8:	6963      	ldr	r3, [r4, #20]
 8009bda:	f043 0301 	orr.w	r3, r3, #1
 8009bde:	6163      	str	r3, [r4, #20]
  if (2U == pHandle->pParams_str->FreqRatio)
 8009be0:	f895 3067 	ldrb.w	r3, [r5, #103]	; 0x67
 8009be4:	2b02      	cmp	r3, #2
 8009be6:	d011      	beq.n	8009c0c <R3_1_Init+0x288>
    if (M1 == pHandle->_Super.Motor)
 8009be8:	f897 307a 	ldrb.w	r3, [r7, #122]	; 0x7a
 8009bec:	b9b3      	cbnz	r3, 8009c1c <R3_1_Init+0x298>
      if (1U == pHandle->pParams_str->RepetitionCounter)
 8009bee:	f895 3062 	ldrb.w	r3, [r5, #98]	; 0x62
 8009bf2:	2b01      	cmp	r3, #1
 8009bf4:	d00e      	beq.n	8009c14 <R3_1_Init+0x290>
      else if (3U == pHandle->pParams_str->RepetitionCounter)
 8009bf6:	2b03      	cmp	r3, #3
 8009bf8:	d110      	bne.n	8009c1c <R3_1_Init+0x298>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009bfa:	2201      	movs	r2, #1
 8009bfc:	6322      	str	r2, [r4, #48]	; 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009bfe:	6962      	ldr	r2, [r4, #20]
 8009c00:	f042 0201 	orr.w	r2, r2, #1
 8009c04:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009c06:	6323      	str	r3, [r4, #48]	; 0x30
}
 8009c08:	e008      	b.n	8009c1c <R3_1_Init+0x298>
 8009c0a:	4770      	bx	lr
    if (HIGHER_FREQ == pHandle->pParams_str->IsHigherFreqTim)
 8009c0c:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
 8009c10:	2b01      	cmp	r3, #1
 8009c12:	d028      	beq.n	8009c66 <R3_1_Init+0x2e2>
        LL_TIM_SetCounter(TIMx, (uint32_t)(pHandle->Half_PWMPeriod) - 1U);
 8009c14:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
 8009c18:	3b01      	subs	r3, #1
  WRITE_REG(TIMx->CNT, Counter);
 8009c1a:	6263      	str	r3, [r4, #36]	; 0x24
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8009c1c:	f06f 0380 	mvn.w	r3, #128	; 0x80
 8009c20:	6123      	str	r3, [r4, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8009c22:	6923      	ldr	r3, [r4, #16]
 8009c24:	05db      	lsls	r3, r3, #23
 8009c26:	d51c      	bpl.n	8009c62 <R3_1_Init+0x2de>
  while ((Brk2Timeout != 0u) && (1U == result))
 8009c28:	9b05      	ldr	r3, [sp, #20]
 8009c2a:	b153      	cbz	r3, 8009c42 <R3_1_Init+0x2be>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8009c2c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009c30:	6122      	str	r2, [r4, #16]
    Brk2Timeout--;
 8009c32:	9b05      	ldr	r3, [sp, #20]
 8009c34:	3b01      	subs	r3, #1
 8009c36:	9305      	str	r3, [sp, #20]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8009c38:	6923      	ldr	r3, [r4, #16]
 8009c3a:	f413 7f80 	tst.w	r3, #256	; 0x100
  while ((Brk2Timeout != 0u) && (1U == result))
 8009c3e:	9b05      	ldr	r3, [sp, #20]
 8009c40:	d10c      	bne.n	8009c5c <R3_1_Init+0x2d8>
  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
 8009c42:	68e3      	ldr	r3, [r4, #12]
 8009c44:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009c48:	60e3      	str	r3, [r4, #12]
  SET_BIT(TIMx->CCER, Channels);
 8009c4a:	6a23      	ldr	r3, [r4, #32]
 8009c4c:	f443 63aa 	orr.w	r3, r3, #1360	; 0x550
 8009c50:	f043 0305 	orr.w	r3, r3, #5
 8009c54:	6223      	str	r3, [r4, #32]
}
 8009c56:	b007      	add	sp, #28
 8009c58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while ((Brk2Timeout != 0u) && (1U == result))
 8009c5c:	2b00      	cmp	r3, #0
 8009c5e:	d1e7      	bne.n	8009c30 <R3_1_Init+0x2ac>
 8009c60:	e7ef      	b.n	8009c42 <R3_1_Init+0x2be>
 8009c62:	9b05      	ldr	r3, [sp, #20]
 8009c64:	e7ed      	b.n	8009c42 <R3_1_Init+0x2be>
      if (3U == pHandle->pParams_str->RepetitionCounter)
 8009c66:	f895 2062 	ldrb.w	r2, [r5, #98]	; 0x62
 8009c6a:	2a03      	cmp	r2, #3
 8009c6c:	d1d2      	bne.n	8009c14 <R3_1_Init+0x290>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009c6e:	6323      	str	r3, [r4, #48]	; 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009c70:	6963      	ldr	r3, [r4, #20]
 8009c72:	f043 0301 	orr.w	r3, r3, #1
 8009c76:	6163      	str	r3, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009c78:	6322      	str	r2, [r4, #48]	; 0x30
}
 8009c7a:	e7cb      	b.n	8009c14 <R3_1_Init+0x290>
 8009c7c:	40012c00 	.word	0x40012c00
 8009c80:	053e2d63 	.word	0x053e2d63
 8009c84:	200014a4 	.word	0x200014a4
 8009c88:	7fffffc0 	.word	0x7fffffc0
 8009c8c:	e0042000 	.word	0xe0042000

08009c90 <R3_1_SetOffsetCalib>:
{
 8009c90:	b410      	push	{r4}
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8009c92:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 8009c96:	680b      	ldr	r3, [r1, #0]
 8009c98:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  pHdl->offsetCalibStatus = true;
 8009c9c:	2301      	movs	r3, #1
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8009c9e:	e9c0 4223 	strd	r4, r2, [r0, #140]	; 0x8c
  pHdl->offsetCalibStatus = true;
 8009ca2:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
}
 8009ca6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009caa:	4770      	bx	lr

08009cac <R3_1_GetOffsetCalib>:
  offsets->phaseAOffset = pHandle->PhaseAOffset;
 8009cac:	e9d0 2323 	ldrd	r2, r3, [r0, #140]	; 0x8c
 8009cb0:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8009cb4:	608b      	str	r3, [r1, #8]
 8009cb6:	e9c1 0200 	strd	r0, r2, [r1]
}
 8009cba:	4770      	bx	lr

08009cbc <R3_1_CurrentReadingPolarization>:
{
 8009cbc:	b570      	push	{r4, r5, r6, lr}
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009cbe:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009cc2:	e9d3 6500 	ldrd	r6, r5, [r3]
  if (true == pHandle->_Super.offsetCalibStatus)
 8009cc6:	f890 3081 	ldrb.w	r3, [r0, #129]	; 0x81
{
 8009cca:	b084      	sub	sp, #16
 8009ccc:	4604      	mov	r4, r0
  if (true == pHandle->_Super.offsetCalibStatus)
 8009cce:	b193      	cbz	r3, 8009cf6 <R3_1_CurrentReadingPolarization+0x3a>
  MODIFY_REG(ADCx->CR,
 8009cd0:	68b3      	ldr	r3, [r6, #8]
 8009cd2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009cd6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009cda:	2280      	movs	r2, #128	; 0x80
 8009cdc:	f043 0308 	orr.w	r3, r3, #8
 8009ce0:	60b3      	str	r3, [r6, #8]
 8009ce2:	f8a0 2096 	strh.w	r2, [r0, #150]	; 0x96
  pHandle->_Super.Sector = SECTOR_5;
 8009ce6:	2204      	movs	r2, #4
  pHandle->_Super.BrakeActionLock = false;
 8009ce8:	2300      	movs	r3, #0
  pHandle->_Super.Sector = SECTOR_5;
 8009cea:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
  pHandle->_Super.BrakeActionLock = false;
 8009cee:	f884 3085 	strb.w	r3, [r4, #133]	; 0x85
}
 8009cf2:	b004      	add	sp, #16
 8009cf4:	bd70      	pop	{r4, r5, r6, pc}
    GetPhaseCurrCbSave = pHandle->_Super.pFctGetPhaseCurrents;
 8009cf6:	6802      	ldr	r2, [r0, #0]
 8009cf8:	9202      	str	r2, [sp, #8]
    SetSampPointSectXCbSave = pHandle->_Super.pFctSetADCSampPointSectX;
 8009cfa:	6942      	ldr	r2, [r0, #20]
 8009cfc:	9203      	str	r2, [sp, #12]
    pHandle->PolarizationCounter = 0U;
 8009cfe:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    pHandle->PhaseBOffset = 0U;
 8009d02:	e9c0 3322 	strd	r3, r3, [r0, #136]	; 0x88
    pHandle->PhaseCOffset = 0U;
 8009d06:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
  CLEAR_BIT(TIMx->CCER, Channels);
 8009d0a:	6a2b      	ldr	r3, [r5, #32]
 8009d0c:	f423 63aa 	bic.w	r3, r3, #1360	; 0x550
 8009d10:	f023 0305 	bic.w	r3, r3, #5
 8009d14:	622b      	str	r3, [r5, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationAB;
 8009d16:	4b3e      	ldr	r3, [pc, #248]	; (8009e10 <R3_1_CurrentReadingPolarization+0x154>)
 8009d18:	6003      	str	r3, [r0, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointPolarization;
 8009d1a:	4b3e      	ldr	r3, [pc, #248]	; (8009e14 <R3_1_CurrentReadingPolarization+0x158>)
 8009d1c:	6143      	str	r3, [r0, #20]
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009d1e:	2380      	movs	r3, #128	; 0x80
 8009d20:	f8a0 3096 	strh.w	r3, [r0, #150]	; 0x96
  pHandle->PolarizationSector=SECTOR_5;
 8009d24:	2304      	movs	r3, #4
 8009d26:	f880 3099 	strb.w	r3, [r0, #153]	; 0x99
  pHandle->_Super.Sector = SECTOR_5;   
 8009d2a:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8009d2e:	f7ff fc83 	bl	8009638 <R3_1_SwitchOnPWM>
    while (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_OC4REF)
 8009d32:	4a39      	ldr	r2, [pc, #228]	; (8009e18 <R3_1_CurrentReadingPolarization+0x15c>)
 8009d34:	686b      	ldr	r3, [r5, #4]
 8009d36:	4013      	ands	r3, r2
 8009d38:	2b70      	cmp	r3, #112	; 0x70
 8009d3a:	d1fb      	bne.n	8009d34 <R3_1_CurrentReadingPolarization+0x78>
 8009d3c:	68b3      	ldr	r3, [r6, #8]
                           pHandle->pParams_str->RepetitionCounter,
 8009d3e:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 8009d42:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009d46:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009d4a:	f043 0308 	orr.w	r3, r3, #8
 8009d4e:	60b3      	str	r3, [r6, #8]
    waitForPolarizationEnd(TIMx,
 8009d50:	f104 0156 	add.w	r1, r4, #86	; 0x56
 8009d54:	f104 0398 	add.w	r3, r4, #152	; 0x98
 8009d58:	f892 2062 	ldrb.w	r2, [r2, #98]	; 0x62
 8009d5c:	4628      	mov	r0, r5
 8009d5e:	e9cd 1300 	strd	r1, r3, [sp]
 8009d62:	f7ff fb23 	bl	80093ac <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8009d66:	4620      	mov	r0, r4
 8009d68:	f7ff fcb2 	bl	80096d0 <R3_1_SwitchOffPWM>
    pHandle->PolarizationCounter = 0U;
 8009d6c:	2200      	movs	r2, #0
 8009d6e:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98
  pHandle->PolarizationSector=SECTOR_1;
 8009d72:	f884 2099 	strb.w	r2, [r4, #153]	; 0x99
  pHandle->_Super.Sector = SECTOR_1;   
 8009d76:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationC;
 8009d7a:	4a28      	ldr	r2, [pc, #160]	; (8009e1c <R3_1_CurrentReadingPolarization+0x160>)
 8009d7c:	6022      	str	r2, [r4, #0]
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8009d7e:	4620      	mov	r0, r4
 8009d80:	f7ff fc5a 	bl	8009638 <R3_1_SwitchOnPWM>
                           pHandle->pParams_str->RepetitionCounter,
 8009d84:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    waitForPolarizationEnd(TIMx,
 8009d88:	9b01      	ldr	r3, [sp, #4]
 8009d8a:	f892 2062 	ldrb.w	r2, [r2, #98]	; 0x62
 8009d8e:	9900      	ldr	r1, [sp, #0]
 8009d90:	4628      	mov	r0, r5
 8009d92:	f7ff fb0b 	bl	80093ac <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8009d96:	4620      	mov	r0, r4
 8009d98:	f7ff fc9a 	bl	80096d0 <R3_1_SwitchOffPWM>
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009d9c:	e9d4 1222 	ldrd	r1, r2, [r4, #136]	; 0x88
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8009da0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009da4:	0912      	lsrs	r2, r2, #4
    pHandle->PhaseAOffset /= NB_CONVERSIONS;
 8009da6:	0909      	lsrs	r1, r1, #4
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009da8:	e9c4 1222 	strd	r1, r2, [r4, #136]	; 0x88
    if (0U == pHandle->_Super.SWerror)
 8009dac:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8009db0:	091b      	lsrs	r3, r3, #4
 8009db2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    if (0U == pHandle->_Super.SWerror)
 8009db6:	b912      	cbnz	r2, 8009dbe <R3_1_CurrentReadingPolarization+0x102>
      pHandle->_Super.offsetCalibStatus = true;
 8009db8:	2301      	movs	r3, #1
 8009dba:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8009dbe:	9902      	ldr	r1, [sp, #8]
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 8009dc0:	9a03      	ldr	r2, [sp, #12]
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009dc2:	69ab      	ldr	r3, [r5, #24]
 8009dc4:	6162      	str	r2, [r4, #20]
 8009dc6:	f023 0308 	bic.w	r3, r3, #8
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8009dca:	6021      	str	r1, [r4, #0]
 8009dcc:	61ab      	str	r3, [r5, #24]
 8009dce:	69aa      	ldr	r2, [r5, #24]
  LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod);
 8009dd0:	f8b4 3094 	ldrh.w	r3, [r4, #148]	; 0x94
 8009dd4:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8009dd8:	61aa      	str	r2, [r5, #24]
 8009dda:	69ea      	ldr	r2, [r5, #28]
 8009ddc:	f022 0208 	bic.w	r2, r2, #8
 8009de0:	61ea      	str	r2, [r5, #28]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009de2:	636b      	str	r3, [r5, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009de4:	63ab      	str	r3, [r5, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009de6:	63eb      	str	r3, [r5, #60]	; 0x3c
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009de8:	69ab      	ldr	r3, [r5, #24]
 8009dea:	f043 0308 	orr.w	r3, r3, #8
 8009dee:	61ab      	str	r3, [r5, #24]
 8009df0:	69ab      	ldr	r3, [r5, #24]
 8009df2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009df6:	61ab      	str	r3, [r5, #24]
 8009df8:	69eb      	ldr	r3, [r5, #28]
 8009dfa:	f043 0308 	orr.w	r3, r3, #8
 8009dfe:	61eb      	str	r3, [r5, #28]
  SET_BIT(TIMx->CCER, Channels);
 8009e00:	6a2b      	ldr	r3, [r5, #32]
 8009e02:	f443 63aa 	orr.w	r3, r3, #1360	; 0x550
 8009e06:	f043 0305 	orr.w	r3, r3, #5
 8009e0a:	622b      	str	r3, [r5, #32]
}
 8009e0c:	e76b      	b.n	8009ce6 <R3_1_CurrentReadingPolarization+0x2a>
 8009e0e:	bf00      	nop
 8009e10:	080095a1 	.word	0x080095a1
 8009e14:	0800955d 	.word	0x0800955d
 8009e18:	02000070 	.word	0x02000070
 8009e1c:	080095f1 	.word	0x080095f1

08009e20 <R3_1_SetADCSampPointSectX>:
  if (MC_NULL == pHdl)
 8009e20:	2800      	cmp	r0, #0
 8009e22:	d03b      	beq.n	8009e9c <R3_1_SetADCSampPointSectX+0x7c>
{
 8009e24:	b530      	push	{r4, r5, lr}
    if ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) > pHandle->pParams_str->Tafter)
 8009e26:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 8009e2a:	f8b0 e094 	ldrh.w	lr, [r0, #148]	; 0x94
 8009e2e:	f8d0 109c 	ldr.w	r1, [r0, #156]	; 0x9c
 8009e32:	ebae 0203 	sub.w	r2, lr, r3
 8009e36:	f8b1 4054 	ldrh.w	r4, [r1, #84]	; 0x54
 8009e3a:	b292      	uxth	r2, r2
 8009e3c:	42a2      	cmp	r2, r4
 8009e3e:	d917      	bls.n	8009e70 <R3_1_SetADCSampPointSectX+0x50>
      pHandle->_Super.Sector = SECTOR_5;
 8009e40:	2204      	movs	r2, #4
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8009e42:	f10e 33ff 	add.w	r3, lr, #4294967295
      pHandle->_Super.Sector = SECTOR_5;
 8009e46:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8009e4a:	b29b      	uxth	r3, r3
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009e4c:	684a      	ldr	r2, [r1, #4]
  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8009e4e:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8009e52:	f8b0 4052 	ldrh.w	r4, [r0, #82]	; 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 8009e56:	f8b0 1054 	ldrh.w	r1, [r0, #84]	; 0x54
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009e5a:	6355      	str	r5, [r2, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009e5c:	6394      	str	r4, [r2, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009e5e:	63d1      	str	r1, [r2, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009e60:	6413      	str	r3, [r2, #64]	; 0x40
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009e62:	6852      	ldr	r2, [r2, #4]
 8009e64:	4b10      	ldr	r3, [pc, #64]	; (8009ea8 <R3_1_SetADCSampPointSectX+0x88>)
 8009e66:	421a      	tst	r2, r3
    returnValue = 0U;
 8009e68:	bf14      	ite	ne
 8009e6a:	2001      	movne	r0, #1
 8009e6c:	2000      	moveq	r0, #0
}
 8009e6e:	bd30      	pop	{r4, r5, pc}
      DeltaDuty = (uint16_t)(pHdl->lowDuty - pHdl->midDuty);
 8009e70:	f8b0 c05a 	ldrh.w	ip, [r0, #90]	; 0x5a
 8009e74:	eba3 0c0c 	sub.w	ip, r3, ip
      if (DeltaDuty > ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) * 2U))
 8009e78:	fa1f fc8c 	uxth.w	ip, ip
 8009e7c:	ebbc 0f42 	cmp.w	ip, r2, lsl #1
 8009e80:	d80d      	bhi.n	8009e9e <R3_1_SetADCSampPointSectX+0x7e>
        SamplingPoint = pHdl->lowDuty + pHandle->pParams_str->Tafter;
 8009e82:	4423      	add	r3, r4
 8009e84:	b29b      	uxth	r3, r3
        if (SamplingPoint >= pHandle->Half_PWMPeriod)
 8009e86:	459e      	cmp	lr, r3
 8009e88:	d8e0      	bhi.n	8009e4c <R3_1_SetADCSampPointSectX+0x2c>
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e8a:	43db      	mvns	r3, r3
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8009e8c:	f44f 7280 	mov.w	r2, #256	; 0x100
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e90:	eb03 034e 	add.w	r3, r3, lr, lsl #1
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8009e94:	f8a0 2096 	strh.w	r2, [r0, #150]	; 0x96
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e98:	b29b      	uxth	r3, r3
 8009e9a:	e7d7      	b.n	8009e4c <R3_1_SetADCSampPointSectX+0x2c>
}
 8009e9c:	4770      	bx	lr
        SamplingPoint = pHdl->lowDuty - pHandle->pParams_str->Tbefore;
 8009e9e:	f8b1 2058 	ldrh.w	r2, [r1, #88]	; 0x58
 8009ea2:	1a9b      	subs	r3, r3, r2
 8009ea4:	b29b      	uxth	r3, r3
 8009ea6:	e7d1      	b.n	8009e4c <R3_1_SetADCSampPointSectX+0x2c>
 8009ea8:	02000070 	.word	0x02000070

08009eac <R3_1_TIMx_UP_IRQHandler>:
  if (MC_NULL == pHandle)
 8009eac:	4602      	mov	r2, r0
 8009eae:	2800      	cmp	r0, #0
 8009eb0:	d03b      	beq.n	8009f2a <R3_1_TIMx_UP_IRQHandler+0x7e>
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009eb2:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
{
 8009eb6:	b4f0      	push	{r4, r5, r6, r7}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009eb8:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009ebc:	6801      	ldr	r1, [r0, #0]
    if (OPAMPParams != NULL)
 8009ebe:	b38c      	cbz	r4, 8009f24 <R3_1_TIMx_UP_IRQHandler+0x78>
      while (ADCx->JSQR != 0x0u)
 8009ec0:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 8009ec2:	2b00      	cmp	r3, #0
 8009ec4:	d1fc      	bne.n	8009ec0 <R3_1_TIMx_UP_IRQHandler+0x14>
      operationAmp = OPAMPParams->OPAMPSelect_1[pHandle->_Super.Sector];
 8009ec6:	f892 307c 	ldrb.w	r3, [r2, #124]	; 0x7c
 8009eca:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
      if (operationAmp != NULL)
 8009ece:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8009ed2:	f1bc 0f00 	cmp.w	ip, #0
 8009ed6:	d007      	beq.n	8009ee8 <R3_1_TIMx_UP_IRQHandler+0x3c>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8009ed8:	f8dc 6000 	ldr.w	r6, [ip]
 8009edc:	6b27      	ldr	r7, [r4, #48]	; 0x30
 8009ede:	f426 7686 	bic.w	r6, r6, #268	; 0x10c
 8009ee2:	433e      	orrs	r6, r7
 8009ee4:	f8cc 6000 	str.w	r6, [ip]
      operationAmp = OPAMPParams->OPAMPSelect_2[pHandle->_Super.Sector];
 8009ee8:	69a6      	ldr	r6, [r4, #24]
      if (operationAmp != NULL)
 8009eea:	b12e      	cbz	r6, 8009ef8 <R3_1_TIMx_UP_IRQHandler+0x4c>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8009eec:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 8009eee:	6834      	ldr	r4, [r6, #0]
 8009ef0:	f424 7486 	bic.w	r4, r4, #268	; 0x10c
 8009ef4:	433c      	orrs	r4, r7
 8009ef6:	6034      	str	r4, [r6, #0]
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8009ef8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8009efc:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8009f00:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8009f02:	4303      	orrs	r3, r0
 8009f04:	64cb      	str	r3, [r1, #76]	; 0x4c
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009f06:	686b      	ldr	r3, [r5, #4]
 8009f08:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009f0c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009f10:	2180      	movs	r1, #128	; 0x80
 8009f12:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8009f16:	606b      	str	r3, [r5, #4]
    tempPointer = &(pHandle->_Super.Motor);
 8009f18:	f102 007a 	add.w	r0, r2, #122	; 0x7a
}
 8009f1c:	bcf0      	pop	{r4, r5, r6, r7}
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009f1e:	f8a2 1096 	strh.w	r1, [r2, #150]	; 0x96
}
 8009f22:	4770      	bx	lr
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8009f24:	f892 307c 	ldrb.w	r3, [r2, #124]	; 0x7c
 8009f28:	e7e6      	b.n	8009ef8 <R3_1_TIMx_UP_IRQHandler+0x4c>
}
 8009f2a:	4770      	bx	lr

08009f2c <R3_1_RLDetectionModeEnable>:
  if (false == pHandle->_Super.RLDetectionMode)
 8009f2c:	f890 1080 	ldrb.w	r1, [r0, #128]	; 0x80
{
 8009f30:	b410      	push	{r4}
  if (false == pHandle->_Super.RLDetectionMode)
 8009f32:	2900      	cmp	r1, #0
 8009f34:	d13f      	bne.n	8009fb6 <R3_1_RLDetectionModeEnable+0x8a>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009f36:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 8009f3a:	685b      	ldr	r3, [r3, #4]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f3c:	699a      	ldr	r2, [r3, #24]
 8009f3e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009f42:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009f46:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009f4a:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009f4c:	6a1a      	ldr	r2, [r3, #32]
 8009f4e:	f042 0201 	orr.w	r2, r2, #1
 8009f52:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f54:	6a1a      	ldr	r2, [r3, #32]
 8009f56:	f022 0204 	bic.w	r2, r2, #4
 8009f5a:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009f5c:	6359      	str	r1, [r3, #52]	; 0x34
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009f5e:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 8009f62:	2a01      	cmp	r2, #1
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8009f64:	f103 0418 	add.w	r4, r3, #24
 8009f68:	d033      	beq.n	8009fd2 <R3_1_RLDetectionModeEnable+0xa6>
    else if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 8009f6a:	2a02      	cmp	r2, #2
 8009f6c:	d10f      	bne.n	8009f8e <R3_1_RLDetectionModeEnable+0x62>
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f6e:	699a      	ldr	r2, [r3, #24]
 8009f70:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009f74:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 8009f78:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009f7c:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009f7e:	6a1a      	ldr	r2, [r3, #32]
 8009f80:	f042 0210 	orr.w	r2, r2, #16
 8009f84:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f86:	6a1a      	ldr	r2, [r3, #32]
 8009f88:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009f8c:	621a      	str	r2, [r3, #32]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f8e:	6862      	ldr	r2, [r4, #4]
 8009f90:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009f94:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009f98:	f042 0270 	orr.w	r2, r2, #112	; 0x70
 8009f9c:	6062      	str	r2, [r4, #4]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f9e:	6a1a      	ldr	r2, [r3, #32]
    pHandle->PhaseAOffset = pHandle->PhaseBOffset; /* Use only the offset of phB */
 8009fa0:	f8d0 108c 	ldr.w	r1, [r0, #140]	; 0x8c
 8009fa4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009fa8:	621a      	str	r2, [r3, #32]
 8009faa:	6a1a      	ldr	r2, [r3, #32]
 8009fac:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009fb0:	621a      	str	r2, [r3, #32]
 8009fb2:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 8009fb6:	4b0f      	ldr	r3, [pc, #60]	; (8009ff4 <R3_1_RLDetectionModeEnable+0xc8>)
  pHandle->_Super.pFctSwitchOnPwm = &R3_1_RLSwitchOnPWM;
 8009fb8:	490f      	ldr	r1, [pc, #60]	; (8009ff8 <R3_1_RLDetectionModeEnable+0xcc>)
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009fba:	4a10      	ldr	r2, [pc, #64]	; (8009ffc <R3_1_RLDetectionModeEnable+0xd0>)
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 8009fbc:	4c10      	ldr	r4, [pc, #64]	; (800a000 <R3_1_RLDetectionModeEnable+0xd4>)
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 8009fbe:	6103      	str	r3, [r0, #16]
  pHandle->_Super.RLDetectionMode = true;
 8009fc0:	2301      	movs	r3, #1
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 8009fc2:	6004      	str	r4, [r0, #0]
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009fc4:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 8009fc8:	f85d 4b04 	ldr.w	r4, [sp], #4
  pHandle->_Super.RLDetectionMode = true;
 8009fcc:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
}
 8009fd0:	4770      	bx	lr
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009fd2:	699a      	ldr	r2, [r3, #24]
 8009fd4:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009fd8:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 8009fdc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009fe0:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009fe2:	6a1a      	ldr	r2, [r3, #32]
 8009fe4:	f022 0210 	bic.w	r2, r2, #16
 8009fe8:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CCER, Channels);
 8009fea:	6a1a      	ldr	r2, [r3, #32]
 8009fec:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009ff0:	621a      	str	r2, [r3, #32]
}
 8009ff2:	e7cc      	b.n	8009f8e <R3_1_RLDetectionModeEnable+0x62>
 8009ff4:	08009935 	.word	0x08009935
 8009ff8:	080097a5 	.word	0x080097a5
 8009ffc:	080096d1 	.word	0x080096d1
 800a000:	0800974d 	.word	0x0800974d

0800a004 <R3_1_RLDetectionModeDisable>:
  if (true ==  pHandle->_Super.RLDetectionMode)
 800a004:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800a008:	2b00      	cmp	r3, #0
 800a00a:	d03c      	beq.n	800a086 <R3_1_RLDetectionModeDisable+0x82>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a00c:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 800a010:	685b      	ldr	r3, [r3, #4]
{
 800a012:	b410      	push	{r4}
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a014:	699a      	ldr	r2, [r3, #24]
 800a016:	4c43      	ldr	r4, [pc, #268]	; (800a124 <R3_1_RLDetectionModeDisable+0x120>)
 800a018:	4022      	ands	r2, r4
 800a01a:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 800a01e:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a020:	6a1a      	ldr	r2, [r3, #32]
 800a022:	f042 0201 	orr.w	r2, r2, #1
 800a026:	621a      	str	r2, [r3, #32]
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 800a028:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 800a02c:	2a01      	cmp	r2, #1
 800a02e:	d02b      	beq.n	800a088 <R3_1_RLDetectionModeDisable+0x84>
    else if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 800a030:	2a02      	cmp	r2, #2
 800a032:	d050      	beq.n	800a0d6 <R3_1_RLDetectionModeDisable+0xd2>
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 800a034:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 800a038:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a03a:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a03c:	6999      	ldr	r1, [r3, #24]
 800a03e:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800a042:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 800a046:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a04a:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a04c:	6a19      	ldr	r1, [r3, #32]
 800a04e:	f041 0110 	orr.w	r1, r1, #16
 800a052:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a054:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a056:	69d9      	ldr	r1, [r3, #28]
 800a058:	4021      	ands	r1, r4
 800a05a:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a05e:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a060:	6a19      	ldr	r1, [r3, #32]
 800a062:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a066:	6219      	str	r1, [r3, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800a068:	492f      	ldr	r1, [pc, #188]	; (800a128 <R3_1_RLDetectionModeDisable+0x124>)
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a06a:	63da      	str	r2, [r3, #60]	; 0x3c
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800a06c:	4a2f      	ldr	r2, [pc, #188]	; (800a12c <R3_1_RLDetectionModeDisable+0x128>)
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800a06e:	6001      	str	r1, [r0, #0]
    pHandle->_Super.pFctSwitchOnPwm = &R3_1_SwitchOnPWM;
 800a070:	492f      	ldr	r1, [pc, #188]	; (800a130 <R3_1_RLDetectionModeDisable+0x12c>)
    pHandle->_Super.pFctTurnOnLowSides = &R3_1_TurnOnLowSides;
 800a072:	4c30      	ldr	r4, [pc, #192]	; (800a134 <R3_1_RLDetectionModeDisable+0x130>)
 800a074:	6104      	str	r4, [r0, #16]
    pHandle->_Super.RLDetectionMode = false;
 800a076:	2300      	movs	r3, #0
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800a078:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 800a07c:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->_Super.RLDetectionMode = false;
 800a080:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
}
 800a084:	4770      	bx	lr
 800a086:	4770      	bx	lr
  SET_BIT(TIMx->CCER, Channels);
 800a088:	6a19      	ldr	r1, [r3, #32]
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 800a08a:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 800a08e:	f041 0104 	orr.w	r1, r1, #4
 800a092:	0852      	lsrs	r2, r2, #1
 800a094:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a096:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a098:	6999      	ldr	r1, [r3, #24]
 800a09a:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800a09e:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 800a0a2:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a0a6:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a0a8:	6a19      	ldr	r1, [r3, #32]
 800a0aa:	f041 0110 	orr.w	r1, r1, #16
 800a0ae:	6219      	str	r1, [r3, #32]
 800a0b0:	6a19      	ldr	r1, [r3, #32]
 800a0b2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 800a0b6:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a0b8:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a0ba:	69d9      	ldr	r1, [r3, #28]
 800a0bc:	4021      	ands	r1, r4
 800a0be:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a0c2:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a0c4:	6a19      	ldr	r1, [r3, #32]
 800a0c6:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a0ca:	6219      	str	r1, [r3, #32]
 800a0cc:	6a19      	ldr	r1, [r3, #32]
 800a0ce:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 800a0d2:	6219      	str	r1, [r3, #32]
}
 800a0d4:	e7c8      	b.n	800a068 <R3_1_RLDetectionModeDisable+0x64>
  CLEAR_BIT(TIMx->CCER, Channels);
 800a0d6:	6a19      	ldr	r1, [r3, #32]
 800a0d8:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 800a0dc:	f021 0104 	bic.w	r1, r1, #4
 800a0e0:	0852      	lsrs	r2, r2, #1
 800a0e2:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a0e4:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a0e6:	6999      	ldr	r1, [r3, #24]
 800a0e8:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800a0ec:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 800a0f0:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a0f4:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a0f6:	6a19      	ldr	r1, [r3, #32]
 800a0f8:	f041 0110 	orr.w	r1, r1, #16
 800a0fc:	6219      	str	r1, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 800a0fe:	6a19      	ldr	r1, [r3, #32]
 800a100:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800a104:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a106:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a108:	69d9      	ldr	r1, [r3, #28]
 800a10a:	4021      	ands	r1, r4
 800a10c:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a110:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a112:	6a19      	ldr	r1, [r3, #32]
 800a114:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a118:	6219      	str	r1, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 800a11a:	6a19      	ldr	r1, [r3, #32]
 800a11c:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800a120:	6219      	str	r1, [r3, #32]
}
 800a122:	e7a1      	b.n	800a068 <R3_1_RLDetectionModeDisable+0x64>
 800a124:	fffeff8c 	.word	0xfffeff8c
 800a128:	080093e9 	.word	0x080093e9
 800a12c:	080096d1 	.word	0x080096d1
 800a130:	08009639 	.word	0x08009639
 800a134:	08009849 	.word	0x08009849

0800a138 <R3_1_RLDetectionModeSetDuty>:
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a138:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a13c:	f8b0 c094 	ldrh.w	ip, [r0, #148]	; 0x94
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a140:	6852      	ldr	r2, [r2, #4]
{
 800a142:	4603      	mov	r3, r0
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a144:	69d0      	ldr	r0, [r2, #28]
 800a146:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a14a:	fb0c f101 	mul.w	r1, ip, r1
 800a14e:	f420 40e6 	bic.w	r0, r0, #29440	; 0x7300
{
 800a152:	b410      	push	{r4}
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a154:	0c09      	lsrs	r1, r1, #16
    pHandle->ADCRegularLocked = true;
 800a156:	2401      	movs	r4, #1
 800a158:	f440 40e0 	orr.w	r0, r0, #28672	; 0x7000
 800a15c:	f883 40a0 	strb.w	r4, [r3, #160]	; 0xa0
    pHandle->_Super.CntPhA = (uint16_t)val;
 800a160:	f8a3 1050 	strh.w	r1, [r3, #80]	; 0x50
 800a164:	61d0      	str	r0, [r2, #28]
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800a166:	f8b3 0076 	ldrh.w	r0, [r3, #118]	; 0x76
    LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t)pHandle->_Super.Toff);
 800a16a:	f8b3 4078 	ldrh.w	r4, [r3, #120]	; 0x78
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800a16e:	ebac 0000 	sub.w	r0, ip, r0
  WRITE_REG(TIMx->CCR4, CompareValue);
 800a172:	6410      	str	r0, [r2, #64]	; 0x40
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a174:	63d4      	str	r4, [r2, #60]	; 0x3c
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a176:	6351      	str	r1, [r2, #52]	; 0x34
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800a178:	6851      	ldr	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a17a:	f8b3 0056 	ldrh.w	r0, [r3, #86]	; 0x56
 800a17e:	f021 7100 	bic.w	r1, r1, #33554432	; 0x2000000
 800a182:	f021 0170 	bic.w	r1, r1, #112	; 0x70
    pHdl->Sector = SECTOR_4;
 800a186:	f04f 0c03 	mov.w	ip, #3
 800a18a:	f041 0170 	orr.w	r1, r1, #112	; 0x70
 800a18e:	6051      	str	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a190:	2801      	cmp	r0, #1
    pHdl->Sector = SECTOR_4;
 800a192:	f883 c07c 	strb.w	ip, [r3, #124]	; 0x7c
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a196:	6852      	ldr	r2, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a198:	d007      	beq.n	800a1aa <R3_1_RLDetectionModeSetDuty+0x72>
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a19a:	4b07      	ldr	r3, [pc, #28]	; (800a1b8 <R3_1_RLDetectionModeSetDuty+0x80>)
}
 800a19c:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a1a0:	421a      	tst	r2, r3
      hAux = MC_DURATION;
 800a1a2:	bf14      	ite	ne
 800a1a4:	2001      	movne	r0, #1
 800a1a6:	2000      	moveq	r0, #0
}
 800a1a8:	4770      	bx	lr
      pHandle->_Super.SWerror = 0U;
 800a1aa:	2200      	movs	r2, #0
}
 800a1ac:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->_Super.SWerror = 0U;
 800a1b0:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
}
 800a1b4:	4770      	bx	lr
 800a1b6:	bf00      	nop
 800a1b8:	02000070 	.word	0x02000070

0800a1bc <R3_1_RLTurnOnLowSidesAndStart>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a1bc:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 800a1c0:	685b      	ldr	r3, [r3, #4]

    pHandle->ADCRegularLocked=true;
 800a1c2:	2101      	movs	r1, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800a1c4:	f06f 0201 	mvn.w	r2, #1
{
 800a1c8:	b430      	push	{r4, r5}
    pHandle->ADCRegularLocked=true;
 800a1ca:	f880 10a0 	strb.w	r1, [r0, #160]	; 0xa0
 800a1ce:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800a1d0:	691a      	ldr	r2, [r3, #16]
 800a1d2:	07d1      	lsls	r1, r2, #31
 800a1d4:	d5fc      	bpl.n	800a1d0 <R3_1_RLTurnOnLowSidesAndStart+0x14>
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH2(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH3(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 800a1d6:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a1da:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800a1dc:	f06f 0401 	mvn.w	r4, #1
 800a1e0:	3a05      	subs	r2, #5
 800a1e2:	611c      	str	r4, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a1e4:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a1e6:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a1e8:	63d9      	str	r1, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 800a1ea:	641a      	str	r2, [r3, #64]	; 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800a1ec:	691a      	ldr	r2, [r3, #16]
 800a1ee:	07d2      	lsls	r2, r2, #31
 800a1f0:	d5fc      	bpl.n	800a1ec <R3_1_RLTurnOnLowSidesAndStart+0x30>
    {
      /* Nothing to do */
    }

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 800a1f2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1f4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a1f8:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800a1fa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1fc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800a200:	645a      	str	r2, [r3, #68]	; 0x44
    LL_TIM_EnableAllOutputs (TIMx);

    if (ES_GPIO == pHandle->_Super.LowSideOutputs )
 800a202:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 800a206:	2a02      	cmp	r2, #2
 800a208:	d10b      	bne.n	800a222 <R3_1_RLTurnOnLowSidesAndStart+0x66>
    {
      /* It is executed during calibration phase the EN signal shall stay off */
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800a20a:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	; 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800a20e:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800a212:	6c42      	ldr	r2, [r0, #68]	; 0x44
  WRITE_REG(GPIOx->BSRR, PinMask);
 800a214:	61a5      	str	r5, [r4, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800a216:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 800a21a:	618c      	str	r4, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800a21c:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 800a220:	6191      	str	r1, [r2, #24]
    else
    {
      /* Nothing to do */
    }

    pHdl->Sector = SECTOR_4;
 800a222:	2203      	movs	r2, #3
 800a224:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
  SET_BIT(TIMx->CCER, Channels);
 800a228:	6a1a      	ldr	r2, [r3, #32]
 800a22a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a22e:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 800a230:	68da      	ldr	r2, [r3, #12]
 800a232:	f042 0201 	orr.w	r2, r2, #1

    LL_TIM_EnableIT_UPDATE(TIMx);
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800a236:	bc30      	pop	{r4, r5}
 800a238:	60da      	str	r2, [r3, #12]
 800a23a:	4770      	bx	lr

0800a23c <RVBS_Clear>:
  {
#endif
    uint16_t aux;
    uint16_t index;

    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 800a23c:	f8b0 c00c 	ldrh.w	ip, [r0, #12]
 800a240:	8a42      	ldrh	r2, [r0, #18]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a242:	8943      	ldrh	r3, [r0, #10]
    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 800a244:	4494      	add	ip, r2
 800a246:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
{
 800a24a:	b430      	push	{r4, r5}
 800a24c:	2500      	movs	r5, #0
 800a24e:	f36c 050f 	bfi	r5, ip, #0, #16
 800a252:	f36c 451f 	bfi	r5, ip, #16, #16
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a256:	b14b      	cbz	r3, 800a26c <RVBS_Clear+0x30>
    {
      pHandle->aBuffer[index] = aux;
 800a258:	6944      	ldr	r4, [r0, #20]
 800a25a:	2300      	movs	r3, #0
 800a25c:	b29a      	uxth	r2, r3
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a25e:	3301      	adds	r3, #1
      pHandle->aBuffer[index] = aux;
 800a260:	f824 c012 	strh.w	ip, [r4, r2, lsl #1]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a264:	8941      	ldrh	r1, [r0, #10]
 800a266:	b29a      	uxth	r2, r3
 800a268:	4291      	cmp	r1, r2
 800a26a:	d8f7      	bhi.n	800a25c <RVBS_Clear+0x20>
    }
    pHandle->_Super.LatestConv = aux;
    pHandle->_Super.AvBusVoltage_d = aux;
    pHandle->index = 0U;
 800a26c:	2300      	movs	r3, #0
    pHandle->_Super.LatestConv = aux;
 800a26e:	6045      	str	r5, [r0, #4]
    pHandle->index = 0U;
 800a270:	7643      	strb	r3, [r0, #25]
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
}
 800a272:	bc30      	pop	{r4, r5}
 800a274:	4770      	bx	lr
 800a276:	bf00      	nop

0800a278 <RVBS_Init>:
{
 800a278:	b508      	push	{r3, lr}
    RVBS_Clear(pHandle);
 800a27a:	f7ff ffdf 	bl	800a23c <RVBS_Clear>
}
 800a27e:	bd08      	pop	{r3, pc}

0800a280 <RVBS_CheckFaultState>:
  }
  else
  {
#endif
	/* If both thresholds are equal, single threshold feature is used */
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 800a280:	8982      	ldrh	r2, [r0, #12]
 800a282:	89c1      	ldrh	r1, [r0, #14]
 800a284:	428a      	cmp	r2, r1
 800a286:	d00e      	beq.n	800a2a6 <RVBS_CheckFaultState+0x26>
      }
	}
    else
    {
      /* If both thresholds are different, hysteresis feature is used (Brake mode) */
      if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 800a288:	f8b0 c006 	ldrh.w	ip, [r0, #6]
 800a28c:	8a43      	ldrh	r3, [r0, #18]
 800a28e:	4563      	cmp	r3, ip
 800a290:	d807      	bhi.n	800a2a2 <RVBS_CheckFaultState+0x22>
      {
        fault = MC_UNDER_VOLT;
      }
      else if ( false == pHandle->OverVoltageHysteresisUpDir )
 800a292:	7c03      	ldrb	r3, [r0, #16]
 800a294:	b98b      	cbnz	r3, 800a2ba <RVBS_CheckFaultState+0x3a>
      {
        if (pHandle->_Super.AvBusVoltage_d < pHandle->OverVoltageThresholdLow)
 800a296:	4561      	cmp	r1, ip
 800a298:	d913      	bls.n	800a2c2 <RVBS_CheckFaultState+0x42>
        {
          pHandle->OverVoltageHysteresisUpDir = true;
 800a29a:	2201      	movs	r2, #1
 800a29c:	7402      	strb	r2, [r0, #16]
          fault = MC_NO_ERROR;
 800a29e:	4618      	mov	r0, r3
 800a2a0:	4770      	bx	lr
        fault = MC_UNDER_VOLT;
 800a2a2:	2004      	movs	r0, #4
 800a2a4:	4770      	bx	lr
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 800a2a6:	88c3      	ldrh	r3, [r0, #6]
 800a2a8:	429a      	cmp	r2, r3
 800a2aa:	d30a      	bcc.n	800a2c2 <RVBS_CheckFaultState+0x42>
      else if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 800a2ac:	8a40      	ldrh	r0, [r0, #18]
 800a2ae:	4298      	cmp	r0, r3
 800a2b0:	bf94      	ite	ls
 800a2b2:	2000      	movls	r0, #0
 800a2b4:	2001      	movhi	r0, #1
 800a2b6:	0080      	lsls	r0, r0, #2
 800a2b8:	4770      	bx	lr
          fault = MC_OVER_VOLT;
        }
      }
      else
      {
        if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 800a2ba:	4562      	cmp	r2, ip
 800a2bc:	d303      	bcc.n	800a2c6 <RVBS_CheckFaultState+0x46>
        {
          pHandle->OverVoltageHysteresisUpDir = false;
          fault = MC_OVER_VOLT;
        }
        else{
          fault = MC_NO_ERROR;
 800a2be:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
  return (fault);
}
 800a2c0:	4770      	bx	lr
        fault = MC_OVER_VOLT;
 800a2c2:	2002      	movs	r0, #2
 800a2c4:	4770      	bx	lr
          pHandle->OverVoltageHysteresisUpDir = false;
 800a2c6:	2300      	movs	r3, #0
 800a2c8:	7403      	strb	r3, [r0, #16]
          fault = MC_OVER_VOLT;
 800a2ca:	2002      	movs	r0, #2
 800a2cc:	4770      	bx	lr
 800a2ce:	bf00      	nop

0800a2d0 <RVBS_CalcAvVbus>:
{
 800a2d0:	b538      	push	{r3, r4, r5, lr}
    if (0xFFFFU == hAux)
 800a2d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800a2d6:	4299      	cmp	r1, r3
{
 800a2d8:	4604      	mov	r4, r0
    if (0xFFFFU == hAux)
 800a2da:	d021      	beq.n	800a320 <RVBS_CalcAvVbus+0x50>
      pHandle->aBuffer[pHandle->index] = hAux;
 800a2dc:	6943      	ldr	r3, [r0, #20]
 800a2de:	7e45      	ldrb	r5, [r0, #25]
 800a2e0:	f823 1015 	strh.w	r1, [r3, r5, lsl #1]
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a2e4:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
 800a2e8:	f01e 02ff 	ands.w	r2, lr, #255	; 0xff
 800a2ec:	d00d      	beq.n	800a30a <RVBS_CalcAvVbus+0x3a>
 800a2ee:	3a01      	subs	r2, #1
 800a2f0:	b2d2      	uxtb	r2, r2
 800a2f2:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 800a2f6:	3b02      	subs	r3, #2
      wtemp = 0u;
 800a2f8:	2200      	movs	r2, #0
        wtemp += pHandle->aBuffer[i];
 800a2fa:	f833 cf02 	ldrh.w	ip, [r3, #2]!
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a2fe:	4298      	cmp	r0, r3
        wtemp += pHandle->aBuffer[i];
 800a300:	4462      	add	r2, ip
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a302:	d1fa      	bne.n	800a2fa <RVBS_CalcAvVbus+0x2a>
      wtemp /= pHandle->LowPassFilterBW;
 800a304:	fbb2 f2fe 	udiv	r2, r2, lr
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 800a308:	b292      	uxth	r2, r2
      if ((uint16_t)pHandle->index < (pHandle->LowPassFilterBW - 1U))
 800a30a:	f10e 3eff 	add.w	lr, lr, #4294967295
 800a30e:	4575      	cmp	r5, lr
        pHandle->index++;
 800a310:	bf34      	ite	cc
 800a312:	3501      	addcc	r5, #1
        pHandle->index = 0U;
 800a314:	2300      	movcs	r3, #0
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 800a316:	80e2      	strh	r2, [r4, #6]
      pHandle->_Super.LatestConv = hAux;
 800a318:	80a1      	strh	r1, [r4, #4]
        pHandle->index++;
 800a31a:	bf34      	ite	cc
 800a31c:	7665      	strbcc	r5, [r4, #25]
        pHandle->index = 0U;
 800a31e:	7663      	strbcs	r3, [r4, #25]
    pHandle->_Super.FaultState = RVBS_CheckFaultState(pHandle);
 800a320:	4620      	mov	r0, r4
 800a322:	f7ff ffad 	bl	800a280 <RVBS_CheckFaultState>
 800a326:	8120      	strh	r0, [r4, #8]
}
 800a328:	bd38      	pop	{r3, r4, r5, pc}
 800a32a:	bf00      	nop

0800a32c <REMNG_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->Ext = 0;
 800a32c:	2300      	movs	r3, #0
    pHandle->TargetFinal = 0;
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
    pHandle->ScalingFactor = 1U;
 800a32e:	2201      	movs	r2, #1
    pHandle->TargetFinal = 0;
 800a330:	e9c0 3301 	strd	r3, r3, [r0, #4]
    pHandle->IncDecAmount = 0;
 800a334:	e9c0 3303 	strd	r3, r3, [r0, #12]
    pHandle->ScalingFactor = 1U;
 800a338:	6142      	str	r2, [r0, #20]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
}
 800a33a:	4770      	bx	lr

0800a33c <SPD_GetElAngle>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
#else
  return (pHandle->hElAngle);
#endif
}
 800a33c:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 800a340:	4770      	bx	lr
 800a342:	bf00      	nop

0800a344 <SPD_GetAvrgMecSpeedUnit>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hAvrMecSpeedUnit);
#else
  return (pHandle->hAvrMecSpeedUnit);
#endif
}
 800a344:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 800a348:	4770      	bx	lr
 800a34a:	bf00      	nop

0800a34c <SPD_GetInstElSpeedDpp>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->InstantaneousElSpeedDpp);
#else
  return (pHandle->InstantaneousElSpeedDpp);
#endif
}
 800a34c:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
 800a350:	4770      	bx	lr
 800a352:	bf00      	nop

0800a354 <SPD_IsMecSpeedReliable>:
    bool SpeedError = false;

    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;

    /* Compute absoulte value of mechanical speed */
    if (*pMecSpeedUnit < 0)
 800a354:	f9b1 3000 	ldrsh.w	r3, [r1]
    else
    {
      /* Nothing to do */
    }

    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a358:	f8b0 c016 	ldrh.w	ip, [r0, #22]
{
 800a35c:	b410      	push	{r4}
    if (*pMecSpeedUnit < 0)
 800a35e:	2b00      	cmp	r3, #0
      hAux = -(*pMecSpeedUnit);
 800a360:	bfb8      	it	lt
 800a362:	425b      	neglt	r3, r3
      hAbsMecSpeedUnit = (uint16_t)(*pMecSpeedUnit);
 800a364:	b29b      	uxth	r3, r3
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a366:	459c      	cmp	ip, r3
    uint8_t bMaximumSpeedErrorsNumber = pHandle->bMaximumSpeedErrorsNumber;
 800a368:	78c1      	ldrb	r1, [r0, #3]
    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;
 800a36a:	7802      	ldrb	r2, [r0, #0]
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 800a36c:	8a84      	ldrh	r4, [r0, #20]
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a36e:	d819      	bhi.n	800a3a4 <SPD_IsMecSpeedReliable+0x50>
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 800a370:	429c      	cmp	r4, r3
 800a372:	bf2c      	ite	cs
 800a374:	2400      	movcs	r4, #0
 800a376:	2401      	movcc	r4, #1
    {
      /* Nothing to do */
    }

    /* Compute absoulte value of mechanical acceleration */
    if (pHandle->hMecAccelUnitP < 0)
 800a378:	f9b0 3012 	ldrsh.w	r3, [r0, #18]
    else
    {
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
    }

    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 800a37c:	f8b0 c018 	ldrh.w	ip, [r0, #24]
    if (pHandle->hMecAccelUnitP < 0)
 800a380:	2b00      	cmp	r3, #0
      hAux = -(pHandle->hMecAccelUnitP);
 800a382:	bfb8      	it	lt
 800a384:	425b      	neglt	r3, r3
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
 800a386:	b29b      	uxth	r3, r3
    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 800a388:	459c      	cmp	ip, r3
 800a38a:	d300      	bcc.n	800a38e <SPD_IsMecSpeedReliable+0x3a>
    else
    {
      /* Nothing to do */
    }

    if (true == SpeedError)
 800a38c:	b164      	cbz	r4, 800a3a8 <SPD_IsMecSpeedReliable+0x54>
    {
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 800a38e:	4291      	cmp	r1, r2
 800a390:	d901      	bls.n	800a396 <SPD_IsMecSpeedReliable+0x42>
      {
        bSpeedErrorNumber++;
 800a392:	3201      	adds	r2, #1
 800a394:	b2d2      	uxtb	r2, r2
    else
    {
      /* Nothing to do */
    }

    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 800a396:	7002      	strb	r2, [r0, #0]
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (SpeedSensorReliability);
}
 800a398:	1a50      	subs	r0, r2, r1
 800a39a:	bf18      	it	ne
 800a39c:	2001      	movne	r0, #1
 800a39e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a3a2:	4770      	bx	lr
      SpeedError = true;
 800a3a4:	2401      	movs	r4, #1
 800a3a6:	e7e7      	b.n	800a378 <SPD_IsMecSpeedReliable+0x24>
        bSpeedErrorNumber = 0u;
 800a3a8:	4291      	cmp	r1, r2
 800a3aa:	bf88      	it	hi
 800a3ac:	2200      	movhi	r2, #0
 800a3ae:	e7f2      	b.n	800a396 <SPD_IsMecSpeedReliable+0x42>

0800a3b0 <SPD_GetS16Speed>:
  }
  else
  {
#endif
    int32_t wAux = (int32_t)pHandle->hAvrMecSpeedUnit;
    wAux *= INT16_MAX;
 800a3b0:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 800a3b4:	f9b0 2014 	ldrsh.w	r2, [r0, #20]
    wAux *= INT16_MAX;
 800a3b8:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 800a3bc:	fb93 f0f2 	sdiv	r0, r3, r2
    tempValue = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (tempValue);
}
 800a3c0:	b200      	sxth	r0, r0
 800a3c2:	4770      	bx	lr

0800a3c4 <STC_Init>:
  {
#endif
    pHandle->PISpeed = pPI;
    pHandle->SPD = SPD_Handle;
    pHandle->Mode = pHandle->ModeDefault;
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 800a3c4:	f9b0 c02c 	ldrsh.w	ip, [r0, #44]	; 0x2c
    pHandle->PISpeed = pPI;
 800a3c8:	6101      	str	r1, [r0, #16]
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800a3ca:	f9b0 102e 	ldrsh.w	r1, [r0, #46]	; 0x2e
    pHandle->SPD = SPD_Handle;
 800a3ce:	6142      	str	r2, [r0, #20]
{
 800a3d0:	b410      	push	{r4}
    pHandle->Mode = pHandle->ModeDefault;
 800a3d2:	f890 402a 	ldrb.w	r4, [r0, #42]	; 0x2a
 800a3d6:	7004      	strb	r4, [r0, #0]
    pHandle->TargetFinal = 0;
 800a3d8:	2300      	movs	r3, #0
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 800a3da:	ea4f 440c 	mov.w	r4, ip, lsl #16
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800a3de:	0409      	lsls	r1, r1, #16
 800a3e0:	e9c0 4101 	strd	r4, r1, [r0, #4]
    pHandle->TargetFinal = 0;
 800a3e4:	8043      	strh	r3, [r0, #2]
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3e6:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->RampRemainingStep = 0U;
 800a3ea:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 800a3ec:	6183      	str	r3, [r0, #24]
}
 800a3ee:	4770      	bx	lr

0800a3f0 <STC_SetSpeedSensor>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SPD = SPD_Handle;
 800a3f0:	6141      	str	r1, [r0, #20]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3f2:	4770      	bx	lr

0800a3f4 <STC_GetSpeedSensor>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL ==  pHandle) ? MC_NULL : pHandle->SPD);
#else
  return (pHandle->SPD);
#endif
}
 800a3f4:	6940      	ldr	r0, [r0, #20]
 800a3f6:	4770      	bx	lr

0800a3f8 <STC_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a3f8:	7803      	ldrb	r3, [r0, #0]
 800a3fa:	2b03      	cmp	r3, #3
 800a3fc:	d000      	beq.n	800a400 <STC_Clear+0x8>
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3fe:	4770      	bx	lr
      PID_SetIntegralTerm(pHandle->PISpeed, 0);
 800a400:	6900      	ldr	r0, [r0, #16]
 800a402:	2100      	movs	r1, #0
 800a404:	f7fe bee8 	b.w	80091d8 <PID_SetIntegralTerm>

0800a408 <STC_GetMecSpeedRefUnit>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->SpeedRefUnitExt / 65536));
#else
  return ((int16_t)(pHandle->SpeedRefUnitExt / 65536));
#endif
#endif
}
 800a408:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 800a40c:	4770      	bx	lr
 800a40e:	bf00      	nop

0800a410 <STC_GetTorqueRef>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->TorqueRef / 65536));
#else
  return ((int16_t)(pHandle->TorqueRef / 65536));
#endif
#endif
}
 800a410:	f9b0 000a 	ldrsh.w	r0, [r0, #10]
 800a414:	4770      	bx	lr
 800a416:	bf00      	nop

0800a418 <STC_SetControlMode>:
  }
  else
  {
#endif
    pHandle->Mode = bMode;
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 800a418:	2300      	movs	r3, #0
    pHandle->Mode = bMode;
 800a41a:	7001      	strb	r1, [r0, #0]
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 800a41c:	60c3      	str	r3, [r0, #12]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a41e:	4770      	bx	lr

0800a420 <STC_ExecRamp>:
  * @ref EncAlignCtrl "Encoder Alignment Control",
  * @ref PositionControl "Position Control" loop or
  * speed regulation with @ref SpeedRegulatorPotentiometer Speed potentiometer.
  */
__weak bool STC_ExecRamp(SpeednTorqCtrl_Handle_t *pHandle, int16_t hTargetFinal, uint32_t hDurationms)
{
 800a420:	b570      	push	{r4, r5, r6, lr}
    uint32_t wAux;
    int32_t wAux1;
    int16_t hCurrentReference;

    /* Check if the hTargetFinal is out of the bound of application */
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a422:	7803      	ldrb	r3, [r0, #0]
 800a424:	2b04      	cmp	r3, #4
{
 800a426:	4604      	mov	r4, r0
 800a428:	460d      	mov	r5, r1
 800a42a:	4616      	mov	r6, r2
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a42c:	d01e      	beq.n	800a46c <STC_ExecRamp+0x4c>
#else
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt / 65536);
#endif

#ifdef CHECK_BOUNDARY
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 800a42e:	8bc3      	ldrh	r3, [r0, #30]
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 800a430:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 800a434:	4299      	cmp	r1, r3
 800a436:	dd01      	ble.n	800a43c <STC_ExecRamp+0x1c>
        allowedRange = false;
 800a438:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (allowedRange);
}
 800a43a:	bd70      	pop	{r4, r5, r6, pc}
      else if (hTargetFinal < pHandle->MinAppNegativeMecSpeedUnit)
 800a43c:	f9b4 3024 	ldrsh.w	r3, [r4, #36]	; 0x24
 800a440:	428b      	cmp	r3, r1
 800a442:	dcf9      	bgt.n	800a438 <STC_ExecRamp+0x18>
      else if ((int32_t)hTargetFinal < (int32_t)pHandle->MinAppPositiveMecSpeedUnit)
 800a444:	8c23      	ldrh	r3, [r4, #32]
 800a446:	4299      	cmp	r1, r3
 800a448:	da03      	bge.n	800a452 <STC_ExecRamp+0x32>
        if (hTargetFinal > pHandle->MaxAppNegativeMecSpeedUnit)
 800a44a:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
 800a44e:	428b      	cmp	r3, r1
 800a450:	dbf2      	blt.n	800a438 <STC_ExecRamp+0x18>
      if (0U == hDurationms)
 800a452:	b9ae      	cbnz	r6, 800a480 <STC_ExecRamp+0x60>
        if (MCM_SPEED_MODE == pHandle->Mode)
 800a454:	7823      	ldrb	r3, [r4, #0]
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 800a456:	042d      	lsls	r5, r5, #16
        if (MCM_SPEED_MODE == pHandle->Mode)
 800a458:	2b03      	cmp	r3, #3
        pHandle->RampRemainingStep = 0U;
 800a45a:	f04f 0300 	mov.w	r3, #0
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 800a45e:	bf0c      	ite	eq
 800a460:	6065      	streq	r5, [r4, #4]
          pHandle->TorqueRef = ((int32_t)hTargetFinal) * 65536;
 800a462:	60a5      	strne	r5, [r4, #8]
        pHandle->RampRemainingStep = 0U;
 800a464:	60e3      	str	r3, [r4, #12]
        pHandle->IncDecAmount = 0;
 800a466:	61a3      	str	r3, [r4, #24]
 800a468:	2001      	movs	r0, #1
}
 800a46a:	bd70      	pop	{r4, r5, r6, pc}
      hCurrentReference = STC_GetTorqueRef(pHandle);
 800a46c:	f7ff ffd0 	bl	800a410 <STC_GetTorqueRef>
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxPositiveTorque)
 800a470:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800a472:	429d      	cmp	r5, r3
 800a474:	dce0      	bgt.n	800a438 <STC_ExecRamp+0x18>
      if ((int32_t)hTargetFinal < (int32_t)pHandle->MinNegativeTorque)
 800a476:	f9b4 3028 	ldrsh.w	r3, [r4, #40]	; 0x28
 800a47a:	42ab      	cmp	r3, r5
 800a47c:	dcdc      	bgt.n	800a438 <STC_ExecRamp+0x18>
 800a47e:	e7e8      	b.n	800a452 <STC_ExecRamp+0x32>
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 800a480:	8ba3      	ldrh	r3, [r4, #28]
        wAux /= 1000U;
 800a482:	4a08      	ldr	r2, [pc, #32]	; (800a4a4 <STC_ExecRamp+0x84>)
        pHandle->TargetFinal = hTargetFinal;
 800a484:	8065      	strh	r5, [r4, #2]
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 800a486:	fb06 f303 	mul.w	r3, r6, r3
        wAux /= 1000U;
 800a48a:	fba2 2303 	umull	r2, r3, r2, r3
 800a48e:	099b      	lsrs	r3, r3, #6
        pHandle->RampRemainingStep++;
 800a490:	3301      	adds	r3, #1
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 800a492:	1a28      	subs	r0, r5, r0
 800a494:	0400      	lsls	r0, r0, #16
        pHandle->RampRemainingStep++;
 800a496:	60e3      	str	r3, [r4, #12]
        wAux1 /= ((int32_t)pHandle->RampRemainingStep);
 800a498:	fb90 f0f3 	sdiv	r0, r0, r3
        pHandle->IncDecAmount = wAux1;
 800a49c:	61a0      	str	r0, [r4, #24]
 800a49e:	2001      	movs	r0, #1
}
 800a4a0:	bd70      	pop	{r4, r5, r6, pc}
 800a4a2:	bf00      	nop
 800a4a4:	10624dd3 	.word	0x10624dd3

0800a4a8 <STC_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->RampRemainingStep = 0U;
 800a4a8:	2300      	movs	r3, #0
 800a4aa:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 800a4ac:	6183      	str	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a4ae:	4770      	bx	lr

0800a4b0 <STC_CalcTorqueReference>:
  * - Must be called at fixed time equal to hSTCFrequencyHz. It is called
  * passing as parameter the speed sensor used to perform the speed regulation.
  * - Called during START and ALIGNEMENT states of the MC state machine into MediumFrequencyTask.
  */
__weak int16_t STC_CalcTorqueReference(SpeednTorqCtrl_Handle_t *pHandle)
{
 800a4b0:	b538      	push	{r3, r4, r5, lr}
    int16_t hTargetSpeed;
    int16_t hError;

    if (MCM_TORQUE_MODE == pHandle->Mode)
    {
      wCurrentReference = pHandle->TorqueRef;
 800a4b2:	e9d0 5101 	ldrd	r5, r1, [r0, #4]
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a4b6:	7802      	ldrb	r2, [r0, #0]
      wCurrentReference = pHandle->SpeedRefUnitExt;
    }

    /* Update the speed reference or the torque reference according to the mode
       and terminates the ramp if needed */
    if (pHandle->RampRemainingStep > 1U)
 800a4b8:	68c3      	ldr	r3, [r0, #12]
      wCurrentReference = pHandle->TorqueRef;
 800a4ba:	2a04      	cmp	r2, #4
 800a4bc:	bf08      	it	eq
 800a4be:	460d      	moveq	r5, r1
    if (pHandle->RampRemainingStep > 1U)
 800a4c0:	2b01      	cmp	r3, #1
{
 800a4c2:	4604      	mov	r4, r0
    if (pHandle->RampRemainingStep > 1U)
 800a4c4:	d908      	bls.n	800a4d8 <STC_CalcTorqueReference+0x28>
    {
      /* Increment/decrement the reference value */
      wCurrentReference += pHandle->IncDecAmount;
 800a4c6:	6981      	ldr	r1, [r0, #24]

      /* Decrement the number of remaining steps */
      pHandle->RampRemainingStep--;
 800a4c8:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 800a4ca:	440d      	add	r5, r1
      pHandle->RampRemainingStep--;
 800a4cc:	60c3      	str	r3, [r0, #12]
    else
    {
      /* Do nothing */
    }

    if (MCM_SPEED_MODE == pHandle->Mode)
 800a4ce:	2a03      	cmp	r2, #3
 800a4d0:	d00b      	beq.n	800a4ea <STC_CalcTorqueReference+0x3a>
    else
    {
      pHandle->TorqueRef = wCurrentReference;
#ifndef FULL_MISRA_C_COMPLIANCY_SPD_TORQ_CTRL
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hTorqueReference = (int16_t)(wCurrentReference >> 16);
 800a4d2:	1428      	asrs	r0, r5, #16
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 800a4d4:	60a5      	str	r5, [r4, #8]
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (hTorqueReference);
}
 800a4d6:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 800a4d8:	d1f9      	bne.n	800a4ce <STC_CalcTorqueReference+0x1e>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 800a4da:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 800a4de:	2300      	movs	r3, #0
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a4e0:	2a03      	cmp	r2, #3
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 800a4e2:	ea4f 4505 	mov.w	r5, r5, lsl #16
      pHandle->RampRemainingStep = 0U;
 800a4e6:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a4e8:	d1f3      	bne.n	800a4d2 <STC_CalcTorqueReference+0x22>
      hMeasuredSpeed = SPD_GetAvrgMecSpeedUnit(pHandle->SPD);
 800a4ea:	6960      	ldr	r0, [r4, #20]
 800a4ec:	f7ff ff2a 	bl	800a344 <SPD_GetAvrgMecSpeedUnit>
      hError = hTargetSpeed - hMeasuredSpeed;
 800a4f0:	ebc0 4125 	rsb	r1, r0, r5, asr #16
      hTorqueReference = PI_Controller(pHandle->PISpeed, (int32_t)hError);
 800a4f4:	b209      	sxth	r1, r1
 800a4f6:	6920      	ldr	r0, [r4, #16]
 800a4f8:	f7fe fea0 	bl	800923c <PI_Controller>
      pHandle->SpeedRefUnitExt = wCurrentReference;
 800a4fc:	6065      	str	r5, [r4, #4]
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 800a4fe:	0405      	lsls	r5, r0, #16
 800a500:	60a5      	str	r5, [r4, #8]
}
 800a502:	bd38      	pop	{r3, r4, r5, pc}

0800a504 <STC_GetMecSpeedRefUnitDefault>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL == pHandle) ? 0 : pHandle->MecSpeedRefUnitDefault);
#else
  return (pHandle->MecSpeedRefUnitDefault);
#endif
}
 800a504:	f9b0 002c 	ldrsh.w	r0, [r0, #44]	; 0x2c
 800a508:	4770      	bx	lr
 800a50a:	bf00      	nop

0800a50c <STC_GetDefaultIqdref>:
    IqdRefDefault.d = 0;
  }
  else
  {
#endif
    IqdRefDefault.q = pHandle->TorqueRefDefault;
 800a50c:	f8d0 302e 	ldr.w	r3, [r0, #46]	; 0x2e
    IqdRefDefault.d = pHandle->IdrefDefault;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (IqdRefDefault);
 800a510:	2200      	movs	r2, #0
 800a512:	b299      	uxth	r1, r3
 800a514:	f361 020f 	bfi	r2, r1, #0, #16
 800a518:	0c1b      	lsrs	r3, r3, #16
 800a51a:	f363 421f 	bfi	r2, r3, #16, #16
{
 800a51e:	b082      	sub	sp, #8
}
 800a520:	4610      	mov	r0, r2
 800a522:	b002      	add	sp, #8
 800a524:	4770      	bx	lr
 800a526:	bf00      	nop

0800a528 <STC_ForceSpeedReferenceToCurrentSpeed>:
  *
  * - Called during the CHARGE_BOOT_CAP, SWITCH_OVER and WAIT_STOP_MOTOR states of the MC state machine
  * into MediumFrequencyTask to initialize the speed reference.
  */
__weak void STC_ForceSpeedReferenceToCurrentSpeed(SpeednTorqCtrl_Handle_t *pHandle)
{
 800a528:	b510      	push	{r4, lr}
 800a52a:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SpeedRefUnitExt = ((int32_t)SPD_GetAvrgMecSpeedUnit(pHandle->SPD)) * (int32_t)65536;
 800a52c:	6940      	ldr	r0, [r0, #20]
 800a52e:	f7ff ff09 	bl	800a344 <SPD_GetAvrgMecSpeedUnit>
 800a532:	0400      	lsls	r0, r0, #16
 800a534:	6060      	str	r0, [r4, #4]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a536:	bd10      	pop	{r4, pc}

0800a538 <STO_PLL_CalcElAngle>:
  * @param  pInput: Pointer to the observer inputs structure.
  * @retval int16_t Rotor electrical angle (s16Degrees).
  */
//cstat !MISRAC2012-Rule-8.13
__weak int16_t STO_PLL_CalcElAngle(STO_PLL_Handle_t *pHandle, Observer_Inputs_t *pInputs)
{
 800a538:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int16_t retValue;

  if ((MC_NULL == pHandle) || (MC_NULL == pInputs))
 800a53c:	4604      	mov	r4, r0
{
 800a53e:	b089      	sub	sp, #36	; 0x24
  if ((MC_NULL == pHandle) || (MC_NULL == pInputs))
 800a540:	2800      	cmp	r0, #0
 800a542:	f000 80cf 	beq.w	800a6e4 <STO_PLL_CalcElAngle+0x1ac>
 800a546:	2900      	cmp	r1, #0
 800a548:	f000 80cf 	beq.w	800a6ea <STO_PLL_CalcElAngle+0x1b2>
    int16_t hIbeta_err;
    int16_t hRotor_Speed;
    int16_t hValfa;
    int16_t hVbeta;

    if (pHandle->wBemf_alfa_est > (((int32_t)pHandle->hF2) * INT16_MAX))
 800a54c:	f9b0 302e 	ldrsh.w	r3, [r0, #46]	; 0x2e
 800a550:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800a552:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800a556:	429f      	cmp	r7, r3
 800a558:	f340 80d1 	ble.w	800a6fe <STO_PLL_CalcElAngle+0x1c6>
    {
      pHandle->wBemf_alfa_est = INT16_MAX * ((int32_t)pHandle->hF2);
 800a55c:	6683      	str	r3, [r0, #104]	; 0x68
 800a55e:	461f      	mov	r7, r3
    {
      /* Nothing to do */
    }
#ifndef FULL_MISRA_C_COMPLIANCY_STO_PLL
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a560:	f8b4 511e 	ldrh.w	r5, [r4, #286]	; 0x11e
#else
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est / pHandle->hF2);
#endif

    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a564:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a566:	fa47 f205 	asr.w	r2, r7, r5
    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a56a:	42b3      	cmp	r3, r6
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a56c:	9201      	str	r2, [sp, #4]
 800a56e:	fa0f fe82 	sxth.w	lr, r2
    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a572:	f2c0 80c1 	blt.w	800a6f8 <STO_PLL_CalcElAngle+0x1c0>
    {
      pHandle->wBemf_beta_est = INT16_MAX * ((int32_t)pHandle->hF2);
    }
    else if (pHandle->wBemf_beta_est <= (-INT16_MAX * ((int32_t)pHandle->hF2)))
 800a576:	425b      	negs	r3, r3
 800a578:	429e      	cmp	r6, r3
 800a57a:	f340 80bd 	ble.w	800a6f8 <STO_PLL_CalcElAngle+0x1c0>
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
#else
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est / pHandle->hF2);
#endif

    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a57e:	f9b4 302c 	ldrsh.w	r3, [r4, #44]	; 0x2c
 800a582:	f8d4 9060 	ldr.w	r9, [r4, #96]	; 0x60
 800a586:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 800a58a:	fa46 f505 	asr.w	r5, r6, r5
    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a58e:	4599      	cmp	r9, r3
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 800a590:	fa0f fc85 	sxth.w	ip, r5
    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a594:	f340 80b9 	ble.w	800a70a <STO_PLL_CalcElAngle+0x1d2>
    {
      pHandle->Ialfa_est = INT16_MAX * ((int32_t)pHandle->hF1);
 800a598:	6623      	str	r3, [r4, #96]	; 0x60
 800a59a:	4699      	mov	r9, r3
    else
    {
      /* Nothing to do */
    }

    if (pHandle->Ibeta_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a59c:	f8d4 8064 	ldr.w	r8, [r4, #100]	; 0x64
 800a5a0:	4543      	cmp	r3, r8
 800a5a2:	f2c0 80a6 	blt.w	800a6f2 <STO_PLL_CalcElAngle+0x1ba>
    {
      pHandle->Ibeta_est = INT16_MAX * ((int32_t)pHandle->hF1);
    }
    else if (pHandle->Ibeta_est <= (-INT16_MAX * ((int32_t)pHandle->hF1)))
 800a5a6:	425b      	negs	r3, r3
 800a5a8:	4598      	cmp	r8, r3
 800a5aa:	f340 80a2 	ble.w	800a6f2 <STO_PLL_CalcElAngle+0x1ba>
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
#else
    hIbeta_err = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif

    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5ae:	88c8      	ldrh	r0, [r1, #6]

    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a5b0:	f8b1 a008 	ldrh.w	sl, [r1, #8]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5b4:	888b      	ldrh	r3, [r1, #4]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5b6:	f8ad 0014 	strh.w	r0, [sp, #20]
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
#else
    hValfa = (int16_t)(wAux / 65536);
#endif

    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.beta;
 800a5ba:	f9b1 0002 	ldrsh.w	r0, [r1, #2]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5be:	f8ad 3010 	strh.w	r3, [sp, #16]
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a5c2:	f9b1 3000 	ldrsh.w	r3, [r1]
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a5c6:	f8b4 211c 	ldrh.w	r2, [r4, #284]	; 0x11c
    hAux = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
#else
    hAux = (int16_t)(pHandle->Ialfa_est / pHandle->hF1);
#endif

    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a5ca:	f9b4 b020 	ldrsh.w	fp, [r4, #32]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5ce:	9904      	ldr	r1, [sp, #16]
    wAux = wAux * pHandle->hC6;
    wAux = pHandle->_Super.hElSpeedDpp * wAux;
    wBemf_beta_est_Next -= wAux;

    /* Calls the PLL blockset */
    pHandle->hBemf_alfa_est = hAux_Alfa;
 800a5d0:	f8a4 e070 	strh.w	lr, [r4, #112]	; 0x70
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.beta;
 800a5d4:	fb0a f000 	mul.w	r0, sl, r0
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a5d8:	fb0a f303 	mul.w	r3, sl, r3
    hVbeta = ( int16_t ) ( wAux >> 16 ); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a5dc:	1400      	asrs	r0, r0, #16
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a5de:	141b      	asrs	r3, r3, #16
    hVbeta = ( int16_t ) ( wAux >> 16 ); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a5e0:	9003      	str	r0, [sp, #12]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5e2:	9805      	ldr	r0, [sp, #20]
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a5e4:	9302      	str	r3, [sp, #8]
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a5e6:	fa49 f302 	asr.w	r3, r9, r2
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 800a5ea:	fa48 f202 	asr.w	r2, r8, r2
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5ee:	eba2 0a00 	sub.w	sl, r2, r0
    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a5f2:	fb12 f20b 	smulbb	r2, r2, fp
    wIbeta_est_Next = pHandle->Ibeta_est - wAux;
 800a5f6:	eba8 0202 	sub.w	r2, r8, r2
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5fa:	1a59      	subs	r1, r3, r1
    wAux = ((int32_t)pHandle->hC2) * hIalfa_err;
 800a5fc:	f9b4 8022 	ldrsh.w	r8, [r4, #34]	; 0x22
    wIalfa_est_Next += wAux;
 800a600:	9802      	ldr	r0, [sp, #8]
    pHandle->hBemf_beta_est = hAux_Beta;
 800a602:	f8a4 c072 	strh.w	ip, [r4, #114]	; 0x72
    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a606:	fb13 f30b 	smulbb	r3, r3, fp
    wIalfa_est_Next = pHandle->Ialfa_est - wAux;
 800a60a:	eba9 0303 	sub.w	r3, r9, r3
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a60e:	b209      	sxth	r1, r1
    wAux = ((int32_t)pHandle->hC5) * hValfa;
 800a610:	f9b4 9028 	ldrsh.w	r9, [r4, #40]	; 0x28
    wIalfa_est_Next += wAux;
 800a614:	fb08 3301 	mla	r3, r8, r1, r3
    wIalfa_est_Next += wAux;
 800a618:	fb09 3300 	mla	r3, r9, r0, r3
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a61c:	fa0f fa8a 	sxth.w	sl, sl
    wIbeta_est_Next += wAux;
 800a620:	9803      	ldr	r0, [sp, #12]
    wIbeta_est_Next += wAux;
 800a622:	fb08 280a 	mla	r8, r8, sl, r2
    wIbeta_est_Next += wAux;
 800a626:	fb09 8800 	mla	r8, r9, r0, r8
    wAux = ((int32_t)pHandle->hC4) * hIalfa_err;
 800a62a:	f9b4 0026 	ldrsh.w	r0, [r4, #38]	; 0x26
    wAux = (int32_t)hAux_Beta >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a62e:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    wAux = wAux * pHandle->hC6;
 800a630:	f9b4 902a 	ldrsh.w	r9, [r4, #42]	; 0x2a
    wBemf_alfa_est_Next = pHandle->wBemf_alfa_est + wAux;
 800a634:	fb01 7100 	mla	r1, r1, r0, r7
    wBemf_beta_est_Next = pHandle->wBemf_beta_est + wAux;
 800a638:	fb00 600a 	mla	r0, r0, sl, r6
    wAux = ((int32_t)pHandle->hC3) * hAux_Alfa;
 800a63c:	f9b4 6024 	ldrsh.w	r6, [r4, #36]	; 0x24
    wIalfa_est_Next -= wAux;
 800a640:	fb06 371e 	mls	r7, r6, lr, r3
    wIbeta_est_Next -= wAux;
 800a644:	fb06 861c 	mls	r6, r6, ip, r8
    wAux = (int32_t)hAux_Alfa >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a648:	fa4e fe02 	asr.w	lr, lr, r2
    wAux = (int32_t)hAux_Beta >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a64c:	fa4c fc02 	asr.w	ip, ip, r2
    wAux = pHandle->_Super.hElSpeedDpp * wAux;
 800a650:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
    wAux = wAux * pHandle->hC6;
 800a654:	fb0e f309 	mul.w	r3, lr, r9
    wBemf_beta_est_Next -= wAux;
 800a658:	fb03 0812 	mls	r8, r3, r2, r0

    if (0 == pHandle->hForcedDirection)
 800a65c:	f994 3124 	ldrsb.w	r3, [r4, #292]	; 0x124
    wAux = wAux * pHandle->hC6;
 800a660:	fb0c fc09 	mul.w	ip, ip, r9
    wBemf_alfa_est_Next += wAux;
 800a664:	fb0c 1902 	mla	r9, ip, r2, r1
    if (0 == pHandle->hForcedDirection)
 800a668:	2b00      	cmp	r3, #0
 800a66a:	d154      	bne.n	800a716 <STO_PLL_CalcElAngle+0x1de>
    {
      /* We are in auxiliary mode, then rely on the speed detected */
      if(pHandle->_Super.hElSpeedDpp >= 0)
 800a66c:	2a00      	cmp	r2, #0
 800a66e:	f64f 7aff 	movw	sl, #65535	; 0xffff
 800a672:	bfa8      	it	ge
 800a674:	f04f 0a01 	movge.w	sl, #1
  int16_t hAux1;
  int16_t hAux2;
  int16_t hOutput;
  Trig_Components Local_Components;

  Local_Components = MCM_Trig_Functions(pHandle->_Super.hElAngle);
 800a678:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 800a67c:	f7f7 fcb2 	bl	8001fe4 <MCM_Trig_Functions>
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a680:	9b01      	ldr	r3, [sp, #4]
    hAux_Beta = (int16_t)(hAux_Beta * wDirection);
 800a682:	fb15 f50a 	smulbb	r5, r5, sl
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a686:	fb13 f30a 	smulbb	r3, r3, sl
    hRotor_Speed = STO_ExecutePLL(pHandle, hAux_Alfa, -hAux_Beta);
 800a68a:	426d      	negs	r5, r5

  /* Alfa & Beta BEMF multiplied by Cos & Sin */
  wAlfa_Sin_tmp = ((int32_t )hBemf_alfa_est) * ((int32_t )Local_Components.hSin);
  wBeta_Cos_tmp = ((int32_t )hBemf_beta_est) * ((int32_t )Local_Components.hCos);
 800a68c:	fb10 f505 	smulbb	r5, r0, r5
  wAlfa_Sin_tmp = ((int32_t )hBemf_alfa_est) * ((int32_t )Local_Components.hSin);
 800a690:	fb10 f023 	smultb	r0, r0, r3
#else
  hAux2 = (int16_t)(wAlfa_Sin_tmp / 32768);
#endif

  /* Speed PI regulator */
  hOutput = PI_Controller(& pHandle->PIRegulator, (int32_t)(hAux1 ) - hAux2);
 800a694:	f340 31cf 	sbfx	r1, r0, #15, #16
 800a698:	f345 35cf 	sbfx	r5, r5, #15, #16
 800a69c:	1a69      	subs	r1, r5, r1
 800a69e:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800a6a2:	f7fe fdcb 	bl	800923c <PI_Controller>
  uint8_t bBuffer_index = pHandle->Speed_Buffer_Index;
 800a6a6:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 800a6aa:	f894 210e 	ldrb.w	r2, [r4, #270]	; 0x10e
    pHandle->_Super.InstantaneousElSpeedDpp = hRotor_Speed;
 800a6ae:	8220      	strh	r0, [r4, #16]
  bBuffer_index++;
 800a6b0:	3301      	adds	r3, #1
 800a6b2:	b2db      	uxtb	r3, r3
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 800a6b4:	429a      	cmp	r2, r3
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 800a6b6:	bf12      	itee	ne
 800a6b8:	461a      	movne	r2, r3
 800a6ba:	2200      	moveq	r2, #0
    bBuffer_index = 0U;
 800a6bc:	4613      	moveq	r3, r2
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 800a6be:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 800a6c2:	f9b2 1074 	ldrsh.w	r1, [r2, #116]	; 0x74
 800a6c6:	f8a4 110c 	strh.w	r1, [r4, #268]	; 0x10c
  pHandle->Speed_Buffer[bBuffer_index] = hRotor_Speed;
 800a6ca:	f8a2 0074 	strh.w	r0, [r2, #116]	; 0x74
  pHandle->Speed_Buffer_Index = bBuffer_index;
 800a6ce:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a6d2:	88a3      	ldrh	r3, [r4, #4]
    pHandle->Ialfa_est = wIalfa_est_Next;
 800a6d4:	6627      	str	r7, [r4, #96]	; 0x60
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a6d6:	4418      	add	r0, r3
    pHandle->Ibeta_est = wIbeta_est_Next;
 800a6d8:	e9c4 6919 	strd	r6, r9, [r4, #100]	; 0x64
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a6dc:	b200      	sxth	r0, r0
    pHandle->wBemf_beta_est = wBemf_beta_est_Next;
 800a6de:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a6e2:	80a0      	strh	r0, [r4, #4]
}
 800a6e4:	b009      	add	sp, #36	; 0x24
 800a6e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    retValue = 0;
 800a6ea:	4608      	mov	r0, r1
}
 800a6ec:	b009      	add	sp, #36	; 0x24
 800a6ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      pHandle->Ibeta_est = -INT16_MAX * ((int32_t)pHandle->hF1);
 800a6f2:	6663      	str	r3, [r4, #100]	; 0x64
 800a6f4:	4698      	mov	r8, r3
 800a6f6:	e75a      	b.n	800a5ae <STO_PLL_CalcElAngle+0x76>
      pHandle->wBemf_beta_est = (-INT16_MAX * ((int32_t)pHandle->hF2));
 800a6f8:	66e3      	str	r3, [r4, #108]	; 0x6c
 800a6fa:	461e      	mov	r6, r3
 800a6fc:	e73f      	b.n	800a57e <STO_PLL_CalcElAngle+0x46>
    else if (pHandle->wBemf_alfa_est <= (-INT16_MAX * ((int32_t)pHandle->hF2)))
 800a6fe:	425a      	negs	r2, r3
 800a700:	4297      	cmp	r7, r2
      pHandle->wBemf_alfa_est = -INT16_MAX * ((int32_t)pHandle->hF2);
 800a702:	bfdc      	itt	le
 800a704:	6682      	strle	r2, [r0, #104]	; 0x68
 800a706:	4617      	movle	r7, r2
 800a708:	e72a      	b.n	800a560 <STO_PLL_CalcElAngle+0x28>
    else if (pHandle->Ialfa_est <= (-INT16_MAX * ((int32_t)pHandle->hF1)))
 800a70a:	425a      	negs	r2, r3
 800a70c:	4591      	cmp	r9, r2
      pHandle->Ialfa_est = -INT16_MAX * ((int32_t)pHandle->hF1);
 800a70e:	bfdc      	itt	le
 800a710:	6622      	strle	r2, [r4, #96]	; 0x60
 800a712:	4691      	movle	r9, r2
 800a714:	e742      	b.n	800a59c <STO_PLL_CalcElAngle+0x64>
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a716:	fa1f fa83 	uxth.w	sl, r3
 800a71a:	e7ad      	b.n	800a678 <STO_PLL_CalcElAngle+0x140>

0800a71c <STO_PLL_CalcAvrgMecSpeedUnit>:
{
 800a71c:	b570      	push	{r4, r5, r6, lr}
    uint8_t i, bSpeedBufferSizeUnit = pHandle->SpeedBufferSizeUnit;
 800a71e:	f890 510e 	ldrb.w	r5, [r0, #270]	; 0x10e
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a722:	2d00      	cmp	r5, #0
 800a724:	f000 809c 	beq.w	800a860 <STO_PLL_CalcAvrgMecSpeedUnit+0x144>
 800a728:	1e6b      	subs	r3, r5, #1
 800a72a:	b2db      	uxtb	r3, r3
 800a72c:	f100 0472 	add.w	r4, r0, #114	; 0x72
 800a730:	f100 0c74 	add.w	ip, r0, #116	; 0x74
 800a734:	eb0c 0c43 	add.w	ip, ip, r3, lsl #1
    int32_t wAvrSpeed_dpp = (int32_t)0;
 800a738:	2200      	movs	r2, #0
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a73a:	4623      	mov	r3, r4
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 800a73c:	f933 ef02 	ldrsh.w	lr, [r3, #2]!
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a740:	459c      	cmp	ip, r3
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 800a742:	4472      	add	r2, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a744:	d1fa      	bne.n	800a73c <STO_PLL_CalcAvrgMecSpeedUnit+0x20>
      wAvrSpeed_dpp = wAvrSpeed_dpp / ((int16_t)bSpeedBufferSizeUnit);
 800a746:	fb92 fef5 	sdiv	lr, r2, r5
 800a74a:	2200      	movs	r2, #0
      wError = ((int32_t)pHandle->Speed_Buffer[i]) - wAvrSpeed_dpp;
 800a74c:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
 800a750:	eba3 030e 	sub.w	r3, r3, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a754:	45a4      	cmp	ip, r4
      wAvrQuadraticError += wError;
 800a756:	fb03 2203 	mla	r2, r3, r3, r2
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a75a:	d1f7      	bne.n	800a74c <STO_PLL_CalcAvrgMecSpeedUnit+0x30>
    wAvrQuadraticError = wAvrQuadraticError / ((int16_t)bSpeedBufferSizeUnit);
 800a75c:	fbb2 f2f5 	udiv	r2, r2, r5
    wAvrSquareSpeed = wAvrSpeed_dpp * wAvrSpeed_dpp;
 800a760:	fb0e f30e 	mul.w	r3, lr, lr
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 800a764:	17de      	asrs	r6, r3, #31
 800a766:	f8b0 c110 	ldrh.w	ip, [r0, #272]	; 0x110
    wAux = wAvrSpeed_dpp * ((int32_t)pHandle->_Super.hMeasurementFrequency);
 800a76a:	8b45      	ldrh	r5, [r0, #26]
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 800a76c:	fbac 4303 	umull	r4, r3, ip, r3
 800a770:	fb0c 3306 	mla	r3, ip, r6, r3
    wAvrSquareSpeed = (int32_t)(lAvrSquareSpeed / (int64_t)128);
 800a774:	09e4      	lsrs	r4, r4, #7
 800a776:	ea44 6443 	orr.w	r4, r4, r3, lsl #25
    wAux = wAux * ((int32_t)pHandle->_Super.SpeedUnit);
 800a77a:	7883      	ldrb	r3, [r0, #2]
    if (true == pHandle->EnableDualCheck) /* Do algorithm if it's enabled */
 800a77c:	f890 6104 	ldrb.w	r6, [r0, #260]	; 0x104
    wAux = wAvrSpeed_dpp * ((int32_t)pHandle->_Super.hMeasurementFrequency);
 800a780:	fb0e f505 	mul.w	r5, lr, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a784:	4294      	cmp	r4, r2
    wAux = wAux * ((int32_t)pHandle->_Super.SpeedUnit);
 800a786:	fb05 f303 	mul.w	r3, r5, r3
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a78a:	bfd8      	it	le
 800a78c:	f04f 0c00 	movle.w	ip, #0
    wAux = wAux / ((int32_t)pHandle->_Super.DPPConvFactor);
 800a790:	69c5      	ldr	r5, [r0, #28]
 800a792:	fb93 f3f5 	sdiv	r3, r3, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a796:	bfc8      	it	gt
 800a798:	f04f 0c01 	movgt.w	ip, #1
    wAux = wAux / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a79c:	7845      	ldrb	r5, [r0, #1]
 800a79e:	fb93 f3f5 	sdiv	r3, r3, r5
    *pMecSpeedUnit = (int16_t)wAux;
 800a7a2:	b21d      	sxth	r5, r3
 800a7a4:	800d      	strh	r5, [r1, #0]
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wAux;
 800a7a6:	8185      	strh	r5, [r0, #12]
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a7a8:	f880 c0f5 	strb.w	ip, [r0, #245]	; 0xf5
    if (true == pHandle->EnableDualCheck) /* Do algorithm if it's enabled */
 800a7ac:	b9ae      	cbnz	r6, 800a7da <STO_PLL_CalcAvrgMecSpeedUnit+0xbe>
    if (false == pHandle->IsAlgorithmConverged)
 800a7ae:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
 800a7b2:	b353      	cbz	r3, 800a80a <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
      if ((false == pHandle->IsSpeedReliable) || (false == bIs_Bemf_Consistent))
 800a7b4:	4294      	cmp	r4, r2
 800a7b6:	dc25      	bgt.n	800a804 <STO_PLL_CalcAvrgMecSpeedUnit+0xe8>
        pHandle->ReliabilityCounter++;
 800a7b8:	f890 30f7 	ldrb.w	r3, [r0, #247]	; 0xf7
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a7bc:	f890 2117 	ldrb.w	r2, [r0, #279]	; 0x117
        pHandle->ReliabilityCounter++;
 800a7c0:	3301      	adds	r3, #1
 800a7c2:	b2db      	uxtb	r3, r3
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a7c4:	429a      	cmp	r2, r3
        pHandle->ReliabilityCounter++;
 800a7c6:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a7ca:	d81e      	bhi.n	800a80a <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
          pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 800a7cc:	78c2      	ldrb	r2, [r0, #3]
 800a7ce:	7002      	strb	r2, [r0, #0]
          pHandle->ReliabilityCounter = 0U;
 800a7d0:	2300      	movs	r3, #0
 800a7d2:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
}
 800a7d6:	4618      	mov	r0, r3
 800a7d8:	bd70      	pop	{r4, r5, r6, pc}
      wAux = ((wAux < 0) ? (-wAux) : (wAux));
 800a7da:	2b00      	cmp	r3, #0
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 800a7dc:	f8b0 511a 	ldrh.w	r5, [r0, #282]	; 0x11a
      wAux = ((wAux < 0) ? (-wAux) : (wAux));
 800a7e0:	bfb8      	it	lt
 800a7e2:	425b      	neglt	r3, r3
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 800a7e4:	429d      	cmp	r5, r3
 800a7e6:	dc14      	bgt.n	800a812 <STO_PLL_CalcAvrgMecSpeedUnit+0xf6>
    bool bIs_Bemf_Consistent = false;
 800a7e8:	2500      	movs	r5, #0
    int32_t wEstBemfSq = 0;
 800a7ea:	462b      	mov	r3, r5
    int32_t wObsBemfSq = 0;
 800a7ec:	462e      	mov	r6, r5
      pHandle->Est_Bemf_Level = wEstBemfSq;
 800a7ee:	e9c0 633f 	strd	r6, r3, [r0, #252]	; 0xfc
    if (false == pHandle->IsAlgorithmConverged)
 800a7f2:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
      pHandle->IsBemfConsistent = bIs_Bemf_Consistent;
 800a7f6:	f880 50f9 	strb.w	r5, [r0, #249]	; 0xf9
    if (false == pHandle->IsAlgorithmConverged)
 800a7fa:	b133      	cbz	r3, 800a80a <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
      if ((false == pHandle->IsSpeedReliable) || (false == bIs_Bemf_Consistent))
 800a7fc:	4294      	cmp	r4, r2
 800a7fe:	dddb      	ble.n	800a7b8 <STO_PLL_CalcAvrgMecSpeedUnit+0x9c>
 800a800:	2d00      	cmp	r5, #0
 800a802:	d0d9      	beq.n	800a7b8 <STO_PLL_CalcAvrgMecSpeedUnit+0x9c>
        pHandle->ReliabilityCounter = 0U;
 800a804:	2300      	movs	r3, #0
 800a806:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
}
 800a80a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        bAux = SPD_IsMecSpeedReliable (&pHandle->_Super, pMecSpeedUnit);
 800a80e:	f7ff bda1 	b.w	800a354 <SPD_IsMecSpeedReliable>
        wObsBemf = (int32_t)pHandle->hBemf_alfa_est;
 800a812:	f9b0 5070 	ldrsh.w	r5, [r0, #112]	; 0x70
        wObsBemf = (int32_t)pHandle->hBemf_beta_est;
 800a816:	f9b0 6072 	ldrsh.w	r6, [r0, #114]	; 0x72
        wObsBemfSq = wObsBemf * wObsBemf;
 800a81a:	fb05 fc05 	mul.w	ip, r5, r5
        wEstBemfSq = (wEstBemf * ((int32_t)pHandle->BemfConsistencyGain)) / 64;
 800a81e:	f890 5119 	ldrb.w	r5, [r0, #281]	; 0x119
        wObsBemfSq += wObsBemf * wObsBemf;
 800a822:	fb06 c606 	mla	r6, r6, r6, ip
        wEstBemf = (wAux * 32767) / ((int16_t)pHandle->_Super.hMaxReliableMecSpeedUnit);
 800a826:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800a82a:	f9b0 c014 	ldrsh.w	ip, [r0, #20]
 800a82e:	fb93 f3fc 	sdiv	r3, r3, ip
        wEstBemfSq = (wEstBemf * ((int32_t)pHandle->BemfConsistencyGain)) / 64;
 800a832:	fb03 f505 	mul.w	r5, r3, r5
 800a836:	2d00      	cmp	r5, #0
 800a838:	bfb8      	it	lt
 800a83a:	353f      	addlt	r5, #63	; 0x3f
 800a83c:	11ad      	asrs	r5, r5, #6
        wEstBemfSq *= wEstBemf;
 800a83e:	fb05 f303 	mul.w	r3, r5, r3
        wEstBemfSqLo = wEstBemfSq - ((wEstBemfSq / 64) * ((int32_t)pHandle->BemfConsistencyCheck));
 800a842:	2b00      	cmp	r3, #0
 800a844:	461d      	mov	r5, r3
 800a846:	f890 c118 	ldrb.w	ip, [r0, #280]	; 0x118
 800a84a:	bfb8      	it	lt
 800a84c:	f103 053f 	addlt.w	r5, r3, #63	; 0x3f
 800a850:	11ad      	asrs	r5, r5, #6
 800a852:	fb0c 3515 	mls	r5, ip, r5, r3
        if (wObsBemfSq > wEstBemfSqLo)
 800a856:	42ae      	cmp	r6, r5
 800a858:	bfd4      	ite	le
 800a85a:	2500      	movle	r5, #0
 800a85c:	2501      	movgt	r5, #1
 800a85e:	e7c6      	b.n	800a7ee <STO_PLL_CalcAvrgMecSpeedUnit+0xd2>
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a860:	462a      	mov	r2, r5
 800a862:	462b      	mov	r3, r5
 800a864:	462e      	mov	r6, r5
    int32_t wAvrSpeed_dpp = (int32_t)0;
 800a866:	46ae      	mov	lr, r5
 800a868:	e77d      	b.n	800a766 <STO_PLL_CalcAvrgMecSpeedUnit+0x4a>
 800a86a:	bf00      	nop

0800a86c <STO_PLL_CalcAvrgElSpeedDpp>:
    int16_t hSpeedBufferSizeUnit = (int16_t)pHandle->SpeedBufferSizeUnit;
 800a86c:	f890 110e 	ldrb.w	r1, [r0, #270]	; 0x10e
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 800a870:	f890 310f 	ldrb.w	r3, [r0, #271]	; 0x10f
    int16_t hIndexNew = (int16_t)pHandle->Speed_Buffer_Index;
 800a874:	f890 20f4 	ldrb.w	r2, [r0, #244]	; 0xf4
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 800a878:	1acb      	subs	r3, r1, r3
 800a87a:	b29b      	uxth	r3, r3
{
 800a87c:	b510      	push	{r4, lr}
    int32_t wSum = pHandle->DppBufferSum;
 800a87e:	f8d0 4108 	ldr.w	r4, [r0, #264]	; 0x108
    if (0 == hBufferSizeDiff)
 800a882:	b973      	cbnz	r3, 800a8a2 <STO_PLL_CalcAvrgElSpeedDpp+0x36>
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 800a884:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 800a888:	f9b0 110c 	ldrsh.w	r1, [r0, #268]	; 0x10c
 800a88c:	f9b2 3074 	ldrsh.w	r3, [r2, #116]	; 0x74
 800a890:	4423      	add	r3, r4
 800a892:	1a5b      	subs	r3, r3, r1
  wAvrSpeed_dpp = wSum >> pHandle->SpeedBufferSizeDppLOG;
 800a894:	f8b0 2120 	ldrh.w	r2, [r0, #288]	; 0x120
    pHandle->DppBufferSum = wSum;
 800a898:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  wAvrSpeed_dpp = wSum >> pHandle->SpeedBufferSizeDppLOG;
 800a89c:	4113      	asrs	r3, r2
    pHandle->_Super.hElSpeedDpp = (int16_t)wAvrSpeed_dpp;
 800a89e:	81c3      	strh	r3, [r0, #14]
}
 800a8a0:	bd10      	pop	{r4, pc}
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 800a8a2:	4413      	add	r3, r2
 800a8a4:	fa0f fc83 	sxth.w	ip, r3
      if (hIndexOldTemp >= hSpeedBufferSizeUnit)
 800a8a8:	4561      	cmp	r1, ip
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 800a8aa:	b29b      	uxth	r3, r3
      if (hIndexOldTemp >= hSpeedBufferSizeUnit)
 800a8ac:	dc05      	bgt.n	800a8ba <STO_PLL_CalcAvrgElSpeedDpp+0x4e>
 800a8ae:	fa1f fe81 	uxth.w	lr, r1
        hIndexOld = hIndexOldTemp - hSpeedBufferSizeUnit;
 800a8b2:	eba3 030e 	sub.w	r3, r3, lr
 800a8b6:	fa0f fc83 	sxth.w	ip, r3
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->Speed_Buffer[hIndexOld];
 800a8ba:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 800a8be:	eb00 0c4c 	add.w	ip, r0, ip, lsl #1
 800a8c2:	f9b2 3074 	ldrsh.w	r3, [r2, #116]	; 0x74
 800a8c6:	f9bc 2074 	ldrsh.w	r2, [ip, #116]	; 0x74
 800a8ca:	4423      	add	r3, r4
 800a8cc:	1a9b      	subs	r3, r3, r2
 800a8ce:	e7e1      	b.n	800a894 <STO_PLL_CalcAvrgElSpeedDpp+0x28>

0800a8d0 <STO_PLL_Clear>:
{
 800a8d0:	b510      	push	{r4, lr}
  *
  */
static void STO_InitSpeedBuffer(STO_PLL_Handle_t * pHandle)
{
  uint8_t b_i;
  uint8_t bSpeedBufferSize = pHandle->SpeedBufferSizeUnit;
 800a8d2:	f890 210e 	ldrb.w	r2, [r0, #270]	; 0x10e
    pHandle->Ialfa_est = (int32_t)0;
 800a8d6:	2100      	movs	r1, #0
    pHandle->Ibeta_est = (int32_t)0;
 800a8d8:	e9c0 1118 	strd	r1, r1, [r0, #96]	; 0x60
    pHandle->wBemf_beta_est = (int32_t)0;
 800a8dc:	e9c0 111a 	strd	r1, r1, [r0, #104]	; 0x68
    pHandle->Est_Bemf_Level = (int32_t)0;
 800a8e0:	e9c0 113f 	strd	r1, r1, [r0, #252]	; 0xfc
{
 800a8e4:	4604      	mov	r4, r0
    pHandle->_Super.hElAngle = (int16_t)0;
 800a8e6:	8081      	strh	r1, [r0, #4]
    pHandle->_Super.hElSpeedDpp = (int16_t)0;
 800a8e8:	81c1      	strh	r1, [r0, #14]
    pHandle->ConsistencyCounter = 0u;
 800a8ea:	f8a0 10f6 	strh.w	r1, [r0, #246]	; 0xf6
    pHandle->IsAlgorithmConverged = false;
 800a8ee:	f8a0 10f8 	strh.w	r1, [r0, #248]	; 0xf8
    pHandle->DppBufferSum = (int32_t)0;
 800a8f2:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
    pHandle->ForceConvergency = false;
 800a8f6:	f8a0 1122 	strh.w	r1, [r0, #290]	; 0x122

  /* Init speed buffer */
  for (b_i = 0U; b_i < bSpeedBufferSize; b_i++)
 800a8fa:	b11a      	cbz	r2, 800a904 <STO_PLL_Clear+0x34>
  {
    pHandle->Speed_Buffer[b_i] = (int16_t)0;
 800a8fc:	0052      	lsls	r2, r2, #1
 800a8fe:	3074      	adds	r0, #116	; 0x74
 800a900:	f002 ff04 	bl	800d70c <memset>
  }
  pHandle->Speed_Buffer_Index = 0U;
 800a904:	2100      	movs	r1, #0
 800a906:	f884 10f4 	strb.w	r1, [r4, #244]	; 0xf4
  pHandle->SpeedBufferOldestEl = (int16_t)0;
 800a90a:	f8a4 110c 	strh.w	r1, [r4, #268]	; 0x10c
    PID_SetIntegralTerm(& pHandle->PIRegulator, (int32_t)0);
 800a90e:	f104 0034 	add.w	r0, r4, #52	; 0x34
}
 800a912:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    PID_SetIntegralTerm(& pHandle->PIRegulator, (int32_t)0);
 800a916:	f7fe bc5f 	b.w	80091d8 <PID_SetIntegralTerm>
 800a91a:	bf00      	nop

0800a91c <STO_PLL_Init>:
{
 800a91c:	b510      	push	{r4, lr}
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 800a91e:	f890 1116 	ldrb.w	r1, [r0, #278]	; 0x116
    htempk = (int16_t)(C6_COMP_CONST1 / pHandle->hF2);
 800a922:	4b19      	ldr	r3, [pc, #100]	; (800a988 <STO_PLL_Init+0x6c>)
 800a924:	f9b0 e02e 	ldrsh.w	lr, [r0, #46]	; 0x2e
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 800a928:	f880 10f6 	strb.w	r1, [r0, #246]	; 0xf6
    pHandle->EnableDualCheck = true;
 800a92c:	2201      	movs	r2, #1
    pHandle->F3POW2 = 0U;
 800a92e:	2100      	movs	r1, #0
    htempk = (int16_t)(C6_COMP_CONST1 / pHandle->hF2);
 800a930:	fb93 f3fe 	sdiv	r3, r3, lr
 800a934:	b21b      	sxth	r3, r3
{
 800a936:	4604      	mov	r4, r0
    pHandle->EnableDualCheck = true;
 800a938:	f880 2104 	strb.w	r2, [r0, #260]	; 0x104
    pHandle->F3POW2 = 0U;
 800a93c:	8641      	strh	r1, [r0, #50]	; 0x32
    while (htempk != 0)
 800a93e:	b30b      	cbz	r3, 800a984 <STO_PLL_Init+0x68>
    wAux = ((int32_t)1);
 800a940:	4611      	mov	r1, r2
      htempk /= ((int16_t)2);
 800a942:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    while (htempk != 0)
 800a946:	f102 0c01 	add.w	ip, r2, #1
 800a94a:	105b      	asrs	r3, r3, #1
 800a94c:	4610      	mov	r0, r2
      wAux *= ((int32_t)2);
 800a94e:	ea4f 0141 	mov.w	r1, r1, lsl #1
    while (htempk != 0)
 800a952:	fa1f f28c 	uxth.w	r2, ip
 800a956:	d1f4      	bne.n	800a942 <STO_PLL_Init+0x26>
    pHandle->hF3 = (int16_t)wAux;
 800a958:	b20a      	sxth	r2, r1
 800a95a:	8660      	strh	r0, [r4, #50]	; 0x32
    wAux = ((int32_t)(pHandle->hF2)) * pHandle->hF3;
 800a95c:	fb0e f102 	mul.w	r1, lr, r2
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 800a960:	480a      	ldr	r0, [pc, #40]	; (800a98c <STO_PLL_Init+0x70>)
    pHandle->hF3 = (int16_t)wAux;
 800a962:	8622      	strh	r2, [r4, #48]	; 0x30
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 800a964:	17cb      	asrs	r3, r1, #31
 800a966:	fb80 0101 	smull	r0, r1, r0, r1
 800a96a:	ebc3 2321 	rsb	r3, r3, r1, asr #8
 800a96e:	8563      	strh	r3, [r4, #42]	; 0x2a
    STO_PLL_Clear(pHandle);
 800a970:	4620      	mov	r0, r4
 800a972:	f7ff ffad 	bl	800a8d0 <STO_PLL_Clear>
    PID_HandleInit(&pHandle->PIRegulator);
 800a976:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800a97a:	f7fe fc19 	bl	80091b0 <PID_HandleInit>
    pHandle->_Super.hMecAccelUnitP = 0;
 800a97e:	2300      	movs	r3, #0
 800a980:	8263      	strh	r3, [r4, #18]
}
 800a982:	bd10      	pop	{r4, pc}
 800a984:	4671      	mov	r1, lr
 800a986:	e7eb      	b.n	800a960 <STO_PLL_Init+0x44>
 800a988:	000fea5e 	.word	0x000fea5e
 800a98c:	06488dc5 	.word	0x06488dc5

0800a990 <STO_PLL_GetEstimatedBemf>:
    vaux.alpha = pHandle->hBemf_alfa_est;
    vaux.beta = pHandle->hBemf_beta_est;
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
  return (vaux);
 800a990:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800a992:	2200      	movs	r2, #0
 800a994:	b299      	uxth	r1, r3
 800a996:	f361 020f 	bfi	r2, r1, #0, #16
 800a99a:	0c1b      	lsrs	r3, r3, #16
 800a99c:	f363 421f 	bfi	r2, r3, #16, #16
{
 800a9a0:	b082      	sub	sp, #8
}
 800a9a2:	4610      	mov	r0, r2
 800a9a4:	b002      	add	sp, #8
 800a9a6:	4770      	bx	lr

0800a9a8 <STO_PLL_GetEstimatedCurrent>:
  iaux.alpha = (int16_t)(pHandle->Ialfa_est / pHandle->hF1);
#endif

#ifndef FULL_MISRA_C_COMPLIANCY_STO_PLL
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  iaux.beta = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 800a9a8:	e9d0 2318 	ldrd	r2, r3, [r0, #96]	; 0x60
  iaux.alpha = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a9ac:	f8b0 c11c 	ldrh.w	ip, [r0, #284]	; 0x11c
 800a9b0:	fa42 f20c 	asr.w	r2, r2, ip
  iaux.beta = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
  return (iaux);
 800a9b4:	fa43 f30c 	asr.w	r3, r3, ip
 800a9b8:	b292      	uxth	r2, r2
 800a9ba:	2100      	movs	r1, #0
 800a9bc:	f362 010f 	bfi	r1, r2, #0, #16
 800a9c0:	b29b      	uxth	r3, r3
 800a9c2:	f363 411f 	bfi	r1, r3, #16, #16
{
 800a9c6:	b082      	sub	sp, #8
}
 800a9c8:	4608      	mov	r0, r1
 800a9ca:	b002      	add	sp, #8
 800a9cc:	4770      	bx	lr
 800a9ce:	bf00      	nop

0800a9d0 <STO_PLL_GetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    *phC2 = pHandle->hC2;
 800a9d0:	f9b0 3022 	ldrsh.w	r3, [r0, #34]	; 0x22
 800a9d4:	800b      	strh	r3, [r1, #0]
    *phC4 = pHandle->hC4;
 800a9d6:	f9b0 3026 	ldrsh.w	r3, [r0, #38]	; 0x26
 800a9da:	8013      	strh	r3, [r2, #0]
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
}
 800a9dc:	4770      	bx	lr
 800a9de:	bf00      	nop

0800a9e0 <STO_PLL_SetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hC2 = hhC1;
 800a9e0:	8441      	strh	r1, [r0, #34]	; 0x22
    pHandle->hC4 = hhC2;
 800a9e2:	84c2      	strh	r2, [r0, #38]	; 0x26
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
}
 800a9e4:	4770      	bx	lr
 800a9e6:	bf00      	nop

0800a9e8 <STO_PLL_GetEstimatedBemfLevel>:
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  return ((MC_NULL == pHandle) ? 0 : pHandle->Est_Bemf_Level);
#else
  return (pHandle->Est_Bemf_Level);
#endif
}
 800a9e8:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 800a9ec:	4770      	bx	lr
 800a9ee:	bf00      	nop

0800a9f0 <STO_PLL_GetObservedBemfLevel>:
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  return ((MC_NULL == pHandle) ? 0 : pHandle->Obs_Bemf_Level);
#else
  return (pHandle->Obs_Bemf_Level);
#endif
}
 800a9f0:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 800a9f4:	4770      	bx	lr
 800a9f6:	bf00      	nop

0800a9f8 <VSS_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a9f8:	2300      	movs	r3, #0
    pHandle->hRemainingStep = 0U;
    pHandle->hElAngleAccu = 0;

    pHandle->bTransitionStarted = false;
    pHandle->bTransitionEnded = false;
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800a9fa:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a9fc:	7003      	strb	r3, [r0, #0]
    pHandle->wElSpeedDpp32 = 0;
 800a9fe:	e9c0 3308 	strd	r3, r3, [r0, #32]
    pHandle->_Super.hElAngle = 0;
 800aa02:	6043      	str	r3, [r0, #4]
    pHandle->_Super.hAvrMecSpeedUnit = 0;
 800aa04:	60c3      	str	r3, [r0, #12]
    pHandle->_Super.hMecAccelUnitP = 0;
 800aa06:	8243      	strh	r3, [r0, #18]
    pHandle->hRemainingStep = 0U;
 800aa08:	8503      	strh	r3, [r0, #40]	; 0x28
    pHandle->bTransitionStarted = false;
 800aa0a:	8583      	strh	r3, [r0, #44]	; 0x2c
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800aa0c:	85c2      	strh	r2, [r0, #46]	; 0x2e
    pHandle->hElAngleAccu = 0;
 800aa0e:	6303      	str	r3, [r0, #48]	; 0x30

    pHandle->bCopyObserver = false;
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800aa10:	4770      	bx	lr
 800aa12:	bf00      	nop

0800aa14 <VSS_Init>:
{
 800aa14:	b508      	push	{r3, lr}
  VSS_Clear(pHandle);
 800aa16:	f7ff ffef 	bl	800a9f8 <VSS_Clear>
}
 800aa1a:	bd08      	pop	{r3, pc}

0800aa1c <VSS_SetMecAngle>:
  }
  else
  {
#endif
    pHandle->hElAngleAccu = hMecAngle;
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa1c:	7843      	ldrb	r3, [r0, #1]
    pHandle->hElAngleAccu = hMecAngle;
 800aa1e:	8601      	strh	r1, [r0, #48]	; 0x30
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa20:	fb91 f3f3 	sdiv	r3, r1, r3
    pHandle->_Super.hElAngle = hMecAngle;
 800aa24:	8081      	strh	r1, [r0, #4]
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa26:	80c3      	strh	r3, [r0, #6]
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800aa28:	4770      	bx	lr
 800aa2a:	bf00      	nop

0800aa2c <VSS_SetMecAcceleration>:
    int32_t wMecAccDppP32;
    uint16_t hNbrStep;
    int16_t hCurrentMecSpeedDpp;
    int16_t hFinalMecSpeedDpp;

    if (false == pHandle->bTransitionStarted)
 800aa2c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800aa30:	b99b      	cbnz	r3, 800aa5a <VSS_SetMecAcceleration+0x2e>
{
 800aa32:	b510      	push	{r4, lr}
    {
      if (0U == hDurationms)
 800aa34:	b992      	cbnz	r2, 800aa5c <VSS_SetMecAcceleration+0x30>
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;

        pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)hFinalMecSpeedUnit)
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
                                              / (((int32_t)SPEED_UNIT)
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa36:	8b43      	ldrh	r3, [r0, #26]
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800aa38:	69c4      	ldr	r4, [r0, #28]
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;
 800aa3a:	8181      	strh	r1, [r0, #12]
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa3c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800aa40:	fb04 fc01 	mul.w	ip, r4, r1
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa44:	005b      	lsls	r3, r3, #1
                                              / (((int32_t)SPEED_UNIT)
 800aa46:	fb9c f3f3 	sdiv	r3, ip, r3

        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa4a:	f890 c001 	ldrb.w	ip, [r0, #1]

        pHandle->hRemainingStep = 0U;
 800aa4e:	8502      	strh	r2, [r0, #40]	; 0x28
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa50:	fb1c f303 	smulbb	r3, ip, r3
 800aa54:	81c3      	strh	r3, [r0, #14]

        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa56:	8541      	strh	r1, [r0, #42]	; 0x2a
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800aa58:	bd10      	pop	{r4, pc}
 800aa5a:	4770      	bx	lr
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800aa5c:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 800aa5e:	4c16      	ldr	r4, [pc, #88]	; (800aab8 <VSS_SetMecAcceleration+0x8c>)
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa60:	f9b0 c00e 	ldrsh.w	ip, [r0, #14]
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800aa64:	fb02 f303 	mul.w	r3, r2, r3
 800aa68:	fba4 4303 	umull	r4, r3, r4, r3
 800aa6c:	f3c3 138f 	ubfx	r3, r3, #6, #16
        hNbrStep++;
 800aa70:	3301      	adds	r3, #1
 800aa72:	b29b      	uxth	r3, r3
        pHandle->hRemainingStep = hNbrStep;
 800aa74:	8503      	strh	r3, [r0, #40]	; 0x28
        if (0U == hNbrStep)
 800aa76:	b923      	cbnz	r3, 800aa82 <VSS_SetMecAcceleration+0x56>
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aa78:	ea4f 430c 	mov.w	r3, ip, lsl #16
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa7c:	8541      	strh	r1, [r0, #42]	; 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aa7e:	6243      	str	r3, [r0, #36]	; 0x24
}
 800aa80:	bd10      	pop	{r4, pc}
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa82:	8b42      	ldrh	r2, [r0, #26]
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa84:	7844      	ldrb	r4, [r0, #1]
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa86:	8541      	strh	r1, [r0, #42]	; 0x2a
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa88:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800aa8c:	ea4f 0e42 	mov.w	lr, r2, lsl #1
        hFinalMecSpeedDpp = (int16_t)((((int32_t )hFinalMecSpeedUnit) * ((int32_t)pHandle->_Super.DPPConvFactor))
 800aa90:	69c2      	ldr	r2, [r0, #28]
 800aa92:	fb01 f202 	mul.w	r2, r1, r2
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa96:	fb92 f2fe 	sdiv	r2, r2, lr
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa9a:	fb9c fef4 	sdiv	lr, ip, r4
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800aa9e:	eba2 020e 	sub.w	r2, r2, lr
                         * ((int32_t)65536)) / ((int32_t )hNbrStep);
 800aaa2:	0412      	lsls	r2, r2, #16
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800aaa4:	fb92 f3f3 	sdiv	r3, r2, r3
          pHandle->wElAccDppP32 = wMecAccDppP32 * ((int16_t)pHandle->_Super.bElToMecRatio);
 800aaa8:	fb04 f303 	mul.w	r3, r4, r3
 800aaac:	6203      	str	r3, [r0, #32]
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aaae:	ea4f 430c 	mov.w	r3, ip, lsl #16
 800aab2:	6243      	str	r3, [r0, #36]	; 0x24
    }
 800aab4:	e7e4      	b.n	800aa80 <VSS_SetMecAcceleration+0x54>
 800aab6:	bf00      	nop
 800aab8:	10624dd3 	.word	0x10624dd3

0800aabc <ai_buffer_get_size>:
 800aabc:	b378      	cbz	r0, 800ab1e <ai_buffer_get_size+0x62>
 800aabe:	b410      	push	{r4}
 800aac0:	6803      	ldr	r3, [r0, #0]
 800aac2:	4a17      	ldr	r2, [pc, #92]	; (800ab20 <ai_buffer_get_size+0x64>)
 800aac4:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
 800aac8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800aacc:	4293      	cmp	r3, r2
 800aace:	d01e      	beq.n	800ab0e <ai_buffer_get_size+0x52>
 800aad0:	6984      	ldr	r4, [r0, #24]
 800aad2:	6862      	ldr	r2, [r4, #4]
 800aad4:	7d03      	ldrb	r3, [r0, #20]
 800aad6:	6941      	ldr	r1, [r0, #20]
 800aad8:	f1a3 0301 	sub.w	r3, r3, #1
 800aadc:	fab3 f383 	clz	r3, r3
 800aae0:	095b      	lsrs	r3, r3, #5
 800aae2:	ebb3 2f11 	cmp.w	r3, r1, lsr #8
 800aae6:	f3c1 2017 	ubfx	r0, r1, #8, #24
 800aaea:	da0b      	bge.n	800ab04 <ai_buffer_get_size+0x48>
 800aaec:	2b01      	cmp	r3, #1
 800aaee:	d102      	bne.n	800aaf6 <ai_buffer_get_size+0x3a>
 800aaf0:	2802      	cmp	r0, #2
 800aaf2:	d007      	beq.n	800ab04 <ai_buffer_get_size+0x48>
 800aaf4:	2302      	movs	r3, #2
 800aaf6:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 800aafa:	3301      	adds	r3, #1
 800aafc:	4298      	cmp	r0, r3
 800aafe:	fb01 f202 	mul.w	r2, r1, r2
 800ab02:	d1f3      	bne.n	800aaec <ai_buffer_get_size+0x30>
 800ab04:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
 800ab08:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ab0c:	4770      	bx	lr
 800ab0e:	2900      	cmp	r1, #0
 800ab10:	d0de      	beq.n	800aad0 <ai_buffer_get_size+0x14>
 800ab12:	6984      	ldr	r4, [r0, #24]
 800ab14:	6863      	ldr	r3, [r4, #4]
 800ab16:	331f      	adds	r3, #31
 800ab18:	f023 021f 	bic.w	r2, r3, #31
 800ab1c:	e7da      	b.n	800aad4 <ai_buffer_get_size+0x18>
 800ab1e:	4770      	bx	lr
 800ab20:	000400c0 	.word	0x000400c0

0800ab24 <ai_buffer_array_sane>:
 800ab24:	b138      	cbz	r0, 800ab36 <ai_buffer_array_sane+0x12>
 800ab26:	6843      	ldr	r3, [r0, #4]
 800ab28:	b123      	cbz	r3, 800ab34 <ai_buffer_array_sane+0x10>
 800ab2a:	8840      	ldrh	r0, [r0, #2]
 800ab2c:	3800      	subs	r0, #0
 800ab2e:	bf18      	it	ne
 800ab30:	2001      	movne	r0, #1
 800ab32:	4770      	bx	lr
 800ab34:	4618      	mov	r0, r3
 800ab36:	4770      	bx	lr

0800ab38 <ai_buffer_array_item_set_address>:
 800ab38:	b150      	cbz	r0, 800ab50 <ai_buffer_array_item_set_address+0x18>
 800ab3a:	6843      	ldr	r3, [r0, #4]
 800ab3c:	b14b      	cbz	r3, 800ab52 <ai_buffer_array_item_set_address+0x1a>
 800ab3e:	8840      	ldrh	r0, [r0, #2]
 800ab40:	b900      	cbnz	r0, 800ab44 <ai_buffer_array_item_set_address+0xc>
 800ab42:	4770      	bx	lr
 800ab44:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800ab48:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800ab4c:	2001      	movs	r0, #1
 800ab4e:	604a      	str	r2, [r1, #4]
 800ab50:	4770      	bx	lr
 800ab52:	4618      	mov	r0, r3
 800ab54:	4770      	bx	lr
 800ab56:	bf00      	nop

0800ab58 <_ai_platform_acquire_crc>:
 800ab58:	2001      	movs	r0, #1
 800ab5a:	4770      	bx	lr

0800ab5c <_ai_platform_release_crc>:
 800ab5c:	4770      	bx	lr
 800ab5e:	bf00      	nop

0800ab60 <ai_platform_get_weights_map>:
 800ab60:	2a00      	cmp	r2, #0
 800ab62:	d037      	beq.n	800abd4 <ai_platform_get_weights_map+0x74>
 800ab64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ab66:	4604      	mov	r4, r0
 800ab68:	b1a0      	cbz	r0, 800ab94 <ai_platform_get_weights_map+0x34>
 800ab6a:	460f      	mov	r7, r1
 800ab6c:	b191      	cbz	r1, 800ab94 <ai_platform_get_weights_map+0x34>
 800ab6e:	4b25      	ldr	r3, [pc, #148]	; (800ac04 <ai_platform_get_weights_map+0xa4>)
 800ab70:	6810      	ldr	r0, [r2, #0]
 800ab72:	4298      	cmp	r0, r3
 800ab74:	4615      	mov	r5, r2
 800ab76:	d00f      	beq.n	800ab98 <ai_platform_get_weights_map+0x38>
 800ab78:	6855      	ldr	r5, [r2, #4]
 800ab7a:	b15d      	cbz	r5, 800ab94 <ai_platform_get_weights_map+0x34>
 800ab7c:	682e      	ldr	r6, [r5, #0]
 800ab7e:	429e      	cmp	r6, r3
 800ab80:	d02a      	beq.n	800abd8 <ai_platform_get_weights_map+0x78>
 800ab82:	f1a1 0001 	sub.w	r0, r1, #1
 800ab86:	6025      	str	r5, [r4, #0]
 800ab88:	fab0 f080 	clz	r0, r0
 800ab8c:	0940      	lsrs	r0, r0, #5
 800ab8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab90:	42a7      	cmp	r7, r4
 800ab92:	d034      	beq.n	800abfe <ai_platform_get_weights_map+0x9e>
 800ab94:	2000      	movs	r0, #0
 800ab96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab98:	1d10      	adds	r0, r2, #4
 800ab9a:	f7ff ffc3 	bl	800ab24 <ai_buffer_array_sane>
 800ab9e:	2800      	cmp	r0, #0
 800aba0:	d0f8      	beq.n	800ab94 <ai_platform_get_weights_map+0x34>
 800aba2:	88eb      	ldrh	r3, [r5, #6]
 800aba4:	429f      	cmp	r7, r3
 800aba6:	d1f5      	bne.n	800ab94 <ai_platform_get_weights_map+0x34>
 800aba8:	f04f 0e00 	mov.w	lr, #0
 800abac:	1f23      	subs	r3, r4, #4
 800abae:	4670      	mov	r0, lr
 800abb0:	68aa      	ldr	r2, [r5, #8]
 800abb2:	eb02 0c0e 	add.w	ip, r2, lr
 800abb6:	f10e 0e1c 	add.w	lr, lr, #28
 800abba:	f8dc 4004 	ldr.w	r4, [ip, #4]
 800abbe:	b124      	cbz	r4, 800abca <ai_platform_get_weights_map+0x6a>
 800abc0:	3001      	adds	r0, #1
 800abc2:	4287      	cmp	r7, r0
 800abc4:	f843 4f04 	str.w	r4, [r3, #4]!
 800abc8:	d1f2      	bne.n	800abb0 <ai_platform_get_weights_map+0x50>
 800abca:	1a38      	subs	r0, r7, r0
 800abcc:	fab0 f080 	clz	r0, r0
 800abd0:	0940      	lsrs	r0, r0, #5
 800abd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abd4:	2000      	movs	r0, #0
 800abd6:	4770      	bx	lr
 800abd8:	1f23      	subs	r3, r4, #4
 800abda:	4628      	mov	r0, r5
 800abdc:	2400      	movs	r4, #0
 800abde:	e000      	b.n	800abe2 <ai_platform_get_weights_map+0x82>
 800abe0:	4614      	mov	r4, r2
 800abe2:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800abe6:	42b2      	cmp	r2, r6
 800abe8:	d0d2      	beq.n	800ab90 <ai_platform_get_weights_map+0x30>
 800abea:	f843 2f04 	str.w	r2, [r3, #4]!
 800abee:	1c62      	adds	r2, r4, #1
 800abf0:	4297      	cmp	r7, r2
 800abf2:	d1f5      	bne.n	800abe0 <ai_platform_get_weights_map+0x80>
 800abf4:	3402      	adds	r4, #2
 800abf6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800abfa:	42b3      	cmp	r3, r6
 800abfc:	d1ca      	bne.n	800ab94 <ai_platform_get_weights_map+0x34>
 800abfe:	2001      	movs	r0, #1
 800ac00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac02:	bf00      	nop
 800ac04:	a1facade 	.word	0xa1facade

0800ac08 <ai_platform_get_activations_map>:
 800ac08:	2a00      	cmp	r2, #0
 800ac0a:	d038      	beq.n	800ac7e <ai_platform_get_activations_map+0x76>
 800ac0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ac0e:	4604      	mov	r4, r0
 800ac10:	b1a0      	cbz	r0, 800ac3c <ai_platform_get_activations_map+0x34>
 800ac12:	460f      	mov	r7, r1
 800ac14:	b191      	cbz	r1, 800ac3c <ai_platform_get_activations_map+0x34>
 800ac16:	4b25      	ldr	r3, [pc, #148]	; (800acac <ai_platform_get_activations_map+0xa4>)
 800ac18:	6810      	ldr	r0, [r2, #0]
 800ac1a:	4298      	cmp	r0, r3
 800ac1c:	4615      	mov	r5, r2
 800ac1e:	d00f      	beq.n	800ac40 <ai_platform_get_activations_map+0x38>
 800ac20:	6a15      	ldr	r5, [r2, #32]
 800ac22:	b15d      	cbz	r5, 800ac3c <ai_platform_get_activations_map+0x34>
 800ac24:	682e      	ldr	r6, [r5, #0]
 800ac26:	429e      	cmp	r6, r3
 800ac28:	d02b      	beq.n	800ac82 <ai_platform_get_activations_map+0x7a>
 800ac2a:	f1a1 0001 	sub.w	r0, r1, #1
 800ac2e:	6025      	str	r5, [r4, #0]
 800ac30:	fab0 f080 	clz	r0, r0
 800ac34:	0940      	lsrs	r0, r0, #5
 800ac36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac38:	42a7      	cmp	r7, r4
 800ac3a:	d035      	beq.n	800aca8 <ai_platform_get_activations_map+0xa0>
 800ac3c:	2000      	movs	r0, #0
 800ac3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac40:	f102 000c 	add.w	r0, r2, #12
 800ac44:	f7ff ff6e 	bl	800ab24 <ai_buffer_array_sane>
 800ac48:	2800      	cmp	r0, #0
 800ac4a:	d0f7      	beq.n	800ac3c <ai_platform_get_activations_map+0x34>
 800ac4c:	89eb      	ldrh	r3, [r5, #14]
 800ac4e:	429f      	cmp	r7, r3
 800ac50:	d1f4      	bne.n	800ac3c <ai_platform_get_activations_map+0x34>
 800ac52:	f04f 0e00 	mov.w	lr, #0
 800ac56:	1f23      	subs	r3, r4, #4
 800ac58:	4670      	mov	r0, lr
 800ac5a:	692a      	ldr	r2, [r5, #16]
 800ac5c:	eb02 0c0e 	add.w	ip, r2, lr
 800ac60:	f10e 0e1c 	add.w	lr, lr, #28
 800ac64:	f8dc 4004 	ldr.w	r4, [ip, #4]
 800ac68:	b124      	cbz	r4, 800ac74 <ai_platform_get_activations_map+0x6c>
 800ac6a:	3001      	adds	r0, #1
 800ac6c:	4287      	cmp	r7, r0
 800ac6e:	f843 4f04 	str.w	r4, [r3, #4]!
 800ac72:	d1f2      	bne.n	800ac5a <ai_platform_get_activations_map+0x52>
 800ac74:	1a38      	subs	r0, r7, r0
 800ac76:	fab0 f080 	clz	r0, r0
 800ac7a:	0940      	lsrs	r0, r0, #5
 800ac7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac7e:	2000      	movs	r0, #0
 800ac80:	4770      	bx	lr
 800ac82:	1f23      	subs	r3, r4, #4
 800ac84:	4628      	mov	r0, r5
 800ac86:	2400      	movs	r4, #0
 800ac88:	e000      	b.n	800ac8c <ai_platform_get_activations_map+0x84>
 800ac8a:	4614      	mov	r4, r2
 800ac8c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800ac90:	42b2      	cmp	r2, r6
 800ac92:	d0d1      	beq.n	800ac38 <ai_platform_get_activations_map+0x30>
 800ac94:	f843 2f04 	str.w	r2, [r3, #4]!
 800ac98:	1c62      	adds	r2, r4, #1
 800ac9a:	4297      	cmp	r7, r2
 800ac9c:	d1f5      	bne.n	800ac8a <ai_platform_get_activations_map+0x82>
 800ac9e:	3402      	adds	r4, #2
 800aca0:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800aca4:	42b3      	cmp	r3, r6
 800aca6:	d1c9      	bne.n	800ac3c <ai_platform_get_activations_map+0x34>
 800aca8:	2001      	movs	r0, #1
 800acaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800acac:	a1facade 	.word	0xa1facade

0800acb0 <ai_platform_bind_network_params>:
 800acb0:	b1a0      	cbz	r0, 800acdc <ai_platform_bind_network_params+0x2c>
 800acb2:	b1b1      	cbz	r1, 800ace2 <ai_platform_bind_network_params+0x32>
 800acb4:	b1c2      	cbz	r2, 800ace8 <ai_platform_bind_network_params+0x38>
 800acb6:	b410      	push	{r4}
 800acb8:	4603      	mov	r3, r0
 800acba:	4c0d      	ldr	r4, [pc, #52]	; (800acf0 <ai_platform_bind_network_params+0x40>)
 800acbc:	f843 4b04 	str.w	r4, [r3], #4
 800acc0:	f100 0c0c 	add.w	ip, r0, #12
 800acc4:	c903      	ldmia	r1, {r0, r1}
 800acc6:	e883 0003 	stmia.w	r3, {r0, r1}
 800acca:	e892 0003 	ldmia.w	r2, {r0, r1}
 800acce:	e88c 0003 	stmia.w	ip, {r0, r1}
 800acd2:	2301      	movs	r3, #1
 800acd4:	4618      	mov	r0, r3
 800acd6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800acda:	4770      	bx	lr
 800acdc:	4603      	mov	r3, r0
 800acde:	4618      	mov	r0, r3
 800ace0:	4770      	bx	lr
 800ace2:	460b      	mov	r3, r1
 800ace4:	4618      	mov	r0, r3
 800ace6:	4770      	bx	lr
 800ace8:	4613      	mov	r3, r2
 800acea:	4618      	mov	r0, r3
 800acec:	4770      	bx	lr
 800acee:	bf00      	nop
 800acf0:	a1facade 	.word	0xa1facade

0800acf4 <ai_platform_network_get_error>:
 800acf4:	b510      	push	{r4, lr}
 800acf6:	b1f0      	cbz	r0, 800ad36 <ai_platform_network_get_error+0x42>
 800acf8:	4b2f      	ldr	r3, [pc, #188]	; (800adb8 <ai_platform_network_get_error+0xc4>)
 800acfa:	6802      	ldr	r2, [r0, #0]
 800acfc:	429a      	cmp	r2, r3
 800acfe:	4604      	mov	r4, r0
 800ad00:	d119      	bne.n	800ad36 <ai_platform_network_get_error+0x42>
 800ad02:	f7ff ff29 	bl	800ab58 <_ai_platform_acquire_crc>
 800ad06:	4b2d      	ldr	r3, [pc, #180]	; (800adbc <ai_platform_network_get_error+0xc8>)
 800ad08:	681b      	ldr	r3, [r3, #0]
 800ad0a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800ad0e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800ad12:	d03c      	beq.n	800ad8e <ai_platform_network_get_error+0x9a>
 800ad14:	4a2a      	ldr	r2, [pc, #168]	; (800adc0 <ai_platform_network_get_error+0xcc>)
 800ad16:	2301      	movs	r3, #1
 800ad18:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800ad1c:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800ad20:	2b00      	cmp	r3, #0
 800ad22:	d1fb      	bne.n	800ad1c <ai_platform_network_get_error+0x28>
 800ad24:	4b27      	ldr	r3, [pc, #156]	; (800adc4 <ai_platform_network_get_error+0xd0>)
 800ad26:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ad2a:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ad2e:	4b26      	ldr	r3, [pc, #152]	; (800adc8 <ai_platform_network_get_error+0xd4>)
 800ad30:	429a      	cmp	r2, r3
 800ad32:	d038      	beq.n	800ada6 <ai_platform_network_get_error+0xb2>
 800ad34:	e7fe      	b.n	800ad34 <ai_platform_network_get_error+0x40>
 800ad36:	f7ff ff0f 	bl	800ab58 <_ai_platform_acquire_crc>
 800ad3a:	4b20      	ldr	r3, [pc, #128]	; (800adbc <ai_platform_network_get_error+0xc8>)
 800ad3c:	681b      	ldr	r3, [r3, #0]
 800ad3e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800ad42:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800ad46:	d010      	beq.n	800ad6a <ai_platform_network_get_error+0x76>
 800ad48:	4a1d      	ldr	r2, [pc, #116]	; (800adc0 <ai_platform_network_get_error+0xcc>)
 800ad4a:	2301      	movs	r3, #1
 800ad4c:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800ad50:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800ad54:	2b00      	cmp	r3, #0
 800ad56:	d1fb      	bne.n	800ad50 <ai_platform_network_get_error+0x5c>
 800ad58:	4b1a      	ldr	r3, [pc, #104]	; (800adc4 <ai_platform_network_get_error+0xd0>)
 800ad5a:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ad5e:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ad62:	4b19      	ldr	r3, [pc, #100]	; (800adc8 <ai_platform_network_get_error+0xd4>)
 800ad64:	429a      	cmp	r2, r3
 800ad66:	d00d      	beq.n	800ad84 <ai_platform_network_get_error+0x90>
 800ad68:	e7fe      	b.n	800ad68 <ai_platform_network_get_error+0x74>
 800ad6a:	4a18      	ldr	r2, [pc, #96]	; (800adcc <ai_platform_network_get_error+0xd8>)
 800ad6c:	2301      	movs	r3, #1
 800ad6e:	6093      	str	r3, [r2, #8]
 800ad70:	6893      	ldr	r3, [r2, #8]
 800ad72:	2b00      	cmp	r3, #0
 800ad74:	d1fc      	bne.n	800ad70 <ai_platform_network_get_error+0x7c>
 800ad76:	4b13      	ldr	r3, [pc, #76]	; (800adc4 <ai_platform_network_get_error+0xd0>)
 800ad78:	6013      	str	r3, [r2, #0]
 800ad7a:	6812      	ldr	r2, [r2, #0]
 800ad7c:	4b12      	ldr	r3, [pc, #72]	; (800adc8 <ai_platform_network_get_error+0xd4>)
 800ad7e:	429a      	cmp	r2, r3
 800ad80:	d000      	beq.n	800ad84 <ai_platform_network_get_error+0x90>
 800ad82:	e7fe      	b.n	800ad82 <ai_platform_network_get_error+0x8e>
 800ad84:	f7ff feea 	bl	800ab5c <_ai_platform_release_crc>
 800ad88:	f241 0010 	movw	r0, #4112	; 0x1010
 800ad8c:	bd10      	pop	{r4, pc}
 800ad8e:	4a0f      	ldr	r2, [pc, #60]	; (800adcc <ai_platform_network_get_error+0xd8>)
 800ad90:	2301      	movs	r3, #1
 800ad92:	6093      	str	r3, [r2, #8]
 800ad94:	6893      	ldr	r3, [r2, #8]
 800ad96:	2b00      	cmp	r3, #0
 800ad98:	d1fc      	bne.n	800ad94 <ai_platform_network_get_error+0xa0>
 800ad9a:	4b0a      	ldr	r3, [pc, #40]	; (800adc4 <ai_platform_network_get_error+0xd0>)
 800ad9c:	6013      	str	r3, [r2, #0]
 800ad9e:	6812      	ldr	r2, [r2, #0]
 800ada0:	4b09      	ldr	r3, [pc, #36]	; (800adc8 <ai_platform_network_get_error+0xd4>)
 800ada2:	429a      	cmp	r2, r3
 800ada4:	d107      	bne.n	800adb6 <ai_platform_network_get_error+0xc2>
 800ada6:	f7ff fed9 	bl	800ab5c <_ai_platform_release_crc>
 800adaa:	f104 0010 	add.w	r0, r4, #16
 800adae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800adb2:	f000 be8b 	b.w	800bacc <core_get_error>
 800adb6:	e7fe      	b.n	800adb6 <ai_platform_network_get_error+0xc2>
 800adb8:	a1c00100 	.word	0xa1c00100
 800adbc:	e0042000 	.word	0xe0042000
 800adc0:	58024000 	.word	0x58024000
 800adc4:	f407a5c2 	.word	0xf407a5c2
 800adc8:	b5e8b5cd 	.word	0xb5e8b5cd
 800adcc:	40023000 	.word	0x40023000

0800add0 <ai_platform_network_set_error>:
 800add0:	b110      	cbz	r0, 800add8 <ai_platform_network_set_error+0x8>
 800add2:	3010      	adds	r0, #16
 800add4:	f000 be80 	b.w	800bad8 <core_set_error>
 800add8:	4770      	bx	lr
 800adda:	bf00      	nop

0800addc <ai_platform_inputs_get>:
 800addc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ade0:	b085      	sub	sp, #20
 800ade2:	9102      	str	r1, [sp, #8]
 800ade4:	b1f0      	cbz	r0, 800ae24 <ai_platform_inputs_get+0x48>
 800ade6:	4b62      	ldr	r3, [pc, #392]	; (800af70 <ai_platform_inputs_get+0x194>)
 800ade8:	6802      	ldr	r2, [r0, #0]
 800adea:	429a      	cmp	r2, r3
 800adec:	4607      	mov	r7, r0
 800adee:	d119      	bne.n	800ae24 <ai_platform_inputs_get+0x48>
 800adf0:	f7ff feb2 	bl	800ab58 <_ai_platform_acquire_crc>
 800adf4:	4b5f      	ldr	r3, [pc, #380]	; (800af74 <ai_platform_inputs_get+0x198>)
 800adf6:	681b      	ldr	r3, [r3, #0]
 800adf8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800adfc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800ae00:	d03d      	beq.n	800ae7e <ai_platform_inputs_get+0xa2>
 800ae02:	4a5d      	ldr	r2, [pc, #372]	; (800af78 <ai_platform_inputs_get+0x19c>)
 800ae04:	2301      	movs	r3, #1
 800ae06:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800ae0a:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800ae0e:	2b00      	cmp	r3, #0
 800ae10:	d1fb      	bne.n	800ae0a <ai_platform_inputs_get+0x2e>
 800ae12:	4b5a      	ldr	r3, [pc, #360]	; (800af7c <ai_platform_inputs_get+0x1a0>)
 800ae14:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ae18:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ae1c:	4b58      	ldr	r3, [pc, #352]	; (800af80 <ai_platform_inputs_get+0x1a4>)
 800ae1e:	429a      	cmp	r2, r3
 800ae20:	d039      	beq.n	800ae96 <ai_platform_inputs_get+0xba>
 800ae22:	e7fe      	b.n	800ae22 <ai_platform_inputs_get+0x46>
 800ae24:	f7ff fe98 	bl	800ab58 <_ai_platform_acquire_crc>
 800ae28:	4b52      	ldr	r3, [pc, #328]	; (800af74 <ai_platform_inputs_get+0x198>)
 800ae2a:	681b      	ldr	r3, [r3, #0]
 800ae2c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800ae30:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800ae34:	d010      	beq.n	800ae58 <ai_platform_inputs_get+0x7c>
 800ae36:	4a50      	ldr	r2, [pc, #320]	; (800af78 <ai_platform_inputs_get+0x19c>)
 800ae38:	2301      	movs	r3, #1
 800ae3a:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800ae3e:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800ae42:	2b00      	cmp	r3, #0
 800ae44:	d1fb      	bne.n	800ae3e <ai_platform_inputs_get+0x62>
 800ae46:	4b4d      	ldr	r3, [pc, #308]	; (800af7c <ai_platform_inputs_get+0x1a0>)
 800ae48:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ae4c:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ae50:	4b4b      	ldr	r3, [pc, #300]	; (800af80 <ai_platform_inputs_get+0x1a4>)
 800ae52:	429a      	cmp	r2, r3
 800ae54:	d00d      	beq.n	800ae72 <ai_platform_inputs_get+0x96>
 800ae56:	e7fe      	b.n	800ae56 <ai_platform_inputs_get+0x7a>
 800ae58:	4a4a      	ldr	r2, [pc, #296]	; (800af84 <ai_platform_inputs_get+0x1a8>)
 800ae5a:	2301      	movs	r3, #1
 800ae5c:	6093      	str	r3, [r2, #8]
 800ae5e:	6893      	ldr	r3, [r2, #8]
 800ae60:	2b00      	cmp	r3, #0
 800ae62:	d1fc      	bne.n	800ae5e <ai_platform_inputs_get+0x82>
 800ae64:	4b45      	ldr	r3, [pc, #276]	; (800af7c <ai_platform_inputs_get+0x1a0>)
 800ae66:	6013      	str	r3, [r2, #0]
 800ae68:	6812      	ldr	r2, [r2, #0]
 800ae6a:	4b45      	ldr	r3, [pc, #276]	; (800af80 <ai_platform_inputs_get+0x1a4>)
 800ae6c:	429a      	cmp	r2, r3
 800ae6e:	d000      	beq.n	800ae72 <ai_platform_inputs_get+0x96>
 800ae70:	e7fe      	b.n	800ae70 <ai_platform_inputs_get+0x94>
 800ae72:	f7ff fe73 	bl	800ab5c <_ai_platform_release_crc>
 800ae76:	2000      	movs	r0, #0
 800ae78:	b005      	add	sp, #20
 800ae7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ae7e:	4a41      	ldr	r2, [pc, #260]	; (800af84 <ai_platform_inputs_get+0x1a8>)
 800ae80:	2301      	movs	r3, #1
 800ae82:	6093      	str	r3, [r2, #8]
 800ae84:	6893      	ldr	r3, [r2, #8]
 800ae86:	2b00      	cmp	r3, #0
 800ae88:	d1fc      	bne.n	800ae84 <ai_platform_inputs_get+0xa8>
 800ae8a:	4b3c      	ldr	r3, [pc, #240]	; (800af7c <ai_platform_inputs_get+0x1a0>)
 800ae8c:	6013      	str	r3, [r2, #0]
 800ae8e:	6812      	ldr	r2, [r2, #0]
 800ae90:	4b3b      	ldr	r3, [pc, #236]	; (800af80 <ai_platform_inputs_get+0x1a4>)
 800ae92:	429a      	cmp	r2, r3
 800ae94:	d155      	bne.n	800af42 <ai_platform_inputs_get+0x166>
 800ae96:	f7ff fe61 	bl	800ab5c <_ai_platform_release_crc>
 800ae9a:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800ae9c:	2b00      	cmp	r3, #0
 800ae9e:	d051      	beq.n	800af44 <ai_platform_inputs_get+0x168>
 800aea0:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
 800aea4:	f1ba 0f00 	cmp.w	sl, #0
 800aea8:	d04c      	beq.n	800af44 <ai_platform_inputs_get+0x168>
 800aeaa:	f04f 0b00 	mov.w	fp, #0
 800aeae:	465d      	mov	r5, fp
 800aeb0:	9703      	str	r7, [sp, #12]
 800aeb2:	e016      	b.n	800aee2 <ai_platform_inputs_get+0x106>
 800aeb4:	9901      	ldr	r1, [sp, #4]
 800aeb6:	2301      	movs	r3, #1
 800aeb8:	507b      	str	r3, [r7, r1]
 800aeba:	69b1      	ldr	r1, [r6, #24]
 800aebc:	6849      	ldr	r1, [r1, #4]
 800aebe:	6121      	str	r1, [r4, #16]
 800aec0:	f04f 0301 	mov.w	r3, #1
 800aec4:	7523      	strb	r3, [r4, #20]
 800aec6:	e9c4 c200 	strd	ip, r2, [r4]
 800aeca:	6962      	ldr	r2, [r4, #20]
 800aecc:	60a0      	str	r0, [r4, #8]
 800aece:	2300      	movs	r3, #0
 800aed0:	f369 221f 	bfi	r2, r9, #8, #24
 800aed4:	f8c4 8018 	str.w	r8, [r4, #24]
 800aed8:	60e3      	str	r3, [r4, #12]
 800aeda:	3501      	adds	r5, #1
 800aedc:	f10b 0b1c 	add.w	fp, fp, #28
 800aee0:	6162      	str	r2, [r4, #20]
 800aee2:	f8ba 3000 	ldrh.w	r3, [sl]
 800aee6:	42ab      	cmp	r3, r5
 800aee8:	b2aa      	uxth	r2, r5
 800aeea:	d93a      	bls.n	800af62 <ai_platform_inputs_get+0x186>
 800aeec:	f8da 3004 	ldr.w	r3, [sl, #4]
 800aef0:	00e9      	lsls	r1, r5, #3
 800aef2:	9101      	str	r1, [sp, #4]
 800aef4:	2b00      	cmp	r3, #0
 800aef6:	d034      	beq.n	800af62 <ai_platform_inputs_get+0x186>
 800aef8:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 800aefc:	2e00      	cmp	r6, #0
 800aefe:	d030      	beq.n	800af62 <ai_platform_inputs_get+0x186>
 800af00:	f8da 3008 	ldr.w	r3, [sl, #8]
 800af04:	69b2      	ldr	r2, [r6, #24]
 800af06:	f8d6 800c 	ldr.w	r8, [r6, #12]
 800af0a:	6810      	ldr	r0, [r2, #0]
 800af0c:	e9d3 4701 	ldrd	r4, r7, [r3, #4]
 800af10:	68b3      	ldr	r3, [r6, #8]
 800af12:	f3c3 2917 	ubfx	r9, r3, #8, #24
 800af16:	f001 ffc3 	bl	800cea0 <ai_array_to_buffer_fmt>
 800af1a:	69b1      	ldr	r1, [r6, #24]
 800af1c:	4684      	mov	ip, r0
 800af1e:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 800af22:	688a      	ldr	r2, [r1, #8]
 800af24:	445c      	add	r4, fp
 800af26:	2800      	cmp	r0, #0
 800af28:	d0c8      	beq.n	800aebc <ai_platform_inputs_get+0xe0>
 800af2a:	2100      	movs	r1, #0
 800af2c:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
 800af30:	6831      	ldr	r1, [r6, #0]
 800af32:	6041      	str	r1, [r0, #4]
 800af34:	b111      	cbz	r1, 800af3c <ai_platform_inputs_get+0x160>
 800af36:	8849      	ldrh	r1, [r1, #2]
 800af38:	2900      	cmp	r1, #0
 800af3a:	d1bb      	bne.n	800aeb4 <ai_platform_inputs_get+0xd8>
 800af3c:	69b1      	ldr	r1, [r6, #24]
 800af3e:	2000      	movs	r0, #0
 800af40:	e7bc      	b.n	800aebc <ai_platform_inputs_get+0xe0>
 800af42:	e7fe      	b.n	800af42 <ai_platform_inputs_get+0x166>
 800af44:	2218      	movs	r2, #24
 800af46:	2111      	movs	r1, #17
 800af48:	f107 0010 	add.w	r0, r7, #16
 800af4c:	f000 fdc4 	bl	800bad8 <core_set_error>
 800af50:	2200      	movs	r2, #0
 800af52:	4610      	mov	r0, r2
 800af54:	9b02      	ldr	r3, [sp, #8]
 800af56:	2b00      	cmp	r3, #0
 800af58:	d08e      	beq.n	800ae78 <ai_platform_inputs_get+0x9c>
 800af5a:	801a      	strh	r2, [r3, #0]
 800af5c:	b005      	add	sp, #20
 800af5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800af62:	9f03      	ldr	r7, [sp, #12]
 800af64:	2a00      	cmp	r2, #0
 800af66:	d0ed      	beq.n	800af44 <ai_platform_inputs_get+0x168>
 800af68:	f8da 3008 	ldr.w	r3, [sl, #8]
 800af6c:	6858      	ldr	r0, [r3, #4]
 800af6e:	e7f1      	b.n	800af54 <ai_platform_inputs_get+0x178>
 800af70:	a1c00100 	.word	0xa1c00100
 800af74:	e0042000 	.word	0xe0042000
 800af78:	58024000 	.word	0x58024000
 800af7c:	f407a5c2 	.word	0xf407a5c2
 800af80:	b5e8b5cd 	.word	0xb5e8b5cd
 800af84:	40023000 	.word	0x40023000

0800af88 <ai_platform_outputs_get>:
 800af88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800af8c:	b085      	sub	sp, #20
 800af8e:	9102      	str	r1, [sp, #8]
 800af90:	b1f0      	cbz	r0, 800afd0 <ai_platform_outputs_get+0x48>
 800af92:	4b5f      	ldr	r3, [pc, #380]	; (800b110 <ai_platform_outputs_get+0x188>)
 800af94:	6802      	ldr	r2, [r0, #0]
 800af96:	429a      	cmp	r2, r3
 800af98:	4607      	mov	r7, r0
 800af9a:	d119      	bne.n	800afd0 <ai_platform_outputs_get+0x48>
 800af9c:	f7ff fddc 	bl	800ab58 <_ai_platform_acquire_crc>
 800afa0:	4b5c      	ldr	r3, [pc, #368]	; (800b114 <ai_platform_outputs_get+0x18c>)
 800afa2:	681b      	ldr	r3, [r3, #0]
 800afa4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800afa8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800afac:	d03d      	beq.n	800b02a <ai_platform_outputs_get+0xa2>
 800afae:	4a5a      	ldr	r2, [pc, #360]	; (800b118 <ai_platform_outputs_get+0x190>)
 800afb0:	2301      	movs	r3, #1
 800afb2:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800afb6:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800afba:	2b00      	cmp	r3, #0
 800afbc:	d1fb      	bne.n	800afb6 <ai_platform_outputs_get+0x2e>
 800afbe:	4b57      	ldr	r3, [pc, #348]	; (800b11c <ai_platform_outputs_get+0x194>)
 800afc0:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800afc4:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800afc8:	4b55      	ldr	r3, [pc, #340]	; (800b120 <ai_platform_outputs_get+0x198>)
 800afca:	429a      	cmp	r2, r3
 800afcc:	d039      	beq.n	800b042 <ai_platform_outputs_get+0xba>
 800afce:	e7fe      	b.n	800afce <ai_platform_outputs_get+0x46>
 800afd0:	f7ff fdc2 	bl	800ab58 <_ai_platform_acquire_crc>
 800afd4:	4b4f      	ldr	r3, [pc, #316]	; (800b114 <ai_platform_outputs_get+0x18c>)
 800afd6:	681b      	ldr	r3, [r3, #0]
 800afd8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800afdc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800afe0:	d010      	beq.n	800b004 <ai_platform_outputs_get+0x7c>
 800afe2:	4a4d      	ldr	r2, [pc, #308]	; (800b118 <ai_platform_outputs_get+0x190>)
 800afe4:	2301      	movs	r3, #1
 800afe6:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800afea:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800afee:	2b00      	cmp	r3, #0
 800aff0:	d1fb      	bne.n	800afea <ai_platform_outputs_get+0x62>
 800aff2:	4b4a      	ldr	r3, [pc, #296]	; (800b11c <ai_platform_outputs_get+0x194>)
 800aff4:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800aff8:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800affc:	4b48      	ldr	r3, [pc, #288]	; (800b120 <ai_platform_outputs_get+0x198>)
 800affe:	429a      	cmp	r2, r3
 800b000:	d00d      	beq.n	800b01e <ai_platform_outputs_get+0x96>
 800b002:	e7fe      	b.n	800b002 <ai_platform_outputs_get+0x7a>
 800b004:	4a47      	ldr	r2, [pc, #284]	; (800b124 <ai_platform_outputs_get+0x19c>)
 800b006:	2301      	movs	r3, #1
 800b008:	6093      	str	r3, [r2, #8]
 800b00a:	6893      	ldr	r3, [r2, #8]
 800b00c:	2b00      	cmp	r3, #0
 800b00e:	d1fc      	bne.n	800b00a <ai_platform_outputs_get+0x82>
 800b010:	4b42      	ldr	r3, [pc, #264]	; (800b11c <ai_platform_outputs_get+0x194>)
 800b012:	6013      	str	r3, [r2, #0]
 800b014:	6812      	ldr	r2, [r2, #0]
 800b016:	4b42      	ldr	r3, [pc, #264]	; (800b120 <ai_platform_outputs_get+0x198>)
 800b018:	429a      	cmp	r2, r3
 800b01a:	d000      	beq.n	800b01e <ai_platform_outputs_get+0x96>
 800b01c:	e7fe      	b.n	800b01c <ai_platform_outputs_get+0x94>
 800b01e:	f7ff fd9d 	bl	800ab5c <_ai_platform_release_crc>
 800b022:	2000      	movs	r0, #0
 800b024:	b005      	add	sp, #20
 800b026:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b02a:	4a3e      	ldr	r2, [pc, #248]	; (800b124 <ai_platform_outputs_get+0x19c>)
 800b02c:	2301      	movs	r3, #1
 800b02e:	6093      	str	r3, [r2, #8]
 800b030:	6893      	ldr	r3, [r2, #8]
 800b032:	2b00      	cmp	r3, #0
 800b034:	d1fc      	bne.n	800b030 <ai_platform_outputs_get+0xa8>
 800b036:	4b39      	ldr	r3, [pc, #228]	; (800b11c <ai_platform_outputs_get+0x194>)
 800b038:	6013      	str	r3, [r2, #0]
 800b03a:	6812      	ldr	r2, [r2, #0]
 800b03c:	4b38      	ldr	r3, [pc, #224]	; (800b120 <ai_platform_outputs_get+0x198>)
 800b03e:	429a      	cmp	r2, r3
 800b040:	d150      	bne.n	800b0e4 <ai_platform_outputs_get+0x15c>
 800b042:	f7ff fd8b 	bl	800ab5c <_ai_platform_release_crc>
 800b046:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800b048:	2b01      	cmp	r3, #1
 800b04a:	d958      	bls.n	800b0fe <ai_platform_outputs_get+0x176>
 800b04c:	f04f 0b00 	mov.w	fp, #0
 800b050:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
 800b054:	9703      	str	r7, [sp, #12]
 800b056:	465d      	mov	r5, fp
 800b058:	e016      	b.n	800b088 <ai_platform_outputs_get+0x100>
 800b05a:	9901      	ldr	r1, [sp, #4]
 800b05c:	2301      	movs	r3, #1
 800b05e:	507b      	str	r3, [r7, r1]
 800b060:	69b1      	ldr	r1, [r6, #24]
 800b062:	6849      	ldr	r1, [r1, #4]
 800b064:	6121      	str	r1, [r4, #16]
 800b066:	f04f 0301 	mov.w	r3, #1
 800b06a:	7523      	strb	r3, [r4, #20]
 800b06c:	e9c4 c200 	strd	ip, r2, [r4]
 800b070:	6962      	ldr	r2, [r4, #20]
 800b072:	60a0      	str	r0, [r4, #8]
 800b074:	2300      	movs	r3, #0
 800b076:	f369 221f 	bfi	r2, r9, #8, #24
 800b07a:	f8c4 8018 	str.w	r8, [r4, #24]
 800b07e:	60e3      	str	r3, [r4, #12]
 800b080:	3501      	adds	r5, #1
 800b082:	f10b 0b1c 	add.w	fp, fp, #28
 800b086:	6162      	str	r2, [r4, #20]
 800b088:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 800b08c:	42ab      	cmp	r3, r5
 800b08e:	b2aa      	uxth	r2, r5
 800b090:	d929      	bls.n	800b0e6 <ai_platform_outputs_get+0x15e>
 800b092:	f8da 3010 	ldr.w	r3, [sl, #16]
 800b096:	00e9      	lsls	r1, r5, #3
 800b098:	9101      	str	r1, [sp, #4]
 800b09a:	b323      	cbz	r3, 800b0e6 <ai_platform_outputs_get+0x15e>
 800b09c:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 800b0a0:	b30e      	cbz	r6, 800b0e6 <ai_platform_outputs_get+0x15e>
 800b0a2:	f8da 3014 	ldr.w	r3, [sl, #20]
 800b0a6:	69b2      	ldr	r2, [r6, #24]
 800b0a8:	f8d6 800c 	ldr.w	r8, [r6, #12]
 800b0ac:	6810      	ldr	r0, [r2, #0]
 800b0ae:	e9d3 4701 	ldrd	r4, r7, [r3, #4]
 800b0b2:	68b3      	ldr	r3, [r6, #8]
 800b0b4:	f3c3 2917 	ubfx	r9, r3, #8, #24
 800b0b8:	f001 fef2 	bl	800cea0 <ai_array_to_buffer_fmt>
 800b0bc:	69b1      	ldr	r1, [r6, #24]
 800b0be:	4684      	mov	ip, r0
 800b0c0:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 800b0c4:	688a      	ldr	r2, [r1, #8]
 800b0c6:	445c      	add	r4, fp
 800b0c8:	2800      	cmp	r0, #0
 800b0ca:	d0ca      	beq.n	800b062 <ai_platform_outputs_get+0xda>
 800b0cc:	2100      	movs	r1, #0
 800b0ce:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
 800b0d2:	6831      	ldr	r1, [r6, #0]
 800b0d4:	6041      	str	r1, [r0, #4]
 800b0d6:	b111      	cbz	r1, 800b0de <ai_platform_outputs_get+0x156>
 800b0d8:	8849      	ldrh	r1, [r1, #2]
 800b0da:	2900      	cmp	r1, #0
 800b0dc:	d1bd      	bne.n	800b05a <ai_platform_outputs_get+0xd2>
 800b0de:	69b1      	ldr	r1, [r6, #24]
 800b0e0:	2000      	movs	r0, #0
 800b0e2:	e7be      	b.n	800b062 <ai_platform_outputs_get+0xda>
 800b0e4:	e7fe      	b.n	800b0e4 <ai_platform_outputs_get+0x15c>
 800b0e6:	9f03      	ldr	r7, [sp, #12]
 800b0e8:	b14a      	cbz	r2, 800b0fe <ai_platform_outputs_get+0x176>
 800b0ea:	f8da 3014 	ldr.w	r3, [sl, #20]
 800b0ee:	6858      	ldr	r0, [r3, #4]
 800b0f0:	9b02      	ldr	r3, [sp, #8]
 800b0f2:	2b00      	cmp	r3, #0
 800b0f4:	d096      	beq.n	800b024 <ai_platform_outputs_get+0x9c>
 800b0f6:	801a      	strh	r2, [r3, #0]
 800b0f8:	b005      	add	sp, #20
 800b0fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b0fe:	2218      	movs	r2, #24
 800b100:	2111      	movs	r1, #17
 800b102:	f107 0010 	add.w	r0, r7, #16
 800b106:	f000 fce7 	bl	800bad8 <core_set_error>
 800b10a:	2200      	movs	r2, #0
 800b10c:	4610      	mov	r0, r2
 800b10e:	e7ef      	b.n	800b0f0 <ai_platform_outputs_get+0x168>
 800b110:	a1c00100 	.word	0xa1c00100
 800b114:	e0042000 	.word	0xe0042000
 800b118:	58024000 	.word	0x58024000
 800b11c:	f407a5c2 	.word	0xf407a5c2
 800b120:	b5e8b5cd 	.word	0xb5e8b5cd
 800b124:	40023000 	.word	0x40023000

0800b128 <ai_platform_network_create>:
 800b128:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b12c:	b083      	sub	sp, #12
 800b12e:	4606      	mov	r6, r0
 800b130:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
 800b134:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
 800b138:	4615      	mov	r5, r2
 800b13a:	461f      	mov	r7, r3
 800b13c:	f7ff fd0c 	bl	800ab58 <_ai_platform_acquire_crc>
 800b140:	b188      	cbz	r0, 800b166 <ai_platform_network_create+0x3e>
 800b142:	4a5d      	ldr	r2, [pc, #372]	; (800b2b8 <ai_platform_network_create+0x190>)
 800b144:	6812      	ldr	r2, [r2, #0]
 800b146:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800b14a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800b14e:	4603      	mov	r3, r0
 800b150:	d00e      	beq.n	800b170 <ai_platform_network_create+0x48>
 800b152:	4a5a      	ldr	r2, [pc, #360]	; (800b2bc <ai_platform_network_create+0x194>)
 800b154:	2118      	movs	r1, #24
 800b156:	f8c2 1c08 	str.w	r1, [r2, #3080]	; 0xc08
 800b15a:	f8d2 1c08 	ldr.w	r1, [r2, #3080]	; 0xc08
 800b15e:	2918      	cmp	r1, #24
 800b160:	d018      	beq.n	800b194 <ai_platform_network_create+0x6c>
 800b162:	f7ff fcfb 	bl	800ab5c <_ai_platform_release_crc>
 800b166:	f244 1033 	movw	r0, #16691	; 0x4133
 800b16a:	b003      	add	sp, #12
 800b16c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b170:	4a53      	ldr	r2, [pc, #332]	; (800b2c0 <ai_platform_network_create+0x198>)
 800b172:	2101      	movs	r1, #1
 800b174:	6091      	str	r1, [r2, #8]
 800b176:	2114      	movs	r1, #20
 800b178:	e001      	b.n	800b17e <ai_platform_network_create+0x56>
 800b17a:	3901      	subs	r1, #1
 800b17c:	d002      	beq.n	800b184 <ai_platform_network_create+0x5c>
 800b17e:	6894      	ldr	r4, [r2, #8]
 800b180:	2c00      	cmp	r4, #0
 800b182:	d1fa      	bne.n	800b17a <ai_platform_network_create+0x52>
 800b184:	4a4e      	ldr	r2, [pc, #312]	; (800b2c0 <ai_platform_network_create+0x198>)
 800b186:	6891      	ldr	r1, [r2, #8]
 800b188:	b911      	cbnz	r1, 800b190 <ai_platform_network_create+0x68>
 800b18a:	6812      	ldr	r2, [r2, #0]
 800b18c:	3201      	adds	r2, #1
 800b18e:	d008      	beq.n	800b1a2 <ai_platform_network_create+0x7a>
 800b190:	4618      	mov	r0, r3
 800b192:	e7e6      	b.n	800b162 <ai_platform_network_create+0x3a>
 800b194:	2101      	movs	r1, #1
 800b196:	f8c2 1c08 	str.w	r1, [r2, #3080]	; 0xc08
 800b19a:	f8d2 1c08 	ldr.w	r1, [r2, #3080]	; 0xc08
 800b19e:	2900      	cmp	r1, #0
 800b1a0:	d1fb      	bne.n	800b19a <ai_platform_network_create+0x72>
 800b1a2:	4618      	mov	r0, r3
 800b1a4:	f7ff fcda 	bl	800ab5c <_ai_platform_release_crc>
 800b1a8:	f7ff fcd6 	bl	800ab58 <_ai_platform_acquire_crc>
 800b1ac:	4b42      	ldr	r3, [pc, #264]	; (800b2b8 <ai_platform_network_create+0x190>)
 800b1ae:	681b      	ldr	r3, [r3, #0]
 800b1b0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b1b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b1b8:	d010      	beq.n	800b1dc <ai_platform_network_create+0xb4>
 800b1ba:	4b40      	ldr	r3, [pc, #256]	; (800b2bc <ai_platform_network_create+0x194>)
 800b1bc:	2201      	movs	r2, #1
 800b1be:	f8c3 2c08 	str.w	r2, [r3, #3080]	; 0xc08
 800b1c2:	f8d3 1c08 	ldr.w	r1, [r3, #3080]	; 0xc08
 800b1c6:	2900      	cmp	r1, #0
 800b1c8:	d1fb      	bne.n	800b1c2 <ai_platform_network_create+0x9a>
 800b1ca:	4a3e      	ldr	r2, [pc, #248]	; (800b2c4 <ai_platform_network_create+0x19c>)
 800b1cc:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
 800b1d0:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
 800b1d4:	4b3c      	ldr	r3, [pc, #240]	; (800b2c8 <ai_platform_network_create+0x1a0>)
 800b1d6:	429a      	cmp	r2, r3
 800b1d8:	d00c      	beq.n	800b1f4 <ai_platform_network_create+0xcc>
 800b1da:	e7fe      	b.n	800b1da <ai_platform_network_create+0xb2>
 800b1dc:	4a38      	ldr	r2, [pc, #224]	; (800b2c0 <ai_platform_network_create+0x198>)
 800b1de:	2301      	movs	r3, #1
 800b1e0:	6093      	str	r3, [r2, #8]
 800b1e2:	6893      	ldr	r3, [r2, #8]
 800b1e4:	2b00      	cmp	r3, #0
 800b1e6:	d1fc      	bne.n	800b1e2 <ai_platform_network_create+0xba>
 800b1e8:	4b36      	ldr	r3, [pc, #216]	; (800b2c4 <ai_platform_network_create+0x19c>)
 800b1ea:	6013      	str	r3, [r2, #0]
 800b1ec:	6812      	ldr	r2, [r2, #0]
 800b1ee:	4b36      	ldr	r3, [pc, #216]	; (800b2c8 <ai_platform_network_create+0x1a0>)
 800b1f0:	429a      	cmp	r2, r3
 800b1f2:	d122      	bne.n	800b23a <ai_platform_network_create+0x112>
 800b1f4:	f7ff fcb2 	bl	800ab5c <_ai_platform_release_crc>
 800b1f8:	b38e      	cbz	r6, 800b25e <ai_platform_network_create+0x136>
 800b1fa:	4b34      	ldr	r3, [pc, #208]	; (800b2cc <ai_platform_network_create+0x1a4>)
 800b1fc:	602b      	str	r3, [r5, #0]
 800b1fe:	6035      	str	r5, [r6, #0]
 800b200:	f000 fc62 	bl	800bac8 <core_init>
 800b204:	b1d0      	cbz	r0, 800b23c <ai_platform_network_create+0x114>
 800b206:	f7ff fca7 	bl	800ab58 <_ai_platform_acquire_crc>
 800b20a:	4b2b      	ldr	r3, [pc, #172]	; (800b2b8 <ai_platform_network_create+0x190>)
 800b20c:	681b      	ldr	r3, [r3, #0]
 800b20e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b212:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b216:	d025      	beq.n	800b264 <ai_platform_network_create+0x13c>
 800b218:	4a28      	ldr	r2, [pc, #160]	; (800b2bc <ai_platform_network_create+0x194>)
 800b21a:	2301      	movs	r3, #1
 800b21c:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b220:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b224:	2b00      	cmp	r3, #0
 800b226:	d1fb      	bne.n	800b220 <ai_platform_network_create+0xf8>
 800b228:	4b26      	ldr	r3, [pc, #152]	; (800b2c4 <ai_platform_network_create+0x19c>)
 800b22a:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b22e:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b232:	4b25      	ldr	r3, [pc, #148]	; (800b2c8 <ai_platform_network_create+0x1a0>)
 800b234:	429a      	cmp	r2, r3
 800b236:	d022      	beq.n	800b27e <ai_platform_network_create+0x156>
 800b238:	e7fe      	b.n	800b238 <ai_platform_network_create+0x110>
 800b23a:	e7fe      	b.n	800b23a <ai_platform_network_create+0x112>
 800b23c:	2430      	movs	r4, #48	; 0x30
 800b23e:	2300      	movs	r3, #0
 800b240:	6033      	str	r3, [r6, #0]
 800b242:	2610      	movs	r6, #16
 800b244:	464a      	mov	r2, r9
 800b246:	4641      	mov	r1, r8
 800b248:	4638      	mov	r0, r7
 800b24a:	f001 fecf 	bl	800cfec <ai_version_get>
 800b24e:	4603      	mov	r3, r0
 800b250:	2000      	movs	r0, #0
 800b252:	f364 0007 	bfi	r0, r4, #0, #8
 800b256:	64ab      	str	r3, [r5, #72]	; 0x48
 800b258:	f366 201f 	bfi	r0, r6, #8, #24
 800b25c:	e785      	b.n	800b16a <ai_platform_network_create+0x42>
 800b25e:	f241 0010 	movw	r0, #4112	; 0x1010
 800b262:	e782      	b.n	800b16a <ai_platform_network_create+0x42>
 800b264:	4a16      	ldr	r2, [pc, #88]	; (800b2c0 <ai_platform_network_create+0x198>)
 800b266:	2301      	movs	r3, #1
 800b268:	6093      	str	r3, [r2, #8]
 800b26a:	6893      	ldr	r3, [r2, #8]
 800b26c:	2b00      	cmp	r3, #0
 800b26e:	d1fc      	bne.n	800b26a <ai_platform_network_create+0x142>
 800b270:	4b14      	ldr	r3, [pc, #80]	; (800b2c4 <ai_platform_network_create+0x19c>)
 800b272:	6013      	str	r3, [r2, #0]
 800b274:	6812      	ldr	r2, [r2, #0]
 800b276:	4b14      	ldr	r3, [pc, #80]	; (800b2c8 <ai_platform_network_create+0x1a0>)
 800b278:	429a      	cmp	r2, r3
 800b27a:	d000      	beq.n	800b27e <ai_platform_network_create+0x156>
 800b27c:	e7fe      	b.n	800b27c <ai_platform_network_create+0x154>
 800b27e:	f7ff fc6d 	bl	800ab5c <_ai_platform_release_crc>
 800b282:	2200      	movs	r2, #0
 800b284:	4641      	mov	r1, r8
 800b286:	4638      	mov	r0, r7
 800b288:	f001 feb0 	bl	800cfec <ai_version_get>
 800b28c:	2200      	movs	r2, #0
 800b28e:	4604      	mov	r4, r0
 800b290:	2105      	movs	r1, #5
 800b292:	2001      	movs	r0, #1
 800b294:	f001 feaa 	bl	800cfec <ai_version_get>
 800b298:	4284      	cmp	r4, r0
 800b29a:	d001      	beq.n	800b2a0 <ai_platform_network_create+0x178>
 800b29c:	2401      	movs	r4, #1
 800b29e:	e7ce      	b.n	800b23e <ai_platform_network_create+0x116>
 800b2a0:	4b0b      	ldr	r3, [pc, #44]	; (800b2d0 <ai_platform_network_create+0x1a8>)
 800b2a2:	9301      	str	r3, [sp, #4]
 800b2a4:	a801      	add	r0, sp, #4
 800b2a6:	f000 fc23 	bl	800baf0 <ai_check_custom_types>
 800b2aa:	b110      	cbz	r0, 800b2b2 <ai_platform_network_create+0x18a>
 800b2ac:	2600      	movs	r6, #0
 800b2ae:	4634      	mov	r4, r6
 800b2b0:	e7c8      	b.n	800b244 <ai_platform_network_create+0x11c>
 800b2b2:	2402      	movs	r4, #2
 800b2b4:	e7c3      	b.n	800b23e <ai_platform_network_create+0x116>
 800b2b6:	bf00      	nop
 800b2b8:	e0042000 	.word	0xe0042000
 800b2bc:	58024000 	.word	0x58024000
 800b2c0:	40023000 	.word	0x40023000
 800b2c4:	f407a5c2 	.word	0xf407a5c2
 800b2c8:	b5e8b5cd 	.word	0xb5e8b5cd
 800b2cc:	a1c00100 	.word	0xa1c00100
 800b2d0:	84048403 	.word	0x84048403

0800b2d4 <ai_platform_network_init>:
 800b2d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b2d8:	b1f8      	cbz	r0, 800b31a <ai_platform_network_init+0x46>
 800b2da:	4b6e      	ldr	r3, [pc, #440]	; (800b494 <ai_platform_network_init+0x1c0>)
 800b2dc:	6802      	ldr	r2, [r0, #0]
 800b2de:	429a      	cmp	r2, r3
 800b2e0:	4604      	mov	r4, r0
 800b2e2:	d11a      	bne.n	800b31a <ai_platform_network_init+0x46>
 800b2e4:	460e      	mov	r6, r1
 800b2e6:	f7ff fc37 	bl	800ab58 <_ai_platform_acquire_crc>
 800b2ea:	4b6b      	ldr	r3, [pc, #428]	; (800b498 <ai_platform_network_init+0x1c4>)
 800b2ec:	681b      	ldr	r3, [r3, #0]
 800b2ee:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b2f2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b2f6:	d03d      	beq.n	800b374 <ai_platform_network_init+0xa0>
 800b2f8:	4a68      	ldr	r2, [pc, #416]	; (800b49c <ai_platform_network_init+0x1c8>)
 800b2fa:	2301      	movs	r3, #1
 800b2fc:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b300:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b304:	2b00      	cmp	r3, #0
 800b306:	d1fb      	bne.n	800b300 <ai_platform_network_init+0x2c>
 800b308:	4b65      	ldr	r3, [pc, #404]	; (800b4a0 <ai_platform_network_init+0x1cc>)
 800b30a:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b30e:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b312:	4b64      	ldr	r3, [pc, #400]	; (800b4a4 <ai_platform_network_init+0x1d0>)
 800b314:	429a      	cmp	r2, r3
 800b316:	d039      	beq.n	800b38c <ai_platform_network_init+0xb8>
 800b318:	e7fe      	b.n	800b318 <ai_platform_network_init+0x44>
 800b31a:	f7ff fc1d 	bl	800ab58 <_ai_platform_acquire_crc>
 800b31e:	4b5e      	ldr	r3, [pc, #376]	; (800b498 <ai_platform_network_init+0x1c4>)
 800b320:	681b      	ldr	r3, [r3, #0]
 800b322:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b326:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b32a:	d010      	beq.n	800b34e <ai_platform_network_init+0x7a>
 800b32c:	4a5b      	ldr	r2, [pc, #364]	; (800b49c <ai_platform_network_init+0x1c8>)
 800b32e:	2301      	movs	r3, #1
 800b330:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b334:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b338:	2b00      	cmp	r3, #0
 800b33a:	d1fb      	bne.n	800b334 <ai_platform_network_init+0x60>
 800b33c:	4b58      	ldr	r3, [pc, #352]	; (800b4a0 <ai_platform_network_init+0x1cc>)
 800b33e:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b342:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b346:	4b57      	ldr	r3, [pc, #348]	; (800b4a4 <ai_platform_network_init+0x1d0>)
 800b348:	429a      	cmp	r2, r3
 800b34a:	d00d      	beq.n	800b368 <ai_platform_network_init+0x94>
 800b34c:	e7fe      	b.n	800b34c <ai_platform_network_init+0x78>
 800b34e:	4a56      	ldr	r2, [pc, #344]	; (800b4a8 <ai_platform_network_init+0x1d4>)
 800b350:	2301      	movs	r3, #1
 800b352:	6093      	str	r3, [r2, #8]
 800b354:	6893      	ldr	r3, [r2, #8]
 800b356:	2b00      	cmp	r3, #0
 800b358:	d1fc      	bne.n	800b354 <ai_platform_network_init+0x80>
 800b35a:	4b51      	ldr	r3, [pc, #324]	; (800b4a0 <ai_platform_network_init+0x1cc>)
 800b35c:	6013      	str	r3, [r2, #0]
 800b35e:	6812      	ldr	r2, [r2, #0]
 800b360:	4b50      	ldr	r3, [pc, #320]	; (800b4a4 <ai_platform_network_init+0x1d0>)
 800b362:	429a      	cmp	r2, r3
 800b364:	d000      	beq.n	800b368 <ai_platform_network_init+0x94>
 800b366:	e7fe      	b.n	800b366 <ai_platform_network_init+0x92>
 800b368:	f7ff fbf8 	bl	800ab5c <_ai_platform_release_crc>
 800b36c:	2600      	movs	r6, #0
 800b36e:	4630      	mov	r0, r6
 800b370:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b374:	4a4c      	ldr	r2, [pc, #304]	; (800b4a8 <ai_platform_network_init+0x1d4>)
 800b376:	2301      	movs	r3, #1
 800b378:	6093      	str	r3, [r2, #8]
 800b37a:	6893      	ldr	r3, [r2, #8]
 800b37c:	2b00      	cmp	r3, #0
 800b37e:	d1fc      	bne.n	800b37a <ai_platform_network_init+0xa6>
 800b380:	4b47      	ldr	r3, [pc, #284]	; (800b4a0 <ai_platform_network_init+0x1cc>)
 800b382:	6013      	str	r3, [r2, #0]
 800b384:	6812      	ldr	r2, [r2, #0]
 800b386:	4b47      	ldr	r3, [pc, #284]	; (800b4a4 <ai_platform_network_init+0x1d0>)
 800b388:	429a      	cmp	r2, r3
 800b38a:	d11c      	bne.n	800b3c6 <ai_platform_network_init+0xf2>
 800b38c:	f7ff fbe6 	bl	800ab5c <_ai_platform_release_crc>
 800b390:	2e00      	cmp	r6, #0
 800b392:	d06f      	beq.n	800b474 <ai_platform_network_init+0x1a0>
 800b394:	4b45      	ldr	r3, [pc, #276]	; (800b4ac <ai_platform_network_init+0x1d8>)
 800b396:	6832      	ldr	r2, [r6, #0]
 800b398:	429a      	cmp	r2, r3
 800b39a:	d115      	bne.n	800b3c8 <ai_platform_network_init+0xf4>
 800b39c:	e9d6 2101 	ldrd	r2, r1, [r6, #4]
 800b3a0:	6933      	ldr	r3, [r6, #16]
 800b3a2:	f8b6 e00c 	ldrh.w	lr, [r6, #12]
 800b3a6:	89f7      	ldrh	r7, [r6, #14]
 800b3a8:	62a3      	str	r3, [r4, #40]	; 0x28
 800b3aa:	e9c4 2107 	strd	r2, r1, [r4, #28]
 800b3ae:	2303      	movs	r3, #3
 800b3b0:	84e7      	strh	r7, [r4, #38]	; 0x26
 800b3b2:	f8a4 e024 	strh.w	lr, [r4, #36]	; 0x24
 800b3b6:	60e3      	str	r3, [r4, #12]
 800b3b8:	4620      	mov	r0, r4
 800b3ba:	4626      	mov	r6, r4
 800b3bc:	f000 fbc2 	bl	800bb44 <ai_layers_init_all>
 800b3c0:	4630      	mov	r0, r6
 800b3c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b3c6:	e7fe      	b.n	800b3c6 <ai_platform_network_init+0xf2>
 800b3c8:	2101      	movs	r1, #1
 800b3ca:	4630      	mov	r0, r6
 800b3cc:	4635      	mov	r5, r6
 800b3ce:	6876      	ldr	r6, [r6, #4]
 800b3d0:	f7ff fb74 	bl	800aabc <ai_buffer_get_size>
 800b3d4:	f105 081c 	add.w	r8, r5, #28
 800b3d8:	4681      	mov	r9, r0
 800b3da:	2101      	movs	r1, #1
 800b3dc:	4640      	mov	r0, r8
 800b3de:	6a2f      	ldr	r7, [r5, #32]
 800b3e0:	f7ff fb6c 	bl	800aabc <ai_buffer_get_size>
 800b3e4:	f1b9 0f00 	cmp.w	r9, #0
 800b3e8:	d025      	beq.n	800b436 <ai_platform_network_init+0x162>
 800b3ea:	2201      	movs	r2, #1
 800b3ec:	4696      	mov	lr, r2
 800b3ee:	bb30      	cbnz	r0, 800b43e <ai_platform_network_init+0x16a>
 800b3f0:	4680      	mov	r8, r0
 800b3f2:	4607      	mov	r7, r0
 800b3f4:	b376      	cbz	r6, 800b454 <ai_platform_network_init+0x180>
 800b3f6:	8be3      	ldrh	r3, [r4, #30]
 800b3f8:	4573      	cmp	r3, lr
 800b3fa:	d323      	bcc.n	800b444 <ai_platform_network_init+0x170>
 800b3fc:	b142      	cbz	r2, 800b410 <ai_platform_network_init+0x13c>
 800b3fe:	46ac      	mov	ip, r5
 800b400:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b404:	6a25      	ldr	r5, [r4, #32]
 800b406:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b408:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800b40c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 800b410:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800b412:	f8a4 e01e 	strh.w	lr, [r4, #30]
 800b416:	2600      	movs	r6, #0
 800b418:	42bb      	cmp	r3, r7
 800b41a:	83a6      	strh	r6, [r4, #28]
 800b41c:	d323      	bcc.n	800b466 <ai_platform_network_init+0x192>
 800b41e:	b37f      	cbz	r7, 800b480 <ai_platform_network_init+0x1ac>
 800b420:	46c4      	mov	ip, r8
 800b422:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b426:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800b428:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b42a:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800b42e:	46b6      	mov	lr, r6
 800b430:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 800b434:	e7bb      	b.n	800b3ae <ai_platform_network_init+0xda>
 800b436:	464a      	mov	r2, r9
 800b438:	46ce      	mov	lr, r9
 800b43a:	464d      	mov	r5, r9
 800b43c:	e7d7      	b.n	800b3ee <ai_platform_network_init+0x11a>
 800b43e:	b30f      	cbz	r7, 800b484 <ai_platform_network_init+0x1b0>
 800b440:	2701      	movs	r7, #1
 800b442:	e7d7      	b.n	800b3f4 <ai_platform_network_init+0x120>
 800b444:	2212      	movs	r2, #18
 800b446:	2116      	movs	r1, #22
 800b448:	f104 0010 	add.w	r0, r4, #16
 800b44c:	f000 fb44 	bl	800bad8 <core_set_error>
 800b450:	2600      	movs	r6, #0
 800b452:	e78c      	b.n	800b36e <ai_platform_network_init+0x9a>
 800b454:	f1b9 0f00 	cmp.w	r9, #0
 800b458:	d0cd      	beq.n	800b3f6 <ai_platform_network_init+0x122>
 800b45a:	2110      	movs	r1, #16
 800b45c:	2212      	movs	r2, #18
 800b45e:	1860      	adds	r0, r4, r1
 800b460:	f000 fb3a 	bl	800bad8 <core_set_error>
 800b464:	e783      	b.n	800b36e <ai_platform_network_init+0x9a>
 800b466:	2213      	movs	r2, #19
 800b468:	2116      	movs	r1, #22
 800b46a:	f104 0010 	add.w	r0, r4, #16
 800b46e:	f000 fb33 	bl	800bad8 <core_set_error>
 800b472:	e77c      	b.n	800b36e <ai_platform_network_init+0x9a>
 800b474:	2110      	movs	r1, #16
 800b476:	2211      	movs	r2, #17
 800b478:	1860      	adds	r0, r4, r1
 800b47a:	f000 fb2d 	bl	800bad8 <core_set_error>
 800b47e:	e776      	b.n	800b36e <ai_platform_network_init+0x9a>
 800b480:	46be      	mov	lr, r7
 800b482:	e794      	b.n	800b3ae <ai_platform_network_init+0xda>
 800b484:	2110      	movs	r1, #16
 800b486:	2213      	movs	r2, #19
 800b488:	1860      	adds	r0, r4, r1
 800b48a:	f000 fb25 	bl	800bad8 <core_set_error>
 800b48e:	463e      	mov	r6, r7
 800b490:	e76d      	b.n	800b36e <ai_platform_network_init+0x9a>
 800b492:	bf00      	nop
 800b494:	a1c00100 	.word	0xa1c00100
 800b498:	e0042000 	.word	0xe0042000
 800b49c:	58024000 	.word	0x58024000
 800b4a0:	f407a5c2 	.word	0xf407a5c2
 800b4a4:	b5e8b5cd 	.word	0xb5e8b5cd
 800b4a8:	40023000 	.word	0x40023000
 800b4ac:	a1facade 	.word	0xa1facade

0800b4b0 <ai_platform_network_post_init>:
 800b4b0:	b538      	push	{r3, r4, r5, lr}
 800b4b2:	b1f0      	cbz	r0, 800b4f2 <ai_platform_network_post_init+0x42>
 800b4b4:	4b3c      	ldr	r3, [pc, #240]	; (800b5a8 <ai_platform_network_post_init+0xf8>)
 800b4b6:	6802      	ldr	r2, [r0, #0]
 800b4b8:	429a      	cmp	r2, r3
 800b4ba:	4604      	mov	r4, r0
 800b4bc:	d119      	bne.n	800b4f2 <ai_platform_network_post_init+0x42>
 800b4be:	f7ff fb4b 	bl	800ab58 <_ai_platform_acquire_crc>
 800b4c2:	4b3a      	ldr	r3, [pc, #232]	; (800b5ac <ai_platform_network_post_init+0xfc>)
 800b4c4:	681b      	ldr	r3, [r3, #0]
 800b4c6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b4ca:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b4ce:	d03b      	beq.n	800b548 <ai_platform_network_post_init+0x98>
 800b4d0:	4a37      	ldr	r2, [pc, #220]	; (800b5b0 <ai_platform_network_post_init+0x100>)
 800b4d2:	2301      	movs	r3, #1
 800b4d4:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b4d8:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b4dc:	2b00      	cmp	r3, #0
 800b4de:	d1fb      	bne.n	800b4d8 <ai_platform_network_post_init+0x28>
 800b4e0:	4b34      	ldr	r3, [pc, #208]	; (800b5b4 <ai_platform_network_post_init+0x104>)
 800b4e2:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b4e6:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b4ea:	4b33      	ldr	r3, [pc, #204]	; (800b5b8 <ai_platform_network_post_init+0x108>)
 800b4ec:	429a      	cmp	r2, r3
 800b4ee:	d037      	beq.n	800b560 <ai_platform_network_post_init+0xb0>
 800b4f0:	e7fe      	b.n	800b4f0 <ai_platform_network_post_init+0x40>
 800b4f2:	f7ff fb31 	bl	800ab58 <_ai_platform_acquire_crc>
 800b4f6:	4b2d      	ldr	r3, [pc, #180]	; (800b5ac <ai_platform_network_post_init+0xfc>)
 800b4f8:	681b      	ldr	r3, [r3, #0]
 800b4fa:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b4fe:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b502:	d010      	beq.n	800b526 <ai_platform_network_post_init+0x76>
 800b504:	4a2a      	ldr	r2, [pc, #168]	; (800b5b0 <ai_platform_network_post_init+0x100>)
 800b506:	2301      	movs	r3, #1
 800b508:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b50c:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b510:	2b00      	cmp	r3, #0
 800b512:	d1fb      	bne.n	800b50c <ai_platform_network_post_init+0x5c>
 800b514:	4b27      	ldr	r3, [pc, #156]	; (800b5b4 <ai_platform_network_post_init+0x104>)
 800b516:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b51a:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b51e:	4b26      	ldr	r3, [pc, #152]	; (800b5b8 <ai_platform_network_post_init+0x108>)
 800b520:	429a      	cmp	r2, r3
 800b522:	d00d      	beq.n	800b540 <ai_platform_network_post_init+0x90>
 800b524:	e7fe      	b.n	800b524 <ai_platform_network_post_init+0x74>
 800b526:	4a25      	ldr	r2, [pc, #148]	; (800b5bc <ai_platform_network_post_init+0x10c>)
 800b528:	2301      	movs	r3, #1
 800b52a:	6093      	str	r3, [r2, #8]
 800b52c:	6893      	ldr	r3, [r2, #8]
 800b52e:	2b00      	cmp	r3, #0
 800b530:	d1fc      	bne.n	800b52c <ai_platform_network_post_init+0x7c>
 800b532:	4b20      	ldr	r3, [pc, #128]	; (800b5b4 <ai_platform_network_post_init+0x104>)
 800b534:	6013      	str	r3, [r2, #0]
 800b536:	6812      	ldr	r2, [r2, #0]
 800b538:	4b1f      	ldr	r3, [pc, #124]	; (800b5b8 <ai_platform_network_post_init+0x108>)
 800b53a:	429a      	cmp	r2, r3
 800b53c:	d000      	beq.n	800b540 <ai_platform_network_post_init+0x90>
 800b53e:	e7fe      	b.n	800b53e <ai_platform_network_post_init+0x8e>
 800b540:	f7ff fb0c 	bl	800ab5c <_ai_platform_release_crc>
 800b544:	2000      	movs	r0, #0
 800b546:	bd38      	pop	{r3, r4, r5, pc}
 800b548:	4a1c      	ldr	r2, [pc, #112]	; (800b5bc <ai_platform_network_post_init+0x10c>)
 800b54a:	2301      	movs	r3, #1
 800b54c:	6093      	str	r3, [r2, #8]
 800b54e:	6893      	ldr	r3, [r2, #8]
 800b550:	2b00      	cmp	r3, #0
 800b552:	d1fc      	bne.n	800b54e <ai_platform_network_post_init+0x9e>
 800b554:	4b17      	ldr	r3, [pc, #92]	; (800b5b4 <ai_platform_network_post_init+0x104>)
 800b556:	6013      	str	r3, [r2, #0]
 800b558:	6812      	ldr	r2, [r2, #0]
 800b55a:	4b17      	ldr	r3, [pc, #92]	; (800b5b8 <ai_platform_network_post_init+0x108>)
 800b55c:	429a      	cmp	r2, r3
 800b55e:	d11a      	bne.n	800b596 <ai_platform_network_post_init+0xe6>
 800b560:	f7ff fafc 	bl	800ab5c <_ai_platform_release_crc>
 800b564:	68e3      	ldr	r3, [r4, #12]
 800b566:	f013 0502 	ands.w	r5, r3, #2
 800b56a:	d015      	beq.n	800b598 <ai_platform_network_post_init+0xe8>
 800b56c:	4620      	mov	r0, r4
 800b56e:	f000 faf7 	bl	800bb60 <ai_layers_post_init_all>
 800b572:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b574:	b16b      	cbz	r3, 800b592 <ai_platform_network_post_init+0xe2>
 800b576:	6b65      	ldr	r5, [r4, #52]	; 0x34
 800b578:	e007      	b.n	800b58a <ai_platform_network_post_init+0xda>
 800b57a:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
 800b57e:	4798      	blx	r3
 800b580:	692b      	ldr	r3, [r5, #16]
 800b582:	42ab      	cmp	r3, r5
 800b584:	d005      	beq.n	800b592 <ai_platform_network_post_init+0xe2>
 800b586:	b123      	cbz	r3, 800b592 <ai_platform_network_post_init+0xe2>
 800b588:	461d      	mov	r5, r3
 800b58a:	4629      	mov	r1, r5
 800b58c:	2000      	movs	r0, #0
 800b58e:	2d00      	cmp	r5, #0
 800b590:	d1f3      	bne.n	800b57a <ai_platform_network_post_init+0xca>
 800b592:	2001      	movs	r0, #1
 800b594:	bd38      	pop	{r3, r4, r5, pc}
 800b596:	e7fe      	b.n	800b596 <ai_platform_network_post_init+0xe6>
 800b598:	2210      	movs	r2, #16
 800b59a:	2111      	movs	r1, #17
 800b59c:	18a0      	adds	r0, r4, r2
 800b59e:	f000 fa9b 	bl	800bad8 <core_set_error>
 800b5a2:	4628      	mov	r0, r5
 800b5a4:	bd38      	pop	{r3, r4, r5, pc}
 800b5a6:	bf00      	nop
 800b5a8:	a1c00100 	.word	0xa1c00100
 800b5ac:	e0042000 	.word	0xe0042000
 800b5b0:	58024000 	.word	0x58024000
 800b5b4:	f407a5c2 	.word	0xf407a5c2
 800b5b8:	b5e8b5cd 	.word	0xb5e8b5cd
 800b5bc:	40023000 	.word	0x40023000

0800b5c0 <ai_platform_network_process>:
 800b5c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b5c4:	460e      	mov	r6, r1
 800b5c6:	b085      	sub	sp, #20
 800b5c8:	4693      	mov	fp, r2
 800b5ca:	4605      	mov	r5, r0
 800b5cc:	b120      	cbz	r0, 800b5d8 <ai_platform_network_process+0x18>
 800b5ce:	4bb8      	ldr	r3, [pc, #736]	; (800b8b0 <ai_platform_network_process+0x2f0>)
 800b5d0:	6802      	ldr	r2, [r0, #0]
 800b5d2:	429a      	cmp	r2, r3
 800b5d4:	bf18      	it	ne
 800b5d6:	2500      	movne	r5, #0
 800b5d8:	f7ff fabe 	bl	800ab58 <_ai_platform_acquire_crc>
 800b5dc:	4bb5      	ldr	r3, [pc, #724]	; (800b8b4 <ai_platform_network_process+0x2f4>)
 800b5de:	681b      	ldr	r3, [r3, #0]
 800b5e0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b5e4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b5e8:	d010      	beq.n	800b60c <ai_platform_network_process+0x4c>
 800b5ea:	4ab3      	ldr	r2, [pc, #716]	; (800b8b8 <ai_platform_network_process+0x2f8>)
 800b5ec:	2301      	movs	r3, #1
 800b5ee:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b5f2:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b5f6:	2b00      	cmp	r3, #0
 800b5f8:	d1fb      	bne.n	800b5f2 <ai_platform_network_process+0x32>
 800b5fa:	4bb0      	ldr	r3, [pc, #704]	; (800b8bc <ai_platform_network_process+0x2fc>)
 800b5fc:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b600:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b604:	4bae      	ldr	r3, [pc, #696]	; (800b8c0 <ai_platform_network_process+0x300>)
 800b606:	429a      	cmp	r2, r3
 800b608:	d00d      	beq.n	800b626 <ai_platform_network_process+0x66>
 800b60a:	e7fe      	b.n	800b60a <ai_platform_network_process+0x4a>
 800b60c:	4aad      	ldr	r2, [pc, #692]	; (800b8c4 <ai_platform_network_process+0x304>)
 800b60e:	2301      	movs	r3, #1
 800b610:	6093      	str	r3, [r2, #8]
 800b612:	6893      	ldr	r3, [r2, #8]
 800b614:	2b00      	cmp	r3, #0
 800b616:	d1fc      	bne.n	800b612 <ai_platform_network_process+0x52>
 800b618:	4ba8      	ldr	r3, [pc, #672]	; (800b8bc <ai_platform_network_process+0x2fc>)
 800b61a:	6013      	str	r3, [r2, #0]
 800b61c:	6812      	ldr	r2, [r2, #0]
 800b61e:	4ba8      	ldr	r3, [pc, #672]	; (800b8c0 <ai_platform_network_process+0x300>)
 800b620:	429a      	cmp	r2, r3
 800b622:	f040 812c 	bne.w	800b87e <ai_platform_network_process+0x2be>
 800b626:	f7ff fa99 	bl	800ab5c <_ai_platform_release_crc>
 800b62a:	2d00      	cmp	r5, #0
 800b62c:	f000 8154 	beq.w	800b8d8 <ai_platform_network_process+0x318>
 800b630:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 800b632:	2b00      	cmp	r3, #0
 800b634:	f000 8124 	beq.w	800b880 <ai_platform_network_process+0x2c0>
 800b638:	68eb      	ldr	r3, [r5, #12]
 800b63a:	f8d5 a030 	ldr.w	sl, [r5, #48]	; 0x30
 800b63e:	f003 0303 	and.w	r3, r3, #3
 800b642:	2700      	movs	r7, #0
 800b644:	2b03      	cmp	r3, #3
 800b646:	616f      	str	r7, [r5, #20]
 800b648:	f040 813e 	bne.w	800b8c8 <ai_platform_network_process+0x308>
 800b64c:	2e00      	cmp	r6, #0
 800b64e:	f000 811d 	beq.w	800b88c <ai_platform_network_process+0x2cc>
 800b652:	f1ba 0f00 	cmp.w	sl, #0
 800b656:	f000 8119 	beq.w	800b88c <ai_platform_network_process+0x2cc>
 800b65a:	f8ba 3000 	ldrh.w	r3, [sl]
 800b65e:	2b00      	cmp	r3, #0
 800b660:	f000 8114 	beq.w	800b88c <ai_platform_network_process+0x2cc>
 800b664:	69b3      	ldr	r3, [r6, #24]
 800b666:	f8cd b00c 	str.w	fp, [sp, #12]
 800b66a:	681b      	ldr	r3, [r3, #0]
 800b66c:	e9cd 3501 	strd	r3, r5, [sp, #4]
 800b670:	f8da 3004 	ldr.w	r3, [sl, #4]
 800b674:	2b00      	cmp	r3, #0
 800b676:	d072      	beq.n	800b75e <ai_platform_network_process+0x19e>
 800b678:	f853 4027 	ldr.w	r4, [r3, r7, lsl #2]
 800b67c:	2c00      	cmp	r4, #0
 800b67e:	d06e      	beq.n	800b75e <ai_platform_network_process+0x19e>
 800b680:	f8da 3008 	ldr.w	r3, [sl, #8]
 800b684:	f8d3 9000 	ldr.w	r9, [r3]
 800b688:	eb19 1807 	adds.w	r8, r9, r7, lsl #4
 800b68c:	ea4f 1b07 	mov.w	fp, r7, lsl #4
 800b690:	f000 81de 	beq.w	800ba50 <ai_platform_network_process+0x490>
 800b694:	69a3      	ldr	r3, [r4, #24]
 800b696:	2101      	movs	r1, #1
 800b698:	4630      	mov	r0, r6
 800b69a:	685d      	ldr	r5, [r3, #4]
 800b69c:	f7ff fa0e 	bl	800aabc <ai_buffer_get_size>
 800b6a0:	4285      	cmp	r5, r0
 800b6a2:	f0c0 811b 	bcc.w	800b8dc <ai_platform_network_process+0x31c>
 800b6a6:	68e0      	ldr	r0, [r4, #12]
 800b6a8:	69b1      	ldr	r1, [r6, #24]
 800b6aa:	68c2      	ldr	r2, [r0, #12]
 800b6ac:	68cb      	ldr	r3, [r1, #12]
 800b6ae:	429a      	cmp	r2, r3
 800b6b0:	f040 8114 	bne.w	800b8dc <ai_platform_network_process+0x31c>
 800b6b4:	6882      	ldr	r2, [r0, #8]
 800b6b6:	688b      	ldr	r3, [r1, #8]
 800b6b8:	429a      	cmp	r2, r3
 800b6ba:	f040 810f 	bne.w	800b8dc <ai_platform_network_process+0x31c>
 800b6be:	6842      	ldr	r2, [r0, #4]
 800b6c0:	684b      	ldr	r3, [r1, #4]
 800b6c2:	429a      	cmp	r2, r3
 800b6c4:	f040 810a 	bne.w	800b8dc <ai_platform_network_process+0x31c>
 800b6c8:	69a3      	ldr	r3, [r4, #24]
 800b6ca:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b6ce:	f001 fc7b 	bl	800cfc8 <ai_array_get_data_byte_size>
 800b6d2:	4605      	mov	r5, r0
 800b6d4:	4620      	mov	r0, r4
 800b6d6:	f001 fc8f 	bl	800cff8 <get_tensor_byte_size>
 800b6da:	4285      	cmp	r5, r0
 800b6dc:	f0c0 80fe 	bcc.w	800b8dc <ai_platform_network_process+0x31c>
 800b6e0:	69a3      	ldr	r3, [r4, #24]
 800b6e2:	6818      	ldr	r0, [r3, #0]
 800b6e4:	f001 fbdc 	bl	800cea0 <ai_array_to_buffer_fmt>
 800b6e8:	6833      	ldr	r3, [r6, #0]
 800b6ea:	4058      	eors	r0, r3
 800b6ec:	f030 407e 	bics.w	r0, r0, #4261412864	; 0xfe000000
 800b6f0:	f040 81b9 	bne.w	800ba66 <ai_platform_network_process+0x4a6>
 800b6f4:	6873      	ldr	r3, [r6, #4]
 800b6f6:	2b00      	cmp	r3, #0
 800b6f8:	f000 81ac 	beq.w	800ba54 <ai_platform_network_process+0x494>
 800b6fc:	69b3      	ldr	r3, [r6, #24]
 800b6fe:	681b      	ldr	r3, [r3, #0]
 800b700:	2b00      	cmp	r3, #0
 800b702:	f000 819c 	beq.w	800ba3e <ai_platform_network_process+0x47e>
 800b706:	9a01      	ldr	r2, [sp, #4]
 800b708:	429a      	cmp	r2, r3
 800b70a:	bf38      	it	cc
 800b70c:	461a      	movcc	r2, r3
 800b70e:	4620      	mov	r0, r4
 800b710:	9201      	str	r2, [sp, #4]
 800b712:	f001 fc71 	bl	800cff8 <get_tensor_byte_size>
 800b716:	f8c8 0008 	str.w	r0, [r8, #8]
 800b71a:	69b3      	ldr	r3, [r6, #24]
 800b71c:	681b      	ldr	r3, [r3, #0]
 800b71e:	fb00 f303 	mul.w	r3, r0, r3
 800b722:	f8c8 300c 	str.w	r3, [r8, #12]
 800b726:	6871      	ldr	r1, [r6, #4]
 800b728:	f8c8 1004 	str.w	r1, [r8, #4]
 800b72c:	440b      	add	r3, r1
 800b72e:	f849 300b 	str.w	r3, [r9, fp]
 800b732:	69a0      	ldr	r0, [r4, #24]
 800b734:	6803      	ldr	r3, [r0, #0]
 800b736:	009a      	lsls	r2, r3, #2
 800b738:	f107 0701 	add.w	r7, r7, #1
 800b73c:	f106 061c 	add.w	r6, r6, #28
 800b740:	f100 80af 	bmi.w	800b8a2 <ai_platform_network_process+0x2e2>
 800b744:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 800b748:	1a9b      	subs	r3, r3, r2
 800b74a:	4419      	add	r1, r3
 800b74c:	6081      	str	r1, [r0, #8]
 800b74e:	69a3      	ldr	r3, [r4, #24]
 800b750:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800b754:	60da      	str	r2, [r3, #12]
 800b756:	f8ba 3000 	ldrh.w	r3, [sl]
 800b75a:	42bb      	cmp	r3, r7
 800b75c:	d888      	bhi.n	800b670 <ai_platform_network_process+0xb0>
 800b75e:	e9dd 5b02 	ldrd	r5, fp, [sp, #8]
 800b762:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 800b764:	f1bb 0f00 	cmp.w	fp, #0
 800b768:	f000 8186 	beq.w	800ba78 <ai_platform_network_process+0x4b8>
 800b76c:	2a01      	cmp	r2, #1
 800b76e:	f240 815e 	bls.w	800ba2e <ai_platform_network_process+0x46e>
 800b772:	f8d5 9030 	ldr.w	r9, [r5, #48]	; 0x30
 800b776:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b77a:	2b00      	cmp	r3, #0
 800b77c:	f000 8157 	beq.w	800ba2e <ai_platform_network_process+0x46e>
 800b780:	465e      	mov	r6, fp
 800b782:	2700      	movs	r7, #0
 800b784:	462c      	mov	r4, r5
 800b786:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	f000 80b4 	beq.w	800b8f8 <ai_platform_network_process+0x338>
 800b790:	f853 5027 	ldr.w	r5, [r3, r7, lsl #2]
 800b794:	2d00      	cmp	r5, #0
 800b796:	f000 80af 	beq.w	800b8f8 <ai_platform_network_process+0x338>
 800b79a:	f8d9 3014 	ldr.w	r3, [r9, #20]
 800b79e:	f8d3 8000 	ldr.w	r8, [r3]
 800b7a2:	eb18 1a07 	adds.w	sl, r8, r7, lsl #4
 800b7a6:	ea4f 1b07 	mov.w	fp, r7, lsl #4
 800b7aa:	f000 8171 	beq.w	800ba90 <ai_platform_network_process+0x4d0>
 800b7ae:	69ab      	ldr	r3, [r5, #24]
 800b7b0:	2101      	movs	r1, #1
 800b7b2:	685b      	ldr	r3, [r3, #4]
 800b7b4:	9302      	str	r3, [sp, #8]
 800b7b6:	4630      	mov	r0, r6
 800b7b8:	f7ff f980 	bl	800aabc <ai_buffer_get_size>
 800b7bc:	9b02      	ldr	r3, [sp, #8]
 800b7be:	4283      	cmp	r3, r0
 800b7c0:	f0c0 8134 	bcc.w	800ba2c <ai_platform_network_process+0x46c>
 800b7c4:	68e8      	ldr	r0, [r5, #12]
 800b7c6:	69b1      	ldr	r1, [r6, #24]
 800b7c8:	68c2      	ldr	r2, [r0, #12]
 800b7ca:	68cb      	ldr	r3, [r1, #12]
 800b7cc:	429a      	cmp	r2, r3
 800b7ce:	f040 812d 	bne.w	800ba2c <ai_platform_network_process+0x46c>
 800b7d2:	6882      	ldr	r2, [r0, #8]
 800b7d4:	688b      	ldr	r3, [r1, #8]
 800b7d6:	429a      	cmp	r2, r3
 800b7d8:	f040 8128 	bne.w	800ba2c <ai_platform_network_process+0x46c>
 800b7dc:	6842      	ldr	r2, [r0, #4]
 800b7de:	684b      	ldr	r3, [r1, #4]
 800b7e0:	429a      	cmp	r2, r3
 800b7e2:	f040 8123 	bne.w	800ba2c <ai_platform_network_process+0x46c>
 800b7e6:	69ab      	ldr	r3, [r5, #24]
 800b7e8:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b7ec:	f001 fbec 	bl	800cfc8 <ai_array_get_data_byte_size>
 800b7f0:	9002      	str	r0, [sp, #8]
 800b7f2:	4628      	mov	r0, r5
 800b7f4:	f001 fc00 	bl	800cff8 <get_tensor_byte_size>
 800b7f8:	9b02      	ldr	r3, [sp, #8]
 800b7fa:	4283      	cmp	r3, r0
 800b7fc:	f0c0 8116 	bcc.w	800ba2c <ai_platform_network_process+0x46c>
 800b800:	69ab      	ldr	r3, [r5, #24]
 800b802:	6818      	ldr	r0, [r3, #0]
 800b804:	f001 fb4c 	bl	800cea0 <ai_array_to_buffer_fmt>
 800b808:	6833      	ldr	r3, [r6, #0]
 800b80a:	4058      	eors	r0, r3
 800b80c:	f030 407e 	bics.w	r0, r0, #4261412864	; 0xfe000000
 800b810:	f040 8136 	bne.w	800ba80 <ai_platform_network_process+0x4c0>
 800b814:	6873      	ldr	r3, [r6, #4]
 800b816:	2b00      	cmp	r3, #0
 800b818:	f000 814d 	beq.w	800bab6 <ai_platform_network_process+0x4f6>
 800b81c:	69b3      	ldr	r3, [r6, #24]
 800b81e:	681b      	ldr	r3, [r3, #0]
 800b820:	2b00      	cmp	r3, #0
 800b822:	f000 813f 	beq.w	800baa4 <ai_platform_network_process+0x4e4>
 800b826:	9a01      	ldr	r2, [sp, #4]
 800b828:	429a      	cmp	r2, r3
 800b82a:	bf38      	it	cc
 800b82c:	461a      	movcc	r2, r3
 800b82e:	4628      	mov	r0, r5
 800b830:	9201      	str	r2, [sp, #4]
 800b832:	f001 fbe1 	bl	800cff8 <get_tensor_byte_size>
 800b836:	f8ca 0008 	str.w	r0, [sl, #8]
 800b83a:	69b3      	ldr	r3, [r6, #24]
 800b83c:	681b      	ldr	r3, [r3, #0]
 800b83e:	fb00 f303 	mul.w	r3, r0, r3
 800b842:	f8ca 300c 	str.w	r3, [sl, #12]
 800b846:	6871      	ldr	r1, [r6, #4]
 800b848:	f8ca 1004 	str.w	r1, [sl, #4]
 800b84c:	440b      	add	r3, r1
 800b84e:	f848 300b 	str.w	r3, [r8, fp]
 800b852:	69a8      	ldr	r0, [r5, #24]
 800b854:	6803      	ldr	r3, [r0, #0]
 800b856:	009b      	lsls	r3, r3, #2
 800b858:	f107 0701 	add.w	r7, r7, #1
 800b85c:	f106 061c 	add.w	r6, r6, #28
 800b860:	d445      	bmi.n	800b8ee <ai_platform_network_process+0x32e>
 800b862:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 800b866:	1a9b      	subs	r3, r3, r2
 800b868:	4419      	add	r1, r3
 800b86a:	6081      	str	r1, [r0, #8]
 800b86c:	69ab      	ldr	r3, [r5, #24]
 800b86e:	f8da 2004 	ldr.w	r2, [sl, #4]
 800b872:	60da      	str	r2, [r3, #12]
 800b874:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b878:	429f      	cmp	r7, r3
 800b87a:	d384      	bcc.n	800b786 <ai_platform_network_process+0x1c6>
 800b87c:	e03c      	b.n	800b8f8 <ai_platform_network_process+0x338>
 800b87e:	e7fe      	b.n	800b87e <ai_platform_network_process+0x2be>
 800b880:	68ea      	ldr	r2, [r5, #12]
 800b882:	616b      	str	r3, [r5, #20]
 800b884:	f002 0203 	and.w	r2, r2, #3
 800b888:	2a03      	cmp	r2, #3
 800b88a:	d11d      	bne.n	800b8c8 <ai_platform_network_process+0x308>
 800b88c:	2217      	movs	r2, #23
 800b88e:	2112      	movs	r1, #18
 800b890:	f105 0010 	add.w	r0, r5, #16
 800b894:	f000 f920 	bl	800bad8 <core_set_error>
 800b898:	2400      	movs	r4, #0
 800b89a:	4620      	mov	r0, r4
 800b89c:	b005      	add	sp, #20
 800b89e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b8a2:	f8ba 3000 	ldrh.w	r3, [sl]
 800b8a6:	429f      	cmp	r7, r3
 800b8a8:	f4ff aee2 	bcc.w	800b670 <ai_platform_network_process+0xb0>
 800b8ac:	e757      	b.n	800b75e <ai_platform_network_process+0x19e>
 800b8ae:	bf00      	nop
 800b8b0:	a1c00100 	.word	0xa1c00100
 800b8b4:	e0042000 	.word	0xe0042000
 800b8b8:	58024000 	.word	0x58024000
 800b8bc:	f407a5c2 	.word	0xf407a5c2
 800b8c0:	b5e8b5cd 	.word	0xb5e8b5cd
 800b8c4:	40023000 	.word	0x40023000
 800b8c8:	2230      	movs	r2, #48	; 0x30
 800b8ca:	2111      	movs	r1, #17
 800b8cc:	f105 0010 	add.w	r0, r5, #16
 800b8d0:	f000 f902 	bl	800bad8 <core_set_error>
 800b8d4:	2400      	movs	r4, #0
 800b8d6:	e7e0      	b.n	800b89a <ai_platform_network_process+0x2da>
 800b8d8:	462c      	mov	r4, r5
 800b8da:	e7de      	b.n	800b89a <ai_platform_network_process+0x2da>
 800b8dc:	9d02      	ldr	r5, [sp, #8]
 800b8de:	2218      	movs	r2, #24
 800b8e0:	2112      	movs	r1, #18
 800b8e2:	f105 0010 	add.w	r0, r5, #16
 800b8e6:	f000 f8f7 	bl	800bad8 <core_set_error>
 800b8ea:	2400      	movs	r4, #0
 800b8ec:	e7d5      	b.n	800b89a <ai_platform_network_process+0x2da>
 800b8ee:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b8f2:	429f      	cmp	r7, r3
 800b8f4:	f4ff af47 	bcc.w	800b786 <ai_platform_network_process+0x1c6>
 800b8f8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800b8fc:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800b8fe:	82a3      	strh	r3, [r4, #20]
 800b900:	4625      	mov	r5, r4
 800b902:	2a00      	cmp	r2, #0
 800b904:	f040 808c 	bne.w	800ba20 <ai_platform_network_process+0x460>
 800b908:	4616      	mov	r6, r2
 800b90a:	4617      	mov	r7, r2
 800b90c:	8aec      	ldrh	r4, [r5, #22]
 800b90e:	429c      	cmp	r4, r3
 800b910:	bf38      	it	cc
 800b912:	46ab      	movcc	fp, r5
 800b914:	d2c1      	bcs.n	800b89a <ai_platform_network_process+0x2da>
 800b916:	2e00      	cmp	r6, #0
 800b918:	d030      	beq.n	800b97c <ai_platform_network_process+0x3bc>
 800b91a:	f04f 0800 	mov.w	r8, #0
 800b91e:	e014      	b.n	800b94a <ai_platform_network_process+0x38a>
 800b920:	6882      	ldr	r2, [r0, #8]
 800b922:	68c5      	ldr	r5, [r0, #12]
 800b924:	6863      	ldr	r3, [r4, #4]
 800b926:	1b52      	subs	r2, r2, r5
 800b928:	4413      	add	r3, r2
 800b92a:	6083      	str	r3, [r0, #8]
 800b92c:	698b      	ldr	r3, [r1, #24]
 800b92e:	6862      	ldr	r2, [r4, #4]
 800b930:	60da      	str	r2, [r3, #12]
 800b932:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 800b936:	f859 200a 	ldr.w	r2, [r9, sl]
 800b93a:	440b      	add	r3, r1
 800b93c:	4293      	cmp	r3, r2
 800b93e:	bf24      	itt	cs
 800b940:	68e3      	ldrcs	r3, [r4, #12]
 800b942:	1ad3      	subcs	r3, r2, r3
 800b944:	6063      	str	r3, [r4, #4]
 800b946:	f108 0801 	add.w	r8, r8, #1
 800b94a:	8833      	ldrh	r3, [r6, #0]
 800b94c:	4543      	cmp	r3, r8
 800b94e:	ea4f 1a08 	mov.w	sl, r8, lsl #4
 800b952:	d913      	bls.n	800b97c <ai_platform_network_process+0x3bc>
 800b954:	6873      	ldr	r3, [r6, #4]
 800b956:	b18b      	cbz	r3, 800b97c <ai_platform_network_process+0x3bc>
 800b958:	f853 1028 	ldr.w	r1, [r3, r8, lsl #2]
 800b95c:	b171      	cbz	r1, 800b97c <ai_platform_network_process+0x3bc>
 800b95e:	6988      	ldr	r0, [r1, #24]
 800b960:	68b2      	ldr	r2, [r6, #8]
 800b962:	6803      	ldr	r3, [r0, #0]
 800b964:	f8d2 9000 	ldr.w	r9, [r2]
 800b968:	009d      	lsls	r5, r3, #2
 800b96a:	eb09 1408 	add.w	r4, r9, r8, lsl #4
 800b96e:	d5d7      	bpl.n	800b920 <ai_platform_network_process+0x360>
 800b970:	6881      	ldr	r1, [r0, #8]
 800b972:	68a2      	ldr	r2, [r4, #8]
 800b974:	6860      	ldr	r0, [r4, #4]
 800b976:	f001 f9a5 	bl	800ccc4 <st_int8_copy>
 800b97a:	e7da      	b.n	800b932 <ai_platform_network_process+0x372>
 800b97c:	4658      	mov	r0, fp
 800b97e:	f000 f903 	bl	800bb88 <ai_layers_forward_all>
 800b982:	2f00      	cmp	r7, #0
 800b984:	d03d      	beq.n	800ba02 <ai_platform_network_process+0x442>
 800b986:	2400      	movs	r4, #0
 800b988:	e016      	b.n	800b9b8 <ai_platform_network_process+0x3f8>
 800b98a:	e9d8 3201 	ldrd	r3, r2, [r8, #4]
 800b98e:	f859 100a 	ldr.w	r1, [r9, sl]
 800b992:	4413      	add	r3, r2
 800b994:	428b      	cmp	r3, r1
 800b996:	bf24      	itt	cs
 800b998:	f8d8 300c 	ldrcs.w	r3, [r8, #12]
 800b99c:	1acb      	subcs	r3, r1, r3
 800b99e:	f8c8 3004 	str.w	r3, [r8, #4]
 800b9a2:	6981      	ldr	r1, [r0, #24]
 800b9a4:	e9d1 2502 	ldrd	r2, r5, [r1, #8]
 800b9a8:	1b52      	subs	r2, r2, r5
 800b9aa:	4413      	add	r3, r2
 800b9ac:	608b      	str	r3, [r1, #8]
 800b9ae:	6983      	ldr	r3, [r0, #24]
 800b9b0:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800b9b4:	60da      	str	r2, [r3, #12]
 800b9b6:	3401      	adds	r4, #1
 800b9b8:	883b      	ldrh	r3, [r7, #0]
 800b9ba:	42a3      	cmp	r3, r4
 800b9bc:	d921      	bls.n	800ba02 <ai_platform_network_process+0x442>
 800b9be:	687b      	ldr	r3, [r7, #4]
 800b9c0:	b1fb      	cbz	r3, 800ba02 <ai_platform_network_process+0x442>
 800b9c2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800b9c6:	b1e0      	cbz	r0, 800ba02 <ai_platform_network_process+0x442>
 800b9c8:	68ba      	ldr	r2, [r7, #8]
 800b9ca:	6983      	ldr	r3, [r0, #24]
 800b9cc:	f8d2 9000 	ldr.w	r9, [r2]
 800b9d0:	681a      	ldr	r2, [r3, #0]
 800b9d2:	0092      	lsls	r2, r2, #2
 800b9d4:	ea4f 1a04 	mov.w	sl, r4, lsl #4
 800b9d8:	eb09 1804 	add.w	r8, r9, r4, lsl #4
 800b9dc:	d5d5      	bpl.n	800b98a <ai_platform_network_process+0x3ca>
 800b9de:	e9d8 1201 	ldrd	r1, r2, [r8, #4]
 800b9e2:	6898      	ldr	r0, [r3, #8]
 800b9e4:	f001 f96e 	bl	800ccc4 <st_int8_copy>
 800b9e8:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 800b9ec:	f859 200a 	ldr.w	r2, [r9, sl]
 800b9f0:	440b      	add	r3, r1
 800b9f2:	4293      	cmp	r3, r2
 800b9f4:	bf24      	itt	cs
 800b9f6:	f8d8 300c 	ldrcs.w	r3, [r8, #12]
 800b9fa:	1ad3      	subcs	r3, r2, r3
 800b9fc:	f8c8 3004 	str.w	r3, [r8, #4]
 800ba00:	e7d9      	b.n	800b9b6 <ai_platform_network_process+0x3f6>
 800ba02:	f8bb 4016 	ldrh.w	r4, [fp, #22]
 800ba06:	f8bb 3014 	ldrh.w	r3, [fp, #20]
 800ba0a:	3401      	adds	r4, #1
 800ba0c:	b2a4      	uxth	r4, r4
 800ba0e:	42a3      	cmp	r3, r4
 800ba10:	f8ab 4016 	strh.w	r4, [fp, #22]
 800ba14:	f63f af7f 	bhi.w	800b916 <ai_platform_network_process+0x356>
 800ba18:	4620      	mov	r0, r4
 800ba1a:	b005      	add	sp, #20
 800ba1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ba20:	2a01      	cmp	r2, #1
 800ba22:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800ba24:	d03c      	beq.n	800baa0 <ai_platform_network_process+0x4e0>
 800ba26:	f106 070c 	add.w	r7, r6, #12
 800ba2a:	e76f      	b.n	800b90c <ai_platform_network_process+0x34c>
 800ba2c:	4625      	mov	r5, r4
 800ba2e:	2218      	movs	r2, #24
 800ba30:	2113      	movs	r1, #19
 800ba32:	f105 0010 	add.w	r0, r5, #16
 800ba36:	f000 f84f 	bl	800bad8 <core_set_error>
 800ba3a:	2400      	movs	r4, #0
 800ba3c:	e72d      	b.n	800b89a <ai_platform_network_process+0x2da>
 800ba3e:	9d02      	ldr	r5, [sp, #8]
 800ba40:	4604      	mov	r4, r0
 800ba42:	2221      	movs	r2, #33	; 0x21
 800ba44:	2112      	movs	r1, #18
 800ba46:	f105 0010 	add.w	r0, r5, #16
 800ba4a:	f000 f845 	bl	800bad8 <core_set_error>
 800ba4e:	e724      	b.n	800b89a <ai_platform_network_process+0x2da>
 800ba50:	9d02      	ldr	r5, [sp, #8]
 800ba52:	e71b      	b.n	800b88c <ai_platform_network_process+0x2cc>
 800ba54:	9d02      	ldr	r5, [sp, #8]
 800ba56:	4604      	mov	r4, r0
 800ba58:	2217      	movs	r2, #23
 800ba5a:	2112      	movs	r1, #18
 800ba5c:	f105 0010 	add.w	r0, r5, #16
 800ba60:	f000 f83a 	bl	800bad8 <core_set_error>
 800ba64:	e719      	b.n	800b89a <ai_platform_network_process+0x2da>
 800ba66:	9d02      	ldr	r5, [sp, #8]
 800ba68:	2219      	movs	r2, #25
 800ba6a:	2112      	movs	r1, #18
 800ba6c:	f105 0010 	add.w	r0, r5, #16
 800ba70:	f000 f832 	bl	800bad8 <core_set_error>
 800ba74:	2400      	movs	r4, #0
 800ba76:	e710      	b.n	800b89a <ai_platform_network_process+0x2da>
 800ba78:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800ba7c:	82ab      	strh	r3, [r5, #20]
 800ba7e:	e740      	b.n	800b902 <ai_platform_network_process+0x342>
 800ba80:	f104 0010 	add.w	r0, r4, #16
 800ba84:	2219      	movs	r2, #25
 800ba86:	2113      	movs	r1, #19
 800ba88:	f000 f826 	bl	800bad8 <core_set_error>
 800ba8c:	2400      	movs	r4, #0
 800ba8e:	e704      	b.n	800b89a <ai_platform_network_process+0x2da>
 800ba90:	f104 0010 	add.w	r0, r4, #16
 800ba94:	2217      	movs	r2, #23
 800ba96:	2113      	movs	r1, #19
 800ba98:	f000 f81e 	bl	800bad8 <core_set_error>
 800ba9c:	4654      	mov	r4, sl
 800ba9e:	e6fc      	b.n	800b89a <ai_platform_network_process+0x2da>
 800baa0:	2700      	movs	r7, #0
 800baa2:	e733      	b.n	800b90c <ai_platform_network_process+0x34c>
 800baa4:	4625      	mov	r5, r4
 800baa6:	2221      	movs	r2, #33	; 0x21
 800baa8:	4604      	mov	r4, r0
 800baaa:	2113      	movs	r1, #19
 800baac:	f105 0010 	add.w	r0, r5, #16
 800bab0:	f000 f812 	bl	800bad8 <core_set_error>
 800bab4:	e6f1      	b.n	800b89a <ai_platform_network_process+0x2da>
 800bab6:	4625      	mov	r5, r4
 800bab8:	2217      	movs	r2, #23
 800baba:	4604      	mov	r4, r0
 800babc:	2113      	movs	r1, #19
 800babe:	f105 0010 	add.w	r0, r5, #16
 800bac2:	f000 f809 	bl	800bad8 <core_set_error>
 800bac6:	e6e8      	b.n	800b89a <ai_platform_network_process+0x2da>

0800bac8 <core_init>:
 800bac8:	2001      	movs	r0, #1
 800baca:	4770      	bx	lr

0800bacc <core_get_error>:
 800bacc:	4603      	mov	r3, r0
 800bace:	2200      	movs	r2, #0
 800bad0:	6800      	ldr	r0, [r0, #0]
 800bad2:	601a      	str	r2, [r3, #0]
 800bad4:	4770      	bx	lr
 800bad6:	bf00      	nop

0800bad8 <core_set_error>:
 800bad8:	4603      	mov	r3, r0
 800bada:	7800      	ldrb	r0, [r0, #0]
 800badc:	b108      	cbz	r0, 800bae2 <core_set_error+0xa>
 800bade:	2000      	movs	r0, #0
 800bae0:	4770      	bx	lr
 800bae2:	7019      	strb	r1, [r3, #0]
 800bae4:	6819      	ldr	r1, [r3, #0]
 800bae6:	f362 211f 	bfi	r1, r2, #8, #24
 800baea:	2001      	movs	r0, #1
 800baec:	6019      	str	r1, [r3, #0]
 800baee:	4770      	bx	lr

0800baf0 <ai_check_custom_types>:
 800baf0:	b082      	sub	sp, #8
 800baf2:	4b13      	ldr	r3, [pc, #76]	; (800bb40 <ai_check_custom_types+0x50>)
 800baf4:	9301      	str	r3, [sp, #4]
 800baf6:	b118      	cbz	r0, 800bb00 <ai_check_custom_types+0x10>
 800baf8:	7803      	ldrb	r3, [r0, #0]
 800bafa:	2b03      	cmp	r3, #3
 800bafc:	d002      	beq.n	800bb04 <ai_check_custom_types+0x14>
 800bafe:	2000      	movs	r0, #0
 800bb00:	b002      	add	sp, #8
 800bb02:	4770      	bx	lr
 800bb04:	f89d 2004 	ldrb.w	r2, [sp, #4]
 800bb08:	4293      	cmp	r3, r2
 800bb0a:	d004      	beq.n	800bb16 <ai_check_custom_types+0x26>
 800bb0c:	2001      	movs	r0, #1
 800bb0e:	f080 0001 	eor.w	r0, r0, #1
 800bb12:	b002      	add	sp, #8
 800bb14:	4770      	bx	lr
 800bb16:	7842      	ldrb	r2, [r0, #1]
 800bb18:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800bb1c:	429a      	cmp	r2, r3
 800bb1e:	f100 0001 	add.w	r0, r0, #1
 800bb22:	d1f3      	bne.n	800bb0c <ai_check_custom_types+0x1c>
 800bb24:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 800bb28:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800bb2c:	429a      	cmp	r2, r3
 800bb2e:	d1ed      	bne.n	800bb0c <ai_check_custom_types+0x1c>
 800bb30:	7842      	ldrb	r2, [r0, #1]
 800bb32:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800bb36:	429a      	cmp	r2, r3
 800bb38:	d1e8      	bne.n	800bb0c <ai_check_custom_types+0x1c>
 800bb3a:	2000      	movs	r0, #0
 800bb3c:	e7e7      	b.n	800bb0e <ai_check_custom_types+0x1e>
 800bb3e:	bf00      	nop
 800bb40:	84048403 	.word	0x84048403

0800bb44 <ai_layers_init_all>:
 800bb44:	4601      	mov	r1, r0
 800bb46:	2000      	movs	r0, #0
 800bb48:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800bb4a:	b143      	cbz	r3, 800bb5e <ai_layers_init_all+0x1a>
 800bb4c:	691a      	ldr	r2, [r3, #16]
 800bb4e:	60d9      	str	r1, [r3, #12]
 800bb50:	429a      	cmp	r2, r3
 800bb52:	f100 0001 	add.w	r0, r0, #1
 800bb56:	d002      	beq.n	800bb5e <ai_layers_init_all+0x1a>
 800bb58:	b10a      	cbz	r2, 800bb5e <ai_layers_init_all+0x1a>
 800bb5a:	4613      	mov	r3, r2
 800bb5c:	e7f5      	b.n	800bb4a <ai_layers_init_all+0x6>
 800bb5e:	4770      	bx	lr

0800bb60 <ai_layers_post_init_all>:
 800bb60:	b538      	push	{r3, r4, r5, lr}
 800bb62:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800bb64:	2500      	movs	r5, #0
 800bb66:	b16c      	cbz	r4, 800bb84 <ai_layers_post_init_all+0x24>
 800bb68:	6863      	ldr	r3, [r4, #4]
 800bb6a:	07db      	lsls	r3, r3, #31
 800bb6c:	d504      	bpl.n	800bb78 <ai_layers_post_init_all+0x18>
 800bb6e:	6a23      	ldr	r3, [r4, #32]
 800bb70:	4620      	mov	r0, r4
 800bb72:	b10b      	cbz	r3, 800bb78 <ai_layers_post_init_all+0x18>
 800bb74:	4798      	blx	r3
 800bb76:	3501      	adds	r5, #1
 800bb78:	6923      	ldr	r3, [r4, #16]
 800bb7a:	42a3      	cmp	r3, r4
 800bb7c:	d002      	beq.n	800bb84 <ai_layers_post_init_all+0x24>
 800bb7e:	b10b      	cbz	r3, 800bb84 <ai_layers_post_init_all+0x24>
 800bb80:	461c      	mov	r4, r3
 800bb82:	e7f0      	b.n	800bb66 <ai_layers_post_init_all+0x6>
 800bb84:	4628      	mov	r0, r5
 800bb86:	bd38      	pop	{r3, r4, r5, pc}

0800bb88 <ai_layers_forward_all>:
 800bb88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bb8c:	f8d0 803c 	ldr.w	r8, [r0, #60]	; 0x3c
 800bb90:	4604      	mov	r4, r0
 800bb92:	f1b8 0f00 	cmp.w	r8, #0
 800bb96:	d02b      	beq.n	800bbf0 <ai_layers_forward_all+0x68>
 800bb98:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800bb9a:	6381      	str	r1, [r0, #56]	; 0x38
 800bb9c:	b321      	cbz	r1, 800bbe8 <ai_layers_forward_all+0x60>
 800bb9e:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800bba0:	2001      	movs	r0, #1
 800bba2:	47c0      	blx	r8
 800bba4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800bba6:	b1fe      	cbz	r6, 800bbe8 <ai_layers_forward_all+0x60>
 800bba8:	2700      	movs	r7, #0
 800bbaa:	4631      	mov	r1, r6
 800bbac:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800bbae:	2002      	movs	r0, #2
 800bbb0:	47c0      	blx	r8
 800bbb2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 800bbb4:	4628      	mov	r0, r5
 800bbb6:	696b      	ldr	r3, [r5, #20]
 800bbb8:	4798      	blx	r3
 800bbba:	692e      	ldr	r6, [r5, #16]
 800bbbc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800bbbe:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800bbc0:	42b5      	cmp	r5, r6
 800bbc2:	f04f 0003 	mov.w	r0, #3
 800bbc6:	d007      	beq.n	800bbd8 <ai_layers_forward_all+0x50>
 800bbc8:	47c0      	blx	r8
 800bbca:	3701      	adds	r7, #1
 800bbcc:	63a6      	str	r6, [r4, #56]	; 0x38
 800bbce:	2e00      	cmp	r6, #0
 800bbd0:	d1eb      	bne.n	800bbaa <ai_layers_forward_all+0x22>
 800bbd2:	4638      	mov	r0, r7
 800bbd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bbd8:	2003      	movs	r0, #3
 800bbda:	47c0      	blx	r8
 800bbdc:	2300      	movs	r3, #0
 800bbde:	3701      	adds	r7, #1
 800bbe0:	63a3      	str	r3, [r4, #56]	; 0x38
 800bbe2:	4638      	mov	r0, r7
 800bbe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bbe8:	2700      	movs	r7, #0
 800bbea:	4638      	mov	r0, r7
 800bbec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bbf0:	6b45      	ldr	r5, [r0, #52]	; 0x34
 800bbf2:	6385      	str	r5, [r0, #56]	; 0x38
 800bbf4:	2d00      	cmp	r5, #0
 800bbf6:	d0f7      	beq.n	800bbe8 <ai_layers_forward_all+0x60>
 800bbf8:	4647      	mov	r7, r8
 800bbfa:	696b      	ldr	r3, [r5, #20]
 800bbfc:	4628      	mov	r0, r5
 800bbfe:	4798      	blx	r3
 800bc00:	462b      	mov	r3, r5
 800bc02:	692d      	ldr	r5, [r5, #16]
 800bc04:	429d      	cmp	r5, r3
 800bc06:	d004      	beq.n	800bc12 <ai_layers_forward_all+0x8a>
 800bc08:	63a5      	str	r5, [r4, #56]	; 0x38
 800bc0a:	3701      	adds	r7, #1
 800bc0c:	2d00      	cmp	r5, #0
 800bc0e:	d1f4      	bne.n	800bbfa <ai_layers_forward_all+0x72>
 800bc10:	e7df      	b.n	800bbd2 <ai_layers_forward_all+0x4a>
 800bc12:	2300      	movs	r3, #0
 800bc14:	63a3      	str	r3, [r4, #56]	; 0x38
 800bc16:	3701      	adds	r7, #1
 800bc18:	e7db      	b.n	800bbd2 <ai_layers_forward_all+0x4a>
 800bc1a:	bf00      	nop

0800bc1c <forward_dense>:
 800bc1c:	6983      	ldr	r3, [r0, #24]
 800bc1e:	881a      	ldrh	r2, [r3, #0]
 800bc20:	2a00      	cmp	r2, #0
 800bc22:	f000 8181 	beq.w	800bf28 <forward_dense+0x30c>
 800bc26:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bc2a:	ed2d 8b02 	vpush	{d8}
 800bc2e:	f8d3 c004 	ldr.w	ip, [r3, #4]
 800bc32:	f8dc 5004 	ldr.w	r5, [ip, #4]
 800bc36:	b095      	sub	sp, #84	; 0x54
 800bc38:	b105      	cbz	r5, 800bc3c <forward_dense+0x20>
 800bc3a:	682d      	ldr	r5, [r5, #0]
 800bc3c:	2a01      	cmp	r2, #1
 800bc3e:	f000 828f 	beq.w	800c160 <forward_dense+0x544>
 800bc42:	f8dc 6010 	ldr.w	r6, [ip, #16]
 800bc46:	b106      	cbz	r6, 800bc4a <forward_dense+0x2e>
 800bc48:	6836      	ldr	r6, [r6, #0]
 800bc4a:	2a02      	cmp	r2, #2
 800bc4c:	f000 816e 	beq.w	800bf2c <forward_dense+0x310>
 800bc50:	f8dc 301c 	ldr.w	r3, [ip, #28]
 800bc54:	930b      	str	r3, [sp, #44]	; 0x2c
 800bc56:	2b00      	cmp	r3, #0
 800bc58:	f000 8274 	beq.w	800c144 <forward_dense+0x528>
 800bc5c:	4619      	mov	r1, r3
 800bc5e:	f8bc 3018 	ldrh.w	r3, [ip, #24]
 800bc62:	6809      	ldr	r1, [r1, #0]
 800bc64:	910d      	str	r1, [sp, #52]	; 0x34
 800bc66:	2b01      	cmp	r3, #1
 800bc68:	f240 826e 	bls.w	800c148 <forward_dense+0x52c>
 800bc6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800bc6e:	685b      	ldr	r3, [r3, #4]
 800bc70:	930b      	str	r3, [sp, #44]	; 0x2c
 800bc72:	460b      	mov	r3, r1
 800bc74:	68e8      	ldr	r0, [r5, #12]
 800bc76:	68f7      	ldr	r7, [r6, #12]
 800bc78:	6840      	ldr	r0, [r0, #4]
 800bc7a:	6999      	ldr	r1, [r3, #24]
 800bc7c:	9013      	str	r0, [sp, #76]	; 0x4c
 800bc7e:	6878      	ldr	r0, [r7, #4]
 800bc80:	680b      	ldr	r3, [r1, #0]
 800bc82:	9012      	str	r0, [sp, #72]	; 0x48
 800bc84:	e9d7 4702 	ldrd	r4, r7, [r7, #8]
 800bc88:	f3c3 1ec6 	ubfx	lr, r3, #7, #7
 800bc8c:	fb00 f404 	mul.w	r4, r0, r4
 800bc90:	f3c3 5041 	ubfx	r0, r3, #21, #2
 800bc94:	fa4e f000 	asr.w	r0, lr, r0
 800bc98:	2a03      	cmp	r2, #3
 800bc9a:	9010      	str	r0, [sp, #64]	; 0x40
 800bc9c:	f000 825d 	beq.w	800c15a <forward_dense+0x53e>
 800bca0:	f8dc 2028 	ldr.w	r2, [ip, #40]	; 0x28
 800bca4:	f3c3 4343 	ubfx	r3, r3, #17, #4
 800bca8:	2a00      	cmp	r2, #0
 800bcaa:	f000 8246 	beq.w	800c13a <forward_dense+0x51e>
 800bcae:	6812      	ldr	r2, [r2, #0]
 800bcb0:	2a00      	cmp	r2, #0
 800bcb2:	f000 8242 	beq.w	800c13a <forward_dense+0x51e>
 800bcb6:	2b04      	cmp	r3, #4
 800bcb8:	f8d2 9018 	ldr.w	r9, [r2, #24]
 800bcbc:	f000 822c 	beq.w	800c118 <forward_dense+0x4fc>
 800bcc0:	2b08      	cmp	r3, #8
 800bcc2:	f000 8229 	beq.w	800c118 <forward_dense+0x4fc>
 800bcc6:	f04f 0b00 	mov.w	fp, #0
 800bcca:	69b2      	ldr	r2, [r6, #24]
 800bccc:	69ab      	ldr	r3, [r5, #24]
 800bcce:	6891      	ldr	r1, [r2, #8]
 800bcd0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800bcd2:	689b      	ldr	r3, [r3, #8]
 800bcd4:	6952      	ldr	r2, [r2, #20]
 800bcd6:	9106      	str	r1, [sp, #24]
 800bcd8:	fb07 f404 	mul.w	r4, r7, r4
 800bcdc:	f8d2 9004 	ldr.w	r9, [r2, #4]
 800bce0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800bce2:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 800bce6:	4281      	cmp	r1, r0
 800bce8:	ea4f 0482 	mov.w	r4, r2, lsl #2
 800bcec:	900e      	str	r0, [sp, #56]	; 0x38
 800bcee:	940c      	str	r4, [sp, #48]	; 0x30
 800bcf0:	eb01 0882 	add.w	r8, r1, r2, lsl #2
 800bcf4:	f080 8113 	bcs.w	800bf1e <forward_dense+0x302>
 800bcf8:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800bcfa:	ed9f 8a93 	vldr	s16, [pc, #588]	; 800bf48 <forward_dense+0x32c>
 800bcfe:	f021 0201 	bic.w	r2, r1, #1
 800bd02:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800bd06:	9204      	str	r2, [sp, #16]
 800bd08:	f001 0201 	and.w	r2, r1, #1
 800bd0c:	08c8      	lsrs	r0, r1, #3
 800bd0e:	9208      	str	r2, [sp, #32]
 800bd10:	008a      	lsls	r2, r1, #2
 800bd12:	f001 0a07 	and.w	sl, r1, #7
 800bd16:	920f      	str	r2, [sp, #60]	; 0x3c
 800bd18:	eb03 1240 	add.w	r2, r3, r0, lsl #5
 800bd1c:	3320      	adds	r3, #32
 800bd1e:	465c      	mov	r4, fp
 800bd20:	9007      	str	r0, [sp, #28]
 800bd22:	46cb      	mov	fp, r9
 800bd24:	9205      	str	r2, [sp, #20]
 800bd26:	9302      	str	r3, [sp, #8]
 800bd28:	46c1      	mov	r9, r8
 800bd2a:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
 800bd2e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800bd30:	699b      	ldr	r3, [r3, #24]
 800bd32:	689a      	ldr	r2, [r3, #8]
 800bd34:	9b02      	ldr	r3, [sp, #8]
 800bd36:	3b20      	subs	r3, #32
 800bd38:	930a      	str	r3, [sp, #40]	; 0x28
 800bd3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800bd3c:	b10b      	cbz	r3, 800bd42 <forward_dense+0x126>
 800bd3e:	699b      	ldr	r3, [r3, #24]
 800bd40:	689b      	ldr	r3, [r3, #8]
 800bd42:	2c00      	cmp	r4, #0
 800bd44:	f000 81da 	beq.w	800c0fc <forward_dense+0x4e0>
 800bd48:	9910      	ldr	r1, [sp, #64]	; 0x40
 800bd4a:	2904      	cmp	r1, #4
 800bd4c:	9906      	ldr	r1, [sp, #24]
 800bd4e:	f000 80fd 	beq.w	800bf4c <forward_dense+0x330>
 800bd52:	4549      	cmp	r1, r9
 800bd54:	f080 80d2 	bcs.w	800befc <forward_dense+0x2e0>
 800bd58:	460f      	mov	r7, r1
 800bd5a:	9907      	ldr	r1, [sp, #28]
 800bd5c:	f8dd 8008 	ldr.w	r8, [sp, #8]
 800bd60:	f8dd a014 	ldr.w	sl, [sp, #20]
 800bd64:	1c4e      	adds	r6, r1, #1
 800bd66:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 800bd6a:	4694      	mov	ip, r2
 800bd6c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800bd6e:	468e      	mov	lr, r1
 800bd70:	2b00      	cmp	r3, #0
 800bd72:	f000 80de 	beq.w	800bf32 <forward_dense+0x316>
 800bd76:	ecf3 2a01 	vldmia	r3!, {s5}
 800bd7a:	ed9f 7a73 	vldr	s14, [pc, #460]	; 800bf48 <forward_dense+0x32c>
 800bd7e:	f1be 0f00 	cmp.w	lr, #0
 800bd82:	f000 80de 	beq.w	800bf42 <forward_dense+0x326>
 800bd86:	f10c 0108 	add.w	r1, ip, #8
 800bd8a:	4640      	mov	r0, r8
 800bd8c:	f811 5c07 	ldrb.w	r5, [r1, #-7]
 800bd90:	ed10 3a07 	vldr	s6, [r0, #-28]	; 0xffffffe4
 800bd94:	ed50 3a08 	vldr	s7, [r0, #-32]	; 0xffffffe0
 800bd98:	ed10 4a06 	vldr	s8, [r0, #-24]	; 0xffffffe8
 800bd9c:	ed50 4a05 	vldr	s9, [r0, #-20]	; 0xffffffec
 800bda0:	ed10 5a04 	vldr	s10, [r0, #-16]
 800bda4:	ed50 5a03 	vldr	s11, [r0, #-12]
 800bda8:	ed10 6a02 	vldr	s12, [r0, #-8]
 800bdac:	ed50 6a01 	vldr	s13, [r0, #-4]
 800bdb0:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdb4:	edd5 7a00 	vldr	s15, [r5]
 800bdb8:	f811 5c08 	ldrb.w	r5, [r1, #-8]
 800bdbc:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdc0:	ee67 7a83 	vmul.f32	s15, s15, s6
 800bdc4:	ed95 3a00 	vldr	s6, [r5]
 800bdc8:	f811 5c06 	ldrb.w	r5, [r1, #-6]
 800bdcc:	eee3 7a23 	vfma.f32	s15, s6, s7
 800bdd0:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdd4:	3108      	adds	r1, #8
 800bdd6:	edd5 3a00 	vldr	s7, [r5]
 800bdda:	f811 5c0d 	ldrb.w	r5, [r1, #-13]
 800bdde:	eee3 7a84 	vfma.f32	s15, s7, s8
 800bde2:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bde6:	3020      	adds	r0, #32
 800bde8:	ed95 4a00 	vldr	s8, [r5]
 800bdec:	f811 5c0c 	ldrb.w	r5, [r1, #-12]
 800bdf0:	eee4 7a24 	vfma.f32	s15, s8, s9
 800bdf4:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdf8:	edd5 4a00 	vldr	s9, [r5]
 800bdfc:	f811 5c0b 	ldrb.w	r5, [r1, #-11]
 800be00:	eee4 7a85 	vfma.f32	s15, s9, s10
 800be04:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be08:	ed95 5a00 	vldr	s10, [r5]
 800be0c:	f811 5c0a 	ldrb.w	r5, [r1, #-10]
 800be10:	eee5 7a25 	vfma.f32	s15, s10, s11
 800be14:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be18:	edd5 5a00 	vldr	s11, [r5]
 800be1c:	f811 5c09 	ldrb.w	r5, [r1, #-9]
 800be20:	eee5 7a86 	vfma.f32	s15, s11, s12
 800be24:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be28:	428e      	cmp	r6, r1
 800be2a:	ed95 6a00 	vldr	s12, [r5]
 800be2e:	eee6 7a26 	vfma.f32	s15, s12, s13
 800be32:	ee37 7a27 	vadd.f32	s14, s14, s15
 800be36:	d1a9      	bne.n	800bd8c <forward_dense+0x170>
 800be38:	f1a6 0108 	sub.w	r1, r6, #8
 800be3c:	4650      	mov	r0, sl
 800be3e:	2a00      	cmp	r2, #0
 800be40:	d04a      	beq.n	800bed8 <forward_dense+0x2bc>
 800be42:	780d      	ldrb	r5, [r1, #0]
 800be44:	edd0 6a00 	vldr	s13, [r0]
 800be48:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be4c:	edd5 7a00 	vldr	s15, [r5]
 800be50:	2a01      	cmp	r2, #1
 800be52:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be56:	d03f      	beq.n	800bed8 <forward_dense+0x2bc>
 800be58:	784d      	ldrb	r5, [r1, #1]
 800be5a:	edd0 6a01 	vldr	s13, [r0, #4]
 800be5e:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be62:	edd5 7a00 	vldr	s15, [r5]
 800be66:	2a02      	cmp	r2, #2
 800be68:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be6c:	d034      	beq.n	800bed8 <forward_dense+0x2bc>
 800be6e:	788d      	ldrb	r5, [r1, #2]
 800be70:	edd0 6a02 	vldr	s13, [r0, #8]
 800be74:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be78:	edd5 7a00 	vldr	s15, [r5]
 800be7c:	2a03      	cmp	r2, #3
 800be7e:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be82:	d029      	beq.n	800bed8 <forward_dense+0x2bc>
 800be84:	78cd      	ldrb	r5, [r1, #3]
 800be86:	edd0 6a03 	vldr	s13, [r0, #12]
 800be8a:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be8e:	edd5 7a00 	vldr	s15, [r5]
 800be92:	2a04      	cmp	r2, #4
 800be94:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be98:	d01e      	beq.n	800bed8 <forward_dense+0x2bc>
 800be9a:	790d      	ldrb	r5, [r1, #4]
 800be9c:	edd0 6a04 	vldr	s13, [r0, #16]
 800bea0:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bea4:	edd5 7a00 	vldr	s15, [r5]
 800bea8:	2a05      	cmp	r2, #5
 800beaa:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800beae:	d013      	beq.n	800bed8 <forward_dense+0x2bc>
 800beb0:	794d      	ldrb	r5, [r1, #5]
 800beb2:	edd0 6a05 	vldr	s13, [r0, #20]
 800beb6:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800beba:	edd5 7a00 	vldr	s15, [r5]
 800bebe:	2a06      	cmp	r2, #6
 800bec0:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800bec4:	d008      	beq.n	800bed8 <forward_dense+0x2bc>
 800bec6:	7989      	ldrb	r1, [r1, #6]
 800bec8:	edd0 7a06 	vldr	s15, [r0, #24]
 800becc:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800bed0:	edd1 6a00 	vldr	s13, [r1]
 800bed4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800bed8:	44dc      	add	ip, fp
 800beda:	445e      	add	r6, fp
 800bedc:	ee32 7a87 	vadd.f32	s14, s5, s14
 800bee0:	eca7 7a01 	vstmia	r7!, {s14}
 800bee4:	454f      	cmp	r7, r9
 800bee6:	f4ff af43 	bcc.w	800bd70 <forward_dense+0x154>
 800beea:	9a06      	ldr	r2, [sp, #24]
 800beec:	eba9 0302 	sub.w	r3, r9, r2
 800bef0:	3b01      	subs	r3, #1
 800bef2:	f023 0303 	bic.w	r3, r3, #3
 800bef6:	3304      	adds	r3, #4
 800bef8:	18d3      	adds	r3, r2, r3
 800befa:	9306      	str	r3, [sp, #24]
 800befc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800befe:	9a05      	ldr	r2, [sp, #20]
 800bf00:	4499      	add	r9, r3
 800bf02:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800bf04:	441a      	add	r2, r3
 800bf06:	9205      	str	r2, [sp, #20]
 800bf08:	9a02      	ldr	r2, [sp, #8]
 800bf0a:	441a      	add	r2, r3
 800bf0c:	9202      	str	r2, [sp, #8]
 800bf0e:	9a04      	ldr	r2, [sp, #16]
 800bf10:	441a      	add	r2, r3
 800bf12:	9204      	str	r2, [sp, #16]
 800bf14:	9b06      	ldr	r3, [sp, #24]
 800bf16:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800bf18:	4293      	cmp	r3, r2
 800bf1a:	f4ff af08 	bcc.w	800bd2e <forward_dense+0x112>
 800bf1e:	b015      	add	sp, #84	; 0x54
 800bf20:	ecbd 8b02 	vpop	{d8}
 800bf24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bf28:	6853      	ldr	r3, [r2, #4]
 800bf2a:	deff      	udf	#255	; 0xff
 800bf2c:	2300      	movs	r3, #0
 800bf2e:	685b      	ldr	r3, [r3, #4]
 800bf30:	deff      	udf	#255	; 0xff
 800bf32:	ed9f 7a05 	vldr	s14, [pc, #20]	; 800bf48 <forward_dense+0x32c>
 800bf36:	eef0 2a48 	vmov.f32	s5, s16
 800bf3a:	f1be 0f00 	cmp.w	lr, #0
 800bf3e:	f47f af22 	bne.w	800bd86 <forward_dense+0x16a>
 800bf42:	980a      	ldr	r0, [sp, #40]	; 0x28
 800bf44:	4661      	mov	r1, ip
 800bf46:	e77a      	b.n	800be3e <forward_dense+0x222>
 800bf48:	00000000 	.word	0x00000000
 800bf4c:	4549      	cmp	r1, r9
 800bf4e:	d2d5      	bcs.n	800befc <forward_dense+0x2e0>
 800bf50:	9807      	ldr	r0, [sp, #28]
 800bf52:	9103      	str	r1, [sp, #12]
 800bf54:	9904      	ldr	r1, [sp, #16]
 800bf56:	f100 0c01 	add.w	ip, r0, #1
 800bf5a:	3901      	subs	r1, #1
 800bf5c:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 800bf60:	9109      	str	r1, [sp, #36]	; 0x24
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	f000 80b2 	beq.w	800c0cc <forward_dense+0x4b0>
 800bf68:	9907      	ldr	r1, [sp, #28]
 800bf6a:	ecf3 2a01 	vldmia	r3!, {s5}
 800bf6e:	ed1f 7a0a 	vldr	s14, [pc, #-40]	; 800bf48 <forward_dense+0x32c>
 800bf72:	2900      	cmp	r1, #0
 800bf74:	f000 80b2 	beq.w	800c0dc <forward_dense+0x4c0>
 800bf78:	9902      	ldr	r1, [sp, #8]
 800bf7a:	1d10      	adds	r0, r2, #4
 800bf7c:	f810 6c04 	ldrb.w	r6, [r0, #-4]
 800bf80:	ed11 2a07 	vldr	s4, [r1, #-28]	; 0xffffffe4
 800bf84:	f810 5c03 	ldrb.w	r5, [r0, #-3]
 800bf88:	ed51 3a08 	vldr	s7, [r1, #-32]	; 0xffffffe0
 800bf8c:	ed11 4a06 	vldr	s8, [r1, #-24]	; 0xffffffe8
 800bf90:	ed51 4a05 	vldr	s9, [r1, #-20]	; 0xffffffec
 800bf94:	ed11 5a04 	vldr	s10, [r1, #-16]
 800bf98:	ed51 5a03 	vldr	s11, [r1, #-12]
 800bf9c:	ed11 6a02 	vldr	s12, [r1, #-8]
 800bfa0:	ed51 6a01 	vldr	s13, [r1, #-4]
 800bfa4:	f006 070f 	and.w	r7, r6, #15
 800bfa8:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 800bfac:	edd7 7a00 	vldr	s15, [r7]
 800bfb0:	0936      	lsrs	r6, r6, #4
 800bfb2:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bfb6:	ed96 3a00 	vldr	s6, [r6]
 800bfba:	ee67 7a82 	vmul.f32	s15, s15, s4
 800bfbe:	092e      	lsrs	r6, r5, #4
 800bfc0:	eee3 7a23 	vfma.f32	s15, s6, s7
 800bfc4:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bfc8:	f005 050f 	and.w	r5, r5, #15
 800bfcc:	edd6 3a00 	vldr	s7, [r6]
 800bfd0:	f810 6c02 	ldrb.w	r6, [r0, #-2]
 800bfd4:	eee3 7a84 	vfma.f32	s15, s7, s8
 800bfd8:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bfdc:	0937      	lsrs	r7, r6, #4
 800bfde:	ed95 4a00 	vldr	s8, [r5]
 800bfe2:	f810 5c01 	ldrb.w	r5, [r0, #-1]
 800bfe6:	eee4 7a24 	vfma.f32	s15, s8, s9
 800bfea:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 800bfee:	f006 060f 	and.w	r6, r6, #15
 800bff2:	edd7 4a00 	vldr	s9, [r7]
 800bff6:	eee4 7a85 	vfma.f32	s15, s9, s10
 800bffa:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bffe:	3004      	adds	r0, #4
 800c000:	ed96 5a00 	vldr	s10, [r6]
 800c004:	092e      	lsrs	r6, r5, #4
 800c006:	eee5 7a25 	vfma.f32	s15, s10, s11
 800c00a:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800c00e:	f005 050f 	and.w	r5, r5, #15
 800c012:	edd6 5a00 	vldr	s11, [r6]
 800c016:	eee5 7a86 	vfma.f32	s15, s11, s12
 800c01a:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800c01e:	4584      	cmp	ip, r0
 800c020:	ed95 6a00 	vldr	s12, [r5]
 800c024:	eee6 7a26 	vfma.f32	s15, s12, s13
 800c028:	f101 0120 	add.w	r1, r1, #32
 800c02c:	ee37 7a27 	vadd.f32	s14, s14, s15
 800c030:	d1a4      	bne.n	800bf7c <forward_dense+0x360>
 800c032:	f8dd e014 	ldr.w	lr, [sp, #20]
 800c036:	f1ac 0804 	sub.w	r8, ip, #4
 800c03a:	9904      	ldr	r1, [sp, #16]
 800c03c:	458e      	cmp	lr, r1
 800c03e:	d22a      	bcs.n	800c096 <forward_dense+0x47a>
 800c040:	9909      	ldr	r1, [sp, #36]	; 0x24
 800c042:	eba1 070e 	sub.w	r7, r1, lr
 800c046:	ea4f 0ad7 	mov.w	sl, r7, lsr #3
 800c04a:	f10e 0008 	add.w	r0, lr, #8
 800c04e:	f108 36ff 	add.w	r6, r8, #4294967295
 800c052:	eb08 07d7 	add.w	r7, r8, r7, lsr #3
 800c056:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800c05a:	ed50 5a01 	vldr	s11, [r0, #-4]
 800c05e:	ed50 6a02 	vldr	s13, [r0, #-8]
 800c062:	f001 050f 	and.w	r5, r1, #15
 800c066:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800c06a:	edd5 7a00 	vldr	s15, [r5]
 800c06e:	0909      	lsrs	r1, r1, #4
 800c070:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800c074:	ed91 6a00 	vldr	s12, [r1]
 800c078:	ee67 7aa5 	vmul.f32	s15, s15, s11
 800c07c:	42b7      	cmp	r7, r6
 800c07e:	eee6 7a26 	vfma.f32	s15, s12, s13
 800c082:	f100 0008 	add.w	r0, r0, #8
 800c086:	ee37 7a27 	vadd.f32	s14, s14, s15
 800c08a:	d1e4      	bne.n	800c056 <forward_dense+0x43a>
 800c08c:	f10a 0a01 	add.w	sl, sl, #1
 800c090:	44d0      	add	r8, sl
 800c092:	eb0e 0eca 	add.w	lr, lr, sl, lsl #3
 800c096:	9908      	ldr	r1, [sp, #32]
 800c098:	b321      	cbz	r1, 800c0e4 <forward_dense+0x4c8>
 800c09a:	f898 1000 	ldrb.w	r1, [r8]
 800c09e:	edde 7a00 	vldr	s15, [lr]
 800c0a2:	0909      	lsrs	r1, r1, #4
 800c0a4:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800c0a8:	edd1 6a00 	vldr	s13, [r1]
 800c0ac:	9903      	ldr	r1, [sp, #12]
 800c0ae:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800c0b2:	445a      	add	r2, fp
 800c0b4:	44dc      	add	ip, fp
 800c0b6:	ee72 2a87 	vadd.f32	s5, s5, s14
 800c0ba:	ece1 2a01 	vstmia	r1!, {s5}
 800c0be:	4589      	cmp	r9, r1
 800c0c0:	9103      	str	r1, [sp, #12]
 800c0c2:	f67f af12 	bls.w	800beea <forward_dense+0x2ce>
 800c0c6:	2b00      	cmp	r3, #0
 800c0c8:	f47f af4e 	bne.w	800bf68 <forward_dense+0x34c>
 800c0cc:	9907      	ldr	r1, [sp, #28]
 800c0ce:	ed1f 7a62 	vldr	s14, [pc, #-392]	; 800bf48 <forward_dense+0x32c>
 800c0d2:	eef0 2a48 	vmov.f32	s5, s16
 800c0d6:	2900      	cmp	r1, #0
 800c0d8:	f47f af4e 	bne.w	800bf78 <forward_dense+0x35c>
 800c0dc:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
 800c0e0:	4690      	mov	r8, r2
 800c0e2:	e7aa      	b.n	800c03a <forward_dense+0x41e>
 800c0e4:	9903      	ldr	r1, [sp, #12]
 800c0e6:	ee32 7a87 	vadd.f32	s14, s5, s14
 800c0ea:	445a      	add	r2, fp
 800c0ec:	eca1 7a01 	vstmia	r1!, {s14}
 800c0f0:	4549      	cmp	r1, r9
 800c0f2:	9103      	str	r1, [sp, #12]
 800c0f4:	44dc      	add	ip, fp
 800c0f6:	f4ff af34 	bcc.w	800bf62 <forward_dense+0x346>
 800c0fa:	e6f6      	b.n	800beea <forward_dense+0x2ce>
 800c0fc:	9912      	ldr	r1, [sp, #72]	; 0x48
 800c0fe:	9d06      	ldr	r5, [sp, #24]
 800c100:	9101      	str	r1, [sp, #4]
 800c102:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800c104:	9100      	str	r1, [sp, #0]
 800c106:	4628      	mov	r0, r5
 800c108:	990a      	ldr	r1, [sp, #40]	; 0x28
 800c10a:	f000 fcb7 	bl	800ca7c <forward_lite_dense_if32of32wf32>
 800c10e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c110:	462b      	mov	r3, r5
 800c112:	4413      	add	r3, r2
 800c114:	9306      	str	r3, [sp, #24]
 800c116:	e6f1      	b.n	800befc <forward_dense+0x2e0>
 800c118:	f8d1 800c 	ldr.w	r8, [r1, #12]
 800c11c:	f1b9 0f00 	cmp.w	r9, #0
 800c120:	d016      	beq.n	800c150 <forward_dense+0x534>
 800c122:	e9d9 0100 	ldrd	r0, r1, [r9]
 800c126:	f000 ff27 	bl	800cf78 <ai_array_get_byte_size>
 800c12a:	f8d9 b00c 	ldr.w	fp, [r9, #12]
 800c12e:	4602      	mov	r2, r0
 800c130:	4659      	mov	r1, fp
 800c132:	4640      	mov	r0, r8
 800c134:	f000 fdc6 	bl	800ccc4 <st_int8_copy>
 800c138:	e5c7      	b.n	800bcca <forward_dense+0xae>
 800c13a:	2b04      	cmp	r3, #4
 800c13c:	d00a      	beq.n	800c154 <forward_dense+0x538>
 800c13e:	f04f 0900 	mov.w	r9, #0
 800c142:	e5bd      	b.n	800bcc0 <forward_dense+0xa4>
 800c144:	930d      	str	r3, [sp, #52]	; 0x34
 800c146:	e595      	b.n	800bc74 <forward_dense+0x58>
 800c148:	2300      	movs	r3, #0
 800c14a:	930b      	str	r3, [sp, #44]	; 0x2c
 800c14c:	460b      	mov	r3, r1
 800c14e:	e591      	b.n	800bc74 <forward_dense+0x58>
 800c150:	46c3      	mov	fp, r8
 800c152:	e5ba      	b.n	800bcca <forward_dense+0xae>
 800c154:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 800c158:	e5b7      	b.n	800bcca <forward_dense+0xae>
 800c15a:	2300      	movs	r3, #0
 800c15c:	685b      	ldr	r3, [r3, #4]
 800c15e:	deff      	udf	#255	; 0xff
 800c160:	2300      	movs	r3, #0
 800c162:	685b      	ldr	r3, [r3, #4]
 800c164:	deff      	udf	#255	; 0xff
 800c166:	bf00      	nop

0800c168 <forward_concat>:
 800c168:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c16c:	ed2d 8b06 	vpush	{d8-d10}
 800c170:	6982      	ldr	r2, [r0, #24]
 800c172:	b085      	sub	sp, #20
 800c174:	8813      	ldrh	r3, [r2, #0]
 800c176:	9002      	str	r0, [sp, #8]
 800c178:	b90b      	cbnz	r3, 800c17e <forward_concat+0x16>
 800c17a:	685b      	ldr	r3, [r3, #4]
 800c17c:	deff      	udf	#255	; 0xff
 800c17e:	2b01      	cmp	r3, #1
 800c180:	6856      	ldr	r6, [r2, #4]
 800c182:	f000 8293 	beq.w	800c6ac <forward_concat+0x544>
 800c186:	6933      	ldr	r3, [r6, #16]
 800c188:	9301      	str	r3, [sp, #4]
 800c18a:	b10b      	cbz	r3, 800c190 <forward_concat+0x28>
 800c18c:	681b      	ldr	r3, [r3, #0]
 800c18e:	9301      	str	r3, [sp, #4]
 800c190:	8834      	ldrh	r4, [r6, #0]
 800c192:	2300      	movs	r3, #0
 800c194:	4621      	mov	r1, r4
 800c196:	4618      	mov	r0, r3
 800c198:	e00c      	b.n	800c1b4 <forward_concat+0x4c>
 800c19a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c19e:	b172      	cbz	r2, 800c1be <forward_concat+0x56>
 800c1a0:	6992      	ldr	r2, [r2, #24]
 800c1a2:	6812      	ldr	r2, [r2, #0]
 800c1a4:	f3c2 4243 	ubfx	r2, r2, #17, #4
 800c1a8:	2a01      	cmp	r2, #1
 800c1aa:	bf0c      	ite	eq
 800c1ac:	2201      	moveq	r2, #1
 800c1ae:	2202      	movne	r2, #2
 800c1b0:	3301      	adds	r3, #1
 800c1b2:	4310      	orrs	r0, r2
 800c1b4:	429c      	cmp	r4, r3
 800c1b6:	d002      	beq.n	800c1be <forward_concat+0x56>
 800c1b8:	6872      	ldr	r2, [r6, #4]
 800c1ba:	2a00      	cmp	r2, #0
 800c1bc:	d1ed      	bne.n	800c19a <forward_concat+0x32>
 800c1be:	9b01      	ldr	r3, [sp, #4]
 800c1c0:	699a      	ldr	r2, [r3, #24]
 800c1c2:	6813      	ldr	r3, [r2, #0]
 800c1c4:	f8d2 b008 	ldr.w	fp, [r2, #8]
 800c1c8:	f3c3 4243 	ubfx	r2, r3, #17, #4
 800c1cc:	2a01      	cmp	r2, #1
 800c1ce:	d006      	beq.n	800c1de <forward_concat+0x76>
 800c1d0:	2801      	cmp	r0, #1
 800c1d2:	d146      	bne.n	800c262 <forward_concat+0xfa>
 800c1d4:	b005      	add	sp, #20
 800c1d6:	ecbd 8b06 	vpop	{d8-d10}
 800c1da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c1de:	2801      	cmp	r0, #1
 800c1e0:	d134      	bne.n	800c24c <forward_concat+0xe4>
 800c1e2:	f04f 0800 	mov.w	r8, #0
 800c1e6:	4541      	cmp	r1, r8
 800c1e8:	d9f4      	bls.n	800c1d4 <forward_concat+0x6c>
 800c1ea:	6873      	ldr	r3, [r6, #4]
 800c1ec:	2b00      	cmp	r3, #0
 800c1ee:	d0f1      	beq.n	800c1d4 <forward_concat+0x6c>
 800c1f0:	f853 5028 	ldr.w	r5, [r3, r8, lsl #2]
 800c1f4:	2d00      	cmp	r5, #0
 800c1f6:	d0ed      	beq.n	800c1d4 <forward_concat+0x6c>
 800c1f8:	69ab      	ldr	r3, [r5, #24]
 800c1fa:	e9d3 0100 	ldrd	r0, r1, [r3]
 800c1fe:	f000 febb 	bl	800cf78 <ai_array_get_byte_size>
 800c202:	69ab      	ldr	r3, [r5, #24]
 800c204:	6969      	ldr	r1, [r5, #20]
 800c206:	689c      	ldr	r4, [r3, #8]
 800c208:	9b02      	ldr	r3, [sp, #8]
 800c20a:	68ea      	ldr	r2, [r5, #12]
 800c20c:	69db      	ldr	r3, [r3, #28]
 800c20e:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 800c212:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c216:	fb02 f905 	mul.w	r9, r2, r5
 800c21a:	9a01      	ldr	r2, [sp, #4]
 800c21c:	68d1      	ldr	r1, [r2, #12]
 800c21e:	1827      	adds	r7, r4, r0
 800c220:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800c224:	42bc      	cmp	r4, r7
 800c226:	fb03 f505 	mul.w	r5, r3, r5
 800c22a:	bf38      	it	cc
 800c22c:	46da      	movcc	sl, fp
 800c22e:	d208      	bcs.n	800c242 <forward_concat+0xda>
 800c230:	4651      	mov	r1, sl
 800c232:	4620      	mov	r0, r4
 800c234:	464a      	mov	r2, r9
 800c236:	444c      	add	r4, r9
 800c238:	f000 fd44 	bl	800ccc4 <st_int8_copy>
 800c23c:	42a7      	cmp	r7, r4
 800c23e:	44aa      	add	sl, r5
 800c240:	d8f6      	bhi.n	800c230 <forward_concat+0xc8>
 800c242:	8831      	ldrh	r1, [r6, #0]
 800c244:	44cb      	add	fp, r9
 800c246:	f108 0801 	add.w	r8, r8, #1
 800c24a:	e7cc      	b.n	800c1e6 <forward_concat+0x7e>
 800c24c:	0782      	lsls	r2, r0, #30
 800c24e:	d4c1      	bmi.n	800c1d4 <forward_concat+0x6c>
 800c250:	9a01      	ldr	r2, [sp, #4]
 800c252:	f8d2 8000 	ldr.w	r8, [r2]
 800c256:	f1b8 0f00 	cmp.w	r8, #0
 800c25a:	d109      	bne.n	800c270 <forward_concat+0x108>
 800c25c:	ed9f 8aba 	vldr	s16, [pc, #744]	; 800c548 <forward_concat+0x3e0>
 800c260:	e011      	b.n	800c286 <forward_concat+0x11e>
 800c262:	9a01      	ldr	r2, [sp, #4]
 800c264:	f8d2 8000 	ldr.w	r8, [r2]
 800c268:	f1b8 0f00 	cmp.w	r8, #0
 800c26c:	f000 8216 	beq.w	800c69c <forward_concat+0x534>
 800c270:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800c274:	2a00      	cmp	r2, #0
 800c276:	d0f1      	beq.n	800c25c <forward_concat+0xf4>
 800c278:	f8b8 1002 	ldrh.w	r1, [r8, #2]
 800c27c:	2900      	cmp	r1, #0
 800c27e:	d0ed      	beq.n	800c25c <forward_concat+0xf4>
 800c280:	6812      	ldr	r2, [r2, #0]
 800c282:	ed92 8a00 	vldr	s16, [r2]
 800c286:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800c28a:	ee87 9a88 	vdiv.f32	s18, s15, s16
 800c28e:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 800c292:	9303      	str	r3, [sp, #12]
 800c294:	4621      	mov	r1, r4
 800c296:	4633      	mov	r3, r6
 800c298:	2700      	movs	r7, #0
 800c29a:	4646      	mov	r6, r8
 800c29c:	4698      	mov	r8, r3
 800c29e:	ed9f aaa8 	vldr	s20, [pc, #672]	; 800c540 <forward_concat+0x3d8>
 800c2a2:	eddf 8aa9 	vldr	s17, [pc, #676]	; 800c548 <forward_concat+0x3e0>
 800c2a6:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
 800c2aa:	42b9      	cmp	r1, r7
 800c2ac:	d992      	bls.n	800c1d4 <forward_concat+0x6c>
 800c2ae:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800c2b2:	2b00      	cmp	r3, #0
 800c2b4:	d08e      	beq.n	800c1d4 <forward_concat+0x6c>
 800c2b6:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 800c2ba:	2b00      	cmp	r3, #0
 800c2bc:	d08a      	beq.n	800c1d4 <forward_concat+0x6c>
 800c2be:	9a02      	ldr	r2, [sp, #8]
 800c2c0:	68d9      	ldr	r1, [r3, #12]
 800c2c2:	69d4      	ldr	r4, [r2, #28]
 800c2c4:	9a01      	ldr	r2, [sp, #4]
 800c2c6:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 800c2ca:	68d2      	ldr	r2, [r2, #12]
 800c2cc:	6958      	ldr	r0, [r3, #20]
 800c2ce:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 800c2d2:	699a      	ldr	r2, [r3, #24]
 800c2d4:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 800c2d8:	f8d2 9000 	ldr.w	r9, [r2]
 800c2dc:	9300      	str	r3, [sp, #0]
 800c2de:	fb01 fa00 	mul.w	sl, r1, r0
 800c2e2:	fb00 f505 	mul.w	r5, r0, r5
 800c2e6:	e9d2 1401 	ldrd	r1, r4, [r2, #4]
 800c2ea:	4648      	mov	r0, r9
 800c2ec:	f000 fe44 	bl	800cf78 <ai_array_get_byte_size>
 800c2f0:	f3c9 4243 	ubfx	r2, r9, #17, #4
 800c2f4:	2a01      	cmp	r2, #1
 800c2f6:	9b00      	ldr	r3, [sp, #0]
 800c2f8:	eb04 0900 	add.w	r9, r4, r0
 800c2fc:	d079      	beq.n	800c3f2 <forward_concat+0x28a>
 800c2fe:	6818      	ldr	r0, [r3, #0]
 800c300:	2800      	cmp	r0, #0
 800c302:	f000 8118 	beq.w	800c536 <forward_concat+0x3ce>
 800c306:	6841      	ldr	r1, [r0, #4]
 800c308:	2900      	cmp	r1, #0
 800c30a:	f000 8166 	beq.w	800c5da <forward_concat+0x472>
 800c30e:	8842      	ldrh	r2, [r0, #2]
 800c310:	2a00      	cmp	r2, #0
 800c312:	f000 815f 	beq.w	800c5d4 <forward_concat+0x46c>
 800c316:	680b      	ldr	r3, [r1, #0]
 800c318:	edd3 6a00 	vldr	s13, [r3]
 800c31c:	684b      	ldr	r3, [r1, #4]
 800c31e:	f993 2000 	ldrsb.w	r2, [r3]
 800c322:	2e00      	cmp	r6, #0
 800c324:	f000 8105 	beq.w	800c532 <forward_concat+0x3ca>
 800c328:	6871      	ldr	r1, [r6, #4]
 800c32a:	2900      	cmp	r1, #0
 800c32c:	f000 8159 	beq.w	800c5e2 <forward_concat+0x47a>
 800c330:	8873      	ldrh	r3, [r6, #2]
 800c332:	b113      	cbz	r3, 800c33a <forward_concat+0x1d2>
 800c334:	684b      	ldr	r3, [r1, #4]
 800c336:	f993 3000 	ldrsb.w	r3, [r3]
 800c33a:	eeb4 8a66 	vcmp.f32	s16, s13
 800c33e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c342:	d102      	bne.n	800c34a <forward_concat+0x1e2>
 800c344:	429a      	cmp	r2, r3
 800c346:	f000 818b 	beq.w	800c660 <forward_concat+0x4f8>
 800c34a:	9b03      	ldr	r3, [sp, #12]
 800c34c:	2b00      	cmp	r3, #0
 800c34e:	f040 809a 	bne.w	800c486 <forward_concat+0x31e>
 800c352:	2800      	cmp	r0, #0
 800c354:	f000 8150 	beq.w	800c5f8 <forward_concat+0x490>
 800c358:	6843      	ldr	r3, [r0, #4]
 800c35a:	2b00      	cmp	r3, #0
 800c35c:	f000 8143 	beq.w	800c5e6 <forward_concat+0x47e>
 800c360:	8842      	ldrh	r2, [r0, #2]
 800c362:	2a00      	cmp	r2, #0
 800c364:	f000 813f 	beq.w	800c5e6 <forward_concat+0x47e>
 800c368:	685b      	ldr	r3, [r3, #4]
 800c36a:	7819      	ldrb	r1, [r3, #0]
 800c36c:	2e00      	cmp	r6, #0
 800c36e:	f000 813e 	beq.w	800c5ee <forward_concat+0x486>
 800c372:	6872      	ldr	r2, [r6, #4]
 800c374:	2a00      	cmp	r2, #0
 800c376:	f000 816d 	beq.w	800c654 <forward_concat+0x4ec>
 800c37a:	8873      	ldrh	r3, [r6, #2]
 800c37c:	b10b      	cbz	r3, 800c382 <forward_concat+0x21a>
 800c37e:	6853      	ldr	r3, [r2, #4]
 800c380:	781b      	ldrb	r3, [r3, #0]
 800c382:	eeb4 8a66 	vcmp.f32	s16, s13
 800c386:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c38a:	d102      	bne.n	800c392 <forward_concat+0x22a>
 800c38c:	4299      	cmp	r1, r3
 800c38e:	f000 814c 	beq.w	800c62a <forward_concat+0x4c2>
 800c392:	454c      	cmp	r4, r9
 800c394:	ee66 6a89 	vmul.f32	s13, s13, s18
 800c398:	f080 80c7 	bcs.w	800c52a <forward_concat+0x3c2>
 800c39c:	2d00      	cmp	r5, #0
 800c39e:	f340 80c4 	ble.w	800c52a <forward_concat+0x3c2>
 800c3a2:	ee07 3a90 	vmov	s15, r3
 800c3a6:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 800c3aa:	1960      	adds	r0, r4, r5
 800c3ac:	ee36 6a29 	vadd.f32	s12, s12, s19
 800c3b0:	4602      	mov	r2, r0
 800c3b2:	46dc      	mov	ip, fp
 800c3b4:	46e6      	mov	lr, ip
 800c3b6:	f814 3b01 	ldrb.w	r3, [r4], #1
 800c3ba:	1a5b      	subs	r3, r3, r1
 800c3bc:	ee07 3a90 	vmov	s15, r3
 800c3c0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c3c4:	eeb0 7a46 	vmov.f32	s14, s12
 800c3c8:	eea7 7aa6 	vfma.f32	s14, s15, s13
 800c3cc:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 800c3d0:	ee17 3a90 	vmov	r3, s15
 800c3d4:	f383 0308 	usat	r3, #8, r3
 800c3d8:	4294      	cmp	r4, r2
 800c3da:	f80e 3b01 	strb.w	r3, [lr], #1
 800c3de:	d1ea      	bne.n	800c3b6 <forward_concat+0x24e>
 800c3e0:	4548      	cmp	r0, r9
 800c3e2:	eb04 0205 	add.w	r2, r4, r5
 800c3e6:	44d4      	add	ip, sl
 800c3e8:	4604      	mov	r4, r0
 800c3ea:	f080 809e 	bcs.w	800c52a <forward_concat+0x3c2>
 800c3ee:	4428      	add	r0, r5
 800c3f0:	e7e0      	b.n	800c3b4 <forward_concat+0x24c>
 800c3f2:	2d00      	cmp	r5, #0
 800c3f4:	9b03      	ldr	r3, [sp, #12]
 800c3f6:	4629      	mov	r1, r5
 800c3f8:	bfb8      	it	lt
 800c3fa:	1ce9      	addlt	r1, r5, #3
 800c3fc:	1089      	asrs	r1, r1, #2
 800c3fe:	2b00      	cmp	r3, #0
 800c400:	f040 80a4 	bne.w	800c54c <forward_concat+0x3e4>
 800c404:	2e00      	cmp	r6, #0
 800c406:	f000 80f4 	beq.w	800c5f2 <forward_concat+0x48a>
 800c40a:	6873      	ldr	r3, [r6, #4]
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	f000 80f0 	beq.w	800c5f2 <forward_concat+0x48a>
 800c412:	8872      	ldrh	r2, [r6, #2]
 800c414:	2a00      	cmp	r2, #0
 800c416:	f000 80ec 	beq.w	800c5f2 <forward_concat+0x48a>
 800c41a:	685b      	ldr	r3, [r3, #4]
 800c41c:	781b      	ldrb	r3, [r3, #0]
 800c41e:	ee06 3a90 	vmov	s13, r3
 800c422:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c426:	ee76 6aa9 	vadd.f32	s13, s13, s19
 800c42a:	454c      	cmp	r4, r9
 800c42c:	d226      	bcs.n	800c47c <forward_concat+0x314>
 800c42e:	2d03      	cmp	r5, #3
 800c430:	ebaa 0a01 	sub.w	sl, sl, r1
 800c434:	bfc8      	it	gt
 800c436:	46de      	movgt	lr, fp
 800c438:	dd20      	ble.n	800c47c <forward_concat+0x314>
 800c43a:	46f4      	mov	ip, lr
 800c43c:	4620      	mov	r0, r4
 800c43e:	2200      	movs	r2, #0
 800c440:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c444:	ee07 3a10 	vmov	s14, r3
 800c448:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c44c:	eef0 7a66 	vmov.f32	s15, s13
 800c450:	eee7 7a09 	vfma.f32	s15, s14, s18
 800c454:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c458:	ee17 3a90 	vmov	r3, s15
 800c45c:	f383 0308 	usat	r3, #8, r3
 800c460:	3201      	adds	r2, #1
 800c462:	4291      	cmp	r1, r2
 800c464:	f80c 3b01 	strb.w	r3, [ip], #1
 800c468:	dcea      	bgt.n	800c440 <forward_concat+0x2d8>
 800c46a:	2d03      	cmp	r5, #3
 800c46c:	bfcc      	ite	gt
 800c46e:	460b      	movgt	r3, r1
 800c470:	2301      	movle	r3, #1
 800c472:	441c      	add	r4, r3
 800c474:	45a1      	cmp	r9, r4
 800c476:	4453      	add	r3, sl
 800c478:	449e      	add	lr, r3
 800c47a:	d8de      	bhi.n	800c43a <forward_concat+0x2d2>
 800c47c:	448b      	add	fp, r1
 800c47e:	f8b8 1000 	ldrh.w	r1, [r8]
 800c482:	3701      	adds	r7, #1
 800c484:	e711      	b.n	800c2aa <forward_concat+0x142>
 800c486:	b140      	cbz	r0, 800c49a <forward_concat+0x332>
 800c488:	6843      	ldr	r3, [r0, #4]
 800c48a:	2b00      	cmp	r3, #0
 800c48c:	f000 80e4 	beq.w	800c658 <forward_concat+0x4f0>
 800c490:	8840      	ldrh	r0, [r0, #2]
 800c492:	b110      	cbz	r0, 800c49a <forward_concat+0x332>
 800c494:	685b      	ldr	r3, [r3, #4]
 800c496:	f993 0000 	ldrsb.w	r0, [r3]
 800c49a:	2e00      	cmp	r6, #0
 800c49c:	f000 80ae 	beq.w	800c5fc <forward_concat+0x494>
 800c4a0:	6872      	ldr	r2, [r6, #4]
 800c4a2:	2a00      	cmp	r2, #0
 800c4a4:	f000 80da 	beq.w	800c65c <forward_concat+0x4f4>
 800c4a8:	8873      	ldrh	r3, [r6, #2]
 800c4aa:	b113      	cbz	r3, 800c4b2 <forward_concat+0x34a>
 800c4ac:	6853      	ldr	r3, [r2, #4]
 800c4ae:	f993 3000 	ldrsb.w	r3, [r3]
 800c4b2:	eeb4 8a66 	vcmp.f32	s16, s13
 800c4b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c4ba:	d102      	bne.n	800c4c2 <forward_concat+0x35a>
 800c4bc:	4298      	cmp	r0, r3
 800c4be:	f000 809f 	beq.w	800c600 <forward_concat+0x498>
 800c4c2:	454c      	cmp	r4, r9
 800c4c4:	ee66 6a89 	vmul.f32	s13, s13, s18
 800c4c8:	d22f      	bcs.n	800c52a <forward_concat+0x3c2>
 800c4ca:	2d00      	cmp	r5, #0
 800c4cc:	dd2d      	ble.n	800c52a <forward_concat+0x3c2>
 800c4ce:	ee07 3a90 	vmov	s15, r3
 800c4d2:	eb0b 0e05 	add.w	lr, fp, r5
 800c4d6:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 800c4da:	46f4      	mov	ip, lr
 800c4dc:	465a      	mov	r2, fp
 800c4de:	4621      	mov	r1, r4
 800c4e0:	f911 3b01 	ldrsb.w	r3, [r1], #1
 800c4e4:	1a1b      	subs	r3, r3, r0
 800c4e6:	ee07 3a90 	vmov	s15, r3
 800c4ea:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800c4ee:	eef0 7a46 	vmov.f32	s15, s12
 800c4f2:	eee7 7a26 	vfma.f32	s15, s14, s13
 800c4f6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c4fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c4fe:	bf4c      	ite	mi
 800c500:	ee77 7aca 	vsubmi.f32	s15, s15, s20
 800c504:	ee77 7aa9 	vaddpl.f32	s15, s15, s19
 800c508:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c50c:	ee17 3a90 	vmov	r3, s15
 800c510:	f303 0307 	ssat	r3, #8, r3
 800c514:	f802 3b01 	strb.w	r3, [r2], #1
 800c518:	4562      	cmp	r2, ip
 800c51a:	d1e1      	bne.n	800c4e0 <forward_concat+0x378>
 800c51c:	442c      	add	r4, r5
 800c51e:	454c      	cmp	r4, r9
 800c520:	44d3      	add	fp, sl
 800c522:	44d4      	add	ip, sl
 800c524:	d3da      	bcc.n	800c4dc <forward_concat+0x374>
 800c526:	46f3      	mov	fp, lr
 800c528:	e7a9      	b.n	800c47e <forward_concat+0x316>
 800c52a:	eb0b 0e05 	add.w	lr, fp, r5
 800c52e:	46f3      	mov	fp, lr
 800c530:	e7a5      	b.n	800c47e <forward_concat+0x316>
 800c532:	4633      	mov	r3, r6
 800c534:	e701      	b.n	800c33a <forward_concat+0x1d2>
 800c536:	eef0 6a68 	vmov.f32	s13, s17
 800c53a:	4602      	mov	r2, r0
 800c53c:	e6f1      	b.n	800c322 <forward_concat+0x1ba>
 800c53e:	bf00      	nop
 800c540:	3efffffc 	.word	0x3efffffc
 800c544:	7f800000 	.word	0x7f800000
 800c548:	00000000 	.word	0x00000000
 800c54c:	2e00      	cmp	r6, #0
 800c54e:	f000 809c 	beq.w	800c68a <forward_concat+0x522>
 800c552:	6873      	ldr	r3, [r6, #4]
 800c554:	2b00      	cmp	r3, #0
 800c556:	f000 809e 	beq.w	800c696 <forward_concat+0x52e>
 800c55a:	8872      	ldrh	r2, [r6, #2]
 800c55c:	2a00      	cmp	r2, #0
 800c55e:	f000 8097 	beq.w	800c690 <forward_concat+0x528>
 800c562:	685b      	ldr	r3, [r3, #4]
 800c564:	f993 3000 	ldrsb.w	r3, [r3]
 800c568:	ee06 3a90 	vmov	s13, r3
 800c56c:	454c      	cmp	r4, r9
 800c56e:	d285      	bcs.n	800c47c <forward_concat+0x314>
 800c570:	2d03      	cmp	r5, #3
 800c572:	ebaa 0a01 	sub.w	sl, sl, r1
 800c576:	dd81      	ble.n	800c47c <forward_concat+0x314>
 800c578:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c57c:	46de      	mov	lr, fp
 800c57e:	46f4      	mov	ip, lr
 800c580:	4620      	mov	r0, r4
 800c582:	2200      	movs	r2, #0
 800c584:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c588:	ee07 3a10 	vmov	s14, r3
 800c58c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c590:	eef0 7a66 	vmov.f32	s15, s13
 800c594:	eee7 7a09 	vfma.f32	s15, s14, s18
 800c598:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c59c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c5a0:	bf4c      	ite	mi
 800c5a2:	ee77 7aca 	vsubmi.f32	s15, s15, s20
 800c5a6:	ee77 7aa9 	vaddpl.f32	s15, s15, s19
 800c5aa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c5ae:	ee17 3a90 	vmov	r3, s15
 800c5b2:	f303 0307 	ssat	r3, #8, r3
 800c5b6:	3201      	adds	r2, #1
 800c5b8:	4291      	cmp	r1, r2
 800c5ba:	f80c 3b01 	strb.w	r3, [ip], #1
 800c5be:	dce1      	bgt.n	800c584 <forward_concat+0x41c>
 800c5c0:	2d03      	cmp	r5, #3
 800c5c2:	bfcc      	ite	gt
 800c5c4:	460b      	movgt	r3, r1
 800c5c6:	2301      	movle	r3, #1
 800c5c8:	441c      	add	r4, r3
 800c5ca:	45a1      	cmp	r9, r4
 800c5cc:	4453      	add	r3, sl
 800c5ce:	449e      	add	lr, r3
 800c5d0:	d8d5      	bhi.n	800c57e <forward_concat+0x416>
 800c5d2:	e753      	b.n	800c47c <forward_concat+0x314>
 800c5d4:	eef0 6a68 	vmov.f32	s13, s17
 800c5d8:	e6a3      	b.n	800c322 <forward_concat+0x1ba>
 800c5da:	eef0 6a68 	vmov.f32	s13, s17
 800c5de:	460a      	mov	r2, r1
 800c5e0:	e69f      	b.n	800c322 <forward_concat+0x1ba>
 800c5e2:	460b      	mov	r3, r1
 800c5e4:	e6a9      	b.n	800c33a <forward_concat+0x1d2>
 800c5e6:	9903      	ldr	r1, [sp, #12]
 800c5e8:	2e00      	cmp	r6, #0
 800c5ea:	f47f aec2 	bne.w	800c372 <forward_concat+0x20a>
 800c5ee:	4633      	mov	r3, r6
 800c5f0:	e6c7      	b.n	800c382 <forward_concat+0x21a>
 800c5f2:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 800c5f6:	e718      	b.n	800c42a <forward_concat+0x2c2>
 800c5f8:	4619      	mov	r1, r3
 800c5fa:	e6b7      	b.n	800c36c <forward_concat+0x204>
 800c5fc:	4633      	mov	r3, r6
 800c5fe:	e758      	b.n	800c4b2 <forward_concat+0x34a>
 800c600:	454c      	cmp	r4, r9
 800c602:	d292      	bcs.n	800c52a <forward_concat+0x3c2>
 800c604:	9600      	str	r6, [sp, #0]
 800c606:	462e      	mov	r6, r5
 800c608:	464d      	mov	r5, r9
 800c60a:	46d9      	mov	r9, fp
 800c60c:	4649      	mov	r1, r9
 800c60e:	4620      	mov	r0, r4
 800c610:	4632      	mov	r2, r6
 800c612:	4434      	add	r4, r6
 800c614:	f000 fb56 	bl	800ccc4 <st_int8_copy>
 800c618:	42a5      	cmp	r5, r4
 800c61a:	44d1      	add	r9, sl
 800c61c:	d8f6      	bhi.n	800c60c <forward_concat+0x4a4>
 800c61e:	4635      	mov	r5, r6
 800c620:	9e00      	ldr	r6, [sp, #0]
 800c622:	eb0b 0e05 	add.w	lr, fp, r5
 800c626:	46f3      	mov	fp, lr
 800c628:	e729      	b.n	800c47e <forward_concat+0x316>
 800c62a:	454c      	cmp	r4, r9
 800c62c:	f4bf af7d 	bcs.w	800c52a <forward_concat+0x3c2>
 800c630:	9600      	str	r6, [sp, #0]
 800c632:	462e      	mov	r6, r5
 800c634:	464d      	mov	r5, r9
 800c636:	46d9      	mov	r9, fp
 800c638:	4649      	mov	r1, r9
 800c63a:	4620      	mov	r0, r4
 800c63c:	4632      	mov	r2, r6
 800c63e:	4434      	add	r4, r6
 800c640:	f000 fb40 	bl	800ccc4 <st_int8_copy>
 800c644:	42a5      	cmp	r5, r4
 800c646:	44d1      	add	r9, sl
 800c648:	d8f6      	bhi.n	800c638 <forward_concat+0x4d0>
 800c64a:	4635      	mov	r5, r6
 800c64c:	eb0b 0e05 	add.w	lr, fp, r5
 800c650:	9e00      	ldr	r6, [sp, #0]
 800c652:	e7e8      	b.n	800c626 <forward_concat+0x4be>
 800c654:	4613      	mov	r3, r2
 800c656:	e694      	b.n	800c382 <forward_concat+0x21a>
 800c658:	4618      	mov	r0, r3
 800c65a:	e71e      	b.n	800c49a <forward_concat+0x332>
 800c65c:	4613      	mov	r3, r2
 800c65e:	e728      	b.n	800c4b2 <forward_concat+0x34a>
 800c660:	454c      	cmp	r4, r9
 800c662:	f4bf af62 	bcs.w	800c52a <forward_concat+0x3c2>
 800c666:	9600      	str	r6, [sp, #0]
 800c668:	462e      	mov	r6, r5
 800c66a:	464d      	mov	r5, r9
 800c66c:	46d9      	mov	r9, fp
 800c66e:	4649      	mov	r1, r9
 800c670:	4620      	mov	r0, r4
 800c672:	4632      	mov	r2, r6
 800c674:	4434      	add	r4, r6
 800c676:	f000 fb25 	bl	800ccc4 <st_int8_copy>
 800c67a:	42a5      	cmp	r5, r4
 800c67c:	44d1      	add	r9, sl
 800c67e:	d8f6      	bhi.n	800c66e <forward_concat+0x506>
 800c680:	4635      	mov	r5, r6
 800c682:	eb0b 0e05 	add.w	lr, fp, r5
 800c686:	9e00      	ldr	r6, [sp, #0]
 800c688:	e7cd      	b.n	800c626 <forward_concat+0x4be>
 800c68a:	ee06 6a90 	vmov	s13, r6
 800c68e:	e76d      	b.n	800c56c <forward_concat+0x404>
 800c690:	ee06 2a90 	vmov	s13, r2
 800c694:	e76a      	b.n	800c56c <forward_concat+0x404>
 800c696:	ee06 3a90 	vmov	s13, r3
 800c69a:	e767      	b.n	800c56c <forward_concat+0x404>
 800c69c:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 800c6a0:	ed1f 9a58 	vldr	s18, [pc, #-352]	; 800c544 <forward_concat+0x3dc>
 800c6a4:	ed1f 8a58 	vldr	s16, [pc, #-352]	; 800c548 <forward_concat+0x3e0>
 800c6a8:	9303      	str	r3, [sp, #12]
 800c6aa:	e5f4      	b.n	800c296 <forward_concat+0x12e>
 800c6ac:	2300      	movs	r3, #0
 800c6ae:	e564      	b.n	800c17a <forward_concat+0x12>

0800c6b0 <forward_eltwise>:
 800c6b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c6b4:	6982      	ldr	r2, [r0, #24]
 800c6b6:	b09d      	sub	sp, #116	; 0x74
 800c6b8:	8811      	ldrh	r1, [r2, #0]
 800c6ba:	9003      	str	r0, [sp, #12]
 800c6bc:	2900      	cmp	r1, #0
 800c6be:	f000 80c7 	beq.w	800c850 <forward_eltwise+0x1a0>
 800c6c2:	6853      	ldr	r3, [r2, #4]
 800c6c4:	2b00      	cmp	r3, #0
 800c6c6:	f000 810f 	beq.w	800c8e8 <forward_eltwise+0x238>
 800c6ca:	881d      	ldrh	r5, [r3, #0]
 800c6cc:	f8d3 8004 	ldr.w	r8, [r3, #4]
 800c6d0:	f1b8 0f00 	cmp.w	r8, #0
 800c6d4:	d001      	beq.n	800c6da <forward_eltwise+0x2a>
 800c6d6:	f8d8 8000 	ldr.w	r8, [r8]
 800c6da:	2901      	cmp	r1, #1
 800c6dc:	f000 8108 	beq.w	800c8f0 <forward_eltwise+0x240>
 800c6e0:	691b      	ldr	r3, [r3, #16]
 800c6e2:	9300      	str	r3, [sp, #0]
 800c6e4:	b10b      	cbz	r3, 800c6ea <forward_eltwise+0x3a>
 800c6e6:	681b      	ldr	r3, [r3, #0]
 800c6e8:	9300      	str	r3, [sp, #0]
 800c6ea:	2300      	movs	r3, #0
 800c6ec:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 800c6f0:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
 800c6f4:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 800c6f8:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
 800c6fc:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 800c700:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
 800c704:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
 800c708:	931b      	str	r3, [sp, #108]	; 0x6c
 800c70a:	f240 5302 	movw	r3, #1282	; 0x502
 800c70e:	9307      	str	r3, [sp, #28]
 800c710:	9309      	str	r3, [sp, #36]	; 0x24
 800c712:	f240 5301 	movw	r3, #1281	; 0x501
 800c716:	930b      	str	r3, [sp, #44]	; 0x2c
 800c718:	9b03      	ldr	r3, [sp, #12]
 800c71a:	e9d3 7307 	ldrd	r7, r3, [r3, #28]
 800c71e:	ac0d      	add	r4, sp, #52	; 0x34
 800c720:	a812      	add	r0, sp, #72	; 0x48
 800c722:	a917      	add	r1, sp, #92	; 0x5c
 800c724:	2d01      	cmp	r5, #1
 800c726:	9408      	str	r4, [sp, #32]
 800c728:	900a      	str	r0, [sp, #40]	; 0x28
 800c72a:	910c      	str	r1, [sp, #48]	; 0x30
 800c72c:	9304      	str	r3, [sp, #16]
 800c72e:	f240 80d8 	bls.w	800c8e2 <forward_eltwise+0x232>
 800c732:	00ab      	lsls	r3, r5, #2
 800c734:	9305      	str	r3, [sp, #20]
 800c736:	2304      	movs	r3, #4
 800c738:	9301      	str	r3, [sp, #4]
 800c73a:	8813      	ldrh	r3, [r2, #0]
 800c73c:	2b00      	cmp	r3, #0
 800c73e:	f000 80da 	beq.w	800c8f6 <forward_eltwise+0x246>
 800c742:	6853      	ldr	r3, [r2, #4]
 800c744:	685b      	ldr	r3, [r3, #4]
 800c746:	2b00      	cmp	r3, #0
 800c748:	f000 80d0 	beq.w	800c8ec <forward_eltwise+0x23c>
 800c74c:	9a01      	ldr	r2, [sp, #4]
 800c74e:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800c752:	f853 a002 	ldr.w	sl, [r3, r2]
 800c756:	f8da 3008 	ldr.w	r3, [sl, #8]
 800c75a:	4043      	eors	r3, r0
 800c75c:	f033 03ff 	bics.w	r3, r3, #255	; 0xff
 800c760:	f108 0108 	add.w	r1, r8, #8
 800c764:	f10a 0908 	add.w	r9, sl, #8
 800c768:	d10f      	bne.n	800c78a <forward_eltwise+0xda>
 800c76a:	f3c0 2017 	ubfx	r0, r0, #8, #24
 800c76e:	2800      	cmp	r0, #0
 800c770:	f000 8095 	beq.w	800c89e <forward_eltwise+0x1ee>
 800c774:	3801      	subs	r0, #1
 800c776:	f8d8 200c 	ldr.w	r2, [r8, #12]
 800c77a:	f8da 300c 	ldr.w	r3, [sl, #12]
 800c77e:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800c782:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800c786:	429a      	cmp	r2, r3
 800c788:	d0f1      	beq.n	800c76e <forward_eltwise+0xbe>
 800c78a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800c78e:	9102      	str	r1, [sp, #8]
 800c790:	689d      	ldr	r5, [r3, #8]
 800c792:	f8da 3018 	ldr.w	r3, [sl, #24]
 800c796:	689c      	ldr	r4, [r3, #8]
 800c798:	9b00      	ldr	r3, [sp, #0]
 800c79a:	699b      	ldr	r3, [r3, #24]
 800c79c:	464a      	mov	r2, r9
 800c79e:	a80b      	add	r0, sp, #44	; 0x2c
 800c7a0:	689e      	ldr	r6, [r3, #8]
 800c7a2:	f000 fc41 	bl	800d028 <core_get_broadcasted_shape>
 800c7a6:	f8da 2014 	ldr.w	r2, [sl, #20]
 800c7aa:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800c7ae:	f8d2 a004 	ldr.w	sl, [r2, #4]
 800c7b2:	9a00      	ldr	r2, [sp, #0]
 800c7b4:	685b      	ldr	r3, [r3, #4]
 800c7b6:	6952      	ldr	r2, [r2, #20]
 800c7b8:	9902      	ldr	r1, [sp, #8]
 800c7ba:	f8d2 8004 	ldr.w	r8, [r2, #4]
 800c7be:	a807      	add	r0, sp, #28
 800c7c0:	aa0b      	add	r2, sp, #44	; 0x2c
 800c7c2:	f000 fc5d 	bl	800d080 <core_compute_offsets>
 800c7c6:	4653      	mov	r3, sl
 800c7c8:	aa0b      	add	r2, sp, #44	; 0x2c
 800c7ca:	4649      	mov	r1, r9
 800c7cc:	a809      	add	r0, sp, #36	; 0x24
 800c7ce:	f000 fc57 	bl	800d080 <core_compute_offsets>
 800c7d2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c7d4:	68d3      	ldr	r3, [r2, #12]
 800c7d6:	2b00      	cmp	r3, #0
 800c7d8:	d056      	beq.n	800c888 <forward_eltwise+0x1d8>
 800c7da:	2300      	movs	r3, #0
 800c7dc:	6890      	ldr	r0, [r2, #8]
 800c7de:	9302      	str	r3, [sp, #8]
 800c7e0:	2800      	cmp	r0, #0
 800c7e2:	d051      	beq.n	800c888 <forward_eltwise+0x1d8>
 800c7e4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800c7e6:	f04f 0b00 	mov.w	fp, #0
 800c7ea:	f3c1 2117 	ubfx	r1, r1, #8, #24
 800c7ee:	f04f 0a00 	mov.w	sl, #0
 800c7f2:	2904      	cmp	r1, #4
 800c7f4:	bf8c      	ite	hi
 800c7f6:	6913      	ldrhi	r3, [r2, #16]
 800c7f8:	2301      	movls	r3, #1
 800c7fa:	459a      	cmp	sl, r3
 800c7fc:	d22a      	bcs.n	800c854 <forward_eltwise+0x1a4>
 800c7fe:	6850      	ldr	r0, [r2, #4]
 800c800:	f04f 0900 	mov.w	r9, #0
 800c804:	b198      	cbz	r0, 800c82e <forward_eltwise+0x17e>
 800c806:	4622      	mov	r2, r4
 800c808:	4629      	mov	r1, r5
 800c80a:	4630      	mov	r0, r6
 800c80c:	47b8      	blx	r7
 800c80e:	9b08      	ldr	r3, [sp, #32]
 800c810:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c812:	685b      	ldr	r3, [r3, #4]
 800c814:	441d      	add	r5, r3
 800c816:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c818:	685b      	ldr	r3, [r3, #4]
 800c81a:	441c      	add	r4, r3
 800c81c:	6853      	ldr	r3, [r2, #4]
 800c81e:	f109 0901 	add.w	r9, r9, #1
 800c822:	454b      	cmp	r3, r9
 800c824:	4446      	add	r6, r8
 800c826:	d8ee      	bhi.n	800c806 <forward_eltwise+0x156>
 800c828:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c82a:	f3c3 2117 	ubfx	r1, r3, #8, #24
 800c82e:	9807      	ldr	r0, [sp, #28]
 800c830:	f5b0 6fa0 	cmp.w	r0, #1280	; 0x500
 800c834:	d302      	bcc.n	800c83c <forward_eltwise+0x18c>
 800c836:	9808      	ldr	r0, [sp, #32]
 800c838:	6903      	ldr	r3, [r0, #16]
 800c83a:	441d      	add	r5, r3
 800c83c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800c83e:	f5b0 6fa0 	cmp.w	r0, #1280	; 0x500
 800c842:	d302      	bcc.n	800c84a <forward_eltwise+0x19a>
 800c844:	980a      	ldr	r0, [sp, #40]	; 0x28
 800c846:	6903      	ldr	r3, [r0, #16]
 800c848:	441c      	add	r4, r3
 800c84a:	f10a 0a01 	add.w	sl, sl, #1
 800c84e:	e7d0      	b.n	800c7f2 <forward_eltwise+0x142>
 800c850:	684b      	ldr	r3, [r1, #4]
 800c852:	deff      	udf	#255	; 0xff
 800c854:	9b08      	ldr	r3, [sp, #32]
 800c856:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 800c85a:	6898      	ldr	r0, [r3, #8]
 800c85c:	4405      	add	r5, r0
 800c85e:	f8dc 0008 	ldr.w	r0, [ip, #8]
 800c862:	4404      	add	r4, r0
 800c864:	6890      	ldr	r0, [r2, #8]
 800c866:	f10b 0b01 	add.w	fp, fp, #1
 800c86a:	4558      	cmp	r0, fp
 800c86c:	d8bf      	bhi.n	800c7ee <forward_eltwise+0x13e>
 800c86e:	68d9      	ldr	r1, [r3, #12]
 800c870:	469e      	mov	lr, r3
 800c872:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800c876:	441c      	add	r4, r3
 800c878:	9b02      	ldr	r3, [sp, #8]
 800c87a:	3301      	adds	r3, #1
 800c87c:	440d      	add	r5, r1
 800c87e:	9302      	str	r3, [sp, #8]
 800c880:	4619      	mov	r1, r3
 800c882:	68d3      	ldr	r3, [r2, #12]
 800c884:	428b      	cmp	r3, r1
 800c886:	d8ab      	bhi.n	800c7e0 <forward_eltwise+0x130>
 800c888:	9b01      	ldr	r3, [sp, #4]
 800c88a:	9a05      	ldr	r2, [sp, #20]
 800c88c:	3304      	adds	r3, #4
 800c88e:	4293      	cmp	r3, r2
 800c890:	9301      	str	r3, [sp, #4]
 800c892:	d026      	beq.n	800c8e2 <forward_eltwise+0x232>
 800c894:	9b03      	ldr	r3, [sp, #12]
 800c896:	f8dd 8000 	ldr.w	r8, [sp]
 800c89a:	699a      	ldr	r2, [r3, #24]
 800c89c:	e74d      	b.n	800c73a <forward_eltwise+0x8a>
 800c89e:	9b00      	ldr	r3, [sp, #0]
 800c8a0:	f8da 0018 	ldr.w	r0, [sl, #24]
 800c8a4:	699b      	ldr	r3, [r3, #24]
 800c8a6:	f8d8 4018 	ldr.w	r4, [r8, #24]
 800c8aa:	6885      	ldr	r5, [r0, #8]
 800c8ac:	689e      	ldr	r6, [r3, #8]
 800c8ae:	68a4      	ldr	r4, [r4, #8]
 800c8b0:	464a      	mov	r2, r9
 800c8b2:	a80b      	add	r0, sp, #44	; 0x2c
 800c8b4:	f000 fbb8 	bl	800d028 <core_get_broadcasted_shape>
 800c8b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c8ba:	0a1b      	lsrs	r3, r3, #8
 800c8bc:	bf08      	it	eq
 800c8be:	2301      	moveq	r3, #1
 800c8c0:	d009      	beq.n	800c8d6 <forward_eltwise+0x226>
 800c8c2:	980c      	ldr	r0, [sp, #48]	; 0x30
 800c8c4:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 800c8c8:	2301      	movs	r3, #1
 800c8ca:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 800c8ce:	4290      	cmp	r0, r2
 800c8d0:	fb01 f303 	mul.w	r3, r1, r3
 800c8d4:	d1f9      	bne.n	800c8ca <forward_eltwise+0x21a>
 800c8d6:	4621      	mov	r1, r4
 800c8d8:	462a      	mov	r2, r5
 800c8da:	9c04      	ldr	r4, [sp, #16]
 800c8dc:	4630      	mov	r0, r6
 800c8de:	47a0      	blx	r4
 800c8e0:	e7d2      	b.n	800c888 <forward_eltwise+0x1d8>
 800c8e2:	b01d      	add	sp, #116	; 0x74
 800c8e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c8e8:	461d      	mov	r5, r3
 800c8ea:	e6ef      	b.n	800c6cc <forward_eltwise+0x1c>
 800c8ec:	689b      	ldr	r3, [r3, #8]
 800c8ee:	deff      	udf	#255	; 0xff
 800c8f0:	2300      	movs	r3, #0
 800c8f2:	685b      	ldr	r3, [r3, #4]
 800c8f4:	deff      	udf	#255	; 0xff
 800c8f6:	685b      	ldr	r3, [r3, #4]
 800c8f8:	deff      	udf	#255	; 0xff
 800c8fa:	bf00      	nop

0800c8fc <forward_elu>:
 800c8fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c8fe:	ed2d 8b04 	vpush	{d8-d9}
 800c902:	6982      	ldr	r2, [r0, #24]
 800c904:	8813      	ldrh	r3, [r2, #0]
 800c906:	2b00      	cmp	r3, #0
 800c908:	d051      	beq.n	800c9ae <forward_elu+0xb2>
 800c90a:	6851      	ldr	r1, [r2, #4]
 800c90c:	684a      	ldr	r2, [r1, #4]
 800c90e:	b102      	cbz	r2, 800c912 <forward_elu+0x16>
 800c910:	6812      	ldr	r2, [r2, #0]
 800c912:	2b01      	cmp	r3, #1
 800c914:	d04a      	beq.n	800c9ac <forward_elu+0xb0>
 800c916:	690b      	ldr	r3, [r1, #16]
 800c918:	2b00      	cmp	r3, #0
 800c91a:	d050      	beq.n	800c9be <forward_elu+0xc2>
 800c91c:	681b      	ldr	r3, [r3, #0]
 800c91e:	6991      	ldr	r1, [r2, #24]
 800c920:	699c      	ldr	r4, [r3, #24]
 800c922:	6893      	ldr	r3, [r2, #8]
 800c924:	68a7      	ldr	r7, [r4, #8]
 800c926:	688e      	ldr	r6, [r1, #8]
 800c928:	0a1b      	lsrs	r3, r3, #8
 800c92a:	d042      	beq.n	800c9b2 <forward_elu+0xb6>
 800c92c:	68d4      	ldr	r4, [r2, #12]
 800c92e:	2201      	movs	r2, #1
 800c930:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800c934:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800c938:	429c      	cmp	r4, r3
 800c93a:	fb01 f202 	mul.w	r2, r1, r2
 800c93e:	d1f9      	bne.n	800c934 <forward_elu+0x38>
 800c940:	69c3      	ldr	r3, [r0, #28]
 800c942:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800c946:	3a01      	subs	r2, #1
 800c948:	689b      	ldr	r3, [r3, #8]
 800c94a:	eb06 0582 	add.w	r5, r6, r2, lsl #2
 800c94e:	42ae      	cmp	r6, r5
 800c950:	ed93 9a00 	vldr	s18, [r3]
 800c954:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 800c958:	d825      	bhi.n	800c9a6 <forward_elu+0xaa>
 800c95a:	eddf 8a1a 	vldr	s17, [pc, #104]	; 800c9c4 <forward_elu+0xc8>
 800c95e:	3504      	adds	r5, #4
 800c960:	3704      	adds	r7, #4
 800c962:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 800c966:	462c      	mov	r4, r5
 800c968:	ed35 8a01 	vldmdb	r5!, {s16}
 800c96c:	eeb0 0a48 	vmov.f32	s0, s16
 800c970:	f001 fbb8 	bl	800e0e4 <expf>
 800c974:	ee30 0a69 	vsub.f32	s0, s0, s19
 800c978:	3c08      	subs	r4, #8
 800c97a:	ee60 7a09 	vmul.f32	s15, s0, s18
 800c97e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c986:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800c98a:	bf88      	it	hi
 800c98c:	eef0 7a68 	vmovhi.f32	s15, s17
 800c990:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c994:	bfb8      	it	lt
 800c996:	eeb0 8a68 	vmovlt.f32	s16, s17
 800c99a:	ee77 7a88 	vadd.f32	s15, s15, s16
 800c99e:	42a6      	cmp	r6, r4
 800c9a0:	ed67 7a01 	vstmdb	r7!, {s15}
 800c9a4:	d9df      	bls.n	800c966 <forward_elu+0x6a>
 800c9a6:	ecbd 8b04 	vpop	{d8-d9}
 800c9aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c9ac:	2300      	movs	r3, #0
 800c9ae:	685b      	ldr	r3, [r3, #4]
 800c9b0:	deff      	udf	#255	; 0xff
 800c9b2:	69c3      	ldr	r3, [r0, #28]
 800c9b4:	689b      	ldr	r3, [r3, #8]
 800c9b6:	4635      	mov	r5, r6
 800c9b8:	ed93 9a00 	vldr	s18, [r3]
 800c9bc:	e7cd      	b.n	800c95a <forward_elu+0x5e>
 800c9be:	699b      	ldr	r3, [r3, #24]
 800c9c0:	deff      	udf	#255	; 0xff
 800c9c2:	bf00      	nop
 800c9c4:	00000000 	.word	0x00000000

0800c9c8 <forward_clip>:
 800c9c8:	6982      	ldr	r2, [r0, #24]
 800c9ca:	8813      	ldrh	r3, [r2, #0]
 800c9cc:	2b00      	cmp	r3, #0
 800c9ce:	d045      	beq.n	800ca5c <forward_clip+0x94>
 800c9d0:	6851      	ldr	r1, [r2, #4]
 800c9d2:	684a      	ldr	r2, [r1, #4]
 800c9d4:	b102      	cbz	r2, 800c9d8 <forward_clip+0x10>
 800c9d6:	6812      	ldr	r2, [r2, #0]
 800c9d8:	2b01      	cmp	r3, #1
 800c9da:	d049      	beq.n	800ca70 <forward_clip+0xa8>
 800c9dc:	690b      	ldr	r3, [r1, #16]
 800c9de:	2b00      	cmp	r3, #0
 800c9e0:	d049      	beq.n	800ca76 <forward_clip+0xae>
 800c9e2:	b470      	push	{r4, r5, r6}
 800c9e4:	681b      	ldr	r3, [r3, #0]
 800c9e6:	6994      	ldr	r4, [r2, #24]
 800c9e8:	6999      	ldr	r1, [r3, #24]
 800c9ea:	6893      	ldr	r3, [r2, #8]
 800c9ec:	6889      	ldr	r1, [r1, #8]
 800c9ee:	68a5      	ldr	r5, [r4, #8]
 800c9f0:	0a1b      	lsrs	r3, r3, #8
 800c9f2:	d035      	beq.n	800ca60 <forward_clip+0x98>
 800c9f4:	68d6      	ldr	r6, [r2, #12]
 800c9f6:	2201      	movs	r2, #1
 800c9f8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800c9fc:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800ca00:	429e      	cmp	r6, r3
 800ca02:	fb04 f202 	mul.w	r2, r4, r2
 800ca06:	d1f9      	bne.n	800c9fc <forward_clip+0x34>
 800ca08:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
 800ca0c:	69c0      	ldr	r0, [r0, #28]
 800ca0e:	3b01      	subs	r3, #1
 800ca10:	6880      	ldr	r0, [r0, #8]
 800ca12:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 800ca16:	4295      	cmp	r5, r2
 800ca18:	edd0 6a00 	vldr	s13, [r0]
 800ca1c:	ed90 7a01 	vldr	s14, [r0, #4]
 800ca20:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800ca24:	d818      	bhi.n	800ca58 <forward_clip+0x90>
 800ca26:	3204      	adds	r2, #4
 800ca28:	3104      	adds	r1, #4
 800ca2a:	4613      	mov	r3, r2
 800ca2c:	ed72 7a01 	vldmdb	r2!, {s15}
 800ca30:	eef4 7ae6 	vcmpe.f32	s15, s13
 800ca34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca38:	bfb8      	it	lt
 800ca3a:	eef0 7a66 	vmovlt.f32	s15, s13
 800ca3e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800ca42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca46:	f1a3 0308 	sub.w	r3, r3, #8
 800ca4a:	bf88      	it	hi
 800ca4c:	eef0 7a47 	vmovhi.f32	s15, s14
 800ca50:	429d      	cmp	r5, r3
 800ca52:	ed61 7a01 	vstmdb	r1!, {s15}
 800ca56:	d9e8      	bls.n	800ca2a <forward_clip+0x62>
 800ca58:	bc70      	pop	{r4, r5, r6}
 800ca5a:	4770      	bx	lr
 800ca5c:	685b      	ldr	r3, [r3, #4]
 800ca5e:	deff      	udf	#255	; 0xff
 800ca60:	69c3      	ldr	r3, [r0, #28]
 800ca62:	689b      	ldr	r3, [r3, #8]
 800ca64:	462a      	mov	r2, r5
 800ca66:	edd3 6a00 	vldr	s13, [r3]
 800ca6a:	ed93 7a01 	vldr	s14, [r3, #4]
 800ca6e:	e7da      	b.n	800ca26 <forward_clip+0x5e>
 800ca70:	2300      	movs	r3, #0
 800ca72:	685b      	ldr	r3, [r3, #4]
 800ca74:	deff      	udf	#255	; 0xff
 800ca76:	699b      	ldr	r3, [r3, #24]
 800ca78:	deff      	udf	#255	; 0xff
 800ca7a:	bf00      	nop

0800ca7c <forward_lite_dense_if32of32wf32>:
 800ca7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ca80:	e9dd 6409 	ldrd	r6, r4, [sp, #36]	; 0x24
 800ca84:	eb00 0784 	add.w	r7, r0, r4, lsl #2
 800ca88:	4287      	cmp	r7, r0
 800ca8a:	f240 8106 	bls.w	800cc9a <forward_lite_dense_if32of32wf32+0x21e>
 800ca8e:	f1a6 0810 	sub.w	r8, r6, #16
 800ca92:	ea4f 1818 	mov.w	r8, r8, lsr #4
 800ca96:	f108 0801 	add.w	r8, r8, #1
 800ca9a:	ea4f 1b88 	mov.w	fp, r8, lsl #6
 800ca9e:	ea4f 0986 	mov.w	r9, r6, lsl #2
 800caa2:	eb01 1888 	add.w	r8, r1, r8, lsl #6
 800caa6:	4605      	mov	r5, r0
 800caa8:	f006 0a0f 	and.w	sl, r6, #15
 800caac:	2e0f      	cmp	r6, #15
 800caae:	ed9f 7a84 	vldr	s14, [pc, #528]	; 800ccc0 <forward_lite_dense_if32of32wf32+0x244>
 800cab2:	f240 8101 	bls.w	800ccb8 <forward_lite_dense_if32of32wf32+0x23c>
 800cab6:	f101 0c40 	add.w	ip, r1, #64	; 0x40
 800caba:	f102 0440 	add.w	r4, r2, #64	; 0x40
 800cabe:	46b6      	mov	lr, r6
 800cac0:	ed54 5a0f 	vldr	s11, [r4, #-60]	; 0xffffffc4
 800cac4:	ed5c 7a0f 	vldr	s15, [ip, #-60]	; 0xffffffc4
 800cac8:	ed1c 6a10 	vldr	s12, [ip, #-64]	; 0xffffffc0
 800cacc:	ed54 6a10 	vldr	s13, [r4, #-64]	; 0xffffffc0
 800cad0:	ed5c 4a0d 	vldr	s9, [ip, #-52]	; 0xffffffcc
 800cad4:	ed1c 5a0c 	vldr	s10, [ip, #-48]	; 0xffffffd0
 800cad8:	ed1c 3a0a 	vldr	s6, [ip, #-40]	; 0xffffffd8
 800cadc:	ed54 3a0a 	vldr	s7, [r4, #-40]	; 0xffffffd8
 800cae0:	ed1c 4a09 	vldr	s8, [ip, #-36]	; 0xffffffdc
 800cae4:	ed1c 1a06 	vldr	s2, [ip, #-24]	; 0xffffffe8
 800cae8:	ed54 1a06 	vldr	s3, [r4, #-24]	; 0xffffffe8
 800caec:	ed1c 2a05 	vldr	s4, [ip, #-20]	; 0xffffffec
 800caf0:	ed54 2a05 	vldr	s5, [r4, #-20]	; 0xffffffec
 800caf4:	ee67 7aa5 	vmul.f32	s15, s15, s11
 800caf8:	ed5c 5a0e 	vldr	s11, [ip, #-56]	; 0xffffffc8
 800cafc:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb00:	f1ae 0e10 	sub.w	lr, lr, #16
 800cb04:	f1be 0f0f 	cmp.w	lr, #15
 800cb08:	ed14 6a0e 	vldr	s12, [r4, #-56]	; 0xffffffc8
 800cb0c:	ed54 6a0d 	vldr	s13, [r4, #-52]	; 0xffffffcc
 800cb10:	eee5 7a86 	vfma.f32	s15, s11, s12
 800cb14:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
 800cb18:	f104 0440 	add.w	r4, r4, #64	; 0x40
 800cb1c:	ed54 5a1c 	vldr	s11, [r4, #-112]	; 0xffffff90
 800cb20:	ed1c 6a1b 	vldr	s12, [ip, #-108]	; 0xffffff94
 800cb24:	eee4 7aa6 	vfma.f32	s15, s9, s13
 800cb28:	ed54 6a1b 	vldr	s13, [r4, #-108]	; 0xffffff94
 800cb2c:	ed54 4a19 	vldr	s9, [r4, #-100]	; 0xffffff9c
 800cb30:	eee5 7a25 	vfma.f32	s15, s10, s11
 800cb34:	ed1c 5a18 	vldr	s10, [ip, #-96]	; 0xffffffa0
 800cb38:	ed54 5a18 	vldr	s11, [r4, #-96]	; 0xffffffa0
 800cb3c:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb40:	ed1c 6a17 	vldr	s12, [ip, #-92]	; 0xffffffa4
 800cb44:	ed54 6a17 	vldr	s13, [r4, #-92]	; 0xffffffa4
 800cb48:	eee3 7a23 	vfma.f32	s15, s6, s7
 800cb4c:	ed1c 3a14 	vldr	s6, [ip, #-80]	; 0xffffffb0
 800cb50:	ed54 3a14 	vldr	s7, [r4, #-80]	; 0xffffffb0
 800cb54:	eee4 7a24 	vfma.f32	s15, s8, s9
 800cb58:	ed1c 4a13 	vldr	s8, [ip, #-76]	; 0xffffffb4
 800cb5c:	ed54 4a13 	vldr	s9, [r4, #-76]	; 0xffffffb4
 800cb60:	eee5 7a25 	vfma.f32	s15, s10, s11
 800cb64:	ed1c 5a12 	vldr	s10, [ip, #-72]	; 0xffffffb8
 800cb68:	ed54 5a12 	vldr	s11, [r4, #-72]	; 0xffffffb8
 800cb6c:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb70:	ed1c 6a11 	vldr	s12, [ip, #-68]	; 0xffffffbc
 800cb74:	ed54 6a11 	vldr	s13, [r4, #-68]	; 0xffffffbc
 800cb78:	eee1 7a21 	vfma.f32	s15, s2, s3
 800cb7c:	eee2 7a22 	vfma.f32	s15, s4, s5
 800cb80:	eee3 7a23 	vfma.f32	s15, s6, s7
 800cb84:	eee4 7a24 	vfma.f32	s15, s8, s9
 800cb88:	eee5 7a25 	vfma.f32	s15, s10, s11
 800cb8c:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb90:	ee37 7a27 	vadd.f32	s14, s14, s15
 800cb94:	d894      	bhi.n	800cac0 <forward_lite_dense_if32of32wf32+0x44>
 800cb96:	eb02 0e0b 	add.w	lr, r2, fp
 800cb9a:	4654      	mov	r4, sl
 800cb9c:	46c4      	mov	ip, r8
 800cb9e:	2c00      	cmp	r4, #0
 800cba0:	d075      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cba2:	eddc 6a00 	vldr	s13, [ip]
 800cba6:	edde 7a00 	vldr	s15, [lr]
 800cbaa:	2c01      	cmp	r4, #1
 800cbac:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbb0:	d06d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cbb2:	eddc 6a01 	vldr	s13, [ip, #4]
 800cbb6:	edde 7a01 	vldr	s15, [lr, #4]
 800cbba:	2c02      	cmp	r4, #2
 800cbbc:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbc0:	d065      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cbc2:	eddc 6a02 	vldr	s13, [ip, #8]
 800cbc6:	edde 7a02 	vldr	s15, [lr, #8]
 800cbca:	2c03      	cmp	r4, #3
 800cbcc:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbd0:	d05d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cbd2:	eddc 6a03 	vldr	s13, [ip, #12]
 800cbd6:	edde 7a03 	vldr	s15, [lr, #12]
 800cbda:	2c04      	cmp	r4, #4
 800cbdc:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbe0:	d055      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cbe2:	eddc 6a04 	vldr	s13, [ip, #16]
 800cbe6:	edde 7a04 	vldr	s15, [lr, #16]
 800cbea:	2c05      	cmp	r4, #5
 800cbec:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbf0:	d04d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cbf2:	eddc 6a05 	vldr	s13, [ip, #20]
 800cbf6:	edde 7a05 	vldr	s15, [lr, #20]
 800cbfa:	2c06      	cmp	r4, #6
 800cbfc:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc00:	d045      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc02:	eddc 6a06 	vldr	s13, [ip, #24]
 800cc06:	edde 7a06 	vldr	s15, [lr, #24]
 800cc0a:	2c07      	cmp	r4, #7
 800cc0c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc10:	d03d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc12:	eddc 6a07 	vldr	s13, [ip, #28]
 800cc16:	edde 7a07 	vldr	s15, [lr, #28]
 800cc1a:	2c08      	cmp	r4, #8
 800cc1c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc20:	d035      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc22:	eddc 6a08 	vldr	s13, [ip, #32]
 800cc26:	edde 7a08 	vldr	s15, [lr, #32]
 800cc2a:	2c09      	cmp	r4, #9
 800cc2c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc30:	d02d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc32:	eddc 6a09 	vldr	s13, [ip, #36]	; 0x24
 800cc36:	edde 7a09 	vldr	s15, [lr, #36]	; 0x24
 800cc3a:	2c0a      	cmp	r4, #10
 800cc3c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc40:	d025      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc42:	eddc 6a0a 	vldr	s13, [ip, #40]	; 0x28
 800cc46:	edde 7a0a 	vldr	s15, [lr, #40]	; 0x28
 800cc4a:	2c0b      	cmp	r4, #11
 800cc4c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc50:	d01d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc52:	eddc 6a0b 	vldr	s13, [ip, #44]	; 0x2c
 800cc56:	edde 7a0b 	vldr	s15, [lr, #44]	; 0x2c
 800cc5a:	2c0c      	cmp	r4, #12
 800cc5c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc60:	d015      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc62:	eddc 6a0c 	vldr	s13, [ip, #48]	; 0x30
 800cc66:	edde 7a0c 	vldr	s15, [lr, #48]	; 0x30
 800cc6a:	3c0d      	subs	r4, #13
 800cc6c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc70:	d00d      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc72:	eddc 6a0d 	vldr	s13, [ip, #52]	; 0x34
 800cc76:	edde 7a0d 	vldr	s15, [lr, #52]	; 0x34
 800cc7a:	2c01      	cmp	r4, #1
 800cc7c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc80:	d005      	beq.n	800cc8e <forward_lite_dense_if32of32wf32+0x212>
 800cc82:	edde 6a0e 	vldr	s13, [lr, #56]	; 0x38
 800cc86:	eddc 7a0e 	vldr	s15, [ip, #56]	; 0x38
 800cc8a:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc8e:	444a      	add	r2, r9
 800cc90:	eca5 7a01 	vstmia	r5!, {s14}
 800cc94:	42af      	cmp	r7, r5
 800cc96:	f63f af09 	bhi.w	800caac <forward_lite_dense_if32of32wf32+0x30>
 800cc9a:	b15b      	cbz	r3, 800ccb4 <forward_lite_dense_if32of32wf32+0x238>
 800cc9c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cc9e:	b14a      	cbz	r2, 800ccb4 <forward_lite_dense_if32of32wf32+0x238>
 800cca0:	edd0 7a00 	vldr	s15, [r0]
 800cca4:	ecb3 7a01 	vldmia	r3!, {s14}
 800cca8:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ccac:	ece0 7a01 	vstmia	r0!, {s15}
 800ccb0:	4287      	cmp	r7, r0
 800ccb2:	d1f5      	bne.n	800cca0 <forward_lite_dense_if32of32wf32+0x224>
 800ccb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ccb8:	4634      	mov	r4, r6
 800ccba:	4696      	mov	lr, r2
 800ccbc:	468c      	mov	ip, r1
 800ccbe:	e76e      	b.n	800cb9e <forward_lite_dense_if32of32wf32+0x122>
 800ccc0:	00000000 	.word	0x00000000

0800ccc4 <st_int8_copy>:
 800ccc4:	4288      	cmp	r0, r1
 800ccc6:	d057      	beq.n	800cd78 <st_int8_copy+0xb4>
 800ccc8:	2a00      	cmp	r2, #0
 800ccca:	d055      	beq.n	800cd78 <st_int8_copy+0xb4>
 800cccc:	4288      	cmp	r0, r1
 800ccce:	d354      	bcc.n	800cd7a <st_int8_copy+0xb6>
 800ccd0:	078b      	lsls	r3, r1, #30
 800ccd2:	d102      	bne.n	800ccda <st_int8_copy+0x16>
 800ccd4:	e009      	b.n	800ccea <st_int8_copy+0x26>
 800ccd6:	2a00      	cmp	r2, #0
 800ccd8:	d05c      	beq.n	800cd94 <st_int8_copy+0xd0>
 800ccda:	f910 3b01 	ldrsb.w	r3, [r0], #1
 800ccde:	f801 3b01 	strb.w	r3, [r1], #1
 800cce2:	078b      	lsls	r3, r1, #30
 800cce4:	f102 32ff 	add.w	r2, r2, #4294967295
 800cce8:	d1f5      	bne.n	800ccd6 <st_int8_copy+0x12>
 800ccea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ccee:	ea5f 1e12 	movs.w	lr, r2, lsr #4
 800ccf2:	d069      	beq.n	800cdc8 <st_int8_copy+0x104>
 800ccf4:	ea41 0300 	orr.w	r3, r1, r0
 800ccf8:	075b      	lsls	r3, r3, #29
 800ccfa:	d14c      	bne.n	800cd96 <st_int8_copy+0xd2>
 800ccfc:	f10e 33ff 	add.w	r3, lr, #4294967295
 800cd00:	2b01      	cmp	r3, #1
 800cd02:	d948      	bls.n	800cd96 <st_int8_copy+0xd2>
 800cd04:	f100 0310 	add.w	r3, r0, #16
 800cd08:	ea4f 140e 	mov.w	r4, lr, lsl #4
 800cd0c:	f101 0c10 	add.w	ip, r1, #16
 800cd10:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 800cd14:	ed13 6b04 	vldr	d6, [r3, #-16]
 800cd18:	ed13 7b02 	vldr	d7, [r3, #-8]
 800cd1c:	3310      	adds	r3, #16
 800cd1e:	4573      	cmp	r3, lr
 800cd20:	ed0c 6b04 	vstr	d6, [ip, #-16]
 800cd24:	ed0c 7b02 	vstr	d7, [ip, #-8]
 800cd28:	f10c 0c10 	add.w	ip, ip, #16
 800cd2c:	d1f2      	bne.n	800cd14 <st_int8_copy+0x50>
 800cd2e:	f3c2 0381 	ubfx	r3, r2, #2, #2
 800cd32:	4421      	add	r1, r4
 800cd34:	4420      	add	r0, r4
 800cd36:	f002 0203 	and.w	r2, r2, #3
 800cd3a:	b16b      	cbz	r3, 800cd58 <st_int8_copy+0x94>
 800cd3c:	6804      	ldr	r4, [r0, #0]
 800cd3e:	600c      	str	r4, [r1, #0]
 800cd40:	1e5c      	subs	r4, r3, #1
 800cd42:	d005      	beq.n	800cd50 <st_int8_copy+0x8c>
 800cd44:	6845      	ldr	r5, [r0, #4]
 800cd46:	604d      	str	r5, [r1, #4]
 800cd48:	2c01      	cmp	r4, #1
 800cd4a:	bf1c      	itt	ne
 800cd4c:	6884      	ldrne	r4, [r0, #8]
 800cd4e:	608c      	strne	r4, [r1, #8]
 800cd50:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800cd54:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800cd58:	b162      	cbz	r2, 800cd74 <st_int8_copy+0xb0>
 800cd5a:	f990 3000 	ldrsb.w	r3, [r0]
 800cd5e:	700b      	strb	r3, [r1, #0]
 800cd60:	3a01      	subs	r2, #1
 800cd62:	d007      	beq.n	800cd74 <st_int8_copy+0xb0>
 800cd64:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800cd68:	704b      	strb	r3, [r1, #1]
 800cd6a:	2a01      	cmp	r2, #1
 800cd6c:	bf1c      	itt	ne
 800cd6e:	f990 3002 	ldrsbne.w	r3, [r0, #2]
 800cd72:	708b      	strbne	r3, [r1, #2]
 800cd74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cd78:	4770      	bx	lr
 800cd7a:	1883      	adds	r3, r0, r2
 800cd7c:	428b      	cmp	r3, r1
 800cd7e:	d9a7      	bls.n	800ccd0 <st_int8_copy+0xc>
 800cd80:	4283      	cmp	r3, r0
 800cd82:	440a      	add	r2, r1
 800cd84:	d9f8      	bls.n	800cd78 <st_int8_copy+0xb4>
 800cd86:	f913 1d01 	ldrsb.w	r1, [r3, #-1]!
 800cd8a:	f802 1d01 	strb.w	r1, [r2, #-1]!
 800cd8e:	4283      	cmp	r3, r0
 800cd90:	d1f9      	bne.n	800cd86 <st_int8_copy+0xc2>
 800cd92:	4770      	bx	lr
 800cd94:	4770      	bx	lr
 800cd96:	ea4f 140e 	mov.w	r4, lr, lsl #4
 800cd9a:	460b      	mov	r3, r1
 800cd9c:	eb01 1e0e 	add.w	lr, r1, lr, lsl #4
 800cda0:	4684      	mov	ip, r0
 800cda2:	f8dc 7000 	ldr.w	r7, [ip]
 800cda6:	f8dc 6004 	ldr.w	r6, [ip, #4]
 800cdaa:	f8dc 5008 	ldr.w	r5, [ip, #8]
 800cdae:	f8dc 800c 	ldr.w	r8, [ip, #12]
 800cdb2:	f8c3 800c 	str.w	r8, [r3, #12]
 800cdb6:	601f      	str	r7, [r3, #0]
 800cdb8:	605e      	str	r6, [r3, #4]
 800cdba:	609d      	str	r5, [r3, #8]
 800cdbc:	3310      	adds	r3, #16
 800cdbe:	459e      	cmp	lr, r3
 800cdc0:	f10c 0c10 	add.w	ip, ip, #16
 800cdc4:	d1ed      	bne.n	800cda2 <st_int8_copy+0xde>
 800cdc6:	e7b2      	b.n	800cd2e <st_int8_copy+0x6a>
 800cdc8:	0893      	lsrs	r3, r2, #2
 800cdca:	f002 0203 	and.w	r2, r2, #3
 800cdce:	e7b4      	b.n	800cd3a <st_int8_copy+0x76>

0800cdd0 <ai_sum_f32>:
 800cdd0:	edd1 7a00 	vldr	s15, [r1]
 800cdd4:	ed92 7a00 	vldr	s14, [r2]
 800cdd8:	ee77 7a87 	vadd.f32	s15, s15, s14
 800cddc:	edc0 7a00 	vstr	s15, [r0]
 800cde0:	4770      	bx	lr
 800cde2:	bf00      	nop

0800cde4 <ai_sum_buffer_f32>:
 800cde4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800cde8:	4298      	cmp	r0, r3
 800cdea:	d209      	bcs.n	800ce00 <ai_sum_buffer_f32+0x1c>
 800cdec:	ecf1 7a01 	vldmia	r1!, {s15}
 800cdf0:	ecb2 7a01 	vldmia	r2!, {s14}
 800cdf4:	ee77 7a87 	vadd.f32	s15, s15, s14
 800cdf8:	ece0 7a01 	vstmia	r0!, {s15}
 800cdfc:	4283      	cmp	r3, r0
 800cdfe:	d8f5      	bhi.n	800cdec <ai_sum_buffer_f32+0x8>
 800ce00:	4770      	bx	lr
 800ce02:	bf00      	nop

0800ce04 <ai_sub_f32>:
 800ce04:	edd1 7a00 	vldr	s15, [r1]
 800ce08:	ed92 7a00 	vldr	s14, [r2]
 800ce0c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ce10:	edc0 7a00 	vstr	s15, [r0]
 800ce14:	4770      	bx	lr
 800ce16:	bf00      	nop

0800ce18 <ai_sub_buffer_f32>:
 800ce18:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ce1c:	4298      	cmp	r0, r3
 800ce1e:	d209      	bcs.n	800ce34 <ai_sub_buffer_f32+0x1c>
 800ce20:	ecf1 7a01 	vldmia	r1!, {s15}
 800ce24:	ecb2 7a01 	vldmia	r2!, {s14}
 800ce28:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ce2c:	ece0 7a01 	vstmia	r0!, {s15}
 800ce30:	4283      	cmp	r3, r0
 800ce32:	d8f5      	bhi.n	800ce20 <ai_sub_buffer_f32+0x8>
 800ce34:	4770      	bx	lr
 800ce36:	bf00      	nop

0800ce38 <ai_mul_f32>:
 800ce38:	edd1 7a00 	vldr	s15, [r1]
 800ce3c:	ed92 7a00 	vldr	s14, [r2]
 800ce40:	ee67 7a87 	vmul.f32	s15, s15, s14
 800ce44:	edc0 7a00 	vstr	s15, [r0]
 800ce48:	4770      	bx	lr
 800ce4a:	bf00      	nop

0800ce4c <ai_mul_buffer_f32>:
 800ce4c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ce50:	4298      	cmp	r0, r3
 800ce52:	d209      	bcs.n	800ce68 <ai_mul_buffer_f32+0x1c>
 800ce54:	ecf1 7a01 	vldmia	r1!, {s15}
 800ce58:	ecb2 7a01 	vldmia	r2!, {s14}
 800ce5c:	ee67 7a87 	vmul.f32	s15, s15, s14
 800ce60:	ece0 7a01 	vstmia	r0!, {s15}
 800ce64:	4283      	cmp	r3, r0
 800ce66:	d8f5      	bhi.n	800ce54 <ai_mul_buffer_f32+0x8>
 800ce68:	4770      	bx	lr
 800ce6a:	bf00      	nop

0800ce6c <ai_div_f32>:
 800ce6c:	edd1 6a00 	vldr	s13, [r1]
 800ce70:	ed92 7a00 	vldr	s14, [r2]
 800ce74:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ce78:	edc0 7a00 	vstr	s15, [r0]
 800ce7c:	4770      	bx	lr
 800ce7e:	bf00      	nop

0800ce80 <ai_div_buffer_f32>:
 800ce80:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ce84:	4298      	cmp	r0, r3
 800ce86:	d209      	bcs.n	800ce9c <ai_div_buffer_f32+0x1c>
 800ce88:	ecf1 6a01 	vldmia	r1!, {s13}
 800ce8c:	ecb2 7a01 	vldmia	r2!, {s14}
 800ce90:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ce94:	ece0 7a01 	vstmia	r0!, {s15}
 800ce98:	4283      	cmp	r3, r0
 800ce9a:	d8f5      	bhi.n	800ce88 <ai_div_buffer_f32+0x8>
 800ce9c:	4770      	bx	lr
 800ce9e:	bf00      	nop

0800cea0 <ai_array_to_buffer_fmt>:
 800cea0:	f3c0 4343 	ubfx	r3, r0, #17, #4
 800cea4:	2b02      	cmp	r3, #2
 800cea6:	d050      	beq.n	800cf4a <ai_array_to_buffer_fmt+0xaa>
 800cea8:	4b2a      	ldr	r3, [pc, #168]	; (800cf54 <ai_array_to_buffer_fmt+0xb4>)
 800ceaa:	f020 427e 	bic.w	r2, r0, #4261412864	; 0xfe000000
 800ceae:	429a      	cmp	r2, r3
 800ceb0:	d00b      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800ceb2:	dc1c      	bgt.n	800ceee <ai_array_to_buffer_fmt+0x4e>
 800ceb4:	4b28      	ldr	r3, [pc, #160]	; (800cf58 <ai_array_to_buffer_fmt+0xb8>)
 800ceb6:	429a      	cmp	r2, r3
 800ceb8:	d007      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800ceba:	dd0b      	ble.n	800ced4 <ai_array_to_buffer_fmt+0x34>
 800cebc:	4b27      	ldr	r3, [pc, #156]	; (800cf5c <ai_array_to_buffer_fmt+0xbc>)
 800cebe:	429a      	cmp	r2, r3
 800cec0:	d003      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cec2:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 800cec6:	429a      	cmp	r2, r3
 800cec8:	d131      	bne.n	800cf2e <ai_array_to_buffer_fmt+0x8e>
 800ceca:	4613      	mov	r3, r2
 800cecc:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800ced0:	4318      	orrs	r0, r3
 800ced2:	4770      	bx	lr
 800ced4:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800ced8:	429a      	cmp	r2, r3
 800ceda:	d0f6      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cedc:	dd2c      	ble.n	800cf38 <ai_array_to_buffer_fmt+0x98>
 800cede:	4b20      	ldr	r3, [pc, #128]	; (800cf60 <ai_array_to_buffer_fmt+0xc0>)
 800cee0:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800cee4:	429a      	cmp	r2, r3
 800cee6:	bf18      	it	ne
 800cee8:	2340      	movne	r3, #64	; 0x40
 800ceea:	4318      	orrs	r0, r3
 800ceec:	4770      	bx	lr
 800ceee:	4b1d      	ldr	r3, [pc, #116]	; (800cf64 <ai_array_to_buffer_fmt+0xc4>)
 800cef0:	429a      	cmp	r2, r3
 800cef2:	d0ea      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cef4:	dd0e      	ble.n	800cf14 <ai_array_to_buffer_fmt+0x74>
 800cef6:	4b1c      	ldr	r3, [pc, #112]	; (800cf68 <ai_array_to_buffer_fmt+0xc8>)
 800cef8:	429a      	cmp	r2, r3
 800cefa:	d0e6      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cefc:	f503 037e 	add.w	r3, r3, #16646144	; 0xfe0000
 800cf00:	429a      	cmp	r2, r3
 800cf02:	d0e2      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cf04:	4b19      	ldr	r3, [pc, #100]	; (800cf6c <ai_array_to_buffer_fmt+0xcc>)
 800cf06:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800cf0a:	429a      	cmp	r2, r3
 800cf0c:	bf18      	it	ne
 800cf0e:	2340      	movne	r3, #64	; 0x40
 800cf10:	4318      	orrs	r0, r3
 800cf12:	4770      	bx	lr
 800cf14:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800cf18:	429a      	cmp	r2, r3
 800cf1a:	d0d6      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cf1c:	3307      	adds	r3, #7
 800cf1e:	429a      	cmp	r2, r3
 800cf20:	d0d3      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cf22:	f2a3 3387 	subw	r3, r3, #903	; 0x387
 800cf26:	429a      	cmp	r2, r3
 800cf28:	bf18      	it	ne
 800cf2a:	2340      	movne	r3, #64	; 0x40
 800cf2c:	e7ce      	b.n	800cecc <ai_array_to_buffer_fmt+0x2c>
 800cf2e:	4b10      	ldr	r3, [pc, #64]	; (800cf70 <ai_array_to_buffer_fmt+0xd0>)
 800cf30:	429a      	cmp	r2, r3
 800cf32:	bf18      	it	ne
 800cf34:	2340      	movne	r3, #64	; 0x40
 800cf36:	e7c9      	b.n	800cecc <ai_array_to_buffer_fmt+0x2c>
 800cf38:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800cf3c:	429a      	cmp	r2, r3
 800cf3e:	d0c4      	beq.n	800ceca <ai_array_to_buffer_fmt+0x2a>
 800cf40:	3380      	adds	r3, #128	; 0x80
 800cf42:	429a      	cmp	r2, r3
 800cf44:	bf18      	it	ne
 800cf46:	2340      	movne	r3, #64	; 0x40
 800cf48:	e7c0      	b.n	800cecc <ai_array_to_buffer_fmt+0x2c>
 800cf4a:	4b0a      	ldr	r3, [pc, #40]	; (800cf74 <ai_array_to_buffer_fmt+0xd4>)
 800cf4c:	4003      	ands	r3, r0
 800cf4e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800cf52:	e7bb      	b.n	800cecc <ai_array_to_buffer_fmt+0x2c>
 800cf54:	00840040 	.word	0x00840040
 800cf58:	00040840 	.word	0x00040840
 800cf5c:	00041040 	.word	0x00041040
 800cf60:	00040447 	.word	0x00040447
 800cf64:	00840840 	.word	0x00840840
 800cf68:	00841040 	.word	0x00841040
 800cf6c:	0084084f 	.word	0x0084084f
 800cf70:	0004084f 	.word	0x0004084f
 800cf74:	00803fff 	.word	0x00803fff

0800cf78 <ai_array_get_byte_size>:
 800cf78:	b319      	cbz	r1, 800cfc2 <ai_array_get_byte_size+0x4a>
 800cf7a:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 800cf7e:	fb03 f101 	mul.w	r1, r3, r1
 800cf82:	3107      	adds	r1, #7
 800cf84:	f3c0 4243 	ubfx	r2, r0, #17, #4
 800cf88:	f021 0307 	bic.w	r3, r1, #7
 800cf8c:	2a04      	cmp	r2, #4
 800cf8e:	f3c0 5141 	ubfx	r1, r0, #21, #2
 800cf92:	fa23 f101 	lsr.w	r1, r3, r1
 800cf96:	ea4f 10e0 	mov.w	r0, r0, asr #7
 800cf9a:	d00b      	beq.n	800cfb4 <ai_array_get_byte_size+0x3c>
 800cf9c:	2a08      	cmp	r2, #8
 800cf9e:	d002      	beq.n	800cfa6 <ai_array_get_byte_size+0x2e>
 800cfa0:	3107      	adds	r1, #7
 800cfa2:	08c8      	lsrs	r0, r1, #3
 800cfa4:	4770      	bx	lr
 800cfa6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800cfaa:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 800cfae:	3107      	adds	r1, #7
 800cfb0:	08c8      	lsrs	r0, r1, #3
 800cfb2:	4770      	bx	lr
 800cfb4:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800cfb8:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 800cfbc:	3107      	adds	r1, #7
 800cfbe:	08c8      	lsrs	r0, r1, #3
 800cfc0:	4770      	bx	lr
 800cfc2:	4608      	mov	r0, r1
 800cfc4:	4770      	bx	lr
 800cfc6:	bf00      	nop

0800cfc8 <ai_array_get_data_byte_size>:
 800cfc8:	b169      	cbz	r1, 800cfe6 <ai_array_get_data_byte_size+0x1e>
 800cfca:	f3c0 12c6 	ubfx	r2, r0, #7, #7
 800cfce:	fb02 f101 	mul.w	r1, r2, r1
 800cfd2:	1dcb      	adds	r3, r1, #7
 800cfd4:	f023 0307 	bic.w	r3, r3, #7
 800cfd8:	f3c0 5041 	ubfx	r0, r0, #21, #2
 800cfdc:	fa23 f000 	lsr.w	r0, r3, r0
 800cfe0:	3007      	adds	r0, #7
 800cfe2:	08c0      	lsrs	r0, r0, #3
 800cfe4:	4770      	bx	lr
 800cfe6:	4608      	mov	r0, r1
 800cfe8:	4770      	bx	lr
 800cfea:	bf00      	nop

0800cfec <ai_version_get>:
 800cfec:	0212      	lsls	r2, r2, #8
 800cfee:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800cff2:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 800cff6:	4770      	bx	lr

0800cff8 <get_tensor_byte_size>:
 800cff8:	b410      	push	{r4}
 800cffa:	6983      	ldr	r3, [r0, #24]
 800cffc:	68c4      	ldr	r4, [r0, #12]
 800cffe:	6941      	ldr	r1, [r0, #20]
 800d000:	681b      	ldr	r3, [r3, #0]
 800d002:	68e0      	ldr	r0, [r4, #12]
 800d004:	4a07      	ldr	r2, [pc, #28]	; (800d024 <get_tensor_byte_size+0x2c>)
 800d006:	68c9      	ldr	r1, [r1, #12]
 800d008:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d00c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
 800d010:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800d014:	fb01 f000 	mul.w	r0, r1, r0
 800d018:	4293      	cmp	r3, r2
 800d01a:	bf04      	itt	eq
 800d01c:	3007      	addeq	r0, #7
 800d01e:	08c0      	lsreq	r0, r0, #3
 800d020:	4770      	bx	lr
 800d022:	bf00      	nop
 800d024:	000400c0 	.word	0x000400c0

0800d028 <core_get_broadcasted_shape>:
 800d028:	b470      	push	{r4, r5, r6}
 800d02a:	6804      	ldr	r4, [r0, #0]
 800d02c:	f3c4 2417 	ubfx	r4, r4, #8, #24
 800d030:	b324      	cbz	r4, 800d07c <core_get_broadcasted_shape+0x54>
 800d032:	4623      	mov	r3, r4
 800d034:	3b01      	subs	r3, #1
 800d036:	429c      	cmp	r4, r3
 800d038:	d91b      	bls.n	800d072 <core_get_broadcasted_shape+0x4a>
 800d03a:	6814      	ldr	r4, [r2, #0]
 800d03c:	680e      	ldr	r6, [r1, #0]
 800d03e:	ebb3 2f14 	cmp.w	r3, r4, lsr #8
 800d042:	bf36      	itet	cc
 800d044:	6854      	ldrcc	r4, [r2, #4]
 800d046:	2401      	movcs	r4, #1
 800d048:	f854 4023 	ldrcc.w	r4, [r4, r3, lsl #2]
 800d04c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 800d050:	bf38      	it	cc
 800d052:	ea4f 0c83 	movcc.w	ip, r3, lsl #2
 800d056:	ebb3 2f16 	cmp.w	r3, r6, lsr #8
 800d05a:	f04f 0501 	mov.w	r5, #1
 800d05e:	bf3c      	itt	cc
 800d060:	684d      	ldrcc	r5, [r1, #4]
 800d062:	f855 500c 	ldrcc.w	r5, [r5, ip]
 800d066:	42ac      	cmp	r4, r5
 800d068:	bf38      	it	cc
 800d06a:	462c      	movcc	r4, r5
 800d06c:	6845      	ldr	r5, [r0, #4]
 800d06e:	f845 400c 	str.w	r4, [r5, ip]
 800d072:	b11b      	cbz	r3, 800d07c <core_get_broadcasted_shape+0x54>
 800d074:	6804      	ldr	r4, [r0, #0]
 800d076:	f3c4 2417 	ubfx	r4, r4, #8, #24
 800d07a:	e7db      	b.n	800d034 <core_get_broadcasted_shape+0xc>
 800d07c:	bc70      	pop	{r4, r5, r6}
 800d07e:	4770      	bx	lr

0800d080 <core_compute_offsets>:
 800d080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d084:	e9d1 4600 	ldrd	r4, r6, [r1]
 800d088:	f5b4 6fa0 	cmp.w	r4, #1280	; 0x500
 800d08c:	f8d2 9004 	ldr.w	r9, [r2, #4]
 800d090:	6871      	ldr	r1, [r6, #4]
 800d092:	6812      	ldr	r2, [r2, #0]
 800d094:	bf28      	it	cs
 800d096:	6935      	ldrcs	r5, [r6, #16]
 800d098:	f8d9 c004 	ldr.w	ip, [r9, #4]
 800d09c:	f8d0 b000 	ldr.w	fp, [r0]
 800d0a0:	bf2e      	itee	cs
 800d0a2:	fb05 fe01 	mulcs.w	lr, r5, r1
 800d0a6:	468e      	movcc	lr, r1
 800d0a8:	2501      	movcc	r5, #1
 800d0aa:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800d0ae:	bf28      	it	cs
 800d0b0:	f8d9 2010 	ldrcs.w	r2, [r9, #16]
 800d0b4:	e9d6 4802 	ldrd	r4, r8, [r6, #8]
 800d0b8:	e9d9 6902 	ldrd	r6, r9, [r9, #8]
 800d0bc:	bf38      	it	cc
 800d0be:	2201      	movcc	r2, #1
 800d0c0:	b083      	sub	sp, #12
 800d0c2:	ebb4 0a06 	subs.w	sl, r4, r6
 800d0c6:	bf18      	it	ne
 800d0c8:	f04f 0a01 	movne.w	sl, #1
 800d0cc:	f5bb 7f00 	cmp.w	fp, #512	; 0x200
 800d0d0:	9201      	str	r2, [sp, #4]
 800d0d2:	f3cb 2217 	ubfx	r2, fp, #8, #24
 800d0d6:	d308      	bcc.n	800d0ea <core_compute_offsets+0x6a>
 800d0d8:	6847      	ldr	r7, [r0, #4]
 800d0da:	4561      	cmp	r1, ip
 800d0dc:	bf0c      	ite	eq
 800d0de:	461a      	moveq	r2, r3
 800d0e0:	2200      	movne	r2, #0
 800d0e2:	607a      	str	r2, [r7, #4]
 800d0e4:	6802      	ldr	r2, [r0, #0]
 800d0e6:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d0ea:	9f01      	ldr	r7, [sp, #4]
 800d0ec:	42bd      	cmp	r5, r7
 800d0ee:	d03f      	beq.n	800d170 <core_compute_offsets+0xf0>
 800d0f0:	eba1 0b0c 	sub.w	fp, r1, ip
 800d0f4:	fabb fb8b 	clz	fp, fp
 800d0f8:	ea4f 1b5b 	mov.w	fp, fp, lsr #5
 800d0fc:	fb01 fb0b 	mul.w	fp, r1, fp
 800d100:	f1cb 0b00 	rsb	fp, fp, #0
 800d104:	2a04      	cmp	r2, #4
 800d106:	d906      	bls.n	800d116 <core_compute_offsets+0x96>
 800d108:	6847      	ldr	r7, [r0, #4]
 800d10a:	fb0b f203 	mul.w	r2, fp, r3
 800d10e:	613a      	str	r2, [r7, #16]
 800d110:	6802      	ldr	r2, [r0, #0]
 800d112:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d116:	42b4      	cmp	r4, r6
 800d118:	d03a      	beq.n	800d190 <core_compute_offsets+0x110>
 800d11a:	f04f 0b00 	mov.w	fp, #0
 800d11e:	2a02      	cmp	r2, #2
 800d120:	fb0e fa0a 	mul.w	sl, lr, sl
 800d124:	d90e      	bls.n	800d144 <core_compute_offsets+0xc4>
 800d126:	9a01      	ldr	r2, [sp, #4]
 800d128:	6847      	ldr	r7, [r0, #4]
 800d12a:	1aaa      	subs	r2, r5, r2
 800d12c:	bf18      	it	ne
 800d12e:	2201      	movne	r2, #1
 800d130:	ebab 0b0a 	sub.w	fp, fp, sl
 800d134:	fb01 bb02 	mla	fp, r1, r2, fp
 800d138:	fb03 f20b 	mul.w	r2, r3, fp
 800d13c:	60ba      	str	r2, [r7, #8]
 800d13e:	6802      	ldr	r2, [r0, #0]
 800d140:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d144:	45c8      	cmp	r8, r9
 800d146:	d019      	beq.n	800d17c <core_compute_offsets+0xfc>
 800d148:	2100      	movs	r1, #0
 800d14a:	2a03      	cmp	r2, #3
 800d14c:	d90d      	bls.n	800d16a <core_compute_offsets+0xea>
 800d14e:	ebb8 0809 	subs.w	r8, r8, r9
 800d152:	fb0e f404 	mul.w	r4, lr, r4
 800d156:	bf18      	it	ne
 800d158:	f04f 0801 	movne.w	r8, #1
 800d15c:	fb08 1114 	mls	r1, r8, r4, r1
 800d160:	6842      	ldr	r2, [r0, #4]
 800d162:	448a      	add	sl, r1
 800d164:	fb03 f30a 	mul.w	r3, r3, sl
 800d168:	60d3      	str	r3, [r2, #12]
 800d16a:	b003      	add	sp, #12
 800d16c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d170:	ebb1 0b0c 	subs.w	fp, r1, ip
 800d174:	bf18      	it	ne
 800d176:	f04f 0b01 	movne.w	fp, #1
 800d17a:	e7c3      	b.n	800d104 <core_compute_offsets+0x84>
 800d17c:	42b4      	cmp	r4, r6
 800d17e:	d0e3      	beq.n	800d148 <core_compute_offsets+0xc8>
 800d180:	9e01      	ldr	r6, [sp, #4]
 800d182:	42b5      	cmp	r5, r6
 800d184:	d0e0      	beq.n	800d148 <core_compute_offsets+0xc8>
 800d186:	ebb1 010c 	subs.w	r1, r1, ip
 800d18a:	bf18      	it	ne
 800d18c:	2101      	movne	r1, #1
 800d18e:	e7dc      	b.n	800d14a <core_compute_offsets+0xca>
 800d190:	9f01      	ldr	r7, [sp, #4]
 800d192:	42bd      	cmp	r5, r7
 800d194:	d0c1      	beq.n	800d11a <core_compute_offsets+0x9a>
 800d196:	ebb1 0b0c 	subs.w	fp, r1, ip
 800d19a:	bf18      	it	ne
 800d19c:	f04f 0b01 	movne.w	fp, #1
 800d1a0:	e7bd      	b.n	800d11e <core_compute_offsets+0x9e>
 800d1a2:	bf00      	nop

0800d1a4 <sbrk_aligned>:
 800d1a4:	b570      	push	{r4, r5, r6, lr}
 800d1a6:	4e0e      	ldr	r6, [pc, #56]	; (800d1e0 <sbrk_aligned+0x3c>)
 800d1a8:	460c      	mov	r4, r1
 800d1aa:	6831      	ldr	r1, [r6, #0]
 800d1ac:	4605      	mov	r5, r0
 800d1ae:	b911      	cbnz	r1, 800d1b6 <sbrk_aligned+0x12>
 800d1b0:	f000 fae8 	bl	800d784 <_sbrk_r>
 800d1b4:	6030      	str	r0, [r6, #0]
 800d1b6:	4621      	mov	r1, r4
 800d1b8:	4628      	mov	r0, r5
 800d1ba:	f000 fae3 	bl	800d784 <_sbrk_r>
 800d1be:	1c43      	adds	r3, r0, #1
 800d1c0:	d00a      	beq.n	800d1d8 <sbrk_aligned+0x34>
 800d1c2:	1cc4      	adds	r4, r0, #3
 800d1c4:	f024 0403 	bic.w	r4, r4, #3
 800d1c8:	42a0      	cmp	r0, r4
 800d1ca:	d007      	beq.n	800d1dc <sbrk_aligned+0x38>
 800d1cc:	1a21      	subs	r1, r4, r0
 800d1ce:	4628      	mov	r0, r5
 800d1d0:	f000 fad8 	bl	800d784 <_sbrk_r>
 800d1d4:	3001      	adds	r0, #1
 800d1d6:	d101      	bne.n	800d1dc <sbrk_aligned+0x38>
 800d1d8:	f04f 34ff 	mov.w	r4, #4294967295
 800d1dc:	4620      	mov	r0, r4
 800d1de:	bd70      	pop	{r4, r5, r6, pc}
 800d1e0:	200030b0 	.word	0x200030b0

0800d1e4 <_malloc_r>:
 800d1e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d1e8:	1ccd      	adds	r5, r1, #3
 800d1ea:	f025 0503 	bic.w	r5, r5, #3
 800d1ee:	3508      	adds	r5, #8
 800d1f0:	2d0c      	cmp	r5, #12
 800d1f2:	bf38      	it	cc
 800d1f4:	250c      	movcc	r5, #12
 800d1f6:	2d00      	cmp	r5, #0
 800d1f8:	4607      	mov	r7, r0
 800d1fa:	db01      	blt.n	800d200 <_malloc_r+0x1c>
 800d1fc:	42a9      	cmp	r1, r5
 800d1fe:	d905      	bls.n	800d20c <_malloc_r+0x28>
 800d200:	230c      	movs	r3, #12
 800d202:	603b      	str	r3, [r7, #0]
 800d204:	2600      	movs	r6, #0
 800d206:	4630      	mov	r0, r6
 800d208:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d20c:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800d2e0 <_malloc_r+0xfc>
 800d210:	f000 f868 	bl	800d2e4 <__malloc_lock>
 800d214:	f8d8 3000 	ldr.w	r3, [r8]
 800d218:	461c      	mov	r4, r3
 800d21a:	bb5c      	cbnz	r4, 800d274 <_malloc_r+0x90>
 800d21c:	4629      	mov	r1, r5
 800d21e:	4638      	mov	r0, r7
 800d220:	f7ff ffc0 	bl	800d1a4 <sbrk_aligned>
 800d224:	1c43      	adds	r3, r0, #1
 800d226:	4604      	mov	r4, r0
 800d228:	d155      	bne.n	800d2d6 <_malloc_r+0xf2>
 800d22a:	f8d8 4000 	ldr.w	r4, [r8]
 800d22e:	4626      	mov	r6, r4
 800d230:	2e00      	cmp	r6, #0
 800d232:	d145      	bne.n	800d2c0 <_malloc_r+0xdc>
 800d234:	2c00      	cmp	r4, #0
 800d236:	d048      	beq.n	800d2ca <_malloc_r+0xe6>
 800d238:	6823      	ldr	r3, [r4, #0]
 800d23a:	4631      	mov	r1, r6
 800d23c:	4638      	mov	r0, r7
 800d23e:	eb04 0903 	add.w	r9, r4, r3
 800d242:	f000 fa9f 	bl	800d784 <_sbrk_r>
 800d246:	4581      	cmp	r9, r0
 800d248:	d13f      	bne.n	800d2ca <_malloc_r+0xe6>
 800d24a:	6821      	ldr	r1, [r4, #0]
 800d24c:	1a6d      	subs	r5, r5, r1
 800d24e:	4629      	mov	r1, r5
 800d250:	4638      	mov	r0, r7
 800d252:	f7ff ffa7 	bl	800d1a4 <sbrk_aligned>
 800d256:	3001      	adds	r0, #1
 800d258:	d037      	beq.n	800d2ca <_malloc_r+0xe6>
 800d25a:	6823      	ldr	r3, [r4, #0]
 800d25c:	442b      	add	r3, r5
 800d25e:	6023      	str	r3, [r4, #0]
 800d260:	f8d8 3000 	ldr.w	r3, [r8]
 800d264:	2b00      	cmp	r3, #0
 800d266:	d038      	beq.n	800d2da <_malloc_r+0xf6>
 800d268:	685a      	ldr	r2, [r3, #4]
 800d26a:	42a2      	cmp	r2, r4
 800d26c:	d12b      	bne.n	800d2c6 <_malloc_r+0xe2>
 800d26e:	2200      	movs	r2, #0
 800d270:	605a      	str	r2, [r3, #4]
 800d272:	e00f      	b.n	800d294 <_malloc_r+0xb0>
 800d274:	6822      	ldr	r2, [r4, #0]
 800d276:	1b52      	subs	r2, r2, r5
 800d278:	d41f      	bmi.n	800d2ba <_malloc_r+0xd6>
 800d27a:	2a0b      	cmp	r2, #11
 800d27c:	d917      	bls.n	800d2ae <_malloc_r+0xca>
 800d27e:	1961      	adds	r1, r4, r5
 800d280:	42a3      	cmp	r3, r4
 800d282:	6025      	str	r5, [r4, #0]
 800d284:	bf18      	it	ne
 800d286:	6059      	strne	r1, [r3, #4]
 800d288:	6863      	ldr	r3, [r4, #4]
 800d28a:	bf08      	it	eq
 800d28c:	f8c8 1000 	streq.w	r1, [r8]
 800d290:	5162      	str	r2, [r4, r5]
 800d292:	604b      	str	r3, [r1, #4]
 800d294:	4638      	mov	r0, r7
 800d296:	f104 060b 	add.w	r6, r4, #11
 800d29a:	f000 f829 	bl	800d2f0 <__malloc_unlock>
 800d29e:	f026 0607 	bic.w	r6, r6, #7
 800d2a2:	1d23      	adds	r3, r4, #4
 800d2a4:	1af2      	subs	r2, r6, r3
 800d2a6:	d0ae      	beq.n	800d206 <_malloc_r+0x22>
 800d2a8:	1b9b      	subs	r3, r3, r6
 800d2aa:	50a3      	str	r3, [r4, r2]
 800d2ac:	e7ab      	b.n	800d206 <_malloc_r+0x22>
 800d2ae:	42a3      	cmp	r3, r4
 800d2b0:	6862      	ldr	r2, [r4, #4]
 800d2b2:	d1dd      	bne.n	800d270 <_malloc_r+0x8c>
 800d2b4:	f8c8 2000 	str.w	r2, [r8]
 800d2b8:	e7ec      	b.n	800d294 <_malloc_r+0xb0>
 800d2ba:	4623      	mov	r3, r4
 800d2bc:	6864      	ldr	r4, [r4, #4]
 800d2be:	e7ac      	b.n	800d21a <_malloc_r+0x36>
 800d2c0:	4634      	mov	r4, r6
 800d2c2:	6876      	ldr	r6, [r6, #4]
 800d2c4:	e7b4      	b.n	800d230 <_malloc_r+0x4c>
 800d2c6:	4613      	mov	r3, r2
 800d2c8:	e7cc      	b.n	800d264 <_malloc_r+0x80>
 800d2ca:	230c      	movs	r3, #12
 800d2cc:	603b      	str	r3, [r7, #0]
 800d2ce:	4638      	mov	r0, r7
 800d2d0:	f000 f80e 	bl	800d2f0 <__malloc_unlock>
 800d2d4:	e797      	b.n	800d206 <_malloc_r+0x22>
 800d2d6:	6025      	str	r5, [r4, #0]
 800d2d8:	e7dc      	b.n	800d294 <_malloc_r+0xb0>
 800d2da:	605b      	str	r3, [r3, #4]
 800d2dc:	deff      	udf	#255	; 0xff
 800d2de:	bf00      	nop
 800d2e0:	200030ac 	.word	0x200030ac

0800d2e4 <__malloc_lock>:
 800d2e4:	4801      	ldr	r0, [pc, #4]	; (800d2ec <__malloc_lock+0x8>)
 800d2e6:	f000 ba9a 	b.w	800d81e <__retarget_lock_acquire_recursive>
 800d2ea:	bf00      	nop
 800d2ec:	200031f4 	.word	0x200031f4

0800d2f0 <__malloc_unlock>:
 800d2f0:	4801      	ldr	r0, [pc, #4]	; (800d2f8 <__malloc_unlock+0x8>)
 800d2f2:	f000 ba95 	b.w	800d820 <__retarget_lock_release_recursive>
 800d2f6:	bf00      	nop
 800d2f8:	200031f4 	.word	0x200031f4

0800d2fc <std>:
 800d2fc:	2300      	movs	r3, #0
 800d2fe:	b510      	push	{r4, lr}
 800d300:	4604      	mov	r4, r0
 800d302:	e9c0 3300 	strd	r3, r3, [r0]
 800d306:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800d30a:	6083      	str	r3, [r0, #8]
 800d30c:	8181      	strh	r1, [r0, #12]
 800d30e:	6643      	str	r3, [r0, #100]	; 0x64
 800d310:	81c2      	strh	r2, [r0, #14]
 800d312:	6183      	str	r3, [r0, #24]
 800d314:	4619      	mov	r1, r3
 800d316:	2208      	movs	r2, #8
 800d318:	305c      	adds	r0, #92	; 0x5c
 800d31a:	f000 f9f7 	bl	800d70c <memset>
 800d31e:	4b0d      	ldr	r3, [pc, #52]	; (800d354 <std+0x58>)
 800d320:	6263      	str	r3, [r4, #36]	; 0x24
 800d322:	4b0d      	ldr	r3, [pc, #52]	; (800d358 <std+0x5c>)
 800d324:	62a3      	str	r3, [r4, #40]	; 0x28
 800d326:	4b0d      	ldr	r3, [pc, #52]	; (800d35c <std+0x60>)
 800d328:	62e3      	str	r3, [r4, #44]	; 0x2c
 800d32a:	4b0d      	ldr	r3, [pc, #52]	; (800d360 <std+0x64>)
 800d32c:	6323      	str	r3, [r4, #48]	; 0x30
 800d32e:	4b0d      	ldr	r3, [pc, #52]	; (800d364 <std+0x68>)
 800d330:	6224      	str	r4, [r4, #32]
 800d332:	429c      	cmp	r4, r3
 800d334:	d006      	beq.n	800d344 <std+0x48>
 800d336:	f103 0268 	add.w	r2, r3, #104	; 0x68
 800d33a:	4294      	cmp	r4, r2
 800d33c:	d002      	beq.n	800d344 <std+0x48>
 800d33e:	33d0      	adds	r3, #208	; 0xd0
 800d340:	429c      	cmp	r4, r3
 800d342:	d105      	bne.n	800d350 <std+0x54>
 800d344:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800d348:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d34c:	f000 ba66 	b.w	800d81c <__retarget_lock_init_recursive>
 800d350:	bd10      	pop	{r4, pc}
 800d352:	bf00      	nop
 800d354:	0800d55d 	.word	0x0800d55d
 800d358:	0800d57f 	.word	0x0800d57f
 800d35c:	0800d5b7 	.word	0x0800d5b7
 800d360:	0800d5db 	.word	0x0800d5db
 800d364:	200030b4 	.word	0x200030b4

0800d368 <stdio_exit_handler>:
 800d368:	4a02      	ldr	r2, [pc, #8]	; (800d374 <stdio_exit_handler+0xc>)
 800d36a:	4903      	ldr	r1, [pc, #12]	; (800d378 <stdio_exit_handler+0x10>)
 800d36c:	4803      	ldr	r0, [pc, #12]	; (800d37c <stdio_exit_handler+0x14>)
 800d36e:	f000 b869 	b.w	800d444 <_fwalk_sglue>
 800d372:	bf00      	nop
 800d374:	200014b0 	.word	0x200014b0
 800d378:	0800df8d 	.word	0x0800df8d
 800d37c:	200014bc 	.word	0x200014bc

0800d380 <cleanup_stdio>:
 800d380:	6841      	ldr	r1, [r0, #4]
 800d382:	4b0c      	ldr	r3, [pc, #48]	; (800d3b4 <cleanup_stdio+0x34>)
 800d384:	4299      	cmp	r1, r3
 800d386:	b510      	push	{r4, lr}
 800d388:	4604      	mov	r4, r0
 800d38a:	d001      	beq.n	800d390 <cleanup_stdio+0x10>
 800d38c:	f000 fdfe 	bl	800df8c <_fflush_r>
 800d390:	68a1      	ldr	r1, [r4, #8]
 800d392:	4b09      	ldr	r3, [pc, #36]	; (800d3b8 <cleanup_stdio+0x38>)
 800d394:	4299      	cmp	r1, r3
 800d396:	d002      	beq.n	800d39e <cleanup_stdio+0x1e>
 800d398:	4620      	mov	r0, r4
 800d39a:	f000 fdf7 	bl	800df8c <_fflush_r>
 800d39e:	68e1      	ldr	r1, [r4, #12]
 800d3a0:	4b06      	ldr	r3, [pc, #24]	; (800d3bc <cleanup_stdio+0x3c>)
 800d3a2:	4299      	cmp	r1, r3
 800d3a4:	d004      	beq.n	800d3b0 <cleanup_stdio+0x30>
 800d3a6:	4620      	mov	r0, r4
 800d3a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3ac:	f000 bdee 	b.w	800df8c <_fflush_r>
 800d3b0:	bd10      	pop	{r4, pc}
 800d3b2:	bf00      	nop
 800d3b4:	200030b4 	.word	0x200030b4
 800d3b8:	2000311c 	.word	0x2000311c
 800d3bc:	20003184 	.word	0x20003184

0800d3c0 <global_stdio_init.part.0>:
 800d3c0:	b510      	push	{r4, lr}
 800d3c2:	4b0b      	ldr	r3, [pc, #44]	; (800d3f0 <global_stdio_init.part.0+0x30>)
 800d3c4:	4c0b      	ldr	r4, [pc, #44]	; (800d3f4 <global_stdio_init.part.0+0x34>)
 800d3c6:	4a0c      	ldr	r2, [pc, #48]	; (800d3f8 <global_stdio_init.part.0+0x38>)
 800d3c8:	601a      	str	r2, [r3, #0]
 800d3ca:	4620      	mov	r0, r4
 800d3cc:	2200      	movs	r2, #0
 800d3ce:	2104      	movs	r1, #4
 800d3d0:	f7ff ff94 	bl	800d2fc <std>
 800d3d4:	f104 0068 	add.w	r0, r4, #104	; 0x68
 800d3d8:	2201      	movs	r2, #1
 800d3da:	2109      	movs	r1, #9
 800d3dc:	f7ff ff8e 	bl	800d2fc <std>
 800d3e0:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 800d3e4:	2202      	movs	r2, #2
 800d3e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3ea:	2112      	movs	r1, #18
 800d3ec:	f7ff bf86 	b.w	800d2fc <std>
 800d3f0:	200031ec 	.word	0x200031ec
 800d3f4:	200030b4 	.word	0x200030b4
 800d3f8:	0800d369 	.word	0x0800d369

0800d3fc <__sfp_lock_acquire>:
 800d3fc:	4801      	ldr	r0, [pc, #4]	; (800d404 <__sfp_lock_acquire+0x8>)
 800d3fe:	f000 ba0e 	b.w	800d81e <__retarget_lock_acquire_recursive>
 800d402:	bf00      	nop
 800d404:	200031f5 	.word	0x200031f5

0800d408 <__sfp_lock_release>:
 800d408:	4801      	ldr	r0, [pc, #4]	; (800d410 <__sfp_lock_release+0x8>)
 800d40a:	f000 ba09 	b.w	800d820 <__retarget_lock_release_recursive>
 800d40e:	bf00      	nop
 800d410:	200031f5 	.word	0x200031f5

0800d414 <__sinit>:
 800d414:	b510      	push	{r4, lr}
 800d416:	4604      	mov	r4, r0
 800d418:	f7ff fff0 	bl	800d3fc <__sfp_lock_acquire>
 800d41c:	6a23      	ldr	r3, [r4, #32]
 800d41e:	b11b      	cbz	r3, 800d428 <__sinit+0x14>
 800d420:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d424:	f7ff bff0 	b.w	800d408 <__sfp_lock_release>
 800d428:	4b04      	ldr	r3, [pc, #16]	; (800d43c <__sinit+0x28>)
 800d42a:	6223      	str	r3, [r4, #32]
 800d42c:	4b04      	ldr	r3, [pc, #16]	; (800d440 <__sinit+0x2c>)
 800d42e:	681b      	ldr	r3, [r3, #0]
 800d430:	2b00      	cmp	r3, #0
 800d432:	d1f5      	bne.n	800d420 <__sinit+0xc>
 800d434:	f7ff ffc4 	bl	800d3c0 <global_stdio_init.part.0>
 800d438:	e7f2      	b.n	800d420 <__sinit+0xc>
 800d43a:	bf00      	nop
 800d43c:	0800d381 	.word	0x0800d381
 800d440:	200031ec 	.word	0x200031ec

0800d444 <_fwalk_sglue>:
 800d444:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d448:	4607      	mov	r7, r0
 800d44a:	4688      	mov	r8, r1
 800d44c:	4614      	mov	r4, r2
 800d44e:	2600      	movs	r6, #0
 800d450:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800d454:	f1b9 0901 	subs.w	r9, r9, #1
 800d458:	d505      	bpl.n	800d466 <_fwalk_sglue+0x22>
 800d45a:	6824      	ldr	r4, [r4, #0]
 800d45c:	2c00      	cmp	r4, #0
 800d45e:	d1f7      	bne.n	800d450 <_fwalk_sglue+0xc>
 800d460:	4630      	mov	r0, r6
 800d462:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d466:	89ab      	ldrh	r3, [r5, #12]
 800d468:	2b01      	cmp	r3, #1
 800d46a:	d907      	bls.n	800d47c <_fwalk_sglue+0x38>
 800d46c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800d470:	3301      	adds	r3, #1
 800d472:	d003      	beq.n	800d47c <_fwalk_sglue+0x38>
 800d474:	4629      	mov	r1, r5
 800d476:	4638      	mov	r0, r7
 800d478:	47c0      	blx	r8
 800d47a:	4306      	orrs	r6, r0
 800d47c:	3568      	adds	r5, #104	; 0x68
 800d47e:	e7e9      	b.n	800d454 <_fwalk_sglue+0x10>

0800d480 <iprintf>:
 800d480:	b40f      	push	{r0, r1, r2, r3}
 800d482:	b507      	push	{r0, r1, r2, lr}
 800d484:	4906      	ldr	r1, [pc, #24]	; (800d4a0 <iprintf+0x20>)
 800d486:	ab04      	add	r3, sp, #16
 800d488:	6808      	ldr	r0, [r1, #0]
 800d48a:	f853 2b04 	ldr.w	r2, [r3], #4
 800d48e:	6881      	ldr	r1, [r0, #8]
 800d490:	9301      	str	r3, [sp, #4]
 800d492:	f000 fa4b 	bl	800d92c <_vfiprintf_r>
 800d496:	b003      	add	sp, #12
 800d498:	f85d eb04 	ldr.w	lr, [sp], #4
 800d49c:	b004      	add	sp, #16
 800d49e:	4770      	bx	lr
 800d4a0:	20001508 	.word	0x20001508

0800d4a4 <_puts_r>:
 800d4a4:	6a03      	ldr	r3, [r0, #32]
 800d4a6:	b570      	push	{r4, r5, r6, lr}
 800d4a8:	6884      	ldr	r4, [r0, #8]
 800d4aa:	4605      	mov	r5, r0
 800d4ac:	460e      	mov	r6, r1
 800d4ae:	b90b      	cbnz	r3, 800d4b4 <_puts_r+0x10>
 800d4b0:	f7ff ffb0 	bl	800d414 <__sinit>
 800d4b4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d4b6:	07db      	lsls	r3, r3, #31
 800d4b8:	d405      	bmi.n	800d4c6 <_puts_r+0x22>
 800d4ba:	89a3      	ldrh	r3, [r4, #12]
 800d4bc:	0598      	lsls	r0, r3, #22
 800d4be:	d402      	bmi.n	800d4c6 <_puts_r+0x22>
 800d4c0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800d4c2:	f000 f9ac 	bl	800d81e <__retarget_lock_acquire_recursive>
 800d4c6:	89a3      	ldrh	r3, [r4, #12]
 800d4c8:	0719      	lsls	r1, r3, #28
 800d4ca:	d513      	bpl.n	800d4f4 <_puts_r+0x50>
 800d4cc:	6923      	ldr	r3, [r4, #16]
 800d4ce:	b18b      	cbz	r3, 800d4f4 <_puts_r+0x50>
 800d4d0:	3e01      	subs	r6, #1
 800d4d2:	68a3      	ldr	r3, [r4, #8]
 800d4d4:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800d4d8:	3b01      	subs	r3, #1
 800d4da:	60a3      	str	r3, [r4, #8]
 800d4dc:	b9e9      	cbnz	r1, 800d51a <_puts_r+0x76>
 800d4de:	2b00      	cmp	r3, #0
 800d4e0:	da2e      	bge.n	800d540 <_puts_r+0x9c>
 800d4e2:	4622      	mov	r2, r4
 800d4e4:	210a      	movs	r1, #10
 800d4e6:	4628      	mov	r0, r5
 800d4e8:	f000 f87b 	bl	800d5e2 <__swbuf_r>
 800d4ec:	3001      	adds	r0, #1
 800d4ee:	d007      	beq.n	800d500 <_puts_r+0x5c>
 800d4f0:	250a      	movs	r5, #10
 800d4f2:	e007      	b.n	800d504 <_puts_r+0x60>
 800d4f4:	4621      	mov	r1, r4
 800d4f6:	4628      	mov	r0, r5
 800d4f8:	f000 f8b0 	bl	800d65c <__swsetup_r>
 800d4fc:	2800      	cmp	r0, #0
 800d4fe:	d0e7      	beq.n	800d4d0 <_puts_r+0x2c>
 800d500:	f04f 35ff 	mov.w	r5, #4294967295
 800d504:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d506:	07da      	lsls	r2, r3, #31
 800d508:	d405      	bmi.n	800d516 <_puts_r+0x72>
 800d50a:	89a3      	ldrh	r3, [r4, #12]
 800d50c:	059b      	lsls	r3, r3, #22
 800d50e:	d402      	bmi.n	800d516 <_puts_r+0x72>
 800d510:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800d512:	f000 f985 	bl	800d820 <__retarget_lock_release_recursive>
 800d516:	4628      	mov	r0, r5
 800d518:	bd70      	pop	{r4, r5, r6, pc}
 800d51a:	2b00      	cmp	r3, #0
 800d51c:	da04      	bge.n	800d528 <_puts_r+0x84>
 800d51e:	69a2      	ldr	r2, [r4, #24]
 800d520:	429a      	cmp	r2, r3
 800d522:	dc06      	bgt.n	800d532 <_puts_r+0x8e>
 800d524:	290a      	cmp	r1, #10
 800d526:	d004      	beq.n	800d532 <_puts_r+0x8e>
 800d528:	6823      	ldr	r3, [r4, #0]
 800d52a:	1c5a      	adds	r2, r3, #1
 800d52c:	6022      	str	r2, [r4, #0]
 800d52e:	7019      	strb	r1, [r3, #0]
 800d530:	e7cf      	b.n	800d4d2 <_puts_r+0x2e>
 800d532:	4622      	mov	r2, r4
 800d534:	4628      	mov	r0, r5
 800d536:	f000 f854 	bl	800d5e2 <__swbuf_r>
 800d53a:	3001      	adds	r0, #1
 800d53c:	d1c9      	bne.n	800d4d2 <_puts_r+0x2e>
 800d53e:	e7df      	b.n	800d500 <_puts_r+0x5c>
 800d540:	6823      	ldr	r3, [r4, #0]
 800d542:	250a      	movs	r5, #10
 800d544:	1c5a      	adds	r2, r3, #1
 800d546:	6022      	str	r2, [r4, #0]
 800d548:	701d      	strb	r5, [r3, #0]
 800d54a:	e7db      	b.n	800d504 <_puts_r+0x60>

0800d54c <puts>:
 800d54c:	4b02      	ldr	r3, [pc, #8]	; (800d558 <puts+0xc>)
 800d54e:	4601      	mov	r1, r0
 800d550:	6818      	ldr	r0, [r3, #0]
 800d552:	f7ff bfa7 	b.w	800d4a4 <_puts_r>
 800d556:	bf00      	nop
 800d558:	20001508 	.word	0x20001508

0800d55c <__sread>:
 800d55c:	b510      	push	{r4, lr}
 800d55e:	460c      	mov	r4, r1
 800d560:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d564:	f000 f8fc 	bl	800d760 <_read_r>
 800d568:	2800      	cmp	r0, #0
 800d56a:	bfab      	itete	ge
 800d56c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800d56e:	89a3      	ldrhlt	r3, [r4, #12]
 800d570:	181b      	addge	r3, r3, r0
 800d572:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800d576:	bfac      	ite	ge
 800d578:	6563      	strge	r3, [r4, #84]	; 0x54
 800d57a:	81a3      	strhlt	r3, [r4, #12]
 800d57c:	bd10      	pop	{r4, pc}

0800d57e <__swrite>:
 800d57e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d582:	461f      	mov	r7, r3
 800d584:	898b      	ldrh	r3, [r1, #12]
 800d586:	05db      	lsls	r3, r3, #23
 800d588:	4605      	mov	r5, r0
 800d58a:	460c      	mov	r4, r1
 800d58c:	4616      	mov	r6, r2
 800d58e:	d505      	bpl.n	800d59c <__swrite+0x1e>
 800d590:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d594:	2302      	movs	r3, #2
 800d596:	2200      	movs	r2, #0
 800d598:	f000 f8d0 	bl	800d73c <_lseek_r>
 800d59c:	89a3      	ldrh	r3, [r4, #12]
 800d59e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d5a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800d5a6:	81a3      	strh	r3, [r4, #12]
 800d5a8:	4632      	mov	r2, r6
 800d5aa:	463b      	mov	r3, r7
 800d5ac:	4628      	mov	r0, r5
 800d5ae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800d5b2:	f000 b8f7 	b.w	800d7a4 <_write_r>

0800d5b6 <__sseek>:
 800d5b6:	b510      	push	{r4, lr}
 800d5b8:	460c      	mov	r4, r1
 800d5ba:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d5be:	f000 f8bd 	bl	800d73c <_lseek_r>
 800d5c2:	1c43      	adds	r3, r0, #1
 800d5c4:	89a3      	ldrh	r3, [r4, #12]
 800d5c6:	bf15      	itete	ne
 800d5c8:	6560      	strne	r0, [r4, #84]	; 0x54
 800d5ca:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800d5ce:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800d5d2:	81a3      	strheq	r3, [r4, #12]
 800d5d4:	bf18      	it	ne
 800d5d6:	81a3      	strhne	r3, [r4, #12]
 800d5d8:	bd10      	pop	{r4, pc}

0800d5da <__sclose>:
 800d5da:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d5de:	f000 b89d 	b.w	800d71c <_close_r>

0800d5e2 <__swbuf_r>:
 800d5e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d5e4:	460e      	mov	r6, r1
 800d5e6:	4614      	mov	r4, r2
 800d5e8:	4605      	mov	r5, r0
 800d5ea:	b118      	cbz	r0, 800d5f4 <__swbuf_r+0x12>
 800d5ec:	6a03      	ldr	r3, [r0, #32]
 800d5ee:	b90b      	cbnz	r3, 800d5f4 <__swbuf_r+0x12>
 800d5f0:	f7ff ff10 	bl	800d414 <__sinit>
 800d5f4:	69a3      	ldr	r3, [r4, #24]
 800d5f6:	60a3      	str	r3, [r4, #8]
 800d5f8:	89a3      	ldrh	r3, [r4, #12]
 800d5fa:	071a      	lsls	r2, r3, #28
 800d5fc:	d525      	bpl.n	800d64a <__swbuf_r+0x68>
 800d5fe:	6923      	ldr	r3, [r4, #16]
 800d600:	b31b      	cbz	r3, 800d64a <__swbuf_r+0x68>
 800d602:	6823      	ldr	r3, [r4, #0]
 800d604:	6922      	ldr	r2, [r4, #16]
 800d606:	1a98      	subs	r0, r3, r2
 800d608:	6963      	ldr	r3, [r4, #20]
 800d60a:	b2f6      	uxtb	r6, r6
 800d60c:	4283      	cmp	r3, r0
 800d60e:	4637      	mov	r7, r6
 800d610:	dc04      	bgt.n	800d61c <__swbuf_r+0x3a>
 800d612:	4621      	mov	r1, r4
 800d614:	4628      	mov	r0, r5
 800d616:	f000 fcb9 	bl	800df8c <_fflush_r>
 800d61a:	b9e0      	cbnz	r0, 800d656 <__swbuf_r+0x74>
 800d61c:	68a3      	ldr	r3, [r4, #8]
 800d61e:	3b01      	subs	r3, #1
 800d620:	60a3      	str	r3, [r4, #8]
 800d622:	6823      	ldr	r3, [r4, #0]
 800d624:	1c5a      	adds	r2, r3, #1
 800d626:	6022      	str	r2, [r4, #0]
 800d628:	701e      	strb	r6, [r3, #0]
 800d62a:	6962      	ldr	r2, [r4, #20]
 800d62c:	1c43      	adds	r3, r0, #1
 800d62e:	429a      	cmp	r2, r3
 800d630:	d004      	beq.n	800d63c <__swbuf_r+0x5a>
 800d632:	89a3      	ldrh	r3, [r4, #12]
 800d634:	07db      	lsls	r3, r3, #31
 800d636:	d506      	bpl.n	800d646 <__swbuf_r+0x64>
 800d638:	2e0a      	cmp	r6, #10
 800d63a:	d104      	bne.n	800d646 <__swbuf_r+0x64>
 800d63c:	4621      	mov	r1, r4
 800d63e:	4628      	mov	r0, r5
 800d640:	f000 fca4 	bl	800df8c <_fflush_r>
 800d644:	b938      	cbnz	r0, 800d656 <__swbuf_r+0x74>
 800d646:	4638      	mov	r0, r7
 800d648:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d64a:	4621      	mov	r1, r4
 800d64c:	4628      	mov	r0, r5
 800d64e:	f000 f805 	bl	800d65c <__swsetup_r>
 800d652:	2800      	cmp	r0, #0
 800d654:	d0d5      	beq.n	800d602 <__swbuf_r+0x20>
 800d656:	f04f 37ff 	mov.w	r7, #4294967295
 800d65a:	e7f4      	b.n	800d646 <__swbuf_r+0x64>

0800d65c <__swsetup_r>:
 800d65c:	b538      	push	{r3, r4, r5, lr}
 800d65e:	4b2a      	ldr	r3, [pc, #168]	; (800d708 <__swsetup_r+0xac>)
 800d660:	4605      	mov	r5, r0
 800d662:	6818      	ldr	r0, [r3, #0]
 800d664:	460c      	mov	r4, r1
 800d666:	b118      	cbz	r0, 800d670 <__swsetup_r+0x14>
 800d668:	6a03      	ldr	r3, [r0, #32]
 800d66a:	b90b      	cbnz	r3, 800d670 <__swsetup_r+0x14>
 800d66c:	f7ff fed2 	bl	800d414 <__sinit>
 800d670:	89a3      	ldrh	r3, [r4, #12]
 800d672:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800d676:	0718      	lsls	r0, r3, #28
 800d678:	d422      	bmi.n	800d6c0 <__swsetup_r+0x64>
 800d67a:	06d9      	lsls	r1, r3, #27
 800d67c:	d407      	bmi.n	800d68e <__swsetup_r+0x32>
 800d67e:	2309      	movs	r3, #9
 800d680:	602b      	str	r3, [r5, #0]
 800d682:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 800d686:	81a3      	strh	r3, [r4, #12]
 800d688:	f04f 30ff 	mov.w	r0, #4294967295
 800d68c:	e034      	b.n	800d6f8 <__swsetup_r+0x9c>
 800d68e:	0758      	lsls	r0, r3, #29
 800d690:	d512      	bpl.n	800d6b8 <__swsetup_r+0x5c>
 800d692:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d694:	b141      	cbz	r1, 800d6a8 <__swsetup_r+0x4c>
 800d696:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800d69a:	4299      	cmp	r1, r3
 800d69c:	d002      	beq.n	800d6a4 <__swsetup_r+0x48>
 800d69e:	4628      	mov	r0, r5
 800d6a0:	f000 f8ce 	bl	800d840 <_free_r>
 800d6a4:	2300      	movs	r3, #0
 800d6a6:	6363      	str	r3, [r4, #52]	; 0x34
 800d6a8:	89a3      	ldrh	r3, [r4, #12]
 800d6aa:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800d6ae:	81a3      	strh	r3, [r4, #12]
 800d6b0:	2300      	movs	r3, #0
 800d6b2:	6063      	str	r3, [r4, #4]
 800d6b4:	6923      	ldr	r3, [r4, #16]
 800d6b6:	6023      	str	r3, [r4, #0]
 800d6b8:	89a3      	ldrh	r3, [r4, #12]
 800d6ba:	f043 0308 	orr.w	r3, r3, #8
 800d6be:	81a3      	strh	r3, [r4, #12]
 800d6c0:	6923      	ldr	r3, [r4, #16]
 800d6c2:	b94b      	cbnz	r3, 800d6d8 <__swsetup_r+0x7c>
 800d6c4:	89a3      	ldrh	r3, [r4, #12]
 800d6c6:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800d6ca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800d6ce:	d003      	beq.n	800d6d8 <__swsetup_r+0x7c>
 800d6d0:	4621      	mov	r1, r4
 800d6d2:	4628      	mov	r0, r5
 800d6d4:	f000 fca8 	bl	800e028 <__smakebuf_r>
 800d6d8:	89a0      	ldrh	r0, [r4, #12]
 800d6da:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800d6de:	f010 0301 	ands.w	r3, r0, #1
 800d6e2:	d00a      	beq.n	800d6fa <__swsetup_r+0x9e>
 800d6e4:	2300      	movs	r3, #0
 800d6e6:	60a3      	str	r3, [r4, #8]
 800d6e8:	6963      	ldr	r3, [r4, #20]
 800d6ea:	425b      	negs	r3, r3
 800d6ec:	61a3      	str	r3, [r4, #24]
 800d6ee:	6923      	ldr	r3, [r4, #16]
 800d6f0:	b943      	cbnz	r3, 800d704 <__swsetup_r+0xa8>
 800d6f2:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800d6f6:	d1c4      	bne.n	800d682 <__swsetup_r+0x26>
 800d6f8:	bd38      	pop	{r3, r4, r5, pc}
 800d6fa:	0781      	lsls	r1, r0, #30
 800d6fc:	bf58      	it	pl
 800d6fe:	6963      	ldrpl	r3, [r4, #20]
 800d700:	60a3      	str	r3, [r4, #8]
 800d702:	e7f4      	b.n	800d6ee <__swsetup_r+0x92>
 800d704:	2000      	movs	r0, #0
 800d706:	e7f7      	b.n	800d6f8 <__swsetup_r+0x9c>
 800d708:	20001508 	.word	0x20001508

0800d70c <memset>:
 800d70c:	4402      	add	r2, r0
 800d70e:	4603      	mov	r3, r0
 800d710:	4293      	cmp	r3, r2
 800d712:	d100      	bne.n	800d716 <memset+0xa>
 800d714:	4770      	bx	lr
 800d716:	f803 1b01 	strb.w	r1, [r3], #1
 800d71a:	e7f9      	b.n	800d710 <memset+0x4>

0800d71c <_close_r>:
 800d71c:	b538      	push	{r3, r4, r5, lr}
 800d71e:	4d06      	ldr	r5, [pc, #24]	; (800d738 <_close_r+0x1c>)
 800d720:	2300      	movs	r3, #0
 800d722:	4604      	mov	r4, r0
 800d724:	4608      	mov	r0, r1
 800d726:	602b      	str	r3, [r5, #0]
 800d728:	f001 fb8e 	bl	800ee48 <_close>
 800d72c:	1c43      	adds	r3, r0, #1
 800d72e:	d102      	bne.n	800d736 <_close_r+0x1a>
 800d730:	682b      	ldr	r3, [r5, #0]
 800d732:	b103      	cbz	r3, 800d736 <_close_r+0x1a>
 800d734:	6023      	str	r3, [r4, #0]
 800d736:	bd38      	pop	{r3, r4, r5, pc}
 800d738:	200031f0 	.word	0x200031f0

0800d73c <_lseek_r>:
 800d73c:	b538      	push	{r3, r4, r5, lr}
 800d73e:	4d07      	ldr	r5, [pc, #28]	; (800d75c <_lseek_r+0x20>)
 800d740:	4604      	mov	r4, r0
 800d742:	4608      	mov	r0, r1
 800d744:	4611      	mov	r1, r2
 800d746:	2200      	movs	r2, #0
 800d748:	602a      	str	r2, [r5, #0]
 800d74a:	461a      	mov	r2, r3
 800d74c:	f001 fb94 	bl	800ee78 <_lseek>
 800d750:	1c43      	adds	r3, r0, #1
 800d752:	d102      	bne.n	800d75a <_lseek_r+0x1e>
 800d754:	682b      	ldr	r3, [r5, #0]
 800d756:	b103      	cbz	r3, 800d75a <_lseek_r+0x1e>
 800d758:	6023      	str	r3, [r4, #0]
 800d75a:	bd38      	pop	{r3, r4, r5, pc}
 800d75c:	200031f0 	.word	0x200031f0

0800d760 <_read_r>:
 800d760:	b538      	push	{r3, r4, r5, lr}
 800d762:	4d07      	ldr	r5, [pc, #28]	; (800d780 <_read_r+0x20>)
 800d764:	4604      	mov	r4, r0
 800d766:	4608      	mov	r0, r1
 800d768:	4611      	mov	r1, r2
 800d76a:	2200      	movs	r2, #0
 800d76c:	602a      	str	r2, [r5, #0]
 800d76e:	461a      	mov	r2, r3
 800d770:	f001 fb8a 	bl	800ee88 <_read>
 800d774:	1c43      	adds	r3, r0, #1
 800d776:	d102      	bne.n	800d77e <_read_r+0x1e>
 800d778:	682b      	ldr	r3, [r5, #0]
 800d77a:	b103      	cbz	r3, 800d77e <_read_r+0x1e>
 800d77c:	6023      	str	r3, [r4, #0]
 800d77e:	bd38      	pop	{r3, r4, r5, pc}
 800d780:	200031f0 	.word	0x200031f0

0800d784 <_sbrk_r>:
 800d784:	b538      	push	{r3, r4, r5, lr}
 800d786:	4d06      	ldr	r5, [pc, #24]	; (800d7a0 <_sbrk_r+0x1c>)
 800d788:	2300      	movs	r3, #0
 800d78a:	4604      	mov	r4, r0
 800d78c:	4608      	mov	r0, r1
 800d78e:	602b      	str	r3, [r5, #0]
 800d790:	f7f7 fa62 	bl	8004c58 <_sbrk>
 800d794:	1c43      	adds	r3, r0, #1
 800d796:	d102      	bne.n	800d79e <_sbrk_r+0x1a>
 800d798:	682b      	ldr	r3, [r5, #0]
 800d79a:	b103      	cbz	r3, 800d79e <_sbrk_r+0x1a>
 800d79c:	6023      	str	r3, [r4, #0]
 800d79e:	bd38      	pop	{r3, r4, r5, pc}
 800d7a0:	200031f0 	.word	0x200031f0

0800d7a4 <_write_r>:
 800d7a4:	b538      	push	{r3, r4, r5, lr}
 800d7a6:	4d07      	ldr	r5, [pc, #28]	; (800d7c4 <_write_r+0x20>)
 800d7a8:	4604      	mov	r4, r0
 800d7aa:	4608      	mov	r0, r1
 800d7ac:	4611      	mov	r1, r2
 800d7ae:	2200      	movs	r2, #0
 800d7b0:	602a      	str	r2, [r5, #0]
 800d7b2:	461a      	mov	r2, r3
 800d7b4:	f001 fb70 	bl	800ee98 <_write>
 800d7b8:	1c43      	adds	r3, r0, #1
 800d7ba:	d102      	bne.n	800d7c2 <_write_r+0x1e>
 800d7bc:	682b      	ldr	r3, [r5, #0]
 800d7be:	b103      	cbz	r3, 800d7c2 <_write_r+0x1e>
 800d7c0:	6023      	str	r3, [r4, #0]
 800d7c2:	bd38      	pop	{r3, r4, r5, pc}
 800d7c4:	200031f0 	.word	0x200031f0

0800d7c8 <__errno>:
 800d7c8:	4b01      	ldr	r3, [pc, #4]	; (800d7d0 <__errno+0x8>)
 800d7ca:	6818      	ldr	r0, [r3, #0]
 800d7cc:	4770      	bx	lr
 800d7ce:	bf00      	nop
 800d7d0:	20001508 	.word	0x20001508

0800d7d4 <__libc_init_array>:
 800d7d4:	b570      	push	{r4, r5, r6, lr}
 800d7d6:	4d0d      	ldr	r5, [pc, #52]	; (800d80c <__libc_init_array+0x38>)
 800d7d8:	4c0d      	ldr	r4, [pc, #52]	; (800d810 <__libc_init_array+0x3c>)
 800d7da:	1b64      	subs	r4, r4, r5
 800d7dc:	10a4      	asrs	r4, r4, #2
 800d7de:	2600      	movs	r6, #0
 800d7e0:	42a6      	cmp	r6, r4
 800d7e2:	d109      	bne.n	800d7f8 <__libc_init_array+0x24>
 800d7e4:	4d0b      	ldr	r5, [pc, #44]	; (800d814 <__libc_init_array+0x40>)
 800d7e6:	4c0c      	ldr	r4, [pc, #48]	; (800d818 <__libc_init_array+0x44>)
 800d7e8:	f001 fb5e 	bl	800eea8 <_init>
 800d7ec:	1b64      	subs	r4, r4, r5
 800d7ee:	10a4      	asrs	r4, r4, #2
 800d7f0:	2600      	movs	r6, #0
 800d7f2:	42a6      	cmp	r6, r4
 800d7f4:	d105      	bne.n	800d802 <__libc_init_array+0x2e>
 800d7f6:	bd70      	pop	{r4, r5, r6, pc}
 800d7f8:	f855 3b04 	ldr.w	r3, [r5], #4
 800d7fc:	4798      	blx	r3
 800d7fe:	3601      	adds	r6, #1
 800d800:	e7ee      	b.n	800d7e0 <__libc_init_array+0xc>
 800d802:	f855 3b04 	ldr.w	r3, [r5], #4
 800d806:	4798      	blx	r3
 800d808:	3601      	adds	r6, #1
 800d80a:	e7f2      	b.n	800d7f2 <__libc_init_array+0x1e>
 800d80c:	0801a63c 	.word	0x0801a63c
 800d810:	0801a63c 	.word	0x0801a63c
 800d814:	0801a63c 	.word	0x0801a63c
 800d818:	0801a640 	.word	0x0801a640

0800d81c <__retarget_lock_init_recursive>:
 800d81c:	4770      	bx	lr

0800d81e <__retarget_lock_acquire_recursive>:
 800d81e:	4770      	bx	lr

0800d820 <__retarget_lock_release_recursive>:
 800d820:	4770      	bx	lr

0800d822 <memcpy>:
 800d822:	440a      	add	r2, r1
 800d824:	4291      	cmp	r1, r2
 800d826:	f100 33ff 	add.w	r3, r0, #4294967295
 800d82a:	d100      	bne.n	800d82e <memcpy+0xc>
 800d82c:	4770      	bx	lr
 800d82e:	b510      	push	{r4, lr}
 800d830:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d834:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d838:	4291      	cmp	r1, r2
 800d83a:	d1f9      	bne.n	800d830 <memcpy+0xe>
 800d83c:	bd10      	pop	{r4, pc}
	...

0800d840 <_free_r>:
 800d840:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800d842:	2900      	cmp	r1, #0
 800d844:	d044      	beq.n	800d8d0 <_free_r+0x90>
 800d846:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d84a:	9001      	str	r0, [sp, #4]
 800d84c:	2b00      	cmp	r3, #0
 800d84e:	f1a1 0404 	sub.w	r4, r1, #4
 800d852:	bfb8      	it	lt
 800d854:	18e4      	addlt	r4, r4, r3
 800d856:	f7ff fd45 	bl	800d2e4 <__malloc_lock>
 800d85a:	4a1e      	ldr	r2, [pc, #120]	; (800d8d4 <_free_r+0x94>)
 800d85c:	9801      	ldr	r0, [sp, #4]
 800d85e:	6813      	ldr	r3, [r2, #0]
 800d860:	b933      	cbnz	r3, 800d870 <_free_r+0x30>
 800d862:	6063      	str	r3, [r4, #4]
 800d864:	6014      	str	r4, [r2, #0]
 800d866:	b003      	add	sp, #12
 800d868:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800d86c:	f7ff bd40 	b.w	800d2f0 <__malloc_unlock>
 800d870:	42a3      	cmp	r3, r4
 800d872:	d908      	bls.n	800d886 <_free_r+0x46>
 800d874:	6825      	ldr	r5, [r4, #0]
 800d876:	1961      	adds	r1, r4, r5
 800d878:	428b      	cmp	r3, r1
 800d87a:	bf01      	itttt	eq
 800d87c:	6819      	ldreq	r1, [r3, #0]
 800d87e:	685b      	ldreq	r3, [r3, #4]
 800d880:	1949      	addeq	r1, r1, r5
 800d882:	6021      	streq	r1, [r4, #0]
 800d884:	e7ed      	b.n	800d862 <_free_r+0x22>
 800d886:	461a      	mov	r2, r3
 800d888:	685b      	ldr	r3, [r3, #4]
 800d88a:	b10b      	cbz	r3, 800d890 <_free_r+0x50>
 800d88c:	42a3      	cmp	r3, r4
 800d88e:	d9fa      	bls.n	800d886 <_free_r+0x46>
 800d890:	6811      	ldr	r1, [r2, #0]
 800d892:	1855      	adds	r5, r2, r1
 800d894:	42a5      	cmp	r5, r4
 800d896:	d10b      	bne.n	800d8b0 <_free_r+0x70>
 800d898:	6824      	ldr	r4, [r4, #0]
 800d89a:	4421      	add	r1, r4
 800d89c:	1854      	adds	r4, r2, r1
 800d89e:	42a3      	cmp	r3, r4
 800d8a0:	6011      	str	r1, [r2, #0]
 800d8a2:	d1e0      	bne.n	800d866 <_free_r+0x26>
 800d8a4:	681c      	ldr	r4, [r3, #0]
 800d8a6:	685b      	ldr	r3, [r3, #4]
 800d8a8:	6053      	str	r3, [r2, #4]
 800d8aa:	440c      	add	r4, r1
 800d8ac:	6014      	str	r4, [r2, #0]
 800d8ae:	e7da      	b.n	800d866 <_free_r+0x26>
 800d8b0:	d902      	bls.n	800d8b8 <_free_r+0x78>
 800d8b2:	230c      	movs	r3, #12
 800d8b4:	6003      	str	r3, [r0, #0]
 800d8b6:	e7d6      	b.n	800d866 <_free_r+0x26>
 800d8b8:	6825      	ldr	r5, [r4, #0]
 800d8ba:	1961      	adds	r1, r4, r5
 800d8bc:	428b      	cmp	r3, r1
 800d8be:	bf04      	itt	eq
 800d8c0:	6819      	ldreq	r1, [r3, #0]
 800d8c2:	685b      	ldreq	r3, [r3, #4]
 800d8c4:	6063      	str	r3, [r4, #4]
 800d8c6:	bf04      	itt	eq
 800d8c8:	1949      	addeq	r1, r1, r5
 800d8ca:	6021      	streq	r1, [r4, #0]
 800d8cc:	6054      	str	r4, [r2, #4]
 800d8ce:	e7ca      	b.n	800d866 <_free_r+0x26>
 800d8d0:	b003      	add	sp, #12
 800d8d2:	bd30      	pop	{r4, r5, pc}
 800d8d4:	200030ac 	.word	0x200030ac

0800d8d8 <__sfputc_r>:
 800d8d8:	6893      	ldr	r3, [r2, #8]
 800d8da:	3b01      	subs	r3, #1
 800d8dc:	2b00      	cmp	r3, #0
 800d8de:	b410      	push	{r4}
 800d8e0:	6093      	str	r3, [r2, #8]
 800d8e2:	da08      	bge.n	800d8f6 <__sfputc_r+0x1e>
 800d8e4:	6994      	ldr	r4, [r2, #24]
 800d8e6:	42a3      	cmp	r3, r4
 800d8e8:	db01      	blt.n	800d8ee <__sfputc_r+0x16>
 800d8ea:	290a      	cmp	r1, #10
 800d8ec:	d103      	bne.n	800d8f6 <__sfputc_r+0x1e>
 800d8ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d8f2:	f7ff be76 	b.w	800d5e2 <__swbuf_r>
 800d8f6:	6813      	ldr	r3, [r2, #0]
 800d8f8:	1c58      	adds	r0, r3, #1
 800d8fa:	6010      	str	r0, [r2, #0]
 800d8fc:	7019      	strb	r1, [r3, #0]
 800d8fe:	4608      	mov	r0, r1
 800d900:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d904:	4770      	bx	lr

0800d906 <__sfputs_r>:
 800d906:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d908:	4606      	mov	r6, r0
 800d90a:	460f      	mov	r7, r1
 800d90c:	4614      	mov	r4, r2
 800d90e:	18d5      	adds	r5, r2, r3
 800d910:	42ac      	cmp	r4, r5
 800d912:	d101      	bne.n	800d918 <__sfputs_r+0x12>
 800d914:	2000      	movs	r0, #0
 800d916:	e007      	b.n	800d928 <__sfputs_r+0x22>
 800d918:	f814 1b01 	ldrb.w	r1, [r4], #1
 800d91c:	463a      	mov	r2, r7
 800d91e:	4630      	mov	r0, r6
 800d920:	f7ff ffda 	bl	800d8d8 <__sfputc_r>
 800d924:	1c43      	adds	r3, r0, #1
 800d926:	d1f3      	bne.n	800d910 <__sfputs_r+0xa>
 800d928:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800d92c <_vfiprintf_r>:
 800d92c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d930:	460d      	mov	r5, r1
 800d932:	b09d      	sub	sp, #116	; 0x74
 800d934:	4614      	mov	r4, r2
 800d936:	4698      	mov	r8, r3
 800d938:	4606      	mov	r6, r0
 800d93a:	b118      	cbz	r0, 800d944 <_vfiprintf_r+0x18>
 800d93c:	6a03      	ldr	r3, [r0, #32]
 800d93e:	b90b      	cbnz	r3, 800d944 <_vfiprintf_r+0x18>
 800d940:	f7ff fd68 	bl	800d414 <__sinit>
 800d944:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d946:	07d9      	lsls	r1, r3, #31
 800d948:	d405      	bmi.n	800d956 <_vfiprintf_r+0x2a>
 800d94a:	89ab      	ldrh	r3, [r5, #12]
 800d94c:	059a      	lsls	r2, r3, #22
 800d94e:	d402      	bmi.n	800d956 <_vfiprintf_r+0x2a>
 800d950:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800d952:	f7ff ff64 	bl	800d81e <__retarget_lock_acquire_recursive>
 800d956:	89ab      	ldrh	r3, [r5, #12]
 800d958:	071b      	lsls	r3, r3, #28
 800d95a:	d501      	bpl.n	800d960 <_vfiprintf_r+0x34>
 800d95c:	692b      	ldr	r3, [r5, #16]
 800d95e:	b99b      	cbnz	r3, 800d988 <_vfiprintf_r+0x5c>
 800d960:	4629      	mov	r1, r5
 800d962:	4630      	mov	r0, r6
 800d964:	f7ff fe7a 	bl	800d65c <__swsetup_r>
 800d968:	b170      	cbz	r0, 800d988 <_vfiprintf_r+0x5c>
 800d96a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d96c:	07dc      	lsls	r4, r3, #31
 800d96e:	d504      	bpl.n	800d97a <_vfiprintf_r+0x4e>
 800d970:	f04f 30ff 	mov.w	r0, #4294967295
 800d974:	b01d      	add	sp, #116	; 0x74
 800d976:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d97a:	89ab      	ldrh	r3, [r5, #12]
 800d97c:	0598      	lsls	r0, r3, #22
 800d97e:	d4f7      	bmi.n	800d970 <_vfiprintf_r+0x44>
 800d980:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800d982:	f7ff ff4d 	bl	800d820 <__retarget_lock_release_recursive>
 800d986:	e7f3      	b.n	800d970 <_vfiprintf_r+0x44>
 800d988:	2300      	movs	r3, #0
 800d98a:	9309      	str	r3, [sp, #36]	; 0x24
 800d98c:	2320      	movs	r3, #32
 800d98e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800d992:	f8cd 800c 	str.w	r8, [sp, #12]
 800d996:	2330      	movs	r3, #48	; 0x30
 800d998:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 800db4c <_vfiprintf_r+0x220>
 800d99c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800d9a0:	f04f 0901 	mov.w	r9, #1
 800d9a4:	4623      	mov	r3, r4
 800d9a6:	469a      	mov	sl, r3
 800d9a8:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d9ac:	b10a      	cbz	r2, 800d9b2 <_vfiprintf_r+0x86>
 800d9ae:	2a25      	cmp	r2, #37	; 0x25
 800d9b0:	d1f9      	bne.n	800d9a6 <_vfiprintf_r+0x7a>
 800d9b2:	ebba 0b04 	subs.w	fp, sl, r4
 800d9b6:	d00b      	beq.n	800d9d0 <_vfiprintf_r+0xa4>
 800d9b8:	465b      	mov	r3, fp
 800d9ba:	4622      	mov	r2, r4
 800d9bc:	4629      	mov	r1, r5
 800d9be:	4630      	mov	r0, r6
 800d9c0:	f7ff ffa1 	bl	800d906 <__sfputs_r>
 800d9c4:	3001      	adds	r0, #1
 800d9c6:	f000 80a9 	beq.w	800db1c <_vfiprintf_r+0x1f0>
 800d9ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d9cc:	445a      	add	r2, fp
 800d9ce:	9209      	str	r2, [sp, #36]	; 0x24
 800d9d0:	f89a 3000 	ldrb.w	r3, [sl]
 800d9d4:	2b00      	cmp	r3, #0
 800d9d6:	f000 80a1 	beq.w	800db1c <_vfiprintf_r+0x1f0>
 800d9da:	2300      	movs	r3, #0
 800d9dc:	f04f 32ff 	mov.w	r2, #4294967295
 800d9e0:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800d9e4:	f10a 0a01 	add.w	sl, sl, #1
 800d9e8:	9304      	str	r3, [sp, #16]
 800d9ea:	9307      	str	r3, [sp, #28]
 800d9ec:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800d9f0:	931a      	str	r3, [sp, #104]	; 0x68
 800d9f2:	4654      	mov	r4, sl
 800d9f4:	2205      	movs	r2, #5
 800d9f6:	f814 1b01 	ldrb.w	r1, [r4], #1
 800d9fa:	4854      	ldr	r0, [pc, #336]	; (800db4c <_vfiprintf_r+0x220>)
 800d9fc:	f7f2 fc10 	bl	8000220 <memchr>
 800da00:	9a04      	ldr	r2, [sp, #16]
 800da02:	b9d8      	cbnz	r0, 800da3c <_vfiprintf_r+0x110>
 800da04:	06d1      	lsls	r1, r2, #27
 800da06:	bf44      	itt	mi
 800da08:	2320      	movmi	r3, #32
 800da0a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800da0e:	0713      	lsls	r3, r2, #28
 800da10:	bf44      	itt	mi
 800da12:	232b      	movmi	r3, #43	; 0x2b
 800da14:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800da18:	f89a 3000 	ldrb.w	r3, [sl]
 800da1c:	2b2a      	cmp	r3, #42	; 0x2a
 800da1e:	d015      	beq.n	800da4c <_vfiprintf_r+0x120>
 800da20:	9a07      	ldr	r2, [sp, #28]
 800da22:	4654      	mov	r4, sl
 800da24:	2000      	movs	r0, #0
 800da26:	f04f 0c0a 	mov.w	ip, #10
 800da2a:	4621      	mov	r1, r4
 800da2c:	f811 3b01 	ldrb.w	r3, [r1], #1
 800da30:	3b30      	subs	r3, #48	; 0x30
 800da32:	2b09      	cmp	r3, #9
 800da34:	d94d      	bls.n	800dad2 <_vfiprintf_r+0x1a6>
 800da36:	b1b0      	cbz	r0, 800da66 <_vfiprintf_r+0x13a>
 800da38:	9207      	str	r2, [sp, #28]
 800da3a:	e014      	b.n	800da66 <_vfiprintf_r+0x13a>
 800da3c:	eba0 0308 	sub.w	r3, r0, r8
 800da40:	fa09 f303 	lsl.w	r3, r9, r3
 800da44:	4313      	orrs	r3, r2
 800da46:	9304      	str	r3, [sp, #16]
 800da48:	46a2      	mov	sl, r4
 800da4a:	e7d2      	b.n	800d9f2 <_vfiprintf_r+0xc6>
 800da4c:	9b03      	ldr	r3, [sp, #12]
 800da4e:	1d19      	adds	r1, r3, #4
 800da50:	681b      	ldr	r3, [r3, #0]
 800da52:	9103      	str	r1, [sp, #12]
 800da54:	2b00      	cmp	r3, #0
 800da56:	bfbb      	ittet	lt
 800da58:	425b      	neglt	r3, r3
 800da5a:	f042 0202 	orrlt.w	r2, r2, #2
 800da5e:	9307      	strge	r3, [sp, #28]
 800da60:	9307      	strlt	r3, [sp, #28]
 800da62:	bfb8      	it	lt
 800da64:	9204      	strlt	r2, [sp, #16]
 800da66:	7823      	ldrb	r3, [r4, #0]
 800da68:	2b2e      	cmp	r3, #46	; 0x2e
 800da6a:	d10c      	bne.n	800da86 <_vfiprintf_r+0x15a>
 800da6c:	7863      	ldrb	r3, [r4, #1]
 800da6e:	2b2a      	cmp	r3, #42	; 0x2a
 800da70:	d134      	bne.n	800dadc <_vfiprintf_r+0x1b0>
 800da72:	9b03      	ldr	r3, [sp, #12]
 800da74:	1d1a      	adds	r2, r3, #4
 800da76:	681b      	ldr	r3, [r3, #0]
 800da78:	9203      	str	r2, [sp, #12]
 800da7a:	2b00      	cmp	r3, #0
 800da7c:	bfb8      	it	lt
 800da7e:	f04f 33ff 	movlt.w	r3, #4294967295
 800da82:	3402      	adds	r4, #2
 800da84:	9305      	str	r3, [sp, #20]
 800da86:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 800db5c <_vfiprintf_r+0x230>
 800da8a:	7821      	ldrb	r1, [r4, #0]
 800da8c:	2203      	movs	r2, #3
 800da8e:	4650      	mov	r0, sl
 800da90:	f7f2 fbc6 	bl	8000220 <memchr>
 800da94:	b138      	cbz	r0, 800daa6 <_vfiprintf_r+0x17a>
 800da96:	9b04      	ldr	r3, [sp, #16]
 800da98:	eba0 000a 	sub.w	r0, r0, sl
 800da9c:	2240      	movs	r2, #64	; 0x40
 800da9e:	4082      	lsls	r2, r0
 800daa0:	4313      	orrs	r3, r2
 800daa2:	3401      	adds	r4, #1
 800daa4:	9304      	str	r3, [sp, #16]
 800daa6:	f814 1b01 	ldrb.w	r1, [r4], #1
 800daaa:	4829      	ldr	r0, [pc, #164]	; (800db50 <_vfiprintf_r+0x224>)
 800daac:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800dab0:	2206      	movs	r2, #6
 800dab2:	f7f2 fbb5 	bl	8000220 <memchr>
 800dab6:	2800      	cmp	r0, #0
 800dab8:	d03f      	beq.n	800db3a <_vfiprintf_r+0x20e>
 800daba:	4b26      	ldr	r3, [pc, #152]	; (800db54 <_vfiprintf_r+0x228>)
 800dabc:	bb1b      	cbnz	r3, 800db06 <_vfiprintf_r+0x1da>
 800dabe:	9b03      	ldr	r3, [sp, #12]
 800dac0:	3307      	adds	r3, #7
 800dac2:	f023 0307 	bic.w	r3, r3, #7
 800dac6:	3308      	adds	r3, #8
 800dac8:	9303      	str	r3, [sp, #12]
 800daca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dacc:	443b      	add	r3, r7
 800dace:	9309      	str	r3, [sp, #36]	; 0x24
 800dad0:	e768      	b.n	800d9a4 <_vfiprintf_r+0x78>
 800dad2:	fb0c 3202 	mla	r2, ip, r2, r3
 800dad6:	460c      	mov	r4, r1
 800dad8:	2001      	movs	r0, #1
 800dada:	e7a6      	b.n	800da2a <_vfiprintf_r+0xfe>
 800dadc:	2300      	movs	r3, #0
 800dade:	3401      	adds	r4, #1
 800dae0:	9305      	str	r3, [sp, #20]
 800dae2:	4619      	mov	r1, r3
 800dae4:	f04f 0c0a 	mov.w	ip, #10
 800dae8:	4620      	mov	r0, r4
 800daea:	f810 2b01 	ldrb.w	r2, [r0], #1
 800daee:	3a30      	subs	r2, #48	; 0x30
 800daf0:	2a09      	cmp	r2, #9
 800daf2:	d903      	bls.n	800dafc <_vfiprintf_r+0x1d0>
 800daf4:	2b00      	cmp	r3, #0
 800daf6:	d0c6      	beq.n	800da86 <_vfiprintf_r+0x15a>
 800daf8:	9105      	str	r1, [sp, #20]
 800dafa:	e7c4      	b.n	800da86 <_vfiprintf_r+0x15a>
 800dafc:	fb0c 2101 	mla	r1, ip, r1, r2
 800db00:	4604      	mov	r4, r0
 800db02:	2301      	movs	r3, #1
 800db04:	e7f0      	b.n	800dae8 <_vfiprintf_r+0x1bc>
 800db06:	ab03      	add	r3, sp, #12
 800db08:	9300      	str	r3, [sp, #0]
 800db0a:	462a      	mov	r2, r5
 800db0c:	4b12      	ldr	r3, [pc, #72]	; (800db58 <_vfiprintf_r+0x22c>)
 800db0e:	a904      	add	r1, sp, #16
 800db10:	4630      	mov	r0, r6
 800db12:	f3af 8000 	nop.w
 800db16:	4607      	mov	r7, r0
 800db18:	1c78      	adds	r0, r7, #1
 800db1a:	d1d6      	bne.n	800daca <_vfiprintf_r+0x19e>
 800db1c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800db1e:	07d9      	lsls	r1, r3, #31
 800db20:	d405      	bmi.n	800db2e <_vfiprintf_r+0x202>
 800db22:	89ab      	ldrh	r3, [r5, #12]
 800db24:	059a      	lsls	r2, r3, #22
 800db26:	d402      	bmi.n	800db2e <_vfiprintf_r+0x202>
 800db28:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800db2a:	f7ff fe79 	bl	800d820 <__retarget_lock_release_recursive>
 800db2e:	89ab      	ldrh	r3, [r5, #12]
 800db30:	065b      	lsls	r3, r3, #25
 800db32:	f53f af1d 	bmi.w	800d970 <_vfiprintf_r+0x44>
 800db36:	9809      	ldr	r0, [sp, #36]	; 0x24
 800db38:	e71c      	b.n	800d974 <_vfiprintf_r+0x48>
 800db3a:	ab03      	add	r3, sp, #12
 800db3c:	9300      	str	r3, [sp, #0]
 800db3e:	462a      	mov	r2, r5
 800db40:	4b05      	ldr	r3, [pc, #20]	; (800db58 <_vfiprintf_r+0x22c>)
 800db42:	a904      	add	r1, sp, #16
 800db44:	4630      	mov	r0, r6
 800db46:	f000 f879 	bl	800dc3c <_printf_i>
 800db4a:	e7e4      	b.n	800db16 <_vfiprintf_r+0x1ea>
 800db4c:	0801a218 	.word	0x0801a218
 800db50:	0801a222 	.word	0x0801a222
 800db54:	00000000 	.word	0x00000000
 800db58:	0800d907 	.word	0x0800d907
 800db5c:	0801a21e 	.word	0x0801a21e

0800db60 <_printf_common>:
 800db60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800db64:	4616      	mov	r6, r2
 800db66:	4699      	mov	r9, r3
 800db68:	688a      	ldr	r2, [r1, #8]
 800db6a:	690b      	ldr	r3, [r1, #16]
 800db6c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800db70:	4293      	cmp	r3, r2
 800db72:	bfb8      	it	lt
 800db74:	4613      	movlt	r3, r2
 800db76:	6033      	str	r3, [r6, #0]
 800db78:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800db7c:	4607      	mov	r7, r0
 800db7e:	460c      	mov	r4, r1
 800db80:	b10a      	cbz	r2, 800db86 <_printf_common+0x26>
 800db82:	3301      	adds	r3, #1
 800db84:	6033      	str	r3, [r6, #0]
 800db86:	6823      	ldr	r3, [r4, #0]
 800db88:	0699      	lsls	r1, r3, #26
 800db8a:	bf42      	ittt	mi
 800db8c:	6833      	ldrmi	r3, [r6, #0]
 800db8e:	3302      	addmi	r3, #2
 800db90:	6033      	strmi	r3, [r6, #0]
 800db92:	6825      	ldr	r5, [r4, #0]
 800db94:	f015 0506 	ands.w	r5, r5, #6
 800db98:	d106      	bne.n	800dba8 <_printf_common+0x48>
 800db9a:	f104 0a19 	add.w	sl, r4, #25
 800db9e:	68e3      	ldr	r3, [r4, #12]
 800dba0:	6832      	ldr	r2, [r6, #0]
 800dba2:	1a9b      	subs	r3, r3, r2
 800dba4:	42ab      	cmp	r3, r5
 800dba6:	dc26      	bgt.n	800dbf6 <_printf_common+0x96>
 800dba8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800dbac:	1e13      	subs	r3, r2, #0
 800dbae:	6822      	ldr	r2, [r4, #0]
 800dbb0:	bf18      	it	ne
 800dbb2:	2301      	movne	r3, #1
 800dbb4:	0692      	lsls	r2, r2, #26
 800dbb6:	d42b      	bmi.n	800dc10 <_printf_common+0xb0>
 800dbb8:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800dbbc:	4649      	mov	r1, r9
 800dbbe:	4638      	mov	r0, r7
 800dbc0:	47c0      	blx	r8
 800dbc2:	3001      	adds	r0, #1
 800dbc4:	d01e      	beq.n	800dc04 <_printf_common+0xa4>
 800dbc6:	6823      	ldr	r3, [r4, #0]
 800dbc8:	6922      	ldr	r2, [r4, #16]
 800dbca:	f003 0306 	and.w	r3, r3, #6
 800dbce:	2b04      	cmp	r3, #4
 800dbd0:	bf02      	ittt	eq
 800dbd2:	68e5      	ldreq	r5, [r4, #12]
 800dbd4:	6833      	ldreq	r3, [r6, #0]
 800dbd6:	1aed      	subeq	r5, r5, r3
 800dbd8:	68a3      	ldr	r3, [r4, #8]
 800dbda:	bf0c      	ite	eq
 800dbdc:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800dbe0:	2500      	movne	r5, #0
 800dbe2:	4293      	cmp	r3, r2
 800dbe4:	bfc4      	itt	gt
 800dbe6:	1a9b      	subgt	r3, r3, r2
 800dbe8:	18ed      	addgt	r5, r5, r3
 800dbea:	2600      	movs	r6, #0
 800dbec:	341a      	adds	r4, #26
 800dbee:	42b5      	cmp	r5, r6
 800dbf0:	d11a      	bne.n	800dc28 <_printf_common+0xc8>
 800dbf2:	2000      	movs	r0, #0
 800dbf4:	e008      	b.n	800dc08 <_printf_common+0xa8>
 800dbf6:	2301      	movs	r3, #1
 800dbf8:	4652      	mov	r2, sl
 800dbfa:	4649      	mov	r1, r9
 800dbfc:	4638      	mov	r0, r7
 800dbfe:	47c0      	blx	r8
 800dc00:	3001      	adds	r0, #1
 800dc02:	d103      	bne.n	800dc0c <_printf_common+0xac>
 800dc04:	f04f 30ff 	mov.w	r0, #4294967295
 800dc08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dc0c:	3501      	adds	r5, #1
 800dc0e:	e7c6      	b.n	800db9e <_printf_common+0x3e>
 800dc10:	18e1      	adds	r1, r4, r3
 800dc12:	1c5a      	adds	r2, r3, #1
 800dc14:	2030      	movs	r0, #48	; 0x30
 800dc16:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800dc1a:	4422      	add	r2, r4
 800dc1c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800dc20:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800dc24:	3302      	adds	r3, #2
 800dc26:	e7c7      	b.n	800dbb8 <_printf_common+0x58>
 800dc28:	2301      	movs	r3, #1
 800dc2a:	4622      	mov	r2, r4
 800dc2c:	4649      	mov	r1, r9
 800dc2e:	4638      	mov	r0, r7
 800dc30:	47c0      	blx	r8
 800dc32:	3001      	adds	r0, #1
 800dc34:	d0e6      	beq.n	800dc04 <_printf_common+0xa4>
 800dc36:	3601      	adds	r6, #1
 800dc38:	e7d9      	b.n	800dbee <_printf_common+0x8e>
	...

0800dc3c <_printf_i>:
 800dc3c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800dc40:	7e0f      	ldrb	r7, [r1, #24]
 800dc42:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800dc44:	2f78      	cmp	r7, #120	; 0x78
 800dc46:	4691      	mov	r9, r2
 800dc48:	4680      	mov	r8, r0
 800dc4a:	460c      	mov	r4, r1
 800dc4c:	469a      	mov	sl, r3
 800dc4e:	f101 0243 	add.w	r2, r1, #67	; 0x43
 800dc52:	d807      	bhi.n	800dc64 <_printf_i+0x28>
 800dc54:	2f62      	cmp	r7, #98	; 0x62
 800dc56:	d80a      	bhi.n	800dc6e <_printf_i+0x32>
 800dc58:	2f00      	cmp	r7, #0
 800dc5a:	f000 80d4 	beq.w	800de06 <_printf_i+0x1ca>
 800dc5e:	2f58      	cmp	r7, #88	; 0x58
 800dc60:	f000 80c0 	beq.w	800dde4 <_printf_i+0x1a8>
 800dc64:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800dc68:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 800dc6c:	e03a      	b.n	800dce4 <_printf_i+0xa8>
 800dc6e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 800dc72:	2b15      	cmp	r3, #21
 800dc74:	d8f6      	bhi.n	800dc64 <_printf_i+0x28>
 800dc76:	a101      	add	r1, pc, #4	; (adr r1, 800dc7c <_printf_i+0x40>)
 800dc78:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800dc7c:	0800dcd5 	.word	0x0800dcd5
 800dc80:	0800dce9 	.word	0x0800dce9
 800dc84:	0800dc65 	.word	0x0800dc65
 800dc88:	0800dc65 	.word	0x0800dc65
 800dc8c:	0800dc65 	.word	0x0800dc65
 800dc90:	0800dc65 	.word	0x0800dc65
 800dc94:	0800dce9 	.word	0x0800dce9
 800dc98:	0800dc65 	.word	0x0800dc65
 800dc9c:	0800dc65 	.word	0x0800dc65
 800dca0:	0800dc65 	.word	0x0800dc65
 800dca4:	0800dc65 	.word	0x0800dc65
 800dca8:	0800dded 	.word	0x0800dded
 800dcac:	0800dd15 	.word	0x0800dd15
 800dcb0:	0800dda7 	.word	0x0800dda7
 800dcb4:	0800dc65 	.word	0x0800dc65
 800dcb8:	0800dc65 	.word	0x0800dc65
 800dcbc:	0800de0f 	.word	0x0800de0f
 800dcc0:	0800dc65 	.word	0x0800dc65
 800dcc4:	0800dd15 	.word	0x0800dd15
 800dcc8:	0800dc65 	.word	0x0800dc65
 800dccc:	0800dc65 	.word	0x0800dc65
 800dcd0:	0800ddaf 	.word	0x0800ddaf
 800dcd4:	682b      	ldr	r3, [r5, #0]
 800dcd6:	1d1a      	adds	r2, r3, #4
 800dcd8:	681b      	ldr	r3, [r3, #0]
 800dcda:	602a      	str	r2, [r5, #0]
 800dcdc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800dce0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800dce4:	2301      	movs	r3, #1
 800dce6:	e09f      	b.n	800de28 <_printf_i+0x1ec>
 800dce8:	6820      	ldr	r0, [r4, #0]
 800dcea:	682b      	ldr	r3, [r5, #0]
 800dcec:	0607      	lsls	r7, r0, #24
 800dcee:	f103 0104 	add.w	r1, r3, #4
 800dcf2:	6029      	str	r1, [r5, #0]
 800dcf4:	d501      	bpl.n	800dcfa <_printf_i+0xbe>
 800dcf6:	681e      	ldr	r6, [r3, #0]
 800dcf8:	e003      	b.n	800dd02 <_printf_i+0xc6>
 800dcfa:	0646      	lsls	r6, r0, #25
 800dcfc:	d5fb      	bpl.n	800dcf6 <_printf_i+0xba>
 800dcfe:	f9b3 6000 	ldrsh.w	r6, [r3]
 800dd02:	2e00      	cmp	r6, #0
 800dd04:	da03      	bge.n	800dd0e <_printf_i+0xd2>
 800dd06:	232d      	movs	r3, #45	; 0x2d
 800dd08:	4276      	negs	r6, r6
 800dd0a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800dd0e:	485a      	ldr	r0, [pc, #360]	; (800de78 <_printf_i+0x23c>)
 800dd10:	230a      	movs	r3, #10
 800dd12:	e012      	b.n	800dd3a <_printf_i+0xfe>
 800dd14:	682b      	ldr	r3, [r5, #0]
 800dd16:	6820      	ldr	r0, [r4, #0]
 800dd18:	1d19      	adds	r1, r3, #4
 800dd1a:	6029      	str	r1, [r5, #0]
 800dd1c:	0605      	lsls	r5, r0, #24
 800dd1e:	d501      	bpl.n	800dd24 <_printf_i+0xe8>
 800dd20:	681e      	ldr	r6, [r3, #0]
 800dd22:	e002      	b.n	800dd2a <_printf_i+0xee>
 800dd24:	0641      	lsls	r1, r0, #25
 800dd26:	d5fb      	bpl.n	800dd20 <_printf_i+0xe4>
 800dd28:	881e      	ldrh	r6, [r3, #0]
 800dd2a:	4853      	ldr	r0, [pc, #332]	; (800de78 <_printf_i+0x23c>)
 800dd2c:	2f6f      	cmp	r7, #111	; 0x6f
 800dd2e:	bf0c      	ite	eq
 800dd30:	2308      	moveq	r3, #8
 800dd32:	230a      	movne	r3, #10
 800dd34:	2100      	movs	r1, #0
 800dd36:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800dd3a:	6865      	ldr	r5, [r4, #4]
 800dd3c:	60a5      	str	r5, [r4, #8]
 800dd3e:	2d00      	cmp	r5, #0
 800dd40:	bfa2      	ittt	ge
 800dd42:	6821      	ldrge	r1, [r4, #0]
 800dd44:	f021 0104 	bicge.w	r1, r1, #4
 800dd48:	6021      	strge	r1, [r4, #0]
 800dd4a:	b90e      	cbnz	r6, 800dd50 <_printf_i+0x114>
 800dd4c:	2d00      	cmp	r5, #0
 800dd4e:	d04b      	beq.n	800dde8 <_printf_i+0x1ac>
 800dd50:	4615      	mov	r5, r2
 800dd52:	fbb6 f1f3 	udiv	r1, r6, r3
 800dd56:	fb03 6711 	mls	r7, r3, r1, r6
 800dd5a:	5dc7      	ldrb	r7, [r0, r7]
 800dd5c:	f805 7d01 	strb.w	r7, [r5, #-1]!
 800dd60:	4637      	mov	r7, r6
 800dd62:	42bb      	cmp	r3, r7
 800dd64:	460e      	mov	r6, r1
 800dd66:	d9f4      	bls.n	800dd52 <_printf_i+0x116>
 800dd68:	2b08      	cmp	r3, #8
 800dd6a:	d10b      	bne.n	800dd84 <_printf_i+0x148>
 800dd6c:	6823      	ldr	r3, [r4, #0]
 800dd6e:	07de      	lsls	r6, r3, #31
 800dd70:	d508      	bpl.n	800dd84 <_printf_i+0x148>
 800dd72:	6923      	ldr	r3, [r4, #16]
 800dd74:	6861      	ldr	r1, [r4, #4]
 800dd76:	4299      	cmp	r1, r3
 800dd78:	bfde      	ittt	le
 800dd7a:	2330      	movle	r3, #48	; 0x30
 800dd7c:	f805 3c01 	strble.w	r3, [r5, #-1]
 800dd80:	f105 35ff 	addle.w	r5, r5, #4294967295
 800dd84:	1b52      	subs	r2, r2, r5
 800dd86:	6122      	str	r2, [r4, #16]
 800dd88:	f8cd a000 	str.w	sl, [sp]
 800dd8c:	464b      	mov	r3, r9
 800dd8e:	aa03      	add	r2, sp, #12
 800dd90:	4621      	mov	r1, r4
 800dd92:	4640      	mov	r0, r8
 800dd94:	f7ff fee4 	bl	800db60 <_printf_common>
 800dd98:	3001      	adds	r0, #1
 800dd9a:	d14a      	bne.n	800de32 <_printf_i+0x1f6>
 800dd9c:	f04f 30ff 	mov.w	r0, #4294967295
 800dda0:	b004      	add	sp, #16
 800dda2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dda6:	6823      	ldr	r3, [r4, #0]
 800dda8:	f043 0320 	orr.w	r3, r3, #32
 800ddac:	6023      	str	r3, [r4, #0]
 800ddae:	4833      	ldr	r0, [pc, #204]	; (800de7c <_printf_i+0x240>)
 800ddb0:	2778      	movs	r7, #120	; 0x78
 800ddb2:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800ddb6:	6823      	ldr	r3, [r4, #0]
 800ddb8:	6829      	ldr	r1, [r5, #0]
 800ddba:	061f      	lsls	r7, r3, #24
 800ddbc:	f851 6b04 	ldr.w	r6, [r1], #4
 800ddc0:	d402      	bmi.n	800ddc8 <_printf_i+0x18c>
 800ddc2:	065f      	lsls	r7, r3, #25
 800ddc4:	bf48      	it	mi
 800ddc6:	b2b6      	uxthmi	r6, r6
 800ddc8:	07df      	lsls	r7, r3, #31
 800ddca:	bf48      	it	mi
 800ddcc:	f043 0320 	orrmi.w	r3, r3, #32
 800ddd0:	6029      	str	r1, [r5, #0]
 800ddd2:	bf48      	it	mi
 800ddd4:	6023      	strmi	r3, [r4, #0]
 800ddd6:	b91e      	cbnz	r6, 800dde0 <_printf_i+0x1a4>
 800ddd8:	6823      	ldr	r3, [r4, #0]
 800ddda:	f023 0320 	bic.w	r3, r3, #32
 800ddde:	6023      	str	r3, [r4, #0]
 800dde0:	2310      	movs	r3, #16
 800dde2:	e7a7      	b.n	800dd34 <_printf_i+0xf8>
 800dde4:	4824      	ldr	r0, [pc, #144]	; (800de78 <_printf_i+0x23c>)
 800dde6:	e7e4      	b.n	800ddb2 <_printf_i+0x176>
 800dde8:	4615      	mov	r5, r2
 800ddea:	e7bd      	b.n	800dd68 <_printf_i+0x12c>
 800ddec:	682b      	ldr	r3, [r5, #0]
 800ddee:	6826      	ldr	r6, [r4, #0]
 800ddf0:	6961      	ldr	r1, [r4, #20]
 800ddf2:	1d18      	adds	r0, r3, #4
 800ddf4:	6028      	str	r0, [r5, #0]
 800ddf6:	0635      	lsls	r5, r6, #24
 800ddf8:	681b      	ldr	r3, [r3, #0]
 800ddfa:	d501      	bpl.n	800de00 <_printf_i+0x1c4>
 800ddfc:	6019      	str	r1, [r3, #0]
 800ddfe:	e002      	b.n	800de06 <_printf_i+0x1ca>
 800de00:	0670      	lsls	r0, r6, #25
 800de02:	d5fb      	bpl.n	800ddfc <_printf_i+0x1c0>
 800de04:	8019      	strh	r1, [r3, #0]
 800de06:	2300      	movs	r3, #0
 800de08:	6123      	str	r3, [r4, #16]
 800de0a:	4615      	mov	r5, r2
 800de0c:	e7bc      	b.n	800dd88 <_printf_i+0x14c>
 800de0e:	682b      	ldr	r3, [r5, #0]
 800de10:	1d1a      	adds	r2, r3, #4
 800de12:	602a      	str	r2, [r5, #0]
 800de14:	681d      	ldr	r5, [r3, #0]
 800de16:	6862      	ldr	r2, [r4, #4]
 800de18:	2100      	movs	r1, #0
 800de1a:	4628      	mov	r0, r5
 800de1c:	f7f2 fa00 	bl	8000220 <memchr>
 800de20:	b108      	cbz	r0, 800de26 <_printf_i+0x1ea>
 800de22:	1b40      	subs	r0, r0, r5
 800de24:	6060      	str	r0, [r4, #4]
 800de26:	6863      	ldr	r3, [r4, #4]
 800de28:	6123      	str	r3, [r4, #16]
 800de2a:	2300      	movs	r3, #0
 800de2c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800de30:	e7aa      	b.n	800dd88 <_printf_i+0x14c>
 800de32:	6923      	ldr	r3, [r4, #16]
 800de34:	462a      	mov	r2, r5
 800de36:	4649      	mov	r1, r9
 800de38:	4640      	mov	r0, r8
 800de3a:	47d0      	blx	sl
 800de3c:	3001      	adds	r0, #1
 800de3e:	d0ad      	beq.n	800dd9c <_printf_i+0x160>
 800de40:	6823      	ldr	r3, [r4, #0]
 800de42:	079b      	lsls	r3, r3, #30
 800de44:	d413      	bmi.n	800de6e <_printf_i+0x232>
 800de46:	68e0      	ldr	r0, [r4, #12]
 800de48:	9b03      	ldr	r3, [sp, #12]
 800de4a:	4298      	cmp	r0, r3
 800de4c:	bfb8      	it	lt
 800de4e:	4618      	movlt	r0, r3
 800de50:	e7a6      	b.n	800dda0 <_printf_i+0x164>
 800de52:	2301      	movs	r3, #1
 800de54:	4632      	mov	r2, r6
 800de56:	4649      	mov	r1, r9
 800de58:	4640      	mov	r0, r8
 800de5a:	47d0      	blx	sl
 800de5c:	3001      	adds	r0, #1
 800de5e:	d09d      	beq.n	800dd9c <_printf_i+0x160>
 800de60:	3501      	adds	r5, #1
 800de62:	68e3      	ldr	r3, [r4, #12]
 800de64:	9903      	ldr	r1, [sp, #12]
 800de66:	1a5b      	subs	r3, r3, r1
 800de68:	42ab      	cmp	r3, r5
 800de6a:	dcf2      	bgt.n	800de52 <_printf_i+0x216>
 800de6c:	e7eb      	b.n	800de46 <_printf_i+0x20a>
 800de6e:	2500      	movs	r5, #0
 800de70:	f104 0619 	add.w	r6, r4, #25
 800de74:	e7f5      	b.n	800de62 <_printf_i+0x226>
 800de76:	bf00      	nop
 800de78:	0801a229 	.word	0x0801a229
 800de7c:	0801a23a 	.word	0x0801a23a

0800de80 <__sflush_r>:
 800de80:	898a      	ldrh	r2, [r1, #12]
 800de82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800de86:	4605      	mov	r5, r0
 800de88:	0710      	lsls	r0, r2, #28
 800de8a:	460c      	mov	r4, r1
 800de8c:	d458      	bmi.n	800df40 <__sflush_r+0xc0>
 800de8e:	684b      	ldr	r3, [r1, #4]
 800de90:	2b00      	cmp	r3, #0
 800de92:	dc05      	bgt.n	800dea0 <__sflush_r+0x20>
 800de94:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800de96:	2b00      	cmp	r3, #0
 800de98:	dc02      	bgt.n	800dea0 <__sflush_r+0x20>
 800de9a:	2000      	movs	r0, #0
 800de9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800dea0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800dea2:	2e00      	cmp	r6, #0
 800dea4:	d0f9      	beq.n	800de9a <__sflush_r+0x1a>
 800dea6:	2300      	movs	r3, #0
 800dea8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800deac:	682f      	ldr	r7, [r5, #0]
 800deae:	6a21      	ldr	r1, [r4, #32]
 800deb0:	602b      	str	r3, [r5, #0]
 800deb2:	d032      	beq.n	800df1a <__sflush_r+0x9a>
 800deb4:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800deb6:	89a3      	ldrh	r3, [r4, #12]
 800deb8:	075a      	lsls	r2, r3, #29
 800deba:	d505      	bpl.n	800dec8 <__sflush_r+0x48>
 800debc:	6863      	ldr	r3, [r4, #4]
 800debe:	1ac0      	subs	r0, r0, r3
 800dec0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800dec2:	b10b      	cbz	r3, 800dec8 <__sflush_r+0x48>
 800dec4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800dec6:	1ac0      	subs	r0, r0, r3
 800dec8:	2300      	movs	r3, #0
 800deca:	4602      	mov	r2, r0
 800decc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800dece:	6a21      	ldr	r1, [r4, #32]
 800ded0:	4628      	mov	r0, r5
 800ded2:	47b0      	blx	r6
 800ded4:	1c43      	adds	r3, r0, #1
 800ded6:	89a3      	ldrh	r3, [r4, #12]
 800ded8:	d106      	bne.n	800dee8 <__sflush_r+0x68>
 800deda:	6829      	ldr	r1, [r5, #0]
 800dedc:	291d      	cmp	r1, #29
 800dede:	d82b      	bhi.n	800df38 <__sflush_r+0xb8>
 800dee0:	4a29      	ldr	r2, [pc, #164]	; (800df88 <__sflush_r+0x108>)
 800dee2:	410a      	asrs	r2, r1
 800dee4:	07d6      	lsls	r6, r2, #31
 800dee6:	d427      	bmi.n	800df38 <__sflush_r+0xb8>
 800dee8:	2200      	movs	r2, #0
 800deea:	6062      	str	r2, [r4, #4]
 800deec:	04d9      	lsls	r1, r3, #19
 800deee:	6922      	ldr	r2, [r4, #16]
 800def0:	6022      	str	r2, [r4, #0]
 800def2:	d504      	bpl.n	800defe <__sflush_r+0x7e>
 800def4:	1c42      	adds	r2, r0, #1
 800def6:	d101      	bne.n	800defc <__sflush_r+0x7c>
 800def8:	682b      	ldr	r3, [r5, #0]
 800defa:	b903      	cbnz	r3, 800defe <__sflush_r+0x7e>
 800defc:	6560      	str	r0, [r4, #84]	; 0x54
 800defe:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800df00:	602f      	str	r7, [r5, #0]
 800df02:	2900      	cmp	r1, #0
 800df04:	d0c9      	beq.n	800de9a <__sflush_r+0x1a>
 800df06:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800df0a:	4299      	cmp	r1, r3
 800df0c:	d002      	beq.n	800df14 <__sflush_r+0x94>
 800df0e:	4628      	mov	r0, r5
 800df10:	f7ff fc96 	bl	800d840 <_free_r>
 800df14:	2000      	movs	r0, #0
 800df16:	6360      	str	r0, [r4, #52]	; 0x34
 800df18:	e7c0      	b.n	800de9c <__sflush_r+0x1c>
 800df1a:	2301      	movs	r3, #1
 800df1c:	4628      	mov	r0, r5
 800df1e:	47b0      	blx	r6
 800df20:	1c41      	adds	r1, r0, #1
 800df22:	d1c8      	bne.n	800deb6 <__sflush_r+0x36>
 800df24:	682b      	ldr	r3, [r5, #0]
 800df26:	2b00      	cmp	r3, #0
 800df28:	d0c5      	beq.n	800deb6 <__sflush_r+0x36>
 800df2a:	2b1d      	cmp	r3, #29
 800df2c:	d001      	beq.n	800df32 <__sflush_r+0xb2>
 800df2e:	2b16      	cmp	r3, #22
 800df30:	d101      	bne.n	800df36 <__sflush_r+0xb6>
 800df32:	602f      	str	r7, [r5, #0]
 800df34:	e7b1      	b.n	800de9a <__sflush_r+0x1a>
 800df36:	89a3      	ldrh	r3, [r4, #12]
 800df38:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800df3c:	81a3      	strh	r3, [r4, #12]
 800df3e:	e7ad      	b.n	800de9c <__sflush_r+0x1c>
 800df40:	690f      	ldr	r7, [r1, #16]
 800df42:	2f00      	cmp	r7, #0
 800df44:	d0a9      	beq.n	800de9a <__sflush_r+0x1a>
 800df46:	0793      	lsls	r3, r2, #30
 800df48:	680e      	ldr	r6, [r1, #0]
 800df4a:	bf08      	it	eq
 800df4c:	694b      	ldreq	r3, [r1, #20]
 800df4e:	600f      	str	r7, [r1, #0]
 800df50:	bf18      	it	ne
 800df52:	2300      	movne	r3, #0
 800df54:	eba6 0807 	sub.w	r8, r6, r7
 800df58:	608b      	str	r3, [r1, #8]
 800df5a:	f1b8 0f00 	cmp.w	r8, #0
 800df5e:	dd9c      	ble.n	800de9a <__sflush_r+0x1a>
 800df60:	6a21      	ldr	r1, [r4, #32]
 800df62:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800df64:	4643      	mov	r3, r8
 800df66:	463a      	mov	r2, r7
 800df68:	4628      	mov	r0, r5
 800df6a:	47b0      	blx	r6
 800df6c:	2800      	cmp	r0, #0
 800df6e:	dc06      	bgt.n	800df7e <__sflush_r+0xfe>
 800df70:	89a3      	ldrh	r3, [r4, #12]
 800df72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800df76:	81a3      	strh	r3, [r4, #12]
 800df78:	f04f 30ff 	mov.w	r0, #4294967295
 800df7c:	e78e      	b.n	800de9c <__sflush_r+0x1c>
 800df7e:	4407      	add	r7, r0
 800df80:	eba8 0800 	sub.w	r8, r8, r0
 800df84:	e7e9      	b.n	800df5a <__sflush_r+0xda>
 800df86:	bf00      	nop
 800df88:	dfbffffe 	.word	0xdfbffffe

0800df8c <_fflush_r>:
 800df8c:	b538      	push	{r3, r4, r5, lr}
 800df8e:	690b      	ldr	r3, [r1, #16]
 800df90:	4605      	mov	r5, r0
 800df92:	460c      	mov	r4, r1
 800df94:	b913      	cbnz	r3, 800df9c <_fflush_r+0x10>
 800df96:	2500      	movs	r5, #0
 800df98:	4628      	mov	r0, r5
 800df9a:	bd38      	pop	{r3, r4, r5, pc}
 800df9c:	b118      	cbz	r0, 800dfa6 <_fflush_r+0x1a>
 800df9e:	6a03      	ldr	r3, [r0, #32]
 800dfa0:	b90b      	cbnz	r3, 800dfa6 <_fflush_r+0x1a>
 800dfa2:	f7ff fa37 	bl	800d414 <__sinit>
 800dfa6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800dfaa:	2b00      	cmp	r3, #0
 800dfac:	d0f3      	beq.n	800df96 <_fflush_r+0xa>
 800dfae:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800dfb0:	07d0      	lsls	r0, r2, #31
 800dfb2:	d404      	bmi.n	800dfbe <_fflush_r+0x32>
 800dfb4:	0599      	lsls	r1, r3, #22
 800dfb6:	d402      	bmi.n	800dfbe <_fflush_r+0x32>
 800dfb8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800dfba:	f7ff fc30 	bl	800d81e <__retarget_lock_acquire_recursive>
 800dfbe:	4628      	mov	r0, r5
 800dfc0:	4621      	mov	r1, r4
 800dfc2:	f7ff ff5d 	bl	800de80 <__sflush_r>
 800dfc6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800dfc8:	07da      	lsls	r2, r3, #31
 800dfca:	4605      	mov	r5, r0
 800dfcc:	d4e4      	bmi.n	800df98 <_fflush_r+0xc>
 800dfce:	89a3      	ldrh	r3, [r4, #12]
 800dfd0:	059b      	lsls	r3, r3, #22
 800dfd2:	d4e1      	bmi.n	800df98 <_fflush_r+0xc>
 800dfd4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800dfd6:	f7ff fc23 	bl	800d820 <__retarget_lock_release_recursive>
 800dfda:	e7dd      	b.n	800df98 <_fflush_r+0xc>

0800dfdc <__swhatbuf_r>:
 800dfdc:	b570      	push	{r4, r5, r6, lr}
 800dfde:	460c      	mov	r4, r1
 800dfe0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800dfe4:	2900      	cmp	r1, #0
 800dfe6:	b096      	sub	sp, #88	; 0x58
 800dfe8:	4615      	mov	r5, r2
 800dfea:	461e      	mov	r6, r3
 800dfec:	da0d      	bge.n	800e00a <__swhatbuf_r+0x2e>
 800dfee:	89a3      	ldrh	r3, [r4, #12]
 800dff0:	f013 0f80 	tst.w	r3, #128	; 0x80
 800dff4:	f04f 0100 	mov.w	r1, #0
 800dff8:	bf0c      	ite	eq
 800dffa:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 800dffe:	2340      	movne	r3, #64	; 0x40
 800e000:	2000      	movs	r0, #0
 800e002:	6031      	str	r1, [r6, #0]
 800e004:	602b      	str	r3, [r5, #0]
 800e006:	b016      	add	sp, #88	; 0x58
 800e008:	bd70      	pop	{r4, r5, r6, pc}
 800e00a:	466a      	mov	r2, sp
 800e00c:	f000 f848 	bl	800e0a0 <_fstat_r>
 800e010:	2800      	cmp	r0, #0
 800e012:	dbec      	blt.n	800dfee <__swhatbuf_r+0x12>
 800e014:	9901      	ldr	r1, [sp, #4]
 800e016:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 800e01a:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 800e01e:	4259      	negs	r1, r3
 800e020:	4159      	adcs	r1, r3
 800e022:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e026:	e7eb      	b.n	800e000 <__swhatbuf_r+0x24>

0800e028 <__smakebuf_r>:
 800e028:	898b      	ldrh	r3, [r1, #12]
 800e02a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800e02c:	079d      	lsls	r5, r3, #30
 800e02e:	4606      	mov	r6, r0
 800e030:	460c      	mov	r4, r1
 800e032:	d507      	bpl.n	800e044 <__smakebuf_r+0x1c>
 800e034:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800e038:	6023      	str	r3, [r4, #0]
 800e03a:	6123      	str	r3, [r4, #16]
 800e03c:	2301      	movs	r3, #1
 800e03e:	6163      	str	r3, [r4, #20]
 800e040:	b002      	add	sp, #8
 800e042:	bd70      	pop	{r4, r5, r6, pc}
 800e044:	ab01      	add	r3, sp, #4
 800e046:	466a      	mov	r2, sp
 800e048:	f7ff ffc8 	bl	800dfdc <__swhatbuf_r>
 800e04c:	9900      	ldr	r1, [sp, #0]
 800e04e:	4605      	mov	r5, r0
 800e050:	4630      	mov	r0, r6
 800e052:	f7ff f8c7 	bl	800d1e4 <_malloc_r>
 800e056:	b948      	cbnz	r0, 800e06c <__smakebuf_r+0x44>
 800e058:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e05c:	059a      	lsls	r2, r3, #22
 800e05e:	d4ef      	bmi.n	800e040 <__smakebuf_r+0x18>
 800e060:	f023 0303 	bic.w	r3, r3, #3
 800e064:	f043 0302 	orr.w	r3, r3, #2
 800e068:	81a3      	strh	r3, [r4, #12]
 800e06a:	e7e3      	b.n	800e034 <__smakebuf_r+0xc>
 800e06c:	89a3      	ldrh	r3, [r4, #12]
 800e06e:	6020      	str	r0, [r4, #0]
 800e070:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e074:	81a3      	strh	r3, [r4, #12]
 800e076:	9b00      	ldr	r3, [sp, #0]
 800e078:	6163      	str	r3, [r4, #20]
 800e07a:	9b01      	ldr	r3, [sp, #4]
 800e07c:	6120      	str	r0, [r4, #16]
 800e07e:	b15b      	cbz	r3, 800e098 <__smakebuf_r+0x70>
 800e080:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800e084:	4630      	mov	r0, r6
 800e086:	f000 f81d 	bl	800e0c4 <_isatty_r>
 800e08a:	b128      	cbz	r0, 800e098 <__smakebuf_r+0x70>
 800e08c:	89a3      	ldrh	r3, [r4, #12]
 800e08e:	f023 0303 	bic.w	r3, r3, #3
 800e092:	f043 0301 	orr.w	r3, r3, #1
 800e096:	81a3      	strh	r3, [r4, #12]
 800e098:	89a3      	ldrh	r3, [r4, #12]
 800e09a:	431d      	orrs	r5, r3
 800e09c:	81a5      	strh	r5, [r4, #12]
 800e09e:	e7cf      	b.n	800e040 <__smakebuf_r+0x18>

0800e0a0 <_fstat_r>:
 800e0a0:	b538      	push	{r3, r4, r5, lr}
 800e0a2:	4d07      	ldr	r5, [pc, #28]	; (800e0c0 <_fstat_r+0x20>)
 800e0a4:	2300      	movs	r3, #0
 800e0a6:	4604      	mov	r4, r0
 800e0a8:	4608      	mov	r0, r1
 800e0aa:	4611      	mov	r1, r2
 800e0ac:	602b      	str	r3, [r5, #0]
 800e0ae:	f000 fed3 	bl	800ee58 <_fstat>
 800e0b2:	1c43      	adds	r3, r0, #1
 800e0b4:	d102      	bne.n	800e0bc <_fstat_r+0x1c>
 800e0b6:	682b      	ldr	r3, [r5, #0]
 800e0b8:	b103      	cbz	r3, 800e0bc <_fstat_r+0x1c>
 800e0ba:	6023      	str	r3, [r4, #0]
 800e0bc:	bd38      	pop	{r3, r4, r5, pc}
 800e0be:	bf00      	nop
 800e0c0:	200031f0 	.word	0x200031f0

0800e0c4 <_isatty_r>:
 800e0c4:	b538      	push	{r3, r4, r5, lr}
 800e0c6:	4d06      	ldr	r5, [pc, #24]	; (800e0e0 <_isatty_r+0x1c>)
 800e0c8:	2300      	movs	r3, #0
 800e0ca:	4604      	mov	r4, r0
 800e0cc:	4608      	mov	r0, r1
 800e0ce:	602b      	str	r3, [r5, #0]
 800e0d0:	f000 feca 	bl	800ee68 <_isatty>
 800e0d4:	1c43      	adds	r3, r0, #1
 800e0d6:	d102      	bne.n	800e0de <_isatty_r+0x1a>
 800e0d8:	682b      	ldr	r3, [r5, #0]
 800e0da:	b103      	cbz	r3, 800e0de <_isatty_r+0x1a>
 800e0dc:	6023      	str	r3, [r4, #0]
 800e0de:	bd38      	pop	{r3, r4, r5, pc}
 800e0e0:	200031f0 	.word	0x200031f0

0800e0e4 <expf>:
 800e0e4:	b508      	push	{r3, lr}
 800e0e6:	ed2d 8b02 	vpush	{d8}
 800e0ea:	eef0 8a40 	vmov.f32	s17, s0
 800e0ee:	f000 f9d9 	bl	800e4a4 <__ieee754_expf>
 800e0f2:	eeb0 8a40 	vmov.f32	s16, s0
 800e0f6:	eeb0 0a68 	vmov.f32	s0, s17
 800e0fa:	f000 f8bb 	bl	800e274 <finitef>
 800e0fe:	b160      	cbz	r0, 800e11a <expf+0x36>
 800e100:	eddf 7a0f 	vldr	s15, [pc, #60]	; 800e140 <expf+0x5c>
 800e104:	eef4 8ae7 	vcmpe.f32	s17, s15
 800e108:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e10c:	dd0a      	ble.n	800e124 <expf+0x40>
 800e10e:	f7ff fb5b 	bl	800d7c8 <__errno>
 800e112:	ed9f 8a0c 	vldr	s16, [pc, #48]	; 800e144 <expf+0x60>
 800e116:	2322      	movs	r3, #34	; 0x22
 800e118:	6003      	str	r3, [r0, #0]
 800e11a:	eeb0 0a48 	vmov.f32	s0, s16
 800e11e:	ecbd 8b02 	vpop	{d8}
 800e122:	bd08      	pop	{r3, pc}
 800e124:	eddf 7a08 	vldr	s15, [pc, #32]	; 800e148 <expf+0x64>
 800e128:	eef4 8ae7 	vcmpe.f32	s17, s15
 800e12c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e130:	d5f3      	bpl.n	800e11a <expf+0x36>
 800e132:	f7ff fb49 	bl	800d7c8 <__errno>
 800e136:	2322      	movs	r3, #34	; 0x22
 800e138:	ed9f 8a04 	vldr	s16, [pc, #16]	; 800e14c <expf+0x68>
 800e13c:	6003      	str	r3, [r0, #0]
 800e13e:	e7ec      	b.n	800e11a <expf+0x36>
 800e140:	42b17217 	.word	0x42b17217
 800e144:	7f800000 	.word	0x7f800000
 800e148:	c2cff1b5 	.word	0xc2cff1b5
 800e14c:	00000000 	.word	0x00000000

0800e150 <cosf>:
 800e150:	ee10 3a10 	vmov	r3, s0
 800e154:	b507      	push	{r0, r1, r2, lr}
 800e156:	4a1e      	ldr	r2, [pc, #120]	; (800e1d0 <cosf+0x80>)
 800e158:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e15c:	4293      	cmp	r3, r2
 800e15e:	dc06      	bgt.n	800e16e <cosf+0x1e>
 800e160:	eddf 0a1c 	vldr	s1, [pc, #112]	; 800e1d4 <cosf+0x84>
 800e164:	b003      	add	sp, #12
 800e166:	f85d eb04 	ldr.w	lr, [sp], #4
 800e16a:	f000 b8f5 	b.w	800e358 <__kernel_cosf>
 800e16e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e172:	db04      	blt.n	800e17e <cosf+0x2e>
 800e174:	ee30 0a40 	vsub.f32	s0, s0, s0
 800e178:	b003      	add	sp, #12
 800e17a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e17e:	4668      	mov	r0, sp
 800e180:	f000 fa5e 	bl	800e640 <__ieee754_rem_pio2f>
 800e184:	f000 0003 	and.w	r0, r0, #3
 800e188:	2801      	cmp	r0, #1
 800e18a:	d009      	beq.n	800e1a0 <cosf+0x50>
 800e18c:	2802      	cmp	r0, #2
 800e18e:	d010      	beq.n	800e1b2 <cosf+0x62>
 800e190:	b9b0      	cbnz	r0, 800e1c0 <cosf+0x70>
 800e192:	eddd 0a01 	vldr	s1, [sp, #4]
 800e196:	ed9d 0a00 	vldr	s0, [sp]
 800e19a:	f000 f8dd 	bl	800e358 <__kernel_cosf>
 800e19e:	e7eb      	b.n	800e178 <cosf+0x28>
 800e1a0:	eddd 0a01 	vldr	s1, [sp, #4]
 800e1a4:	ed9d 0a00 	vldr	s0, [sp]
 800e1a8:	f000 f934 	bl	800e414 <__kernel_sinf>
 800e1ac:	eeb1 0a40 	vneg.f32	s0, s0
 800e1b0:	e7e2      	b.n	800e178 <cosf+0x28>
 800e1b2:	eddd 0a01 	vldr	s1, [sp, #4]
 800e1b6:	ed9d 0a00 	vldr	s0, [sp]
 800e1ba:	f000 f8cd 	bl	800e358 <__kernel_cosf>
 800e1be:	e7f5      	b.n	800e1ac <cosf+0x5c>
 800e1c0:	eddd 0a01 	vldr	s1, [sp, #4]
 800e1c4:	ed9d 0a00 	vldr	s0, [sp]
 800e1c8:	2001      	movs	r0, #1
 800e1ca:	f000 f923 	bl	800e414 <__kernel_sinf>
 800e1ce:	e7d3      	b.n	800e178 <cosf+0x28>
 800e1d0:	3f490fd8 	.word	0x3f490fd8
 800e1d4:	00000000 	.word	0x00000000

0800e1d8 <fabsf>:
 800e1d8:	ee10 3a10 	vmov	r3, s0
 800e1dc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e1e0:	ee00 3a10 	vmov	s0, r3
 800e1e4:	4770      	bx	lr
	...

0800e1e8 <sinf>:
 800e1e8:	ee10 3a10 	vmov	r3, s0
 800e1ec:	b507      	push	{r0, r1, r2, lr}
 800e1ee:	4a1f      	ldr	r2, [pc, #124]	; (800e26c <sinf+0x84>)
 800e1f0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e1f4:	4293      	cmp	r3, r2
 800e1f6:	dc07      	bgt.n	800e208 <sinf+0x20>
 800e1f8:	eddf 0a1d 	vldr	s1, [pc, #116]	; 800e270 <sinf+0x88>
 800e1fc:	2000      	movs	r0, #0
 800e1fe:	b003      	add	sp, #12
 800e200:	f85d eb04 	ldr.w	lr, [sp], #4
 800e204:	f000 b906 	b.w	800e414 <__kernel_sinf>
 800e208:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e20c:	db04      	blt.n	800e218 <sinf+0x30>
 800e20e:	ee30 0a40 	vsub.f32	s0, s0, s0
 800e212:	b003      	add	sp, #12
 800e214:	f85d fb04 	ldr.w	pc, [sp], #4
 800e218:	4668      	mov	r0, sp
 800e21a:	f000 fa11 	bl	800e640 <__ieee754_rem_pio2f>
 800e21e:	f000 0003 	and.w	r0, r0, #3
 800e222:	2801      	cmp	r0, #1
 800e224:	d00a      	beq.n	800e23c <sinf+0x54>
 800e226:	2802      	cmp	r0, #2
 800e228:	d00f      	beq.n	800e24a <sinf+0x62>
 800e22a:	b9c0      	cbnz	r0, 800e25e <sinf+0x76>
 800e22c:	eddd 0a01 	vldr	s1, [sp, #4]
 800e230:	ed9d 0a00 	vldr	s0, [sp]
 800e234:	2001      	movs	r0, #1
 800e236:	f000 f8ed 	bl	800e414 <__kernel_sinf>
 800e23a:	e7ea      	b.n	800e212 <sinf+0x2a>
 800e23c:	eddd 0a01 	vldr	s1, [sp, #4]
 800e240:	ed9d 0a00 	vldr	s0, [sp]
 800e244:	f000 f888 	bl	800e358 <__kernel_cosf>
 800e248:	e7e3      	b.n	800e212 <sinf+0x2a>
 800e24a:	eddd 0a01 	vldr	s1, [sp, #4]
 800e24e:	ed9d 0a00 	vldr	s0, [sp]
 800e252:	2001      	movs	r0, #1
 800e254:	f000 f8de 	bl	800e414 <__kernel_sinf>
 800e258:	eeb1 0a40 	vneg.f32	s0, s0
 800e25c:	e7d9      	b.n	800e212 <sinf+0x2a>
 800e25e:	eddd 0a01 	vldr	s1, [sp, #4]
 800e262:	ed9d 0a00 	vldr	s0, [sp]
 800e266:	f000 f877 	bl	800e358 <__kernel_cosf>
 800e26a:	e7f5      	b.n	800e258 <sinf+0x70>
 800e26c:	3f490fd8 	.word	0x3f490fd8
 800e270:	00000000 	.word	0x00000000

0800e274 <finitef>:
 800e274:	b082      	sub	sp, #8
 800e276:	ed8d 0a01 	vstr	s0, [sp, #4]
 800e27a:	9801      	ldr	r0, [sp, #4]
 800e27c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800e280:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 800e284:	bfac      	ite	ge
 800e286:	2000      	movge	r0, #0
 800e288:	2001      	movlt	r0, #1
 800e28a:	b002      	add	sp, #8
 800e28c:	4770      	bx	lr

0800e28e <with_errnof>:
 800e28e:	b513      	push	{r0, r1, r4, lr}
 800e290:	4604      	mov	r4, r0
 800e292:	ed8d 0a01 	vstr	s0, [sp, #4]
 800e296:	f7ff fa97 	bl	800d7c8 <__errno>
 800e29a:	ed9d 0a01 	vldr	s0, [sp, #4]
 800e29e:	6004      	str	r4, [r0, #0]
 800e2a0:	b002      	add	sp, #8
 800e2a2:	bd10      	pop	{r4, pc}

0800e2a4 <xflowf>:
 800e2a4:	b130      	cbz	r0, 800e2b4 <xflowf+0x10>
 800e2a6:	eef1 7a40 	vneg.f32	s15, s0
 800e2aa:	ee27 0a80 	vmul.f32	s0, s15, s0
 800e2ae:	2022      	movs	r0, #34	; 0x22
 800e2b0:	f7ff bfed 	b.w	800e28e <with_errnof>
 800e2b4:	eef0 7a40 	vmov.f32	s15, s0
 800e2b8:	e7f7      	b.n	800e2aa <xflowf+0x6>
	...

0800e2bc <__math_uflowf>:
 800e2bc:	ed9f 0a01 	vldr	s0, [pc, #4]	; 800e2c4 <__math_uflowf+0x8>
 800e2c0:	f7ff bff0 	b.w	800e2a4 <xflowf>
 800e2c4:	10000000 	.word	0x10000000

0800e2c8 <__math_oflowf>:
 800e2c8:	ed9f 0a01 	vldr	s0, [pc, #4]	; 800e2d0 <__math_oflowf+0x8>
 800e2cc:	f7ff bfea 	b.w	800e2a4 <xflowf>
 800e2d0:	70000000 	.word	0x70000000

0800e2d4 <floorf>:
 800e2d4:	ee10 3a10 	vmov	r3, s0
 800e2d8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 800e2dc:	3a7f      	subs	r2, #127	; 0x7f
 800e2de:	2a16      	cmp	r2, #22
 800e2e0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800e2e4:	dc2a      	bgt.n	800e33c <floorf+0x68>
 800e2e6:	2a00      	cmp	r2, #0
 800e2e8:	da11      	bge.n	800e30e <floorf+0x3a>
 800e2ea:	eddf 7a18 	vldr	s15, [pc, #96]	; 800e34c <floorf+0x78>
 800e2ee:	ee30 0a27 	vadd.f32	s0, s0, s15
 800e2f2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800e2f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e2fa:	dd05      	ble.n	800e308 <floorf+0x34>
 800e2fc:	2b00      	cmp	r3, #0
 800e2fe:	da23      	bge.n	800e348 <floorf+0x74>
 800e300:	4a13      	ldr	r2, [pc, #76]	; (800e350 <floorf+0x7c>)
 800e302:	2900      	cmp	r1, #0
 800e304:	bf18      	it	ne
 800e306:	4613      	movne	r3, r2
 800e308:	ee00 3a10 	vmov	s0, r3
 800e30c:	4770      	bx	lr
 800e30e:	4911      	ldr	r1, [pc, #68]	; (800e354 <floorf+0x80>)
 800e310:	4111      	asrs	r1, r2
 800e312:	420b      	tst	r3, r1
 800e314:	d0fa      	beq.n	800e30c <floorf+0x38>
 800e316:	eddf 7a0d 	vldr	s15, [pc, #52]	; 800e34c <floorf+0x78>
 800e31a:	ee30 0a27 	vadd.f32	s0, s0, s15
 800e31e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800e322:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e326:	ddef      	ble.n	800e308 <floorf+0x34>
 800e328:	2b00      	cmp	r3, #0
 800e32a:	bfbe      	ittt	lt
 800e32c:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 800e330:	fa40 f202 	asrlt.w	r2, r0, r2
 800e334:	189b      	addlt	r3, r3, r2
 800e336:	ea23 0301 	bic.w	r3, r3, r1
 800e33a:	e7e5      	b.n	800e308 <floorf+0x34>
 800e33c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 800e340:	d3e4      	bcc.n	800e30c <floorf+0x38>
 800e342:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e346:	4770      	bx	lr
 800e348:	2300      	movs	r3, #0
 800e34a:	e7dd      	b.n	800e308 <floorf+0x34>
 800e34c:	7149f2ca 	.word	0x7149f2ca
 800e350:	bf800000 	.word	0xbf800000
 800e354:	007fffff 	.word	0x007fffff

0800e358 <__kernel_cosf>:
 800e358:	ee10 3a10 	vmov	r3, s0
 800e35c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e360:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800e364:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800e368:	da05      	bge.n	800e376 <__kernel_cosf+0x1e>
 800e36a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 800e36e:	ee17 2a90 	vmov	r2, s15
 800e372:	2a00      	cmp	r2, #0
 800e374:	d03b      	beq.n	800e3ee <__kernel_cosf+0x96>
 800e376:	ee20 7a00 	vmul.f32	s14, s0, s0
 800e37a:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800e3f4 <__kernel_cosf+0x9c>
 800e37e:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 800e3f8 <__kernel_cosf+0xa0>
 800e382:	4a1e      	ldr	r2, [pc, #120]	; (800e3fc <__kernel_cosf+0xa4>)
 800e384:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e388:	4293      	cmp	r3, r2
 800e38a:	eddf 7a1d 	vldr	s15, [pc, #116]	; 800e400 <__kernel_cosf+0xa8>
 800e38e:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e392:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 800e404 <__kernel_cosf+0xac>
 800e396:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e39a:	eddf 7a1b 	vldr	s15, [pc, #108]	; 800e408 <__kernel_cosf+0xb0>
 800e39e:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e3a2:	ed9f 6a1a 	vldr	s12, [pc, #104]	; 800e40c <__kernel_cosf+0xb4>
 800e3a6:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e3aa:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 800e3ae:	ee26 6a07 	vmul.f32	s12, s12, s14
 800e3b2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800e3b6:	eee7 0a06 	vfma.f32	s1, s14, s12
 800e3ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 800e3be:	dc04      	bgt.n	800e3ca <__kernel_cosf+0x72>
 800e3c0:	ee77 7ae0 	vsub.f32	s15, s15, s1
 800e3c4:	ee36 0ae7 	vsub.f32	s0, s13, s15
 800e3c8:	4770      	bx	lr
 800e3ca:	4a11      	ldr	r2, [pc, #68]	; (800e410 <__kernel_cosf+0xb8>)
 800e3cc:	4293      	cmp	r3, r2
 800e3ce:	bfda      	itte	le
 800e3d0:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 800e3d4:	ee07 3a10 	vmovle	s14, r3
 800e3d8:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 800e3dc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e3e0:	ee36 0ac7 	vsub.f32	s0, s13, s14
 800e3e4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 800e3e8:	ee30 0a67 	vsub.f32	s0, s0, s15
 800e3ec:	4770      	bx	lr
 800e3ee:	eeb0 0a66 	vmov.f32	s0, s13
 800e3f2:	4770      	bx	lr
 800e3f4:	ad47d74e 	.word	0xad47d74e
 800e3f8:	310f74f6 	.word	0x310f74f6
 800e3fc:	3e999999 	.word	0x3e999999
 800e400:	b493f27c 	.word	0xb493f27c
 800e404:	37d00d01 	.word	0x37d00d01
 800e408:	bab60b61 	.word	0xbab60b61
 800e40c:	3d2aaaab 	.word	0x3d2aaaab
 800e410:	3f480000 	.word	0x3f480000

0800e414 <__kernel_sinf>:
 800e414:	ee10 3a10 	vmov	r3, s0
 800e418:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e41c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800e420:	da04      	bge.n	800e42c <__kernel_sinf+0x18>
 800e422:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 800e426:	ee17 3a90 	vmov	r3, s15
 800e42a:	b35b      	cbz	r3, 800e484 <__kernel_sinf+0x70>
 800e42c:	ee20 7a00 	vmul.f32	s14, s0, s0
 800e430:	eddf 7a15 	vldr	s15, [pc, #84]	; 800e488 <__kernel_sinf+0x74>
 800e434:	ed9f 6a15 	vldr	s12, [pc, #84]	; 800e48c <__kernel_sinf+0x78>
 800e438:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e43c:	eddf 7a14 	vldr	s15, [pc, #80]	; 800e490 <__kernel_sinf+0x7c>
 800e440:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e444:	ed9f 6a13 	vldr	s12, [pc, #76]	; 800e494 <__kernel_sinf+0x80>
 800e448:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e44c:	eddf 7a12 	vldr	s15, [pc, #72]	; 800e498 <__kernel_sinf+0x84>
 800e450:	ee60 6a07 	vmul.f32	s13, s0, s14
 800e454:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e458:	b930      	cbnz	r0, 800e468 <__kernel_sinf+0x54>
 800e45a:	ed9f 6a10 	vldr	s12, [pc, #64]	; 800e49c <__kernel_sinf+0x88>
 800e45e:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e462:	eea6 0a26 	vfma.f32	s0, s12, s13
 800e466:	4770      	bx	lr
 800e468:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 800e46c:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 800e470:	eee0 7a86 	vfma.f32	s15, s1, s12
 800e474:	eed7 0a87 	vfnms.f32	s1, s15, s14
 800e478:	eddf 7a09 	vldr	s15, [pc, #36]	; 800e4a0 <__kernel_sinf+0x8c>
 800e47c:	eee6 0aa7 	vfma.f32	s1, s13, s15
 800e480:	ee30 0a60 	vsub.f32	s0, s0, s1
 800e484:	4770      	bx	lr
 800e486:	bf00      	nop
 800e488:	2f2ec9d3 	.word	0x2f2ec9d3
 800e48c:	b2d72f34 	.word	0xb2d72f34
 800e490:	3638ef1b 	.word	0x3638ef1b
 800e494:	b9500d01 	.word	0xb9500d01
 800e498:	3c088889 	.word	0x3c088889
 800e49c:	be2aaaab 	.word	0xbe2aaaab
 800e4a0:	3e2aaaab 	.word	0x3e2aaaab

0800e4a4 <__ieee754_expf>:
 800e4a4:	ee10 2a10 	vmov	r2, s0
 800e4a8:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 800e4ac:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e4b0:	d902      	bls.n	800e4b8 <__ieee754_expf+0x14>
 800e4b2:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e4b6:	4770      	bx	lr
 800e4b8:	ea4f 71d2 	mov.w	r1, r2, lsr #31
 800e4bc:	d106      	bne.n	800e4cc <__ieee754_expf+0x28>
 800e4be:	eddf 7a4e 	vldr	s15, [pc, #312]	; 800e5f8 <__ieee754_expf+0x154>
 800e4c2:	2900      	cmp	r1, #0
 800e4c4:	bf18      	it	ne
 800e4c6:	eeb0 0a67 	vmovne.f32	s0, s15
 800e4ca:	4770      	bx	lr
 800e4cc:	484b      	ldr	r0, [pc, #300]	; (800e5fc <__ieee754_expf+0x158>)
 800e4ce:	4282      	cmp	r2, r0
 800e4d0:	dd02      	ble.n	800e4d8 <__ieee754_expf+0x34>
 800e4d2:	2000      	movs	r0, #0
 800e4d4:	f7ff bef8 	b.w	800e2c8 <__math_oflowf>
 800e4d8:	2a00      	cmp	r2, #0
 800e4da:	da05      	bge.n	800e4e8 <__ieee754_expf+0x44>
 800e4dc:	4a48      	ldr	r2, [pc, #288]	; (800e600 <__ieee754_expf+0x15c>)
 800e4de:	4293      	cmp	r3, r2
 800e4e0:	d902      	bls.n	800e4e8 <__ieee754_expf+0x44>
 800e4e2:	2000      	movs	r0, #0
 800e4e4:	f7ff beea 	b.w	800e2bc <__math_uflowf>
 800e4e8:	4a46      	ldr	r2, [pc, #280]	; (800e604 <__ieee754_expf+0x160>)
 800e4ea:	4293      	cmp	r3, r2
 800e4ec:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 800e4f0:	d952      	bls.n	800e598 <__ieee754_expf+0xf4>
 800e4f2:	4a45      	ldr	r2, [pc, #276]	; (800e608 <__ieee754_expf+0x164>)
 800e4f4:	4293      	cmp	r3, r2
 800e4f6:	ea4f 0281 	mov.w	r2, r1, lsl #2
 800e4fa:	d834      	bhi.n	800e566 <__ieee754_expf+0xc2>
 800e4fc:	4b43      	ldr	r3, [pc, #268]	; (800e60c <__ieee754_expf+0x168>)
 800e4fe:	4413      	add	r3, r2
 800e500:	ed93 7a00 	vldr	s14, [r3]
 800e504:	4b42      	ldr	r3, [pc, #264]	; (800e610 <__ieee754_expf+0x16c>)
 800e506:	4413      	add	r3, r2
 800e508:	ee30 7a47 	vsub.f32	s14, s0, s14
 800e50c:	f1c1 0201 	rsb	r2, r1, #1
 800e510:	edd3 7a00 	vldr	s15, [r3]
 800e514:	1a52      	subs	r2, r2, r1
 800e516:	ee37 0a67 	vsub.f32	s0, s14, s15
 800e51a:	ee20 6a00 	vmul.f32	s12, s0, s0
 800e51e:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 800e614 <__ieee754_expf+0x170>
 800e522:	eddf 6a3d 	vldr	s13, [pc, #244]	; 800e618 <__ieee754_expf+0x174>
 800e526:	eee6 6a05 	vfma.f32	s13, s12, s10
 800e52a:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 800e61c <__ieee754_expf+0x178>
 800e52e:	eea6 5a86 	vfma.f32	s10, s13, s12
 800e532:	eddf 6a3b 	vldr	s13, [pc, #236]	; 800e620 <__ieee754_expf+0x17c>
 800e536:	eee5 6a06 	vfma.f32	s13, s10, s12
 800e53a:	ed9f 5a3a 	vldr	s10, [pc, #232]	; 800e624 <__ieee754_expf+0x180>
 800e53e:	eea6 5a86 	vfma.f32	s10, s13, s12
 800e542:	eef0 6a40 	vmov.f32	s13, s0
 800e546:	eee5 6a46 	vfms.f32	s13, s10, s12
 800e54a:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 800e54e:	ee20 5a26 	vmul.f32	s10, s0, s13
 800e552:	bb92      	cbnz	r2, 800e5ba <__ieee754_expf+0x116>
 800e554:	ee76 6ac6 	vsub.f32	s13, s13, s12
 800e558:	eec5 7a26 	vdiv.f32	s15, s10, s13
 800e55c:	ee37 0ac0 	vsub.f32	s0, s15, s0
 800e560:	ee35 0ac0 	vsub.f32	s0, s11, s0
 800e564:	4770      	bx	lr
 800e566:	4b30      	ldr	r3, [pc, #192]	; (800e628 <__ieee754_expf+0x184>)
 800e568:	ed9f 7a30 	vldr	s14, [pc, #192]	; 800e62c <__ieee754_expf+0x188>
 800e56c:	eddf 6a30 	vldr	s13, [pc, #192]	; 800e630 <__ieee754_expf+0x18c>
 800e570:	4413      	add	r3, r2
 800e572:	edd3 7a00 	vldr	s15, [r3]
 800e576:	eee0 7a07 	vfma.f32	s15, s0, s14
 800e57a:	eeb0 7a40 	vmov.f32	s14, s0
 800e57e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800e582:	ee17 2a90 	vmov	r2, s15
 800e586:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e58a:	eea7 7ae6 	vfms.f32	s14, s15, s13
 800e58e:	eddf 6a29 	vldr	s13, [pc, #164]	; 800e634 <__ieee754_expf+0x190>
 800e592:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e596:	e7be      	b.n	800e516 <__ieee754_expf+0x72>
 800e598:	f1b3 5f50 	cmp.w	r3, #872415232	; 0x34000000
 800e59c:	d20b      	bcs.n	800e5b6 <__ieee754_expf+0x112>
 800e59e:	eddf 6a26 	vldr	s13, [pc, #152]	; 800e638 <__ieee754_expf+0x194>
 800e5a2:	ee70 6a26 	vadd.f32	s13, s0, s13
 800e5a6:	eef4 6ae5 	vcmpe.f32	s13, s11
 800e5aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e5ae:	dd02      	ble.n	800e5b6 <__ieee754_expf+0x112>
 800e5b0:	ee30 0a25 	vadd.f32	s0, s0, s11
 800e5b4:	4770      	bx	lr
 800e5b6:	2200      	movs	r2, #0
 800e5b8:	e7af      	b.n	800e51a <__ieee754_expf+0x76>
 800e5ba:	ee36 6a66 	vsub.f32	s12, s12, s13
 800e5be:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
 800e5c2:	eec5 6a06 	vdiv.f32	s13, s10, s12
 800e5c6:	bfb8      	it	lt
 800e5c8:	3264      	addlt	r2, #100	; 0x64
 800e5ca:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e5ce:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e5d2:	ee75 7ae7 	vsub.f32	s15, s11, s15
 800e5d6:	ee17 3a90 	vmov	r3, s15
 800e5da:	bfab      	itete	ge
 800e5dc:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 800e5e0:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 800e5e4:	ee00 3a10 	vmovge	s0, r3
 800e5e8:	eddf 7a14 	vldrlt	s15, [pc, #80]	; 800e63c <__ieee754_expf+0x198>
 800e5ec:	bfbc      	itt	lt
 800e5ee:	ee00 3a10 	vmovlt	s0, r3
 800e5f2:	ee20 0a27 	vmullt.f32	s0, s0, s15
 800e5f6:	4770      	bx	lr
 800e5f8:	00000000 	.word	0x00000000
 800e5fc:	42b17217 	.word	0x42b17217
 800e600:	42cff1b5 	.word	0x42cff1b5
 800e604:	3eb17218 	.word	0x3eb17218
 800e608:	3f851591 	.word	0x3f851591
 800e60c:	0801a254 	.word	0x0801a254
 800e610:	0801a25c 	.word	0x0801a25c
 800e614:	3331bb4c 	.word	0x3331bb4c
 800e618:	b5ddea0e 	.word	0xb5ddea0e
 800e61c:	388ab355 	.word	0x388ab355
 800e620:	bb360b61 	.word	0xbb360b61
 800e624:	3e2aaaab 	.word	0x3e2aaaab
 800e628:	0801a24c 	.word	0x0801a24c
 800e62c:	3fb8aa3b 	.word	0x3fb8aa3b
 800e630:	3f317180 	.word	0x3f317180
 800e634:	3717f7d1 	.word	0x3717f7d1
 800e638:	7149f2ca 	.word	0x7149f2ca
 800e63c:	0d800000 	.word	0x0d800000

0800e640 <__ieee754_rem_pio2f>:
 800e640:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e642:	ee10 6a10 	vmov	r6, s0
 800e646:	4b86      	ldr	r3, [pc, #536]	; (800e860 <__ieee754_rem_pio2f+0x220>)
 800e648:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 800e64c:	429d      	cmp	r5, r3
 800e64e:	b087      	sub	sp, #28
 800e650:	4604      	mov	r4, r0
 800e652:	dc05      	bgt.n	800e660 <__ieee754_rem_pio2f+0x20>
 800e654:	2300      	movs	r3, #0
 800e656:	ed80 0a00 	vstr	s0, [r0]
 800e65a:	6043      	str	r3, [r0, #4]
 800e65c:	2000      	movs	r0, #0
 800e65e:	e020      	b.n	800e6a2 <__ieee754_rem_pio2f+0x62>
 800e660:	4b80      	ldr	r3, [pc, #512]	; (800e864 <__ieee754_rem_pio2f+0x224>)
 800e662:	429d      	cmp	r5, r3
 800e664:	dc38      	bgt.n	800e6d8 <__ieee754_rem_pio2f+0x98>
 800e666:	2e00      	cmp	r6, #0
 800e668:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 800e868 <__ieee754_rem_pio2f+0x228>
 800e66c:	4b7f      	ldr	r3, [pc, #508]	; (800e86c <__ieee754_rem_pio2f+0x22c>)
 800e66e:	f025 050f 	bic.w	r5, r5, #15
 800e672:	dd18      	ble.n	800e6a6 <__ieee754_rem_pio2f+0x66>
 800e674:	429d      	cmp	r5, r3
 800e676:	ee70 7a47 	vsub.f32	s15, s0, s14
 800e67a:	bf09      	itett	eq
 800e67c:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 800e870 <__ieee754_rem_pio2f+0x230>
 800e680:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 800e874 <__ieee754_rem_pio2f+0x234>
 800e684:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 800e688:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 800e878 <__ieee754_rem_pio2f+0x238>
 800e68c:	ee77 6ac7 	vsub.f32	s13, s15, s14
 800e690:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e694:	edc0 6a00 	vstr	s13, [r0]
 800e698:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e69c:	edc0 7a01 	vstr	s15, [r0, #4]
 800e6a0:	2001      	movs	r0, #1
 800e6a2:	b007      	add	sp, #28
 800e6a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e6a6:	429d      	cmp	r5, r3
 800e6a8:	ee70 7a07 	vadd.f32	s15, s0, s14
 800e6ac:	bf09      	itett	eq
 800e6ae:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 800e870 <__ieee754_rem_pio2f+0x230>
 800e6b2:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 800e874 <__ieee754_rem_pio2f+0x234>
 800e6b6:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 800e6ba:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 800e878 <__ieee754_rem_pio2f+0x238>
 800e6be:	ee77 6a87 	vadd.f32	s13, s15, s14
 800e6c2:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e6c6:	edc0 6a00 	vstr	s13, [r0]
 800e6ca:	ee77 7a87 	vadd.f32	s15, s15, s14
 800e6ce:	edc0 7a01 	vstr	s15, [r0, #4]
 800e6d2:	f04f 30ff 	mov.w	r0, #4294967295
 800e6d6:	e7e4      	b.n	800e6a2 <__ieee754_rem_pio2f+0x62>
 800e6d8:	4b68      	ldr	r3, [pc, #416]	; (800e87c <__ieee754_rem_pio2f+0x23c>)
 800e6da:	429d      	cmp	r5, r3
 800e6dc:	dc71      	bgt.n	800e7c2 <__ieee754_rem_pio2f+0x182>
 800e6de:	f7ff fd7b 	bl	800e1d8 <fabsf>
 800e6e2:	ed9f 7a67 	vldr	s14, [pc, #412]	; 800e880 <__ieee754_rem_pio2f+0x240>
 800e6e6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800e6ea:	eee0 7a07 	vfma.f32	s15, s0, s14
 800e6ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800e6f2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800e6f6:	ee17 0a90 	vmov	r0, s15
 800e6fa:	eddf 7a5b 	vldr	s15, [pc, #364]	; 800e868 <__ieee754_rem_pio2f+0x228>
 800e6fe:	eea7 0a67 	vfms.f32	s0, s14, s15
 800e702:	281f      	cmp	r0, #31
 800e704:	eddf 7a5b 	vldr	s15, [pc, #364]	; 800e874 <__ieee754_rem_pio2f+0x234>
 800e708:	ee67 7a27 	vmul.f32	s15, s14, s15
 800e70c:	eeb1 6a47 	vneg.f32	s12, s14
 800e710:	ee70 6a67 	vsub.f32	s13, s0, s15
 800e714:	ee16 2a90 	vmov	r2, s13
 800e718:	dc1c      	bgt.n	800e754 <__ieee754_rem_pio2f+0x114>
 800e71a:	495a      	ldr	r1, [pc, #360]	; (800e884 <__ieee754_rem_pio2f+0x244>)
 800e71c:	1e47      	subs	r7, r0, #1
 800e71e:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 800e722:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 800e726:	428b      	cmp	r3, r1
 800e728:	d014      	beq.n	800e754 <__ieee754_rem_pio2f+0x114>
 800e72a:	6022      	str	r2, [r4, #0]
 800e72c:	ed94 7a00 	vldr	s14, [r4]
 800e730:	ee30 0a47 	vsub.f32	s0, s0, s14
 800e734:	2e00      	cmp	r6, #0
 800e736:	ee30 0a67 	vsub.f32	s0, s0, s15
 800e73a:	ed84 0a01 	vstr	s0, [r4, #4]
 800e73e:	dab0      	bge.n	800e6a2 <__ieee754_rem_pio2f+0x62>
 800e740:	eeb1 7a47 	vneg.f32	s14, s14
 800e744:	eeb1 0a40 	vneg.f32	s0, s0
 800e748:	ed84 7a00 	vstr	s14, [r4]
 800e74c:	ed84 0a01 	vstr	s0, [r4, #4]
 800e750:	4240      	negs	r0, r0
 800e752:	e7a6      	b.n	800e6a2 <__ieee754_rem_pio2f+0x62>
 800e754:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 800e758:	ebc1 51d5 	rsb	r1, r1, r5, lsr #23
 800e75c:	2908      	cmp	r1, #8
 800e75e:	ea4f 53e5 	mov.w	r3, r5, asr #23
 800e762:	dde2      	ble.n	800e72a <__ieee754_rem_pio2f+0xea>
 800e764:	eddf 5a42 	vldr	s11, [pc, #264]	; 800e870 <__ieee754_rem_pio2f+0x230>
 800e768:	eef0 6a40 	vmov.f32	s13, s0
 800e76c:	eee6 6a25 	vfma.f32	s13, s12, s11
 800e770:	ee70 7a66 	vsub.f32	s15, s0, s13
 800e774:	eee6 7a25 	vfma.f32	s15, s12, s11
 800e778:	eddf 5a3f 	vldr	s11, [pc, #252]	; 800e878 <__ieee754_rem_pio2f+0x238>
 800e77c:	eed7 7a25 	vfnms.f32	s15, s14, s11
 800e780:	ee76 5ae7 	vsub.f32	s11, s13, s15
 800e784:	ee15 2a90 	vmov	r2, s11
 800e788:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 800e78c:	1a5b      	subs	r3, r3, r1
 800e78e:	2b19      	cmp	r3, #25
 800e790:	dc04      	bgt.n	800e79c <__ieee754_rem_pio2f+0x15c>
 800e792:	edc4 5a00 	vstr	s11, [r4]
 800e796:	eeb0 0a66 	vmov.f32	s0, s13
 800e79a:	e7c7      	b.n	800e72c <__ieee754_rem_pio2f+0xec>
 800e79c:	eddf 5a3a 	vldr	s11, [pc, #232]	; 800e888 <__ieee754_rem_pio2f+0x248>
 800e7a0:	eeb0 0a66 	vmov.f32	s0, s13
 800e7a4:	eea6 0a25 	vfma.f32	s0, s12, s11
 800e7a8:	ee76 7ac0 	vsub.f32	s15, s13, s0
 800e7ac:	eddf 6a37 	vldr	s13, [pc, #220]	; 800e88c <__ieee754_rem_pio2f+0x24c>
 800e7b0:	eee6 7a25 	vfma.f32	s15, s12, s11
 800e7b4:	eed7 7a26 	vfnms.f32	s15, s14, s13
 800e7b8:	ee30 7a67 	vsub.f32	s14, s0, s15
 800e7bc:	ed84 7a00 	vstr	s14, [r4]
 800e7c0:	e7b4      	b.n	800e72c <__ieee754_rem_pio2f+0xec>
 800e7c2:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 800e7c6:	db06      	blt.n	800e7d6 <__ieee754_rem_pio2f+0x196>
 800e7c8:	ee70 7a40 	vsub.f32	s15, s0, s0
 800e7cc:	edc0 7a01 	vstr	s15, [r0, #4]
 800e7d0:	edc0 7a00 	vstr	s15, [r0]
 800e7d4:	e742      	b.n	800e65c <__ieee754_rem_pio2f+0x1c>
 800e7d6:	15ea      	asrs	r2, r5, #23
 800e7d8:	3a86      	subs	r2, #134	; 0x86
 800e7da:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 800e7de:	ee07 3a90 	vmov	s15, r3
 800e7e2:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 800e7e6:	eddf 6a2a 	vldr	s13, [pc, #168]	; 800e890 <__ieee754_rem_pio2f+0x250>
 800e7ea:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800e7ee:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e7f2:	ed8d 7a03 	vstr	s14, [sp, #12]
 800e7f6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e7fa:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 800e7fe:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800e802:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e806:	ed8d 7a04 	vstr	s14, [sp, #16]
 800e80a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e80e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800e812:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e816:	edcd 7a05 	vstr	s15, [sp, #20]
 800e81a:	d11e      	bne.n	800e85a <__ieee754_rem_pio2f+0x21a>
 800e81c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 800e820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e824:	bf14      	ite	ne
 800e826:	2302      	movne	r3, #2
 800e828:	2301      	moveq	r3, #1
 800e82a:	491a      	ldr	r1, [pc, #104]	; (800e894 <__ieee754_rem_pio2f+0x254>)
 800e82c:	9101      	str	r1, [sp, #4]
 800e82e:	2102      	movs	r1, #2
 800e830:	9100      	str	r1, [sp, #0]
 800e832:	a803      	add	r0, sp, #12
 800e834:	4621      	mov	r1, r4
 800e836:	f000 f895 	bl	800e964 <__kernel_rem_pio2f>
 800e83a:	2e00      	cmp	r6, #0
 800e83c:	f6bf af31 	bge.w	800e6a2 <__ieee754_rem_pio2f+0x62>
 800e840:	edd4 7a00 	vldr	s15, [r4]
 800e844:	eef1 7a67 	vneg.f32	s15, s15
 800e848:	edc4 7a00 	vstr	s15, [r4]
 800e84c:	edd4 7a01 	vldr	s15, [r4, #4]
 800e850:	eef1 7a67 	vneg.f32	s15, s15
 800e854:	edc4 7a01 	vstr	s15, [r4, #4]
 800e858:	e77a      	b.n	800e750 <__ieee754_rem_pio2f+0x110>
 800e85a:	2303      	movs	r3, #3
 800e85c:	e7e5      	b.n	800e82a <__ieee754_rem_pio2f+0x1ea>
 800e85e:	bf00      	nop
 800e860:	3f490fd8 	.word	0x3f490fd8
 800e864:	4016cbe3 	.word	0x4016cbe3
 800e868:	3fc90f80 	.word	0x3fc90f80
 800e86c:	3fc90fd0 	.word	0x3fc90fd0
 800e870:	37354400 	.word	0x37354400
 800e874:	37354443 	.word	0x37354443
 800e878:	2e85a308 	.word	0x2e85a308
 800e87c:	43490f80 	.word	0x43490f80
 800e880:	3f22f984 	.word	0x3f22f984
 800e884:	0801a264 	.word	0x0801a264
 800e888:	2e85a300 	.word	0x2e85a300
 800e88c:	248d3132 	.word	0x248d3132
 800e890:	43800000 	.word	0x43800000
 800e894:	0801a2e4 	.word	0x0801a2e4

0800e898 <scalbnf>:
 800e898:	ee10 3a10 	vmov	r3, s0
 800e89c:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 800e8a0:	d02b      	beq.n	800e8fa <scalbnf+0x62>
 800e8a2:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 800e8a6:	d302      	bcc.n	800e8ae <scalbnf+0x16>
 800e8a8:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e8ac:	4770      	bx	lr
 800e8ae:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 800e8b2:	d123      	bne.n	800e8fc <scalbnf+0x64>
 800e8b4:	4b24      	ldr	r3, [pc, #144]	; (800e948 <scalbnf+0xb0>)
 800e8b6:	eddf 7a25 	vldr	s15, [pc, #148]	; 800e94c <scalbnf+0xb4>
 800e8ba:	4298      	cmp	r0, r3
 800e8bc:	ee20 0a27 	vmul.f32	s0, s0, s15
 800e8c0:	db17      	blt.n	800e8f2 <scalbnf+0x5a>
 800e8c2:	ee10 3a10 	vmov	r3, s0
 800e8c6:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 800e8ca:	3a19      	subs	r2, #25
 800e8cc:	f24c 3150 	movw	r1, #50000	; 0xc350
 800e8d0:	4288      	cmp	r0, r1
 800e8d2:	dd15      	ble.n	800e900 <scalbnf+0x68>
 800e8d4:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800e950 <scalbnf+0xb8>
 800e8d8:	eddf 6a1e 	vldr	s13, [pc, #120]	; 800e954 <scalbnf+0xbc>
 800e8dc:	ee10 3a10 	vmov	r3, s0
 800e8e0:	eeb0 7a67 	vmov.f32	s14, s15
 800e8e4:	2b00      	cmp	r3, #0
 800e8e6:	bfb8      	it	lt
 800e8e8:	eef0 7a66 	vmovlt.f32	s15, s13
 800e8ec:	ee27 0a87 	vmul.f32	s0, s15, s14
 800e8f0:	4770      	bx	lr
 800e8f2:	eddf 7a19 	vldr	s15, [pc, #100]	; 800e958 <scalbnf+0xc0>
 800e8f6:	ee27 0a80 	vmul.f32	s0, s15, s0
 800e8fa:	4770      	bx	lr
 800e8fc:	0dd2      	lsrs	r2, r2, #23
 800e8fe:	e7e5      	b.n	800e8cc <scalbnf+0x34>
 800e900:	4410      	add	r0, r2
 800e902:	28fe      	cmp	r0, #254	; 0xfe
 800e904:	dce6      	bgt.n	800e8d4 <scalbnf+0x3c>
 800e906:	2800      	cmp	r0, #0
 800e908:	dd06      	ble.n	800e918 <scalbnf+0x80>
 800e90a:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 800e90e:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 800e912:	ee00 3a10 	vmov	s0, r3
 800e916:	4770      	bx	lr
 800e918:	f110 0f16 	cmn.w	r0, #22
 800e91c:	da09      	bge.n	800e932 <scalbnf+0x9a>
 800e91e:	eddf 7a0e 	vldr	s15, [pc, #56]	; 800e958 <scalbnf+0xc0>
 800e922:	eddf 6a0e 	vldr	s13, [pc, #56]	; 800e95c <scalbnf+0xc4>
 800e926:	ee10 3a10 	vmov	r3, s0
 800e92a:	eeb0 7a67 	vmov.f32	s14, s15
 800e92e:	2b00      	cmp	r3, #0
 800e930:	e7d9      	b.n	800e8e6 <scalbnf+0x4e>
 800e932:	3019      	adds	r0, #25
 800e934:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 800e938:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 800e93c:	ed9f 0a08 	vldr	s0, [pc, #32]	; 800e960 <scalbnf+0xc8>
 800e940:	ee07 3a90 	vmov	s15, r3
 800e944:	e7d7      	b.n	800e8f6 <scalbnf+0x5e>
 800e946:	bf00      	nop
 800e948:	ffff3cb0 	.word	0xffff3cb0
 800e94c:	4c000000 	.word	0x4c000000
 800e950:	7149f2ca 	.word	0x7149f2ca
 800e954:	f149f2ca 	.word	0xf149f2ca
 800e958:	0da24260 	.word	0x0da24260
 800e95c:	8da24260 	.word	0x8da24260
 800e960:	33000000 	.word	0x33000000

0800e964 <__kernel_rem_pio2f>:
 800e964:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e968:	ed2d 8b04 	vpush	{d8-d9}
 800e96c:	b0d9      	sub	sp, #356	; 0x164
 800e96e:	4688      	mov	r8, r1
 800e970:	9002      	str	r0, [sp, #8]
 800e972:	49b8      	ldr	r1, [pc, #736]	; (800ec54 <__kernel_rem_pio2f+0x2f0>)
 800e974:	9866      	ldr	r0, [sp, #408]	; 0x198
 800e976:	9301      	str	r3, [sp, #4]
 800e978:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
 800e97c:	9901      	ldr	r1, [sp, #4]
 800e97e:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 800e980:	f101 3bff 	add.w	fp, r1, #4294967295
 800e984:	1d11      	adds	r1, r2, #4
 800e986:	db25      	blt.n	800e9d4 <__kernel_rem_pio2f+0x70>
 800e988:	1ed0      	subs	r0, r2, #3
 800e98a:	bf48      	it	mi
 800e98c:	1d10      	addmi	r0, r2, #4
 800e98e:	10c0      	asrs	r0, r0, #3
 800e990:	1c45      	adds	r5, r0, #1
 800e992:	00e9      	lsls	r1, r5, #3
 800e994:	eba0 070b 	sub.w	r7, r0, fp
 800e998:	ed9f 7ab2 	vldr	s14, [pc, #712]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800e99c:	9103      	str	r1, [sp, #12]
 800e99e:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 800e9a2:	eb0a 0c0b 	add.w	ip, sl, fp
 800e9a6:	ae1c      	add	r6, sp, #112	; 0x70
 800e9a8:	eb03 0e87 	add.w	lr, r3, r7, lsl #2
 800e9ac:	2400      	movs	r4, #0
 800e9ae:	4564      	cmp	r4, ip
 800e9b0:	dd12      	ble.n	800e9d8 <__kernel_rem_pio2f+0x74>
 800e9b2:	9901      	ldr	r1, [sp, #4]
 800e9b4:	ac1c      	add	r4, sp, #112	; 0x70
 800e9b6:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 800e9ba:	f50d 7988 	add.w	r9, sp, #272	; 0x110
 800e9be:	f04f 0c00 	mov.w	ip, #0
 800e9c2:	45d4      	cmp	ip, sl
 800e9c4:	dc27      	bgt.n	800ea16 <__kernel_rem_pio2f+0xb2>
 800e9c6:	f8dd e008 	ldr.w	lr, [sp, #8]
 800e9ca:	eddf 7aa6 	vldr	s15, [pc, #664]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800e9ce:	4627      	mov	r7, r4
 800e9d0:	2600      	movs	r6, #0
 800e9d2:	e016      	b.n	800ea02 <__kernel_rem_pio2f+0x9e>
 800e9d4:	2000      	movs	r0, #0
 800e9d6:	e7db      	b.n	800e990 <__kernel_rem_pio2f+0x2c>
 800e9d8:	42e7      	cmn	r7, r4
 800e9da:	bf5d      	ittte	pl
 800e9dc:	f85e 1024 	ldrpl.w	r1, [lr, r4, lsl #2]
 800e9e0:	ee07 1a90 	vmovpl	s15, r1
 800e9e4:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 800e9e8:	eef0 7a47 	vmovmi.f32	s15, s14
 800e9ec:	ece6 7a01 	vstmia	r6!, {s15}
 800e9f0:	3401      	adds	r4, #1
 800e9f2:	e7dc      	b.n	800e9ae <__kernel_rem_pio2f+0x4a>
 800e9f4:	ecfe 6a01 	vldmia	lr!, {s13}
 800e9f8:	ed97 7a00 	vldr	s14, [r7]
 800e9fc:	eee6 7a87 	vfma.f32	s15, s13, s14
 800ea00:	3601      	adds	r6, #1
 800ea02:	455e      	cmp	r6, fp
 800ea04:	f1a7 0704 	sub.w	r7, r7, #4
 800ea08:	ddf4      	ble.n	800e9f4 <__kernel_rem_pio2f+0x90>
 800ea0a:	ece9 7a01 	vstmia	r9!, {s15}
 800ea0e:	f10c 0c01 	add.w	ip, ip, #1
 800ea12:	3404      	adds	r4, #4
 800ea14:	e7d5      	b.n	800e9c2 <__kernel_rem_pio2f+0x5e>
 800ea16:	a908      	add	r1, sp, #32
 800ea18:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 800ea1c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800ea20:	eddf 8a8f 	vldr	s17, [pc, #572]	; 800ec60 <__kernel_rem_pio2f+0x2fc>
 800ea24:	ed9f 9a8d 	vldr	s18, [pc, #564]	; 800ec5c <__kernel_rem_pio2f+0x2f8>
 800ea28:	9105      	str	r1, [sp, #20]
 800ea2a:	9304      	str	r3, [sp, #16]
 800ea2c:	4656      	mov	r6, sl
 800ea2e:	00b3      	lsls	r3, r6, #2
 800ea30:	9306      	str	r3, [sp, #24]
 800ea32:	ab58      	add	r3, sp, #352	; 0x160
 800ea34:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 800ea38:	ac08      	add	r4, sp, #32
 800ea3a:	ab44      	add	r3, sp, #272	; 0x110
 800ea3c:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
 800ea40:	46a4      	mov	ip, r4
 800ea42:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 800ea46:	4637      	mov	r7, r6
 800ea48:	2f00      	cmp	r7, #0
 800ea4a:	f1a0 0004 	sub.w	r0, r0, #4
 800ea4e:	dc4a      	bgt.n	800eae6 <__kernel_rem_pio2f+0x182>
 800ea50:	4628      	mov	r0, r5
 800ea52:	9207      	str	r2, [sp, #28]
 800ea54:	f7ff ff20 	bl	800e898 <scalbnf>
 800ea58:	eeb0 8a40 	vmov.f32	s16, s0
 800ea5c:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 800ea60:	ee28 0a00 	vmul.f32	s0, s16, s0
 800ea64:	f7ff fc36 	bl	800e2d4 <floorf>
 800ea68:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 800ea6c:	eea0 8a67 	vfms.f32	s16, s0, s15
 800ea70:	2d00      	cmp	r5, #0
 800ea72:	9a07      	ldr	r2, [sp, #28]
 800ea74:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 800ea78:	ee17 9a90 	vmov	r9, s15
 800ea7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ea80:	ee38 8a67 	vsub.f32	s16, s16, s15
 800ea84:	dd41      	ble.n	800eb0a <__kernel_rem_pio2f+0x1a6>
 800ea86:	f106 3cff 	add.w	ip, r6, #4294967295
 800ea8a:	ab08      	add	r3, sp, #32
 800ea8c:	f1c5 0e08 	rsb	lr, r5, #8
 800ea90:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
 800ea94:	fa47 f00e 	asr.w	r0, r7, lr
 800ea98:	4481      	add	r9, r0
 800ea9a:	fa00 f00e 	lsl.w	r0, r0, lr
 800ea9e:	1a3f      	subs	r7, r7, r0
 800eaa0:	f1c5 0007 	rsb	r0, r5, #7
 800eaa4:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
 800eaa8:	4107      	asrs	r7, r0
 800eaaa:	2f00      	cmp	r7, #0
 800eaac:	dd3c      	ble.n	800eb28 <__kernel_rem_pio2f+0x1c4>
 800eaae:	f04f 0e00 	mov.w	lr, #0
 800eab2:	f109 0901 	add.w	r9, r9, #1
 800eab6:	4671      	mov	r1, lr
 800eab8:	4576      	cmp	r6, lr
 800eaba:	dc67      	bgt.n	800eb8c <__kernel_rem_pio2f+0x228>
 800eabc:	2d00      	cmp	r5, #0
 800eabe:	dd03      	ble.n	800eac8 <__kernel_rem_pio2f+0x164>
 800eac0:	2d01      	cmp	r5, #1
 800eac2:	d074      	beq.n	800ebae <__kernel_rem_pio2f+0x24a>
 800eac4:	2d02      	cmp	r5, #2
 800eac6:	d07b      	beq.n	800ebc0 <__kernel_rem_pio2f+0x25c>
 800eac8:	2f02      	cmp	r7, #2
 800eaca:	d12d      	bne.n	800eb28 <__kernel_rem_pio2f+0x1c4>
 800eacc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800ead0:	ee30 8a48 	vsub.f32	s16, s0, s16
 800ead4:	b341      	cbz	r1, 800eb28 <__kernel_rem_pio2f+0x1c4>
 800ead6:	4628      	mov	r0, r5
 800ead8:	9207      	str	r2, [sp, #28]
 800eada:	f7ff fedd 	bl	800e898 <scalbnf>
 800eade:	9a07      	ldr	r2, [sp, #28]
 800eae0:	ee38 8a40 	vsub.f32	s16, s16, s0
 800eae4:	e020      	b.n	800eb28 <__kernel_rem_pio2f+0x1c4>
 800eae6:	ee60 7a28 	vmul.f32	s15, s0, s17
 800eaea:	3f01      	subs	r7, #1
 800eaec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800eaf0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800eaf4:	eea7 0ac9 	vfms.f32	s0, s15, s18
 800eaf8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800eafc:	ecac 0a01 	vstmia	ip!, {s0}
 800eb00:	ed90 0a00 	vldr	s0, [r0]
 800eb04:	ee37 0a80 	vadd.f32	s0, s15, s0
 800eb08:	e79e      	b.n	800ea48 <__kernel_rem_pio2f+0xe4>
 800eb0a:	d105      	bne.n	800eb18 <__kernel_rem_pio2f+0x1b4>
 800eb0c:	1e70      	subs	r0, r6, #1
 800eb0e:	ab08      	add	r3, sp, #32
 800eb10:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 800eb14:	11ff      	asrs	r7, r7, #7
 800eb16:	e7c8      	b.n	800eaaa <__kernel_rem_pio2f+0x146>
 800eb18:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800eb1c:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800eb20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eb24:	da30      	bge.n	800eb88 <__kernel_rem_pio2f+0x224>
 800eb26:	2700      	movs	r7, #0
 800eb28:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800eb2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eb30:	f040 809a 	bne.w	800ec68 <__kernel_rem_pio2f+0x304>
 800eb34:	1e74      	subs	r4, r6, #1
 800eb36:	46a4      	mov	ip, r4
 800eb38:	2100      	movs	r1, #0
 800eb3a:	45d4      	cmp	ip, sl
 800eb3c:	da47      	bge.n	800ebce <__kernel_rem_pio2f+0x26a>
 800eb3e:	2900      	cmp	r1, #0
 800eb40:	d063      	beq.n	800ec0a <__kernel_rem_pio2f+0x2a6>
 800eb42:	ab08      	add	r3, sp, #32
 800eb44:	3d08      	subs	r5, #8
 800eb46:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800eb4a:	2b00      	cmp	r3, #0
 800eb4c:	d07f      	beq.n	800ec4e <__kernel_rem_pio2f+0x2ea>
 800eb4e:	4628      	mov	r0, r5
 800eb50:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800eb54:	f7ff fea0 	bl	800e898 <scalbnf>
 800eb58:	1c63      	adds	r3, r4, #1
 800eb5a:	aa44      	add	r2, sp, #272	; 0x110
 800eb5c:	ed9f 7a40 	vldr	s14, [pc, #256]	; 800ec60 <__kernel_rem_pio2f+0x2fc>
 800eb60:	0099      	lsls	r1, r3, #2
 800eb62:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800eb66:	4623      	mov	r3, r4
 800eb68:	2b00      	cmp	r3, #0
 800eb6a:	f280 80ad 	bge.w	800ecc8 <__kernel_rem_pio2f+0x364>
 800eb6e:	4623      	mov	r3, r4
 800eb70:	2b00      	cmp	r3, #0
 800eb72:	f2c0 80cb 	blt.w	800ed0c <__kernel_rem_pio2f+0x3a8>
 800eb76:	aa44      	add	r2, sp, #272	; 0x110
 800eb78:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 800eb7c:	4e36      	ldr	r6, [pc, #216]	; (800ec58 <__kernel_rem_pio2f+0x2f4>)
 800eb7e:	eddf 7a39 	vldr	s15, [pc, #228]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800eb82:	2000      	movs	r0, #0
 800eb84:	1ae2      	subs	r2, r4, r3
 800eb86:	e0b6      	b.n	800ecf6 <__kernel_rem_pio2f+0x392>
 800eb88:	2702      	movs	r7, #2
 800eb8a:	e790      	b.n	800eaae <__kernel_rem_pio2f+0x14a>
 800eb8c:	6820      	ldr	r0, [r4, #0]
 800eb8e:	b949      	cbnz	r1, 800eba4 <__kernel_rem_pio2f+0x240>
 800eb90:	b118      	cbz	r0, 800eb9a <__kernel_rem_pio2f+0x236>
 800eb92:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 800eb96:	6020      	str	r0, [r4, #0]
 800eb98:	2001      	movs	r0, #1
 800eb9a:	f10e 0e01 	add.w	lr, lr, #1
 800eb9e:	3404      	adds	r4, #4
 800eba0:	4601      	mov	r1, r0
 800eba2:	e789      	b.n	800eab8 <__kernel_rem_pio2f+0x154>
 800eba4:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 800eba8:	6020      	str	r0, [r4, #0]
 800ebaa:	4608      	mov	r0, r1
 800ebac:	e7f5      	b.n	800eb9a <__kernel_rem_pio2f+0x236>
 800ebae:	1e74      	subs	r4, r6, #1
 800ebb0:	ab08      	add	r3, sp, #32
 800ebb2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800ebb6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800ebba:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 800ebbe:	e783      	b.n	800eac8 <__kernel_rem_pio2f+0x164>
 800ebc0:	1e74      	subs	r4, r6, #1
 800ebc2:	ab08      	add	r3, sp, #32
 800ebc4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800ebc8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 800ebcc:	e7f5      	b.n	800ebba <__kernel_rem_pio2f+0x256>
 800ebce:	ab08      	add	r3, sp, #32
 800ebd0:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 800ebd4:	f10c 3cff 	add.w	ip, ip, #4294967295
 800ebd8:	4301      	orrs	r1, r0
 800ebda:	e7ae      	b.n	800eb3a <__kernel_rem_pio2f+0x1d6>
 800ebdc:	3001      	adds	r0, #1
 800ebde:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 800ebe2:	2f00      	cmp	r7, #0
 800ebe4:	d0fa      	beq.n	800ebdc <__kernel_rem_pio2f+0x278>
 800ebe6:	9b06      	ldr	r3, [sp, #24]
 800ebe8:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 800ebec:	eb0d 0403 	add.w	r4, sp, r3
 800ebf0:	9b01      	ldr	r3, [sp, #4]
 800ebf2:	18f7      	adds	r7, r6, r3
 800ebf4:	ab1c      	add	r3, sp, #112	; 0x70
 800ebf6:	f106 0c01 	add.w	ip, r6, #1
 800ebfa:	3c4c      	subs	r4, #76	; 0x4c
 800ebfc:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800ec00:	4430      	add	r0, r6
 800ec02:	4560      	cmp	r0, ip
 800ec04:	da04      	bge.n	800ec10 <__kernel_rem_pio2f+0x2ac>
 800ec06:	4606      	mov	r6, r0
 800ec08:	e711      	b.n	800ea2e <__kernel_rem_pio2f+0xca>
 800ec0a:	9c05      	ldr	r4, [sp, #20]
 800ec0c:	2001      	movs	r0, #1
 800ec0e:	e7e6      	b.n	800ebde <__kernel_rem_pio2f+0x27a>
 800ec10:	9b04      	ldr	r3, [sp, #16]
 800ec12:	f8dd e008 	ldr.w	lr, [sp, #8]
 800ec16:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 800ec1a:	9306      	str	r3, [sp, #24]
 800ec1c:	ee07 3a90 	vmov	s15, r3
 800ec20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ec24:	2600      	movs	r6, #0
 800ec26:	ece7 7a01 	vstmia	r7!, {s15}
 800ec2a:	eddf 7a0e 	vldr	s15, [pc, #56]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800ec2e:	46b9      	mov	r9, r7
 800ec30:	455e      	cmp	r6, fp
 800ec32:	dd04      	ble.n	800ec3e <__kernel_rem_pio2f+0x2da>
 800ec34:	ece4 7a01 	vstmia	r4!, {s15}
 800ec38:	f10c 0c01 	add.w	ip, ip, #1
 800ec3c:	e7e1      	b.n	800ec02 <__kernel_rem_pio2f+0x29e>
 800ec3e:	ecfe 6a01 	vldmia	lr!, {s13}
 800ec42:	ed39 7a01 	vldmdb	r9!, {s14}
 800ec46:	3601      	adds	r6, #1
 800ec48:	eee6 7a87 	vfma.f32	s15, s13, s14
 800ec4c:	e7f0      	b.n	800ec30 <__kernel_rem_pio2f+0x2cc>
 800ec4e:	3c01      	subs	r4, #1
 800ec50:	e777      	b.n	800eb42 <__kernel_rem_pio2f+0x1de>
 800ec52:	bf00      	nop
 800ec54:	0801a628 	.word	0x0801a628
 800ec58:	0801a5fc 	.word	0x0801a5fc
 800ec5c:	43800000 	.word	0x43800000
 800ec60:	3b800000 	.word	0x3b800000
 800ec64:	00000000 	.word	0x00000000
 800ec68:	9b03      	ldr	r3, [sp, #12]
 800ec6a:	eeb0 0a48 	vmov.f32	s0, s16
 800ec6e:	1a98      	subs	r0, r3, r2
 800ec70:	f7ff fe12 	bl	800e898 <scalbnf>
 800ec74:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 800ec5c <__kernel_rem_pio2f+0x2f8>
 800ec78:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800ec7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ec80:	db19      	blt.n	800ecb6 <__kernel_rem_pio2f+0x352>
 800ec82:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 800ec60 <__kernel_rem_pio2f+0x2fc>
 800ec86:	ee60 7a27 	vmul.f32	s15, s0, s15
 800ec8a:	aa08      	add	r2, sp, #32
 800ec8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ec90:	1c74      	adds	r4, r6, #1
 800ec92:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ec96:	3508      	adds	r5, #8
 800ec98:	eea7 0ac7 	vfms.f32	s0, s15, s14
 800ec9c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800eca0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800eca4:	ee10 3a10 	vmov	r3, s0
 800eca8:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 800ecac:	ee17 3a90 	vmov	r3, s15
 800ecb0:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 800ecb4:	e74b      	b.n	800eb4e <__kernel_rem_pio2f+0x1ea>
 800ecb6:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800ecba:	aa08      	add	r2, sp, #32
 800ecbc:	ee10 3a10 	vmov	r3, s0
 800ecc0:	4634      	mov	r4, r6
 800ecc2:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 800ecc6:	e742      	b.n	800eb4e <__kernel_rem_pio2f+0x1ea>
 800ecc8:	a808      	add	r0, sp, #32
 800ecca:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 800ecce:	9001      	str	r0, [sp, #4]
 800ecd0:	ee07 0a90 	vmov	s15, r0
 800ecd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ecd8:	3b01      	subs	r3, #1
 800ecda:	ee67 7a80 	vmul.f32	s15, s15, s0
 800ecde:	ee20 0a07 	vmul.f32	s0, s0, s14
 800ece2:	ed62 7a01 	vstmdb	r2!, {s15}
 800ece6:	e73f      	b.n	800eb68 <__kernel_rem_pio2f+0x204>
 800ece8:	ecf6 6a01 	vldmia	r6!, {s13}
 800ecec:	ecb5 7a01 	vldmia	r5!, {s14}
 800ecf0:	eee6 7a87 	vfma.f32	s15, s13, s14
 800ecf4:	3001      	adds	r0, #1
 800ecf6:	4550      	cmp	r0, sl
 800ecf8:	dc01      	bgt.n	800ecfe <__kernel_rem_pio2f+0x39a>
 800ecfa:	4290      	cmp	r0, r2
 800ecfc:	ddf4      	ble.n	800ece8 <__kernel_rem_pio2f+0x384>
 800ecfe:	a858      	add	r0, sp, #352	; 0x160
 800ed00:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800ed04:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 800ed08:	3b01      	subs	r3, #1
 800ed0a:	e731      	b.n	800eb70 <__kernel_rem_pio2f+0x20c>
 800ed0c:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ed0e:	2b02      	cmp	r3, #2
 800ed10:	dc09      	bgt.n	800ed26 <__kernel_rem_pio2f+0x3c2>
 800ed12:	2b00      	cmp	r3, #0
 800ed14:	dc2b      	bgt.n	800ed6e <__kernel_rem_pio2f+0x40a>
 800ed16:	d044      	beq.n	800eda2 <__kernel_rem_pio2f+0x43e>
 800ed18:	f009 0007 	and.w	r0, r9, #7
 800ed1c:	b059      	add	sp, #356	; 0x164
 800ed1e:	ecbd 8b04 	vpop	{d8-d9}
 800ed22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ed26:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ed28:	2b03      	cmp	r3, #3
 800ed2a:	d1f5      	bne.n	800ed18 <__kernel_rem_pio2f+0x3b4>
 800ed2c:	aa30      	add	r2, sp, #192	; 0xc0
 800ed2e:	1f0b      	subs	r3, r1, #4
 800ed30:	4413      	add	r3, r2
 800ed32:	461a      	mov	r2, r3
 800ed34:	4620      	mov	r0, r4
 800ed36:	2800      	cmp	r0, #0
 800ed38:	f1a2 0204 	sub.w	r2, r2, #4
 800ed3c:	dc52      	bgt.n	800ede4 <__kernel_rem_pio2f+0x480>
 800ed3e:	4622      	mov	r2, r4
 800ed40:	2a01      	cmp	r2, #1
 800ed42:	f1a3 0304 	sub.w	r3, r3, #4
 800ed46:	dc5d      	bgt.n	800ee04 <__kernel_rem_pio2f+0x4a0>
 800ed48:	ab30      	add	r3, sp, #192	; 0xc0
 800ed4a:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800ed4e:	440b      	add	r3, r1
 800ed50:	2c01      	cmp	r4, #1
 800ed52:	dc67      	bgt.n	800ee24 <__kernel_rem_pio2f+0x4c0>
 800ed54:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
 800ed58:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
 800ed5c:	2f00      	cmp	r7, #0
 800ed5e:	d167      	bne.n	800ee30 <__kernel_rem_pio2f+0x4cc>
 800ed60:	edc8 6a00 	vstr	s13, [r8]
 800ed64:	ed88 7a01 	vstr	s14, [r8, #4]
 800ed68:	edc8 7a02 	vstr	s15, [r8, #8]
 800ed6c:	e7d4      	b.n	800ed18 <__kernel_rem_pio2f+0x3b4>
 800ed6e:	ab30      	add	r3, sp, #192	; 0xc0
 800ed70:	ed1f 7a44 	vldr	s14, [pc, #-272]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800ed74:	440b      	add	r3, r1
 800ed76:	4622      	mov	r2, r4
 800ed78:	2a00      	cmp	r2, #0
 800ed7a:	da24      	bge.n	800edc6 <__kernel_rem_pio2f+0x462>
 800ed7c:	b34f      	cbz	r7, 800edd2 <__kernel_rem_pio2f+0x46e>
 800ed7e:	eef1 7a47 	vneg.f32	s15, s14
 800ed82:	edc8 7a00 	vstr	s15, [r8]
 800ed86:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
 800ed8a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ed8e:	aa31      	add	r2, sp, #196	; 0xc4
 800ed90:	2301      	movs	r3, #1
 800ed92:	429c      	cmp	r4, r3
 800ed94:	da20      	bge.n	800edd8 <__kernel_rem_pio2f+0x474>
 800ed96:	b10f      	cbz	r7, 800ed9c <__kernel_rem_pio2f+0x438>
 800ed98:	eef1 7a67 	vneg.f32	s15, s15
 800ed9c:	edc8 7a01 	vstr	s15, [r8, #4]
 800eda0:	e7ba      	b.n	800ed18 <__kernel_rem_pio2f+0x3b4>
 800eda2:	ab30      	add	r3, sp, #192	; 0xc0
 800eda4:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 800ec64 <__kernel_rem_pio2f+0x300>
 800eda8:	440b      	add	r3, r1
 800edaa:	2c00      	cmp	r4, #0
 800edac:	da05      	bge.n	800edba <__kernel_rem_pio2f+0x456>
 800edae:	b10f      	cbz	r7, 800edb4 <__kernel_rem_pio2f+0x450>
 800edb0:	eef1 7a67 	vneg.f32	s15, s15
 800edb4:	edc8 7a00 	vstr	s15, [r8]
 800edb8:	e7ae      	b.n	800ed18 <__kernel_rem_pio2f+0x3b4>
 800edba:	ed33 7a01 	vldmdb	r3!, {s14}
 800edbe:	3c01      	subs	r4, #1
 800edc0:	ee77 7a87 	vadd.f32	s15, s15, s14
 800edc4:	e7f1      	b.n	800edaa <__kernel_rem_pio2f+0x446>
 800edc6:	ed73 7a01 	vldmdb	r3!, {s15}
 800edca:	3a01      	subs	r2, #1
 800edcc:	ee37 7a27 	vadd.f32	s14, s14, s15
 800edd0:	e7d2      	b.n	800ed78 <__kernel_rem_pio2f+0x414>
 800edd2:	eef0 7a47 	vmov.f32	s15, s14
 800edd6:	e7d4      	b.n	800ed82 <__kernel_rem_pio2f+0x41e>
 800edd8:	ecb2 7a01 	vldmia	r2!, {s14}
 800eddc:	3301      	adds	r3, #1
 800edde:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ede2:	e7d6      	b.n	800ed92 <__kernel_rem_pio2f+0x42e>
 800ede4:	edd2 7a00 	vldr	s15, [r2]
 800ede8:	edd2 6a01 	vldr	s13, [r2, #4]
 800edec:	ee37 7aa6 	vadd.f32	s14, s15, s13
 800edf0:	3801      	subs	r0, #1
 800edf2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800edf6:	ed82 7a00 	vstr	s14, [r2]
 800edfa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800edfe:	edc2 7a01 	vstr	s15, [r2, #4]
 800ee02:	e798      	b.n	800ed36 <__kernel_rem_pio2f+0x3d2>
 800ee04:	edd3 7a00 	vldr	s15, [r3]
 800ee08:	edd3 6a01 	vldr	s13, [r3, #4]
 800ee0c:	ee37 7aa6 	vadd.f32	s14, s15, s13
 800ee10:	3a01      	subs	r2, #1
 800ee12:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ee16:	ed83 7a00 	vstr	s14, [r3]
 800ee1a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800ee1e:	edc3 7a01 	vstr	s15, [r3, #4]
 800ee22:	e78d      	b.n	800ed40 <__kernel_rem_pio2f+0x3dc>
 800ee24:	ed33 7a01 	vldmdb	r3!, {s14}
 800ee28:	3c01      	subs	r4, #1
 800ee2a:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ee2e:	e78f      	b.n	800ed50 <__kernel_rem_pio2f+0x3ec>
 800ee30:	eef1 6a66 	vneg.f32	s13, s13
 800ee34:	eeb1 7a47 	vneg.f32	s14, s14
 800ee38:	edc8 6a00 	vstr	s13, [r8]
 800ee3c:	ed88 7a01 	vstr	s14, [r8, #4]
 800ee40:	eef1 7a67 	vneg.f32	s15, s15
 800ee44:	e790      	b.n	800ed68 <__kernel_rem_pio2f+0x404>
 800ee46:	bf00      	nop

0800ee48 <_close>:
 800ee48:	4b02      	ldr	r3, [pc, #8]	; (800ee54 <_close+0xc>)
 800ee4a:	2258      	movs	r2, #88	; 0x58
 800ee4c:	601a      	str	r2, [r3, #0]
 800ee4e:	f04f 30ff 	mov.w	r0, #4294967295
 800ee52:	4770      	bx	lr
 800ee54:	200031f0 	.word	0x200031f0

0800ee58 <_fstat>:
 800ee58:	4b02      	ldr	r3, [pc, #8]	; (800ee64 <_fstat+0xc>)
 800ee5a:	2258      	movs	r2, #88	; 0x58
 800ee5c:	601a      	str	r2, [r3, #0]
 800ee5e:	f04f 30ff 	mov.w	r0, #4294967295
 800ee62:	4770      	bx	lr
 800ee64:	200031f0 	.word	0x200031f0

0800ee68 <_isatty>:
 800ee68:	4b02      	ldr	r3, [pc, #8]	; (800ee74 <_isatty+0xc>)
 800ee6a:	2258      	movs	r2, #88	; 0x58
 800ee6c:	601a      	str	r2, [r3, #0]
 800ee6e:	2000      	movs	r0, #0
 800ee70:	4770      	bx	lr
 800ee72:	bf00      	nop
 800ee74:	200031f0 	.word	0x200031f0

0800ee78 <_lseek>:
 800ee78:	4b02      	ldr	r3, [pc, #8]	; (800ee84 <_lseek+0xc>)
 800ee7a:	2258      	movs	r2, #88	; 0x58
 800ee7c:	601a      	str	r2, [r3, #0]
 800ee7e:	f04f 30ff 	mov.w	r0, #4294967295
 800ee82:	4770      	bx	lr
 800ee84:	200031f0 	.word	0x200031f0

0800ee88 <_read>:
 800ee88:	4b02      	ldr	r3, [pc, #8]	; (800ee94 <_read+0xc>)
 800ee8a:	2258      	movs	r2, #88	; 0x58
 800ee8c:	601a      	str	r2, [r3, #0]
 800ee8e:	f04f 30ff 	mov.w	r0, #4294967295
 800ee92:	4770      	bx	lr
 800ee94:	200031f0 	.word	0x200031f0

0800ee98 <_write>:
 800ee98:	4b02      	ldr	r3, [pc, #8]	; (800eea4 <_write+0xc>)
 800ee9a:	2258      	movs	r2, #88	; 0x58
 800ee9c:	601a      	str	r2, [r3, #0]
 800ee9e:	f04f 30ff 	mov.w	r0, #4294967295
 800eea2:	4770      	bx	lr
 800eea4:	200031f0 	.word	0x200031f0

0800eea8 <_init>:
 800eea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eeaa:	bf00      	nop
 800eeac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800eeae:	bc08      	pop	{r3}
 800eeb0:	469e      	mov	lr, r3
 800eeb2:	4770      	bx	lr

0800eeb4 <_fini>:
 800eeb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eeb6:	bf00      	nop
 800eeb8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800eeba:	bc08      	pop	{r3}
 800eebc:	469e      	mov	lr, r3
 800eebe:	4770      	bx	lr
