
LegDay.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000ec98  080001e0  080001e0  000101e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000b774  0800ee80  0800ee80  0001ee80  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801a5f4  0801a5f4  0003150c  2**0
                  CONTENTS
  4 .ARM          00000008  0801a5f4  0801a5f4  0002a5f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801a5fc  0801a5fc  0003150c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801a5fc  0801a5fc  0002a5fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801a600  0801a600  0002a600  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000150c  20000000  0801a604  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001cd8  20001520  0801bb10  00031520  2**5
                  ALLOC
 10 ._user_heap_stack 00001000  200031f8  0801bb10  000331f8  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0003150c  2**0
                  CONTENTS, READONLY
 12 .comment      00000093  00000000  00000000  0003153c  2**0
                  CONTENTS, READONLY
 13 .debug_line   00050cc4  00000000  00000000  000315cf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 00000062  00000000  00000000  00082293  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   0004e3c6  00000000  00000000  000822f5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000a371  00000000  00000000  000d06bb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00002038  00000000  00000000  000daa30  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00149d47  00000000  00000000  000dca68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 000036b8  00000000  00000000  002267af  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 0001da65  00000000  00000000  00229e67  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0003989f  00000000  00000000  002478cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_frame  0000673c  00000000  00000000  0028116c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	; (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	; (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	; (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20001520 	.word	0x20001520
 80001fc:	00000000 	.word	0x00000000
 8000200:	0800ee60 	.word	0x0800ee60

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	; (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	; (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	; (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	20001524 	.word	0x20001524
 800021c:	0800ee60 	.word	0x0800ee60

08000220 <memchr>:
 8000220:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000224:	2a10      	cmp	r2, #16
 8000226:	db2b      	blt.n	8000280 <memchr+0x60>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	d008      	beq.n	8000240 <memchr+0x20>
 800022e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000232:	3a01      	subs	r2, #1
 8000234:	428b      	cmp	r3, r1
 8000236:	d02d      	beq.n	8000294 <memchr+0x74>
 8000238:	f010 0f07 	tst.w	r0, #7
 800023c:	b342      	cbz	r2, 8000290 <memchr+0x70>
 800023e:	d1f6      	bne.n	800022e <memchr+0xe>
 8000240:	b4f0      	push	{r4, r5, r6, r7}
 8000242:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000246:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800024a:	f022 0407 	bic.w	r4, r2, #7
 800024e:	f07f 0700 	mvns.w	r7, #0
 8000252:	2300      	movs	r3, #0
 8000254:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000258:	3c08      	subs	r4, #8
 800025a:	ea85 0501 	eor.w	r5, r5, r1
 800025e:	ea86 0601 	eor.w	r6, r6, r1
 8000262:	fa85 f547 	uadd8	r5, r5, r7
 8000266:	faa3 f587 	sel	r5, r3, r7
 800026a:	fa86 f647 	uadd8	r6, r6, r7
 800026e:	faa5 f687 	sel	r6, r5, r7
 8000272:	b98e      	cbnz	r6, 8000298 <memchr+0x78>
 8000274:	d1ee      	bne.n	8000254 <memchr+0x34>
 8000276:	bcf0      	pop	{r4, r5, r6, r7}
 8000278:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800027c:	f002 0207 	and.w	r2, r2, #7
 8000280:	b132      	cbz	r2, 8000290 <memchr+0x70>
 8000282:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000286:	3a01      	subs	r2, #1
 8000288:	ea83 0301 	eor.w	r3, r3, r1
 800028c:	b113      	cbz	r3, 8000294 <memchr+0x74>
 800028e:	d1f8      	bne.n	8000282 <memchr+0x62>
 8000290:	2000      	movs	r0, #0
 8000292:	4770      	bx	lr
 8000294:	3801      	subs	r0, #1
 8000296:	4770      	bx	lr
 8000298:	2d00      	cmp	r5, #0
 800029a:	bf06      	itte	eq
 800029c:	4635      	moveq	r5, r6
 800029e:	3803      	subeq	r0, #3
 80002a0:	3807      	subne	r0, #7
 80002a2:	f015 0f01 	tst.w	r5, #1
 80002a6:	d107      	bne.n	80002b8 <memchr+0x98>
 80002a8:	3001      	adds	r0, #1
 80002aa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002ae:	bf02      	ittt	eq
 80002b0:	3001      	addeq	r0, #1
 80002b2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002b6:	3001      	addeq	r0, #1
 80002b8:	bcf0      	pop	{r4, r5, r6, r7}
 80002ba:	3801      	subs	r0, #1
 80002bc:	4770      	bx	lr
 80002be:	bf00      	nop

080002c0 <__aeabi_drsub>:
 80002c0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002c4:	e002      	b.n	80002cc <__adddf3>
 80002c6:	bf00      	nop

080002c8 <__aeabi_dsub>:
 80002c8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002cc <__adddf3>:
 80002cc:	b530      	push	{r4, r5, lr}
 80002ce:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002d2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002d6:	ea94 0f05 	teq	r4, r5
 80002da:	bf08      	it	eq
 80002dc:	ea90 0f02 	teqeq	r0, r2
 80002e0:	bf1f      	itttt	ne
 80002e2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002e6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ea:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ee:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002f2:	f000 80e2 	beq.w	80004ba <__adddf3+0x1ee>
 80002f6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002fa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002fe:	bfb8      	it	lt
 8000300:	426d      	neglt	r5, r5
 8000302:	dd0c      	ble.n	800031e <__adddf3+0x52>
 8000304:	442c      	add	r4, r5
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	ea82 0000 	eor.w	r0, r2, r0
 8000312:	ea83 0101 	eor.w	r1, r3, r1
 8000316:	ea80 0202 	eor.w	r2, r0, r2
 800031a:	ea81 0303 	eor.w	r3, r1, r3
 800031e:	2d36      	cmp	r5, #54	; 0x36
 8000320:	bf88      	it	hi
 8000322:	bd30      	pophi	{r4, r5, pc}
 8000324:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000328:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800032c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000330:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000334:	d002      	beq.n	800033c <__adddf3+0x70>
 8000336:	4240      	negs	r0, r0
 8000338:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800033c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000340:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000344:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000348:	d002      	beq.n	8000350 <__adddf3+0x84>
 800034a:	4252      	negs	r2, r2
 800034c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000350:	ea94 0f05 	teq	r4, r5
 8000354:	f000 80a7 	beq.w	80004a6 <__adddf3+0x1da>
 8000358:	f1a4 0401 	sub.w	r4, r4, #1
 800035c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000360:	db0d      	blt.n	800037e <__adddf3+0xb2>
 8000362:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000366:	fa22 f205 	lsr.w	r2, r2, r5
 800036a:	1880      	adds	r0, r0, r2
 800036c:	f141 0100 	adc.w	r1, r1, #0
 8000370:	fa03 f20e 	lsl.w	r2, r3, lr
 8000374:	1880      	adds	r0, r0, r2
 8000376:	fa43 f305 	asr.w	r3, r3, r5
 800037a:	4159      	adcs	r1, r3
 800037c:	e00e      	b.n	800039c <__adddf3+0xd0>
 800037e:	f1a5 0520 	sub.w	r5, r5, #32
 8000382:	f10e 0e20 	add.w	lr, lr, #32
 8000386:	2a01      	cmp	r2, #1
 8000388:	fa03 fc0e 	lsl.w	ip, r3, lr
 800038c:	bf28      	it	cs
 800038e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000392:	fa43 f305 	asr.w	r3, r3, r5
 8000396:	18c0      	adds	r0, r0, r3
 8000398:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800039c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003a0:	d507      	bpl.n	80003b2 <__adddf3+0xe6>
 80003a2:	f04f 0e00 	mov.w	lr, #0
 80003a6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003aa:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003ae:	eb6e 0101 	sbc.w	r1, lr, r1
 80003b2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003b6:	d31b      	bcc.n	80003f0 <__adddf3+0x124>
 80003b8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003bc:	d30c      	bcc.n	80003d8 <__adddf3+0x10c>
 80003be:	0849      	lsrs	r1, r1, #1
 80003c0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003c4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003c8:	f104 0401 	add.w	r4, r4, #1
 80003cc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003d0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003d4:	f080 809a 	bcs.w	800050c <__adddf3+0x240>
 80003d8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003dc:	bf08      	it	eq
 80003de:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003e2:	f150 0000 	adcs.w	r0, r0, #0
 80003e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ea:	ea41 0105 	orr.w	r1, r1, r5
 80003ee:	bd30      	pop	{r4, r5, pc}
 80003f0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003f4:	4140      	adcs	r0, r0
 80003f6:	eb41 0101 	adc.w	r1, r1, r1
 80003fa:	3c01      	subs	r4, #1
 80003fc:	bf28      	it	cs
 80003fe:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000402:	d2e9      	bcs.n	80003d8 <__adddf3+0x10c>
 8000404:	f091 0f00 	teq	r1, #0
 8000408:	bf04      	itt	eq
 800040a:	4601      	moveq	r1, r0
 800040c:	2000      	moveq	r0, #0
 800040e:	fab1 f381 	clz	r3, r1
 8000412:	bf08      	it	eq
 8000414:	3320      	addeq	r3, #32
 8000416:	f1a3 030b 	sub.w	r3, r3, #11
 800041a:	f1b3 0220 	subs.w	r2, r3, #32
 800041e:	da0c      	bge.n	800043a <__adddf3+0x16e>
 8000420:	320c      	adds	r2, #12
 8000422:	dd08      	ble.n	8000436 <__adddf3+0x16a>
 8000424:	f102 0c14 	add.w	ip, r2, #20
 8000428:	f1c2 020c 	rsb	r2, r2, #12
 800042c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000430:	fa21 f102 	lsr.w	r1, r1, r2
 8000434:	e00c      	b.n	8000450 <__adddf3+0x184>
 8000436:	f102 0214 	add.w	r2, r2, #20
 800043a:	bfd8      	it	le
 800043c:	f1c2 0c20 	rsble	ip, r2, #32
 8000440:	fa01 f102 	lsl.w	r1, r1, r2
 8000444:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000448:	bfdc      	itt	le
 800044a:	ea41 010c 	orrle.w	r1, r1, ip
 800044e:	4090      	lslle	r0, r2
 8000450:	1ae4      	subs	r4, r4, r3
 8000452:	bfa2      	ittt	ge
 8000454:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000458:	4329      	orrge	r1, r5
 800045a:	bd30      	popge	{r4, r5, pc}
 800045c:	ea6f 0404 	mvn.w	r4, r4
 8000460:	3c1f      	subs	r4, #31
 8000462:	da1c      	bge.n	800049e <__adddf3+0x1d2>
 8000464:	340c      	adds	r4, #12
 8000466:	dc0e      	bgt.n	8000486 <__adddf3+0x1ba>
 8000468:	f104 0414 	add.w	r4, r4, #20
 800046c:	f1c4 0220 	rsb	r2, r4, #32
 8000470:	fa20 f004 	lsr.w	r0, r0, r4
 8000474:	fa01 f302 	lsl.w	r3, r1, r2
 8000478:	ea40 0003 	orr.w	r0, r0, r3
 800047c:	fa21 f304 	lsr.w	r3, r1, r4
 8000480:	ea45 0103 	orr.w	r1, r5, r3
 8000484:	bd30      	pop	{r4, r5, pc}
 8000486:	f1c4 040c 	rsb	r4, r4, #12
 800048a:	f1c4 0220 	rsb	r2, r4, #32
 800048e:	fa20 f002 	lsr.w	r0, r0, r2
 8000492:	fa01 f304 	lsl.w	r3, r1, r4
 8000496:	ea40 0003 	orr.w	r0, r0, r3
 800049a:	4629      	mov	r1, r5
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	fa21 f004 	lsr.w	r0, r1, r4
 80004a2:	4629      	mov	r1, r5
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	f094 0f00 	teq	r4, #0
 80004aa:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004ae:	bf06      	itte	eq
 80004b0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004b4:	3401      	addeq	r4, #1
 80004b6:	3d01      	subne	r5, #1
 80004b8:	e74e      	b.n	8000358 <__adddf3+0x8c>
 80004ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004be:	bf18      	it	ne
 80004c0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004c4:	d029      	beq.n	800051a <__adddf3+0x24e>
 80004c6:	ea94 0f05 	teq	r4, r5
 80004ca:	bf08      	it	eq
 80004cc:	ea90 0f02 	teqeq	r0, r2
 80004d0:	d005      	beq.n	80004de <__adddf3+0x212>
 80004d2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004d6:	bf04      	itt	eq
 80004d8:	4619      	moveq	r1, r3
 80004da:	4610      	moveq	r0, r2
 80004dc:	bd30      	pop	{r4, r5, pc}
 80004de:	ea91 0f03 	teq	r1, r3
 80004e2:	bf1e      	ittt	ne
 80004e4:	2100      	movne	r1, #0
 80004e6:	2000      	movne	r0, #0
 80004e8:	bd30      	popne	{r4, r5, pc}
 80004ea:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ee:	d105      	bne.n	80004fc <__adddf3+0x230>
 80004f0:	0040      	lsls	r0, r0, #1
 80004f2:	4149      	adcs	r1, r1
 80004f4:	bf28      	it	cs
 80004f6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004fa:	bd30      	pop	{r4, r5, pc}
 80004fc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000500:	bf3c      	itt	cc
 8000502:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000506:	bd30      	popcc	{r4, r5, pc}
 8000508:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800050c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000510:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000514:	f04f 0000 	mov.w	r0, #0
 8000518:	bd30      	pop	{r4, r5, pc}
 800051a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800051e:	bf1a      	itte	ne
 8000520:	4619      	movne	r1, r3
 8000522:	4610      	movne	r0, r2
 8000524:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000528:	bf1c      	itt	ne
 800052a:	460b      	movne	r3, r1
 800052c:	4602      	movne	r2, r0
 800052e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000532:	bf06      	itte	eq
 8000534:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000538:	ea91 0f03 	teqeq	r1, r3
 800053c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000540:	bd30      	pop	{r4, r5, pc}
 8000542:	bf00      	nop

08000544 <__aeabi_ui2d>:
 8000544:	f090 0f00 	teq	r0, #0
 8000548:	bf04      	itt	eq
 800054a:	2100      	moveq	r1, #0
 800054c:	4770      	bxeq	lr
 800054e:	b530      	push	{r4, r5, lr}
 8000550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000558:	f04f 0500 	mov.w	r5, #0
 800055c:	f04f 0100 	mov.w	r1, #0
 8000560:	e750      	b.n	8000404 <__adddf3+0x138>
 8000562:	bf00      	nop

08000564 <__aeabi_i2d>:
 8000564:	f090 0f00 	teq	r0, #0
 8000568:	bf04      	itt	eq
 800056a:	2100      	moveq	r1, #0
 800056c:	4770      	bxeq	lr
 800056e:	b530      	push	{r4, r5, lr}
 8000570:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000574:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000578:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800057c:	bf48      	it	mi
 800057e:	4240      	negmi	r0, r0
 8000580:	f04f 0100 	mov.w	r1, #0
 8000584:	e73e      	b.n	8000404 <__adddf3+0x138>
 8000586:	bf00      	nop

08000588 <__aeabi_f2d>:
 8000588:	0042      	lsls	r2, r0, #1
 800058a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800058e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000592:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000596:	bf1f      	itttt	ne
 8000598:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005a4:	4770      	bxne	lr
 80005a6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005aa:	bf08      	it	eq
 80005ac:	4770      	bxeq	lr
 80005ae:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005b2:	bf04      	itt	eq
 80005b4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005b8:	4770      	bxeq	lr
 80005ba:	b530      	push	{r4, r5, lr}
 80005bc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005c0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005c4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005c8:	e71c      	b.n	8000404 <__adddf3+0x138>
 80005ca:	bf00      	nop

080005cc <__aeabi_ul2d>:
 80005cc:	ea50 0201 	orrs.w	r2, r0, r1
 80005d0:	bf08      	it	eq
 80005d2:	4770      	bxeq	lr
 80005d4:	b530      	push	{r4, r5, lr}
 80005d6:	f04f 0500 	mov.w	r5, #0
 80005da:	e00a      	b.n	80005f2 <__aeabi_l2d+0x16>

080005dc <__aeabi_l2d>:
 80005dc:	ea50 0201 	orrs.w	r2, r0, r1
 80005e0:	bf08      	it	eq
 80005e2:	4770      	bxeq	lr
 80005e4:	b530      	push	{r4, r5, lr}
 80005e6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005ea:	d502      	bpl.n	80005f2 <__aeabi_l2d+0x16>
 80005ec:	4240      	negs	r0, r0
 80005ee:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005f2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005f6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005fa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005fe:	f43f aed8 	beq.w	80003b2 <__adddf3+0xe6>
 8000602:	f04f 0203 	mov.w	r2, #3
 8000606:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800060a:	bf18      	it	ne
 800060c:	3203      	addne	r2, #3
 800060e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000612:	bf18      	it	ne
 8000614:	3203      	addne	r2, #3
 8000616:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800061a:	f1c2 0320 	rsb	r3, r2, #32
 800061e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000622:	fa20 f002 	lsr.w	r0, r0, r2
 8000626:	fa01 fe03 	lsl.w	lr, r1, r3
 800062a:	ea40 000e 	orr.w	r0, r0, lr
 800062e:	fa21 f102 	lsr.w	r1, r1, r2
 8000632:	4414      	add	r4, r2
 8000634:	e6bd      	b.n	80003b2 <__adddf3+0xe6>
 8000636:	bf00      	nop

08000638 <__aeabi_dmul>:
 8000638:	b570      	push	{r4, r5, r6, lr}
 800063a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800063e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000642:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000646:	bf1d      	ittte	ne
 8000648:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800064c:	ea94 0f0c 	teqne	r4, ip
 8000650:	ea95 0f0c 	teqne	r5, ip
 8000654:	f000 f8de 	bleq	8000814 <__aeabi_dmul+0x1dc>
 8000658:	442c      	add	r4, r5
 800065a:	ea81 0603 	eor.w	r6, r1, r3
 800065e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000662:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000666:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800066a:	bf18      	it	ne
 800066c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000670:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000674:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000678:	d038      	beq.n	80006ec <__aeabi_dmul+0xb4>
 800067a:	fba0 ce02 	umull	ip, lr, r0, r2
 800067e:	f04f 0500 	mov.w	r5, #0
 8000682:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000686:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800068a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800068e:	f04f 0600 	mov.w	r6, #0
 8000692:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000696:	f09c 0f00 	teq	ip, #0
 800069a:	bf18      	it	ne
 800069c:	f04e 0e01 	orrne.w	lr, lr, #1
 80006a0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006a4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006a8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006ac:	d204      	bcs.n	80006b8 <__aeabi_dmul+0x80>
 80006ae:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006b2:	416d      	adcs	r5, r5
 80006b4:	eb46 0606 	adc.w	r6, r6, r6
 80006b8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006bc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006c0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006c4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006c8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006cc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006d0:	bf88      	it	hi
 80006d2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006d6:	d81e      	bhi.n	8000716 <__aeabi_dmul+0xde>
 80006d8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006dc:	bf08      	it	eq
 80006de:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006e2:	f150 0000 	adcs.w	r0, r0, #0
 80006e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006f0:	ea46 0101 	orr.w	r1, r6, r1
 80006f4:	ea40 0002 	orr.w	r0, r0, r2
 80006f8:	ea81 0103 	eor.w	r1, r1, r3
 80006fc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000700:	bfc2      	ittt	gt
 8000702:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000706:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800070a:	bd70      	popgt	{r4, r5, r6, pc}
 800070c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000710:	f04f 0e00 	mov.w	lr, #0
 8000714:	3c01      	subs	r4, #1
 8000716:	f300 80ab 	bgt.w	8000870 <__aeabi_dmul+0x238>
 800071a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800071e:	bfde      	ittt	le
 8000720:	2000      	movle	r0, #0
 8000722:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000726:	bd70      	pople	{r4, r5, r6, pc}
 8000728:	f1c4 0400 	rsb	r4, r4, #0
 800072c:	3c20      	subs	r4, #32
 800072e:	da35      	bge.n	800079c <__aeabi_dmul+0x164>
 8000730:	340c      	adds	r4, #12
 8000732:	dc1b      	bgt.n	800076c <__aeabi_dmul+0x134>
 8000734:	f104 0414 	add.w	r4, r4, #20
 8000738:	f1c4 0520 	rsb	r5, r4, #32
 800073c:	fa00 f305 	lsl.w	r3, r0, r5
 8000740:	fa20 f004 	lsr.w	r0, r0, r4
 8000744:	fa01 f205 	lsl.w	r2, r1, r5
 8000748:	ea40 0002 	orr.w	r0, r0, r2
 800074c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000750:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000754:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000758:	fa21 f604 	lsr.w	r6, r1, r4
 800075c:	eb42 0106 	adc.w	r1, r2, r6
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f1c4 040c 	rsb	r4, r4, #12
 8000770:	f1c4 0520 	rsb	r5, r4, #32
 8000774:	fa00 f304 	lsl.w	r3, r0, r4
 8000778:	fa20 f005 	lsr.w	r0, r0, r5
 800077c:	fa01 f204 	lsl.w	r2, r1, r4
 8000780:	ea40 0002 	orr.w	r0, r0, r2
 8000784:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800078c:	f141 0100 	adc.w	r1, r1, #0
 8000790:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000794:	bf08      	it	eq
 8000796:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800079a:	bd70      	pop	{r4, r5, r6, pc}
 800079c:	f1c4 0520 	rsb	r5, r4, #32
 80007a0:	fa00 f205 	lsl.w	r2, r0, r5
 80007a4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007a8:	fa20 f304 	lsr.w	r3, r0, r4
 80007ac:	fa01 f205 	lsl.w	r2, r1, r5
 80007b0:	ea43 0302 	orr.w	r3, r3, r2
 80007b4:	fa21 f004 	lsr.w	r0, r1, r4
 80007b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007bc:	fa21 f204 	lsr.w	r2, r1, r4
 80007c0:	ea20 0002 	bic.w	r0, r0, r2
 80007c4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007cc:	bf08      	it	eq
 80007ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007d2:	bd70      	pop	{r4, r5, r6, pc}
 80007d4:	f094 0f00 	teq	r4, #0
 80007d8:	d10f      	bne.n	80007fa <__aeabi_dmul+0x1c2>
 80007da:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007de:	0040      	lsls	r0, r0, #1
 80007e0:	eb41 0101 	adc.w	r1, r1, r1
 80007e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007e8:	bf08      	it	eq
 80007ea:	3c01      	subeq	r4, #1
 80007ec:	d0f7      	beq.n	80007de <__aeabi_dmul+0x1a6>
 80007ee:	ea41 0106 	orr.w	r1, r1, r6
 80007f2:	f095 0f00 	teq	r5, #0
 80007f6:	bf18      	it	ne
 80007f8:	4770      	bxne	lr
 80007fa:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007fe:	0052      	lsls	r2, r2, #1
 8000800:	eb43 0303 	adc.w	r3, r3, r3
 8000804:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000808:	bf08      	it	eq
 800080a:	3d01      	subeq	r5, #1
 800080c:	d0f7      	beq.n	80007fe <__aeabi_dmul+0x1c6>
 800080e:	ea43 0306 	orr.w	r3, r3, r6
 8000812:	4770      	bx	lr
 8000814:	ea94 0f0c 	teq	r4, ip
 8000818:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800081c:	bf18      	it	ne
 800081e:	ea95 0f0c 	teqne	r5, ip
 8000822:	d00c      	beq.n	800083e <__aeabi_dmul+0x206>
 8000824:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000828:	bf18      	it	ne
 800082a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800082e:	d1d1      	bne.n	80007d4 <__aeabi_dmul+0x19c>
 8000830:	ea81 0103 	eor.w	r1, r1, r3
 8000834:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000838:	f04f 0000 	mov.w	r0, #0
 800083c:	bd70      	pop	{r4, r5, r6, pc}
 800083e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000842:	bf06      	itte	eq
 8000844:	4610      	moveq	r0, r2
 8000846:	4619      	moveq	r1, r3
 8000848:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800084c:	d019      	beq.n	8000882 <__aeabi_dmul+0x24a>
 800084e:	ea94 0f0c 	teq	r4, ip
 8000852:	d102      	bne.n	800085a <__aeabi_dmul+0x222>
 8000854:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000858:	d113      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800085a:	ea95 0f0c 	teq	r5, ip
 800085e:	d105      	bne.n	800086c <__aeabi_dmul+0x234>
 8000860:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000864:	bf1c      	itt	ne
 8000866:	4610      	movne	r0, r2
 8000868:	4619      	movne	r1, r3
 800086a:	d10a      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800086c:	ea81 0103 	eor.w	r1, r1, r3
 8000870:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000874:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000878:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800087c:	f04f 0000 	mov.w	r0, #0
 8000880:	bd70      	pop	{r4, r5, r6, pc}
 8000882:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000886:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800088a:	bd70      	pop	{r4, r5, r6, pc}

0800088c <__aeabi_ddiv>:
 800088c:	b570      	push	{r4, r5, r6, lr}
 800088e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000892:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000896:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800089a:	bf1d      	ittte	ne
 800089c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008a0:	ea94 0f0c 	teqne	r4, ip
 80008a4:	ea95 0f0c 	teqne	r5, ip
 80008a8:	f000 f8a7 	bleq	80009fa <__aeabi_ddiv+0x16e>
 80008ac:	eba4 0405 	sub.w	r4, r4, r5
 80008b0:	ea81 0e03 	eor.w	lr, r1, r3
 80008b4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008bc:	f000 8088 	beq.w	80009d0 <__aeabi_ddiv+0x144>
 80008c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008c4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008c8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008cc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008d0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008d4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008d8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008dc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008e0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008e4:	429d      	cmp	r5, r3
 80008e6:	bf08      	it	eq
 80008e8:	4296      	cmpeq	r6, r2
 80008ea:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008ee:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008f2:	d202      	bcs.n	80008fa <__aeabi_ddiv+0x6e>
 80008f4:	085b      	lsrs	r3, r3, #1
 80008f6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fa:	1ab6      	subs	r6, r6, r2
 80008fc:	eb65 0503 	sbc.w	r5, r5, r3
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800090a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000950:	085b      	lsrs	r3, r3, #1
 8000952:	ea4f 0232 	mov.w	r2, r2, rrx
 8000956:	ebb6 0e02 	subs.w	lr, r6, r2
 800095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095e:	bf22      	ittt	cs
 8000960:	1ab6      	subcs	r6, r6, r2
 8000962:	4675      	movcs	r5, lr
 8000964:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000968:	ea55 0e06 	orrs.w	lr, r5, r6
 800096c:	d018      	beq.n	80009a0 <__aeabi_ddiv+0x114>
 800096e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000972:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000976:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800097a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800097e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000982:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000986:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800098a:	d1c0      	bne.n	800090e <__aeabi_ddiv+0x82>
 800098c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000990:	d10b      	bne.n	80009aa <__aeabi_ddiv+0x11e>
 8000992:	ea41 0100 	orr.w	r1, r1, r0
 8000996:	f04f 0000 	mov.w	r0, #0
 800099a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800099e:	e7b6      	b.n	800090e <__aeabi_ddiv+0x82>
 80009a0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a4:	bf04      	itt	eq
 80009a6:	4301      	orreq	r1, r0
 80009a8:	2000      	moveq	r0, #0
 80009aa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009ae:	bf88      	it	hi
 80009b0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009b4:	f63f aeaf 	bhi.w	8000716 <__aeabi_dmul+0xde>
 80009b8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009bc:	bf04      	itt	eq
 80009be:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009c2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009c6:	f150 0000 	adcs.w	r0, r0, #0
 80009ca:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	pop	{r4, r5, r6, pc}
 80009d0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009d4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009d8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009dc:	bfc2      	ittt	gt
 80009de:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009e6:	bd70      	popgt	{r4, r5, r6, pc}
 80009e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009ec:	f04f 0e00 	mov.w	lr, #0
 80009f0:	3c01      	subs	r4, #1
 80009f2:	e690      	b.n	8000716 <__aeabi_dmul+0xde>
 80009f4:	ea45 0e06 	orr.w	lr, r5, r6
 80009f8:	e68d      	b.n	8000716 <__aeabi_dmul+0xde>
 80009fa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009fe:	ea94 0f0c 	teq	r4, ip
 8000a02:	bf08      	it	eq
 8000a04:	ea95 0f0c 	teqeq	r5, ip
 8000a08:	f43f af3b 	beq.w	8000882 <__aeabi_dmul+0x24a>
 8000a0c:	ea94 0f0c 	teq	r4, ip
 8000a10:	d10a      	bne.n	8000a28 <__aeabi_ddiv+0x19c>
 8000a12:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a16:	f47f af34 	bne.w	8000882 <__aeabi_dmul+0x24a>
 8000a1a:	ea95 0f0c 	teq	r5, ip
 8000a1e:	f47f af25 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a22:	4610      	mov	r0, r2
 8000a24:	4619      	mov	r1, r3
 8000a26:	e72c      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a28:	ea95 0f0c 	teq	r5, ip
 8000a2c:	d106      	bne.n	8000a3c <__aeabi_ddiv+0x1b0>
 8000a2e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a32:	f43f aefd 	beq.w	8000830 <__aeabi_dmul+0x1f8>
 8000a36:	4610      	mov	r0, r2
 8000a38:	4619      	mov	r1, r3
 8000a3a:	e722      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a3c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a40:	bf18      	it	ne
 8000a42:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a46:	f47f aec5 	bne.w	80007d4 <__aeabi_dmul+0x19c>
 8000a4a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a4e:	f47f af0d 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a52:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a56:	f47f aeeb 	bne.w	8000830 <__aeabi_dmul+0x1f8>
 8000a5a:	e712      	b.n	8000882 <__aeabi_dmul+0x24a>

08000a5c <__aeabi_d2f>:
 8000a5c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a60:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a64:	bf24      	itt	cs
 8000a66:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a6a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a6e:	d90d      	bls.n	8000a8c <__aeabi_d2f+0x30>
 8000a70:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a74:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a78:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a7c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a80:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a84:	bf08      	it	eq
 8000a86:	f020 0001 	biceq.w	r0, r0, #1
 8000a8a:	4770      	bx	lr
 8000a8c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a90:	d121      	bne.n	8000ad6 <__aeabi_d2f+0x7a>
 8000a92:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a96:	bfbc      	itt	lt
 8000a98:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a9c:	4770      	bxlt	lr
 8000a9e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aa2:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000aa6:	f1c2 0218 	rsb	r2, r2, #24
 8000aaa:	f1c2 0c20 	rsb	ip, r2, #32
 8000aae:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ab2:	fa20 f002 	lsr.w	r0, r0, r2
 8000ab6:	bf18      	it	ne
 8000ab8:	f040 0001 	orrne.w	r0, r0, #1
 8000abc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ac0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ac4:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ac8:	ea40 000c 	orr.w	r0, r0, ip
 8000acc:	fa23 f302 	lsr.w	r3, r3, r2
 8000ad0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ad4:	e7cc      	b.n	8000a70 <__aeabi_d2f+0x14>
 8000ad6:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000ada:	d107      	bne.n	8000aec <__aeabi_d2f+0x90>
 8000adc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000ae0:	bf1e      	ittt	ne
 8000ae2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000ae6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000aea:	4770      	bxne	lr
 8000aec:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000af0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000af4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop

08000afc <__aeabi_uldivmod>:
 8000afc:	b953      	cbnz	r3, 8000b14 <__aeabi_uldivmod+0x18>
 8000afe:	b94a      	cbnz	r2, 8000b14 <__aeabi_uldivmod+0x18>
 8000b00:	2900      	cmp	r1, #0
 8000b02:	bf08      	it	eq
 8000b04:	2800      	cmpeq	r0, #0
 8000b06:	bf1c      	itt	ne
 8000b08:	f04f 31ff 	movne.w	r1, #4294967295
 8000b0c:	f04f 30ff 	movne.w	r0, #4294967295
 8000b10:	f000 b970 	b.w	8000df4 <__aeabi_idiv0>
 8000b14:	f1ad 0c08 	sub.w	ip, sp, #8
 8000b18:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000b1c:	f000 f806 	bl	8000b2c <__udivmoddi4>
 8000b20:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b24:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b28:	b004      	add	sp, #16
 8000b2a:	4770      	bx	lr

08000b2c <__udivmoddi4>:
 8000b2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000b30:	9e08      	ldr	r6, [sp, #32]
 8000b32:	460d      	mov	r5, r1
 8000b34:	4604      	mov	r4, r0
 8000b36:	460f      	mov	r7, r1
 8000b38:	2b00      	cmp	r3, #0
 8000b3a:	d14a      	bne.n	8000bd2 <__udivmoddi4+0xa6>
 8000b3c:	428a      	cmp	r2, r1
 8000b3e:	4694      	mov	ip, r2
 8000b40:	d965      	bls.n	8000c0e <__udivmoddi4+0xe2>
 8000b42:	fab2 f382 	clz	r3, r2
 8000b46:	b143      	cbz	r3, 8000b5a <__udivmoddi4+0x2e>
 8000b48:	fa02 fc03 	lsl.w	ip, r2, r3
 8000b4c:	f1c3 0220 	rsb	r2, r3, #32
 8000b50:	409f      	lsls	r7, r3
 8000b52:	fa20 f202 	lsr.w	r2, r0, r2
 8000b56:	4317      	orrs	r7, r2
 8000b58:	409c      	lsls	r4, r3
 8000b5a:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000b5e:	fa1f f58c 	uxth.w	r5, ip
 8000b62:	fbb7 f1fe 	udiv	r1, r7, lr
 8000b66:	0c22      	lsrs	r2, r4, #16
 8000b68:	fb0e 7711 	mls	r7, lr, r1, r7
 8000b6c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000b70:	fb01 f005 	mul.w	r0, r1, r5
 8000b74:	4290      	cmp	r0, r2
 8000b76:	d90a      	bls.n	8000b8e <__udivmoddi4+0x62>
 8000b78:	eb1c 0202 	adds.w	r2, ip, r2
 8000b7c:	f101 37ff 	add.w	r7, r1, #4294967295
 8000b80:	f080 811c 	bcs.w	8000dbc <__udivmoddi4+0x290>
 8000b84:	4290      	cmp	r0, r2
 8000b86:	f240 8119 	bls.w	8000dbc <__udivmoddi4+0x290>
 8000b8a:	3902      	subs	r1, #2
 8000b8c:	4462      	add	r2, ip
 8000b8e:	1a12      	subs	r2, r2, r0
 8000b90:	b2a4      	uxth	r4, r4
 8000b92:	fbb2 f0fe 	udiv	r0, r2, lr
 8000b96:	fb0e 2210 	mls	r2, lr, r0, r2
 8000b9a:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000b9e:	fb00 f505 	mul.w	r5, r0, r5
 8000ba2:	42a5      	cmp	r5, r4
 8000ba4:	d90a      	bls.n	8000bbc <__udivmoddi4+0x90>
 8000ba6:	eb1c 0404 	adds.w	r4, ip, r4
 8000baa:	f100 32ff 	add.w	r2, r0, #4294967295
 8000bae:	f080 8107 	bcs.w	8000dc0 <__udivmoddi4+0x294>
 8000bb2:	42a5      	cmp	r5, r4
 8000bb4:	f240 8104 	bls.w	8000dc0 <__udivmoddi4+0x294>
 8000bb8:	4464      	add	r4, ip
 8000bba:	3802      	subs	r0, #2
 8000bbc:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000bc0:	1b64      	subs	r4, r4, r5
 8000bc2:	2100      	movs	r1, #0
 8000bc4:	b11e      	cbz	r6, 8000bce <__udivmoddi4+0xa2>
 8000bc6:	40dc      	lsrs	r4, r3
 8000bc8:	2300      	movs	r3, #0
 8000bca:	e9c6 4300 	strd	r4, r3, [r6]
 8000bce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bd2:	428b      	cmp	r3, r1
 8000bd4:	d908      	bls.n	8000be8 <__udivmoddi4+0xbc>
 8000bd6:	2e00      	cmp	r6, #0
 8000bd8:	f000 80ed 	beq.w	8000db6 <__udivmoddi4+0x28a>
 8000bdc:	2100      	movs	r1, #0
 8000bde:	e9c6 0500 	strd	r0, r5, [r6]
 8000be2:	4608      	mov	r0, r1
 8000be4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000be8:	fab3 f183 	clz	r1, r3
 8000bec:	2900      	cmp	r1, #0
 8000bee:	d149      	bne.n	8000c84 <__udivmoddi4+0x158>
 8000bf0:	42ab      	cmp	r3, r5
 8000bf2:	d302      	bcc.n	8000bfa <__udivmoddi4+0xce>
 8000bf4:	4282      	cmp	r2, r0
 8000bf6:	f200 80f8 	bhi.w	8000dea <__udivmoddi4+0x2be>
 8000bfa:	1a84      	subs	r4, r0, r2
 8000bfc:	eb65 0203 	sbc.w	r2, r5, r3
 8000c00:	2001      	movs	r0, #1
 8000c02:	4617      	mov	r7, r2
 8000c04:	2e00      	cmp	r6, #0
 8000c06:	d0e2      	beq.n	8000bce <__udivmoddi4+0xa2>
 8000c08:	e9c6 4700 	strd	r4, r7, [r6]
 8000c0c:	e7df      	b.n	8000bce <__udivmoddi4+0xa2>
 8000c0e:	b902      	cbnz	r2, 8000c12 <__udivmoddi4+0xe6>
 8000c10:	deff      	udf	#255	; 0xff
 8000c12:	fab2 f382 	clz	r3, r2
 8000c16:	2b00      	cmp	r3, #0
 8000c18:	f040 8090 	bne.w	8000d3c <__udivmoddi4+0x210>
 8000c1c:	1a8a      	subs	r2, r1, r2
 8000c1e:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000c22:	fa1f fe8c 	uxth.w	lr, ip
 8000c26:	2101      	movs	r1, #1
 8000c28:	fbb2 f5f7 	udiv	r5, r2, r7
 8000c2c:	fb07 2015 	mls	r0, r7, r5, r2
 8000c30:	0c22      	lsrs	r2, r4, #16
 8000c32:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000c36:	fb0e f005 	mul.w	r0, lr, r5
 8000c3a:	4290      	cmp	r0, r2
 8000c3c:	d908      	bls.n	8000c50 <__udivmoddi4+0x124>
 8000c3e:	eb1c 0202 	adds.w	r2, ip, r2
 8000c42:	f105 38ff 	add.w	r8, r5, #4294967295
 8000c46:	d202      	bcs.n	8000c4e <__udivmoddi4+0x122>
 8000c48:	4290      	cmp	r0, r2
 8000c4a:	f200 80cb 	bhi.w	8000de4 <__udivmoddi4+0x2b8>
 8000c4e:	4645      	mov	r5, r8
 8000c50:	1a12      	subs	r2, r2, r0
 8000c52:	b2a4      	uxth	r4, r4
 8000c54:	fbb2 f0f7 	udiv	r0, r2, r7
 8000c58:	fb07 2210 	mls	r2, r7, r0, r2
 8000c5c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000c60:	fb0e fe00 	mul.w	lr, lr, r0
 8000c64:	45a6      	cmp	lr, r4
 8000c66:	d908      	bls.n	8000c7a <__udivmoddi4+0x14e>
 8000c68:	eb1c 0404 	adds.w	r4, ip, r4
 8000c6c:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c70:	d202      	bcs.n	8000c78 <__udivmoddi4+0x14c>
 8000c72:	45a6      	cmp	lr, r4
 8000c74:	f200 80bb 	bhi.w	8000dee <__udivmoddi4+0x2c2>
 8000c78:	4610      	mov	r0, r2
 8000c7a:	eba4 040e 	sub.w	r4, r4, lr
 8000c7e:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000c82:	e79f      	b.n	8000bc4 <__udivmoddi4+0x98>
 8000c84:	f1c1 0720 	rsb	r7, r1, #32
 8000c88:	408b      	lsls	r3, r1
 8000c8a:	fa22 fc07 	lsr.w	ip, r2, r7
 8000c8e:	ea4c 0c03 	orr.w	ip, ip, r3
 8000c92:	fa05 f401 	lsl.w	r4, r5, r1
 8000c96:	fa20 f307 	lsr.w	r3, r0, r7
 8000c9a:	40fd      	lsrs	r5, r7
 8000c9c:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000ca0:	4323      	orrs	r3, r4
 8000ca2:	fbb5 f8f9 	udiv	r8, r5, r9
 8000ca6:	fa1f fe8c 	uxth.w	lr, ip
 8000caa:	fb09 5518 	mls	r5, r9, r8, r5
 8000cae:	0c1c      	lsrs	r4, r3, #16
 8000cb0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000cb4:	fb08 f50e 	mul.w	r5, r8, lr
 8000cb8:	42a5      	cmp	r5, r4
 8000cba:	fa02 f201 	lsl.w	r2, r2, r1
 8000cbe:	fa00 f001 	lsl.w	r0, r0, r1
 8000cc2:	d90b      	bls.n	8000cdc <__udivmoddi4+0x1b0>
 8000cc4:	eb1c 0404 	adds.w	r4, ip, r4
 8000cc8:	f108 3aff 	add.w	sl, r8, #4294967295
 8000ccc:	f080 8088 	bcs.w	8000de0 <__udivmoddi4+0x2b4>
 8000cd0:	42a5      	cmp	r5, r4
 8000cd2:	f240 8085 	bls.w	8000de0 <__udivmoddi4+0x2b4>
 8000cd6:	f1a8 0802 	sub.w	r8, r8, #2
 8000cda:	4464      	add	r4, ip
 8000cdc:	1b64      	subs	r4, r4, r5
 8000cde:	b29d      	uxth	r5, r3
 8000ce0:	fbb4 f3f9 	udiv	r3, r4, r9
 8000ce4:	fb09 4413 	mls	r4, r9, r3, r4
 8000ce8:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000cec:	fb03 fe0e 	mul.w	lr, r3, lr
 8000cf0:	45a6      	cmp	lr, r4
 8000cf2:	d908      	bls.n	8000d06 <__udivmoddi4+0x1da>
 8000cf4:	eb1c 0404 	adds.w	r4, ip, r4
 8000cf8:	f103 35ff 	add.w	r5, r3, #4294967295
 8000cfc:	d26c      	bcs.n	8000dd8 <__udivmoddi4+0x2ac>
 8000cfe:	45a6      	cmp	lr, r4
 8000d00:	d96a      	bls.n	8000dd8 <__udivmoddi4+0x2ac>
 8000d02:	3b02      	subs	r3, #2
 8000d04:	4464      	add	r4, ip
 8000d06:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000d0a:	fba3 9502 	umull	r9, r5, r3, r2
 8000d0e:	eba4 040e 	sub.w	r4, r4, lr
 8000d12:	42ac      	cmp	r4, r5
 8000d14:	46c8      	mov	r8, r9
 8000d16:	46ae      	mov	lr, r5
 8000d18:	d356      	bcc.n	8000dc8 <__udivmoddi4+0x29c>
 8000d1a:	d053      	beq.n	8000dc4 <__udivmoddi4+0x298>
 8000d1c:	b156      	cbz	r6, 8000d34 <__udivmoddi4+0x208>
 8000d1e:	ebb0 0208 	subs.w	r2, r0, r8
 8000d22:	eb64 040e 	sbc.w	r4, r4, lr
 8000d26:	fa04 f707 	lsl.w	r7, r4, r7
 8000d2a:	40ca      	lsrs	r2, r1
 8000d2c:	40cc      	lsrs	r4, r1
 8000d2e:	4317      	orrs	r7, r2
 8000d30:	e9c6 7400 	strd	r7, r4, [r6]
 8000d34:	4618      	mov	r0, r3
 8000d36:	2100      	movs	r1, #0
 8000d38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d3c:	f1c3 0120 	rsb	r1, r3, #32
 8000d40:	fa02 fc03 	lsl.w	ip, r2, r3
 8000d44:	fa20 f201 	lsr.w	r2, r0, r1
 8000d48:	fa25 f101 	lsr.w	r1, r5, r1
 8000d4c:	409d      	lsls	r5, r3
 8000d4e:	432a      	orrs	r2, r5
 8000d50:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000d54:	fa1f fe8c 	uxth.w	lr, ip
 8000d58:	fbb1 f0f7 	udiv	r0, r1, r7
 8000d5c:	fb07 1510 	mls	r5, r7, r0, r1
 8000d60:	0c11      	lsrs	r1, r2, #16
 8000d62:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000d66:	fb00 f50e 	mul.w	r5, r0, lr
 8000d6a:	428d      	cmp	r5, r1
 8000d6c:	fa04 f403 	lsl.w	r4, r4, r3
 8000d70:	d908      	bls.n	8000d84 <__udivmoddi4+0x258>
 8000d72:	eb1c 0101 	adds.w	r1, ip, r1
 8000d76:	f100 38ff 	add.w	r8, r0, #4294967295
 8000d7a:	d22f      	bcs.n	8000ddc <__udivmoddi4+0x2b0>
 8000d7c:	428d      	cmp	r5, r1
 8000d7e:	d92d      	bls.n	8000ddc <__udivmoddi4+0x2b0>
 8000d80:	3802      	subs	r0, #2
 8000d82:	4461      	add	r1, ip
 8000d84:	1b49      	subs	r1, r1, r5
 8000d86:	b292      	uxth	r2, r2
 8000d88:	fbb1 f5f7 	udiv	r5, r1, r7
 8000d8c:	fb07 1115 	mls	r1, r7, r5, r1
 8000d90:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000d94:	fb05 f10e 	mul.w	r1, r5, lr
 8000d98:	4291      	cmp	r1, r2
 8000d9a:	d908      	bls.n	8000dae <__udivmoddi4+0x282>
 8000d9c:	eb1c 0202 	adds.w	r2, ip, r2
 8000da0:	f105 38ff 	add.w	r8, r5, #4294967295
 8000da4:	d216      	bcs.n	8000dd4 <__udivmoddi4+0x2a8>
 8000da6:	4291      	cmp	r1, r2
 8000da8:	d914      	bls.n	8000dd4 <__udivmoddi4+0x2a8>
 8000daa:	3d02      	subs	r5, #2
 8000dac:	4462      	add	r2, ip
 8000dae:	1a52      	subs	r2, r2, r1
 8000db0:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000db4:	e738      	b.n	8000c28 <__udivmoddi4+0xfc>
 8000db6:	4631      	mov	r1, r6
 8000db8:	4630      	mov	r0, r6
 8000dba:	e708      	b.n	8000bce <__udivmoddi4+0xa2>
 8000dbc:	4639      	mov	r1, r7
 8000dbe:	e6e6      	b.n	8000b8e <__udivmoddi4+0x62>
 8000dc0:	4610      	mov	r0, r2
 8000dc2:	e6fb      	b.n	8000bbc <__udivmoddi4+0x90>
 8000dc4:	4548      	cmp	r0, r9
 8000dc6:	d2a9      	bcs.n	8000d1c <__udivmoddi4+0x1f0>
 8000dc8:	ebb9 0802 	subs.w	r8, r9, r2
 8000dcc:	eb65 0e0c 	sbc.w	lr, r5, ip
 8000dd0:	3b01      	subs	r3, #1
 8000dd2:	e7a3      	b.n	8000d1c <__udivmoddi4+0x1f0>
 8000dd4:	4645      	mov	r5, r8
 8000dd6:	e7ea      	b.n	8000dae <__udivmoddi4+0x282>
 8000dd8:	462b      	mov	r3, r5
 8000dda:	e794      	b.n	8000d06 <__udivmoddi4+0x1da>
 8000ddc:	4640      	mov	r0, r8
 8000dde:	e7d1      	b.n	8000d84 <__udivmoddi4+0x258>
 8000de0:	46d0      	mov	r8, sl
 8000de2:	e77b      	b.n	8000cdc <__udivmoddi4+0x1b0>
 8000de4:	3d02      	subs	r5, #2
 8000de6:	4462      	add	r2, ip
 8000de8:	e732      	b.n	8000c50 <__udivmoddi4+0x124>
 8000dea:	4608      	mov	r0, r1
 8000dec:	e70a      	b.n	8000c04 <__udivmoddi4+0xd8>
 8000dee:	4464      	add	r4, ip
 8000df0:	3802      	subs	r0, #2
 8000df2:	e742      	b.n	8000c7a <__udivmoddi4+0x14e>

08000df4 <__aeabi_idiv0>:
 8000df4:	4770      	bx	lr
 8000df6:	bf00      	nop

08000df8 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000df8:	480d      	ldr	r0, [pc, #52]	; (8000e30 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000dfa:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000dfc:	480d      	ldr	r0, [pc, #52]	; (8000e34 <LoopForever+0x6>)
  ldr r1, =_edata
 8000dfe:	490e      	ldr	r1, [pc, #56]	; (8000e38 <LoopForever+0xa>)
  ldr r2, =_sidata
 8000e00:	4a0e      	ldr	r2, [pc, #56]	; (8000e3c <LoopForever+0xe>)
  movs r3, #0
 8000e02:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 8000e04:	e002      	b.n	8000e0c <LoopCopyDataInit>

08000e06 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000e06:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000e08:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000e0a:	3304      	adds	r3, #4

08000e0c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000e0c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000e0e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000e10:	d3f9      	bcc.n	8000e06 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000e12:	4a0b      	ldr	r2, [pc, #44]	; (8000e40 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000e14:	4c0b      	ldr	r4, [pc, #44]	; (8000e44 <LoopForever+0x16>)
  movs r3, #0
 8000e16:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000e18:	e001      	b.n	8000e1e <LoopFillZerobss>

08000e1a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000e1a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000e1c:	3204      	adds	r2, #4

08000e1e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000e1e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000e20:	d3fb      	bcc.n	8000e1a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8000e22:	f004 fa9b 	bl	800535c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000e26:	f00c fcb1 	bl	800d78c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000e2a:	f000 fddd 	bl	80019e8 <main>

08000e2e <LoopForever>:

LoopForever:
    b LoopForever
 8000e2e:	e7fe      	b.n	8000e2e <LoopForever>
  ldr   r0, =_estack
 8000e30:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8000e34:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000e38:	2000150c 	.word	0x2000150c
  ldr r2, =_sidata
 8000e3c:	0801a604 	.word	0x0801a604
  ldr r2, =_sbss
 8000e40:	20001520 	.word	0x20001520
  ldr r4, =_ebss
 8000e44:	200031f8 	.word	0x200031f8

08000e48 <ADC3_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000e48:	e7fe      	b.n	8000e48 <ADC3_IRQHandler>
	...

08000e4c <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000e4c:	b510      	push	{r4, lr}

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 8000e4e:	2400      	movs	r4, #0
{
 8000e50:	b09a      	sub	sp, #104	; 0x68
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000e52:	223c      	movs	r2, #60	; 0x3c
 8000e54:	4621      	mov	r1, r4
 8000e56:	a80b      	add	r0, sp, #44	; 0x2c
  ADC_MultiModeTypeDef multimode = {0};
 8000e58:	e9cd 4400 	strd	r4, r4, [sp]
 8000e5c:	9402      	str	r4, [sp, #8]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 8000e5e:	f00c fc31 	bl	800d6c4 <memset>
  ADC_ChannelConfTypeDef sConfig = {0};
 8000e62:	2220      	movs	r2, #32
 8000e64:	4621      	mov	r1, r4
 8000e66:	a803      	add	r0, sp, #12
 8000e68:	f00c fc2c 	bl	800d6c4 <memset>

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 8000e6c:	483d      	ldr	r0, [pc, #244]	; (8000f64 <MX_ADC1_Init+0x118>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
  hadc1.Init.GainCompensation = 0;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8000e6e:	2301      	movs	r3, #1
 8000e70:	6143      	str	r3, [r0, #20]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = 1;
 8000e72:	6203      	str	r3, [r0, #32]
  hadc1.Instance = ADC1;
 8000e74:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000e78:	6003      	str	r3, [r0, #0]
  hadc1.Init.DataAlign = ADC_DATAALIGN_LEFT;
 8000e7a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000e7e:	60c3      	str	r3, [r0, #12]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000e80:	8384      	strh	r4, [r0, #28]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000e82:	2304      	movs	r3, #4
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000e84:	e9c0 4401 	strd	r4, r4, [r0, #4]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000e88:	e9c0 440b 	strd	r4, r4, [r0, #44]	; 0x2c
  hadc1.Init.GainCompensation = 0;
 8000e8c:	6104      	str	r4, [r0, #16]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000e8e:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000e92:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000e96:	63c4      	str	r4, [r0, #60]	; 0x3c
  hadc1.Init.OversamplingMode = DISABLE;
 8000e98:	f880 4040 	strb.w	r4, [r0, #64]	; 0x40
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000e9c:	6183      	str	r3, [r0, #24]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000e9e:	f004 fab7 	bl	8005410 <HAL_ADC_Init>
 8000ea2:	2800      	cmp	r0, #0
 8000ea4:	d14a      	bne.n	8000f3c <MX_ADC1_Init+0xf0>
    Error_Handler();
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000ea6:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000ea8:	482e      	ldr	r0, [pc, #184]	; (8000f64 <MX_ADC1_Init+0x118>)
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000eaa:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000eac:	4669      	mov	r1, sp
 8000eae:	f005 f97d 	bl	80061ac <HAL_ADCEx_MultiModeConfigChannel>
 8000eb2:	2800      	cmp	r0, #0
 8000eb4:	d152      	bne.n	8000f5c <MX_ADC1_Init+0x110>
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_1;
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 8000eb6:	482c      	ldr	r0, [pc, #176]	; (8000f68 <MX_ADC1_Init+0x11c>)
 8000eb8:	2109      	movs	r1, #9
 8000eba:	e9cd 010b 	strd	r0, r1, [sp, #44]	; 0x2c
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_6CYCLES_5;
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 8000ebe:	2401      	movs	r4, #1
 8000ec0:	217f      	movs	r1, #127	; 0x7f
 8000ec2:	e9cd 410d 	strd	r4, r1, [sp, #52]	; 0x34
  sConfigInjected.InjectedOffsetNumber = ADC_OFFSET_NONE;
 8000ec6:	2104      	movs	r1, #4
 8000ec8:	910f      	str	r1, [sp, #60]	; 0x3c
  sConfigInjected.InjectedOffset = 0;
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000eca:	2103      	movs	r1, #3
  sConfigInjected.InjectedOffset = 0;
 8000ecc:	2300      	movs	r3, #0
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
  sConfigInjected.AutoInjectedConv = DISABLE;
  sConfigInjected.QueueInjectedContext = DISABLE;
  sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJEC_T1_TRGO;
 8000ece:	2280      	movs	r2, #128	; 0x80
  sConfigInjected.InjectedNbrOfConversion = 3;
 8000ed0:	9113      	str	r1, [sp, #76]	; 0x4c
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
  sConfigInjected.InjecOversamplingMode = DISABLE;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ed2:	4824      	ldr	r0, [pc, #144]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedOffset = 0;
 8000ed4:	9310      	str	r3, [sp, #64]	; 0x40
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ed6:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_RISING;
 8000ed8:	e9cd 2215 	strd	r2, r2, [sp, #84]	; 0x54
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8000edc:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
  sConfigInjected.QueueInjectedContext = DISABLE;
 8000ee0:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
  sConfigInjected.InjecOversamplingMode = DISABLE;
 8000ee4:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ee8:	f004 fe44 	bl	8005b74 <HAL_ADCEx_InjectedConfigChannel>
 8000eec:	2800      	cmp	r0, #0
 8000eee:	d132      	bne.n	8000f56 <MX_ADC1_Init+0x10a>
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_7;
 8000ef0:	4a1e      	ldr	r2, [pc, #120]	; (8000f6c <MX_ADC1_Init+0x120>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000ef2:	481c      	ldr	r0, [pc, #112]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedChannel = ADC_CHANNEL_7;
 8000ef4:	920b      	str	r2, [sp, #44]	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000ef6:	f240 130f 	movw	r3, #271	; 0x10f
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000efa:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
 8000efc:	930c      	str	r3, [sp, #48]	; 0x30
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000efe:	f004 fe39 	bl	8005b74 <HAL_ADCEx_InjectedConfigChannel>
 8000f02:	bb28      	cbnz	r0, 8000f50 <MX_ADC1_Init+0x104>
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_6;
 8000f04:	4a1a      	ldr	r2, [pc, #104]	; (8000f70 <MX_ADC1_Init+0x124>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f06:	4817      	ldr	r0, [pc, #92]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000f08:	f240 2315 	movw	r3, #533	; 0x215
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f0c:	a90b      	add	r1, sp, #44	; 0x2c
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_3;
 8000f0e:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 8000f12:	f004 fe2f 	bl	8005b74 <HAL_ADCEx_InjectedConfigChannel>
 8000f16:	b9c0      	cbnz	r0, 8000f4a <MX_ADC1_Init+0xfe>
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_2;
 8000f18:	4a16      	ldr	r2, [pc, #88]	; (8000f74 <MX_ADC1_Init+0x128>)
 8000f1a:	9203      	str	r2, [sp, #12]
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000f1c:	227f      	movs	r2, #127	; 0x7f
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000f1e:	2304      	movs	r3, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000f20:	2406      	movs	r4, #6
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000f22:	9206      	str	r2, [sp, #24]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f24:	480f      	ldr	r0, [pc, #60]	; (8000f64 <MX_ADC1_Init+0x118>)
  sConfig.Offset = 0;
 8000f26:	2200      	movs	r2, #0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f28:	a903      	add	r1, sp, #12
  sConfig.SamplingTime = ADC_SAMPLETIME_47CYCLES_5;
 8000f2a:	e9cd 4304 	strd	r4, r3, [sp, #16]
  sConfig.Offset = 0;
 8000f2e:	e9cd 3207 	strd	r3, r2, [sp, #28]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f32:	f004 fb93 	bl	800565c <HAL_ADC_ConfigChannel>
 8000f36:	b920      	cbnz	r0, 8000f42 <MX_ADC1_Init+0xf6>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8000f38:	b01a      	add	sp, #104	; 0x68
 8000f3a:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000f3c:	f000 fe58 	bl	8001bf0 <Error_Handler>
 8000f40:	e7b1      	b.n	8000ea6 <MX_ADC1_Init+0x5a>
    Error_Handler();
 8000f42:	f000 fe55 	bl	8001bf0 <Error_Handler>
}
 8000f46:	b01a      	add	sp, #104	; 0x68
 8000f48:	bd10      	pop	{r4, pc}
    Error_Handler();
 8000f4a:	f000 fe51 	bl	8001bf0 <Error_Handler>
 8000f4e:	e7e3      	b.n	8000f18 <MX_ADC1_Init+0xcc>
    Error_Handler();
 8000f50:	f000 fe4e 	bl	8001bf0 <Error_Handler>
 8000f54:	e7d6      	b.n	8000f04 <MX_ADC1_Init+0xb8>
    Error_Handler();
 8000f56:	f000 fe4b 	bl	8001bf0 <Error_Handler>
 8000f5a:	e7c9      	b.n	8000ef0 <MX_ADC1_Init+0xa4>
    Error_Handler();
 8000f5c:	f000 fe48 	bl	8001bf0 <Error_Handler>
 8000f60:	e7a9      	b.n	8000eb6 <MX_ADC1_Init+0x6a>
 8000f62:	bf00      	nop
 8000f64:	2000153c 	.word	0x2000153c
 8000f68:	04300002 	.word	0x04300002
 8000f6c:	1d500080 	.word	0x1d500080
 8000f70:	19200040 	.word	0x19200040
 8000f74:	08600004 	.word	0x08600004

08000f78 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8000f78:	b5d0      	push	{r4, r6, r7, lr}
 8000f7a:	4604      	mov	r4, r0
 8000f7c:	b09e      	sub	sp, #120	; 0x78

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000f7e:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000f80:	2254      	movs	r2, #84	; 0x54
 8000f82:	a809      	add	r0, sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000f84:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8000f88:	e9cd 1106 	strd	r1, r1, [sp, #24]
 8000f8c:	9108      	str	r1, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000f8e:	f00c fb99 	bl	800d6c4 <memset>
  if(adcHandle->Instance==ADC1)
 8000f92:	6823      	ldr	r3, [r4, #0]
 8000f94:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000f98:	d001      	beq.n	8000f9e <HAL_ADC_MspInit+0x26>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8000f9a:	b01e      	add	sp, #120	; 0x78
 8000f9c:	bdd0      	pop	{r4, r6, r7, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8000f9e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8000fa2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000fa6:	a809      	add	r0, sp, #36	; 0x24
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC12;
 8000fa8:	9209      	str	r2, [sp, #36]	; 0x24
    PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8000faa:	931a      	str	r3, [sp, #104]	; 0x68
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000fac:	f006 f880 	bl	80070b0 <HAL_RCCEx_PeriphCLKConfig>
 8000fb0:	2800      	cmp	r0, #0
 8000fb2:	d12f      	bne.n	8001014 <HAL_ADC_MspInit+0x9c>
    __HAL_RCC_ADC12_CLK_ENABLE();
 8000fb4:	4b19      	ldr	r3, [pc, #100]	; (800101c <HAL_ADC_MspInit+0xa4>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000fb6:	481a      	ldr	r0, [pc, #104]	; (8001020 <HAL_ADC_MspInit+0xa8>)
    __HAL_RCC_ADC12_CLK_ENABLE();
 8000fb8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fba:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000fbe:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fc0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fc2:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8000fc6:	9201      	str	r2, [sp, #4]
 8000fc8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000fca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fcc:	f042 0204 	orr.w	r2, r2, #4
 8000fd0:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fd2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fd4:	f002 0204 	and.w	r2, r2, #4
 8000fd8:	9202      	str	r2, [sp, #8]
 8000fda:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000fdc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fde:	f042 0201 	orr.w	r2, r2, #1
 8000fe2:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fe4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fe6:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin;
 8000fea:	2603      	movs	r6, #3
 8000fec:	2703      	movs	r7, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000fee:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff0:	2400      	movs	r4, #0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ff2:	a904      	add	r1, sp, #16
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ff4:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ff6:	9406      	str	r4, [sp, #24]
    GPIO_InitStruct.Pin = M1_CURR_AMPL_W_Pin|M1_CURR_AMPL_V_Pin;
 8000ff8:	e9cd 6704 	strd	r6, r7, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ffc:	f005 fb26 	bl	800664c <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001000:	a904      	add	r1, sp, #16
 8001002:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_CURR_AMPL_U_Pin|M1_BUS_VOLTAGE_Pin;
 8001006:	e9cd 6704 	strd	r6, r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800100a:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800100c:	f005 fb1e 	bl	800664c <HAL_GPIO_Init>
}
 8001010:	b01e      	add	sp, #120	; 0x78
 8001012:	bdd0      	pop	{r4, r6, r7, pc}
      Error_Handler();
 8001014:	f000 fdec 	bl	8001bf0 <Error_Handler>
 8001018:	e7cc      	b.n	8000fb4 <HAL_ADC_MspInit+0x3c>
 800101a:	bf00      	nop
 800101c:	40021000 	.word	0x40021000
 8001020:	48000800 	.word	0x48000800

08001024 <MX_X_CUBE_AI_Init>:
/* USER CODE END 2 */

/* Entry points --------------------------------------------------------------*/

void MX_X_CUBE_AI_Init(void)
{
 8001024:	b570      	push	{r4, r5, r6, lr}
  err = ai_network_create_and_init(&network, act_addr, NULL);
 8001026:	4c16      	ldr	r4, [pc, #88]	; (8001080 <MX_X_CUBE_AI_Init+0x5c>)
    /* USER CODE BEGIN 5 */
  printf("\r\nTEMPLATE - initialization\r\n");
 8001028:	4816      	ldr	r0, [pc, #88]	; (8001084 <MX_X_CUBE_AI_Init+0x60>)
 800102a:	f00c fa6b 	bl	800d504 <puts>
  err = ai_network_create_and_init(&network, act_addr, NULL);
 800102e:	4916      	ldr	r1, [pc, #88]	; (8001088 <MX_X_CUBE_AI_Init+0x64>)
 8001030:	2200      	movs	r2, #0
 8001032:	4620      	mov	r0, r4
 8001034:	f001 ff90 	bl	8002f58 <ai_network_create_and_init>
  if (err.type != AI_ERROR_NONE) {
 8001038:	f010 05ff 	ands.w	r5, r0, #255	; 0xff
 800103c:	d118      	bne.n	8001070 <MX_X_CUBE_AI_Init+0x4c>
  ai_input = ai_network_inputs_get(network, NULL);
 800103e:	6820      	ldr	r0, [r4, #0]
 8001040:	4e12      	ldr	r6, [pc, #72]	; (800108c <MX_X_CUBE_AI_Init+0x68>)
 8001042:	4629      	mov	r1, r5
 8001044:	f001 fe1a 	bl	8002c7c <ai_network_inputs_get>
  ai_output = ai_network_outputs_get(network, NULL);
 8001048:	4629      	mov	r1, r5
  ai_input = ai_network_inputs_get(network, NULL);
 800104a:	4603      	mov	r3, r0
  ai_output = ai_network_outputs_get(network, NULL);
 800104c:	6820      	ldr	r0, [r4, #0]
  ai_input = ai_network_inputs_get(network, NULL);
 800104e:	6033      	str	r3, [r6, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001050:	f001 fe20 	bl	8002c94 <ai_network_outputs_get>
	data_ins[idx] = ai_input[idx].data;
 8001054:	6831      	ldr	r1, [r6, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001056:	4c0e      	ldr	r4, [pc, #56]	; (8001090 <MX_X_CUBE_AI_Init+0x6c>)
	data_ins[idx] = ai_input[idx].data;
 8001058:	4a0e      	ldr	r2, [pc, #56]	; (8001094 <MX_X_CUBE_AI_Init+0x70>)
 800105a:	6849      	ldr	r1, [r1, #4]
	data_outs[idx] = ai_output[idx].data;
 800105c:	4b0e      	ldr	r3, [pc, #56]	; (8001098 <MX_X_CUBE_AI_Init+0x74>)
	data_ins[idx] = ai_input[idx].data;
 800105e:	6011      	str	r1, [r2, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 8001060:	6020      	str	r0, [r4, #0]
	data_outs[idx] = ai_output[idx].data;
 8001062:	6a01      	ldr	r1, [r0, #32]
 8001064:	6844      	ldr	r4, [r0, #4]
 8001066:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8001068:	609a      	str	r2, [r3, #8]
 800106a:	e9c3 4100 	strd	r4, r1, [r3]

  ai_boostrap(data_activations0);
    /* USER CODE END 5 */
}
 800106e:	bd70      	pop	{r4, r5, r6, pc}
    ai_log_err(err, "ai_network_create_and_init");
 8001070:	4603      	mov	r3, r0
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 8001072:	490a      	ldr	r1, [pc, #40]	; (800109c <MX_X_CUBE_AI_Init+0x78>)
 8001074:	480a      	ldr	r0, [pc, #40]	; (80010a0 <MX_X_CUBE_AI_Init+0x7c>)
 8001076:	0a1b      	lsrs	r3, r3, #8
 8001078:	462a      	mov	r2, r5
 800107a:	f00c f9dd 	bl	800d438 <iprintf>
  do {} while (1);
 800107e:	e7fe      	b.n	800107e <MX_X_CUBE_AI_Init+0x5a>
 8001080:	200015c0 	.word	0x200015c0
 8001084:	0800ee90 	.word	0x0800ee90
 8001088:	20000000 	.word	0x20000000
 800108c:	200015a8 	.word	0x200015a8
 8001090:	200015ac 	.word	0x200015ac
 8001094:	200015b0 	.word	0x200015b0
 8001098:	200015b4 	.word	0x200015b4
 800109c:	0800eeb0 	.word	0x0800eeb0
 80010a0:	0800eecc 	.word	0x0800eecc

080010a4 <MX_X_CUBE_AI_Process>:

void MX_X_CUBE_AI_Process(void)
{
 80010a4:	b538      	push	{r3, r4, r5, lr}
    /* USER CODE BEGIN 6 */
  int res = -1;

  printf("TEMPLATE - run - main loop\r\n");

  if (network) {
 80010a6:	4c1b      	ldr	r4, [pc, #108]	; (8001114 <MX_X_CUBE_AI_Process+0x70>)
  printf("TEMPLATE - run - main loop\r\n");
 80010a8:	481b      	ldr	r0, [pc, #108]	; (8001118 <MX_X_CUBE_AI_Process+0x74>)
 80010aa:	f00c fa2b 	bl	800d504 <puts>
  if (network) {
 80010ae:	6823      	ldr	r3, [r4, #0]
 80010b0:	b1eb      	cbz	r3, 80010ee <MX_X_CUBE_AI_Process+0x4a>
  memcpy(data[0], in_data1, AI_NETWORK_IN_1_SIZE * sizeof(ai_float));
 80010b2:	4b1a      	ldr	r3, [pc, #104]	; (800111c <MX_X_CUBE_AI_Process+0x78>)
 80010b4:	4d1a      	ldr	r5, [pc, #104]	; (8001120 <MX_X_CUBE_AI_Process+0x7c>)
 80010b6:	cb07      	ldmia	r3!, {r0, r1, r2}
 80010b8:	682b      	ldr	r3, [r5, #0]
 80010ba:	6018      	str	r0, [r3, #0]
 80010bc:	6059      	str	r1, [r3, #4]
 80010be:	609a      	str	r2, [r3, #8]
  batch = ai_network_run(network, ai_input, ai_output);
 80010c0:	4818      	ldr	r0, [pc, #96]	; (8001124 <MX_X_CUBE_AI_Process+0x80>)
 80010c2:	4b19      	ldr	r3, [pc, #100]	; (8001128 <MX_X_CUBE_AI_Process+0x84>)
 80010c4:	6802      	ldr	r2, [r0, #0]
 80010c6:	6819      	ldr	r1, [r3, #0]
 80010c8:	6820      	ldr	r0, [r4, #0]
 80010ca:	f001 ff9f 	bl	800300c <ai_network_run>
  if (batch != 1) {
 80010ce:	2801      	cmp	r0, #1
 80010d0:	d114      	bne.n	80010fc <MX_X_CUBE_AI_Process+0x58>
  memcpy(out_data1, data[0], AI_NETWORK_OUT_1_SIZE * sizeof(ai_float));
 80010d2:	4b16      	ldr	r3, [pc, #88]	; (800112c <MX_X_CUBE_AI_Process+0x88>)
 80010d4:	4916      	ldr	r1, [pc, #88]	; (8001130 <MX_X_CUBE_AI_Process+0x8c>)
 80010d6:	e9d3 0200 	ldrd	r0, r2, [r3]
 80010da:	6800      	ldr	r0, [r0, #0]
 80010dc:	6008      	str	r0, [r1, #0]
  memcpy(out_data2, data[1], AI_NETWORK_OUT_2_SIZE * sizeof(ai_float));
 80010de:	4915      	ldr	r1, [pc, #84]	; (8001134 <MX_X_CUBE_AI_Process+0x90>)
 80010e0:	6810      	ldr	r0, [r2, #0]
 80010e2:	689a      	ldr	r2, [r3, #8]
 80010e4:	6008      	str	r0, [r1, #0]
  memcpy(out_data3, data[2], AI_NETWORK_OUT_3_SIZE * sizeof(ai_float));
 80010e6:	4b14      	ldr	r3, [pc, #80]	; (8001138 <MX_X_CUBE_AI_Process+0x94>)
 80010e8:	6812      	ldr	r2, [r2, #0]
 80010ea:	601a      	str	r2, [r3, #0]
  if (res) {
    ai_error err = {AI_ERROR_INVALID_STATE, AI_ERROR_CODE_NETWORK};
    ai_log_err(err, "Process has FAILED");
  }
    /* USER CODE END 6 */
}
 80010ec:	bd38      	pop	{r3, r4, r5, pc}
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 80010ee:	4913      	ldr	r1, [pc, #76]	; (800113c <MX_X_CUBE_AI_Process+0x98>)
 80010f0:	4813      	ldr	r0, [pc, #76]	; (8001140 <MX_X_CUBE_AI_Process+0x9c>)
 80010f2:	2310      	movs	r3, #16
 80010f4:	2211      	movs	r2, #17
 80010f6:	f00c f99f 	bl	800d438 <iprintf>
  do {} while (1);
 80010fa:	e7fe      	b.n	80010fa <MX_X_CUBE_AI_Process+0x56>
    ai_log_err(ai_network_get_error(network),
 80010fc:	6820      	ldr	r0, [r4, #0]
 80010fe:	f001 fdbb 	bl	8002c78 <ai_network_get_error>
 8001102:	4602      	mov	r2, r0
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 8001104:	0a13      	lsrs	r3, r2, #8
 8001106:	490f      	ldr	r1, [pc, #60]	; (8001144 <MX_X_CUBE_AI_Process+0xa0>)
 8001108:	480d      	ldr	r0, [pc, #52]	; (8001140 <MX_X_CUBE_AI_Process+0x9c>)
 800110a:	b2d2      	uxtb	r2, r2
 800110c:	f00c f994 	bl	800d438 <iprintf>
  do {} while (1);
 8001110:	e7fe      	b.n	8001110 <MX_X_CUBE_AI_Process+0x6c>
 8001112:	bf00      	nop
 8001114:	200015c0 	.word	0x200015c0
 8001118:	0800ef00 	.word	0x0800ef00
 800111c:	20001a70 	.word	0x20001a70
 8001120:	200015b0 	.word	0x200015b0
 8001124:	200015ac 	.word	0x200015ac
 8001128:	200015a8 	.word	0x200015a8
 800112c:	200015b4 	.word	0x200015b4
 8001130:	20001a7c 	.word	0x20001a7c
 8001134:	20001a80 	.word	0x20001a80
 8001138:	20001a84 	.word	0x20001a84
 800113c:	0800ef2c 	.word	0x0800ef2c
 8001140:	0800eecc 	.word	0x0800eecc
 8001144:	0800ef1c 	.word	0x0800ef1c

08001148 <ASPEP_start>:
  * @brief  Starts ASPEP communication by configuring UART.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_start(ASPEP_Handle_t *pHandle)
{
 8001148:	b570      	push	{r4, r5, r6, lr}
 800114a:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->fASPEP_HWInit(pHandle->HWIp);
 800114c:	6940      	ldr	r0, [r0, #20]
 800114e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001150:	4798      	blx	r3
    pHandle->ASPEP_State = ASPEP_IDLE;
 8001152:	2300      	movs	r3, #0
    pHandle->ASPEP_TL_State = WAITING_PACKET;
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/

    /* Configure UART to receive first packet*/
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 8001154:	6d65      	ldr	r5, [r4, #84]	; 0x54
    pHandle->ASPEP_State = ASPEP_IDLE;
 8001156:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 800115a:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800115e:	6960      	ldr	r0, [r4, #20]
 8001160:	f104 011c 	add.w	r1, r4, #28
 8001164:	462b      	mov	r3, r5
 8001166:	2204      	movs	r2, #4
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001168:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800116c:	4718      	bx	r3
 800116e:	bf00      	nop

08001170 <ASPEP_sendBeacon>:
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  * @param  *capabilities Matched capabilities between controller and performer
  */
void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
{
 8001170:	b410      	push	{r4}
  {
#endif
    uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
    *packet = (BEACON
             | (((uint32_t)capabilities->version) << 4U)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 8001172:	780b      	ldrb	r3, [r1, #0]
             | (((uint32_t)capabilities->version) << 4U)
 8001174:	790a      	ldrb	r2, [r1, #4]
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
             | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 8001176:	f891 c002 	ldrb.w	ip, [r1, #2]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 800117a:	4c1e      	ldr	r4, [pc, #120]	; (80011f4 <ASPEP_sendBeacon+0x84>)
             | (((uint32_t)capabilities->DATA_CRC) << 7U)
 800117c:	01db      	lsls	r3, r3, #7
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 800117e:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
             | (((uint32_t)capabilities->RX_maxSize) << 8U)
 8001182:	784a      	ldrb	r2, [r1, #1]
             | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 8001184:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001188:	78ca      	ldrb	r2, [r1, #3]
 800118a:	ea43 338c 	orr.w	r3, r3, ip, lsl #14
 800118e:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001192:	b2da      	uxtb	r2, r3
 8001194:	f042 0205 	orr.w	r2, r2, #5
  header &= 0x0fffffffU;
 8001198:	f023 4170 	bic.w	r1, r3, #4026531840	; 0xf0000000
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 800119c:	5ca2      	ldrb	r2, [r4, r2]
 800119e:	ea82 2211 	eor.w	r2, r2, r1, lsr #8
 80011a2:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80011a4:	5ca2      	ldrb	r2, [r4, r2]
 80011a6:	ea82 4211 	eor.w	r2, r2, r1, lsr #16
 80011aa:	b2d2      	uxtb	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80011ac:	5ca2      	ldrb	r2, [r4, r2]
 80011ae:	4c12      	ldr	r4, [pc, #72]	; (80011f8 <ASPEP_sendBeacon+0x88>)
 80011b0:	ea82 6211 	eor.w	r2, r2, r1, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 80011b4:	5ca2      	ldrb	r2, [r4, r2]
 80011b6:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80011ba:	f043 0305 	orr.w	r3, r3, #5
 80011be:	6203      	str	r3, [r0, #32]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011c0:	b672      	cpsid	i
  {
#endif
    /* Insert CRC header in the packet to send */
    ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
    __disable_irq(); /*TODO: Disable High frequency task is enough */
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 80011c2:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80011c4:	b14b      	cbz	r3, 80011da <ASPEP_sendBeacon+0x6a>
  __ASM volatile ("cpsie i" : : : "memory");
 80011c6:	b662      	cpsie	i
          pHandle->syncBuffer.length = bufferLength;
        }
      }
      else if(ASPEP_CTRL == dataType)
      {
        if (pHandle->ctrlBuffer.state != available)
 80011c8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80011cc:	b913      	cbnz	r3, 80011d4 <ASPEP_sendBeacon+0x64>
        {
          result = ASPEP_BUFFER_ERROR;
        }
        else
        {
          pHandle->ctrlBuffer.state = pending;
 80011ce:	2302      	movs	r3, #2
 80011d0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 80011d4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80011d8:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 80011da:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 80011de:	2303      	movs	r3, #3
 80011e0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80011e4:	6481      	str	r1, [r0, #72]	; 0x48
 80011e6:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80011e8:	2204      	movs	r2, #4
 80011ea:	6d83      	ldr	r3, [r0, #88]	; 0x58
}
 80011ec:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80011f0:	6940      	ldr	r0, [r0, #20]
 80011f2:	4718      	bx	r3
 80011f4:	0800ef50 	.word	0x0800ef50
 80011f8:	0800ef40 	.word	0x0800ef40

080011fc <ASPEP_sendPing>:
{
 80011fc:	b430      	push	{r4, r5}
                   | (uint32_t)((uint32_t)cBit << 5U)
 80011fe:	014b      	lsls	r3, r1, #5
    uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 8001200:	f890 c060 	ldrb.w	ip, [r0, #96]	; 0x60
    uint8_t ipID = pHandle->liid & 0xFU;
 8001204:	f890 4063 	ldrb.w	r4, [r0, #99]	; 0x63
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001208:	4d1d      	ldr	r5, [pc, #116]	; (8001280 <ASPEP_sendPing+0x84>)
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800120a:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800120e:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
                   | (uint32_t)((uint32_t)Nbit << 6U)
 8001212:	f00c 0101 	and.w	r1, ip, #1
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8001216:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 800121a:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
                   | (uint32_t)((uint32_t)ipID << 8U)
 800121e:	f004 040f 	and.w	r4, r4, #15
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 8001222:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001226:	b2d3      	uxtb	r3, r2
 8001228:	4c16      	ldr	r4, [pc, #88]	; (8001284 <ASPEP_sendPing+0x88>)
 800122a:	f043 0306 	orr.w	r3, r3, #6
                   | (uint32_t)(((uint32_t) packetNumber) << 12U);
 800122e:	f042 0106 	orr.w	r1, r2, #6
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001232:	5ce3      	ldrb	r3, [r4, r3]
 8001234:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 8001238:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 800123a:	5ce3      	ldrb	r3, [r4, r3]
 800123c:	ea83 4312 	eor.w	r3, r3, r2, lsr #16
 8001240:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001242:	5ce3      	ldrb	r3, [r4, r3]
 8001244:	ea83 6312 	eor.w	r3, r3, r2, lsr #24
  *headerPtr |= (uint32_t)crc << 28;
 8001248:	5ceb      	ldrb	r3, [r5, r3]
 800124a:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
 800124e:	6203      	str	r3, [r0, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 8001250:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001252:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8001254:	b143      	cbz	r3, 8001268 <ASPEP_sendPing+0x6c>
  __ASM volatile ("cpsie i" : : : "memory");
 8001256:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8001258:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800125c:	b913      	cbnz	r3, 8001264 <ASPEP_sendPing+0x68>
          pHandle->ctrlBuffer.state = pending;
 800125e:	2302      	movs	r3, #2
 8001260:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 8001264:	bc30      	pop	{r4, r5}
 8001266:	4770      	bx	lr
    (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 8001268:	f100 0120 	add.w	r1, r0, #32
        pHandle->ctrlBuffer.state = readLock;
 800126c:	2303      	movs	r3, #3
 800126e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8001272:	6481      	str	r1, [r0, #72]	; 0x48
 8001274:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 8001276:	2204      	movs	r2, #4
 8001278:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800127a:	6940      	ldr	r0, [r0, #20]
}
 800127c:	bc30      	pop	{r4, r5}
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 800127e:	4718      	bx	r3
 8001280:	0800ef40 	.word	0x0800ef40
 8001284:	0800ef50 	.word	0x0800ef50

08001288 <ASPEP_getBuffer>:
    if (MCTL_SYNC == syncAsync)
 8001288:	2a0a      	cmp	r2, #10
{
 800128a:	b410      	push	{r4}
 800128c:	4603      	mov	r3, r0
    if (MCTL_SYNC == syncAsync)
 800128e:	d00b      	beq.n	80012a8 <ASPEP_getBuffer+0x20>
      if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 8001290:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
 8001294:	2a01      	cmp	r2, #1
 8001296:	d921      	bls.n	80012dc <ASPEP_getBuffer+0x54>
 8001298:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 800129c:	2a01      	cmp	r2, #1
 800129e:	d911      	bls.n	80012c4 <ASPEP_getBuffer+0x3c>
        result = false;
 80012a0:	2000      	movs	r0, #0
}
 80012a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012a6:	4770      	bx	lr
      if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 80012a8:	f890 202e 	ldrb.w	r2, [r0, #46]	; 0x2e
 80012ac:	2a01      	cmp	r2, #1
 80012ae:	d8f7      	bhi.n	80012a0 <ASPEP_getBuffer+0x18>
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80012b0:	6a82      	ldr	r2, [r0, #40]	; 0x28
        pHandle->syncBuffer.state = writeLock;
 80012b2:	2401      	movs	r4, #1
        *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 80012b4:	3204      	adds	r2, #4
 80012b6:	600a      	str	r2, [r1, #0]
        pHandle->syncBuffer.state = writeLock;
 80012b8:	f883 402e 	strb.w	r4, [r3, #46]	; 0x2e
  bool result = true;
 80012bc:	4620      	mov	r0, r4
}
 80012be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012c2:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012c4:	6b82      	ldr	r2, [r0, #56]	; 0x38
          pHandle->asyncBufferB.state = writeLock;
 80012c6:	2001      	movs	r0, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80012c8:	f103 0438 	add.w	r4, r3, #56	; 0x38
          pHandle->asyncBufferB.state = writeLock;
 80012cc:	f883 003e 	strb.w	r0, [r3, #62]	; 0x3e
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012d0:	3204      	adds	r2, #4
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 80012d2:	641c      	str	r4, [r3, #64]	; 0x40
}
 80012d4:	f85d 4b04 	ldr.w	r4, [sp], #4
          *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 80012d8:	600a      	str	r2, [r1, #0]
}
 80012da:	4770      	bx	lr
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012dc:	6b02      	ldr	r2, [r0, #48]	; 0x30
          pHandle->asyncBufferA.state = writeLock;
 80012de:	2001      	movs	r0, #1
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80012e0:	f103 0430 	add.w	r4, r3, #48	; 0x30
          pHandle->asyncBufferA.state = writeLock;
 80012e4:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012e8:	3204      	adds	r2, #4
          pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 80012ea:	641c      	str	r4, [r3, #64]	; 0x40
}
 80012ec:	f85d 4b04 	ldr.w	r4, [sp], #4
          *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 80012f0:	600a      	str	r2, [r1, #0]
}
 80012f2:	4770      	bx	lr

080012f4 <ASPEP_sendPacket>:
{
 80012f4:	4684      	mov	ip, r0
    if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 80012f6:	f890 0064 	ldrb.w	r0, [r0, #100]	; 0x64
 80012fa:	2802      	cmp	r0, #2
 80012fc:	d001      	beq.n	8001302 <ASPEP_sendPacket+0xe>
      result = ASPEP_NOT_CONNECTED;
 80012fe:	2002      	movs	r0, #2
 8001300:	4770      	bx	lr
      tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 8001302:	ea43 1002 	orr.w	r0, r3, r2, lsl #4
      *header = tmpHeader;
 8001306:	f841 0c04 	str.w	r0, [r1, #-4]
      if (1U == pHandle->Capabilities.DATA_CRC)
 800130a:	f89c 006c 	ldrb.w	r0, [ip, #108]	; 0x6c
 800130e:	2801      	cmp	r0, #1
 8001310:	d104      	bne.n	800131c <ASPEP_sendPacket+0x28>
        packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 8001312:	f64f 60ca 	movw	r0, #65226	; 0xfeca
 8001316:	5288      	strh	r0, [r1, r2]
        txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 8001318:	3202      	adds	r2, #2
 800131a:	b292      	uxth	r2, r2
      if (MCTL_SYNC == syncAsync)
 800131c:	2b0a      	cmp	r3, #10
 800131e:	d105      	bne.n	800132c <ASPEP_sendPacket+0x38>
        if (pSupHandle->MCP_PacketAvailable)
 8001320:	f89c 0010 	ldrb.w	r0, [ip, #16]
 8001324:	b378      	cbz	r0, 8001386 <ASPEP_sendPacket+0x92>
          pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 8001326:	2000      	movs	r0, #0
 8001328:	f88c 0010 	strb.w	r0, [ip, #16]
  uint32_t header = *headerPtr;
 800132c:	f851 0c04 	ldr.w	r0, [r1, #-4]
{
 8001330:	b570      	push	{r4, r5, r6, lr}
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001332:	4d35      	ldr	r5, [pc, #212]	; (8001408 <ASPEP_sendPacket+0x114>)
 8001334:	b2c4      	uxtb	r4, r0
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 8001336:	3204      	adds	r2, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001338:	5d2e      	ldrb	r6, [r5, r4]
 800133a:	f3c0 2407 	ubfx	r4, r0, #8, #8
 800133e:	4074      	eors	r4, r6
      header--; /* Header ues 4*8 bits on top of txBuffer*/
 8001340:	f1a1 0e04 	sub.w	lr, r1, #4
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001344:	5d2e      	ldrb	r6, [r5, r4]
 8001346:	f3c0 4407 	ubfx	r4, r0, #16, #8
 800134a:	4074      	eors	r4, r6
        result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPEP_HEADER_SIZE);
 800134c:	b292      	uxth	r2, r2
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 800134e:	5d2c      	ldrb	r4, [r5, r4]
 8001350:	f3c0 6503 	ubfx	r5, r0, #24, #4
 8001354:	406c      	eors	r4, r5
 8001356:	4d2d      	ldr	r5, [pc, #180]	; (800140c <ASPEP_sendPacket+0x118>)
  *headerPtr |= (uint32_t)crc << 28;
 8001358:	5d2c      	ldrb	r4, [r5, r4]
 800135a:	ea40 7004 	orr.w	r0, r0, r4, lsl #28
 800135e:	f841 0c04 	str.w	r0, [r1, #-4]
  __ASM volatile ("cpsid i" : : : "memory");
 8001362:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001364:	f8dc 1048 	ldr.w	r1, [ip, #72]	; 0x48
 8001368:	b1e9      	cbz	r1, 80013a6 <ASPEP_sendPacket+0xb2>
  __ASM volatile ("cpsie i" : : : "memory");
 800136a:	b662      	cpsie	i
      if (MCTL_ASYNC == dataType)
 800136c:	2b09      	cmp	r3, #9
 800136e:	d00c      	beq.n	800138a <ASPEP_sendPacket+0x96>
      else if (MCTL_SYNC == dataType)
 8001370:	2b0a      	cmp	r3, #10
 8001372:	d031      	beq.n	80013d8 <ASPEP_sendPacket+0xe4>
      else if(ASPEP_CTRL == dataType)
 8001374:	2b00      	cmp	r3, #0
 8001376:	d135      	bne.n	80013e4 <ASPEP_sendPacket+0xf0>
        if (pHandle->ctrlBuffer.state != available)
 8001378:	f89c 0024 	ldrb.w	r0, [ip, #36]	; 0x24
 800137c:	bb80      	cbnz	r0, 80013e0 <ASPEP_sendPacket+0xec>
          pHandle->ctrlBuffer.state = pending;
 800137e:	2302      	movs	r3, #2
 8001380:	f88c 3024 	strb.w	r3, [ip, #36]	; 0x24
}
 8001384:	bd70      	pop	{r4, r5, r6, pc}
          result = MCTL_SYNC_NOT_EXPECTED;
 8001386:	2001      	movs	r0, #1
}
 8001388:	4770      	bx	lr
        if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 800138a:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 800138e:	6819      	ldr	r1, [r3, #0]
          result = ASPEP_BUFFER_ERROR;
 8001390:	458e      	cmp	lr, r1
 8001392:	bf14      	ite	ne
 8001394:	2003      	movne	r0, #3
 8001396:	2000      	moveq	r0, #0
        if (NULL == pHandle->asyncNextBuffer)
 8001398:	f8dc 1044 	ldr.w	r1, [ip, #68]	; 0x44
 800139c:	b381      	cbz	r1, 8001400 <ASPEP_sendPacket+0x10c>
        pHandle->lastRequestedAsyncBuff->state = pending;
 800139e:	2102      	movs	r1, #2
 80013a0:	7199      	strb	r1, [r3, #6]
        pHandle->lastRequestedAsyncBuff->length = bufferLength;
 80013a2:	809a      	strh	r2, [r3, #4]
}
 80013a4:	bd70      	pop	{r4, r5, r6, pc}
      if (MCTL_ASYNC == dataType)
 80013a6:	2b09      	cmp	r3, #9
 80013a8:	d025      	beq.n	80013f6 <ASPEP_sendPacket+0x102>
      else if (MCTL_SYNC == dataType)
 80013aa:	2b0a      	cmp	r3, #10
        pHandle->syncBuffer.state = readLock;
 80013ac:	f04f 0303 	mov.w	r3, #3
 80013b0:	bf0b      	itete	eq
 80013b2:	f88c 302e 	strbeq.w	r3, [ip, #46]	; 0x2e
        pHandle->ctrlBuffer.state = readLock;
 80013b6:	f88c 3024 	strbne.w	r3, [ip, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 80013ba:	f10c 0328 	addeq.w	r3, ip, #40	; 0x28
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 80013be:	f10c 0320 	addne.w	r3, ip, #32
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80013c2:	f8cc 3048 	str.w	r3, [ip, #72]	; 0x48
 80013c6:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 80013c8:	f8dc 3058 	ldr.w	r3, [ip, #88]	; 0x58
 80013cc:	f8dc 0014 	ldr.w	r0, [ip, #20]
 80013d0:	4671      	mov	r1, lr
 80013d2:	4798      	blx	r3
 80013d4:	2000      	movs	r0, #0
}
 80013d6:	bd70      	pop	{r4, r5, r6, pc}
        if (pHandle -> syncBuffer.state != writeLock)
 80013d8:	f89c 302e 	ldrb.w	r3, [ip, #46]	; 0x2e
 80013dc:	2b01      	cmp	r3, #1
 80013de:	d003      	beq.n	80013e8 <ASPEP_sendPacket+0xf4>
          result = ASPEP_BUFFER_ERROR;
 80013e0:	2003      	movs	r0, #3
}
 80013e2:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t result = ASPEP_OK;
 80013e4:	2000      	movs	r0, #0
}
 80013e6:	bd70      	pop	{r4, r5, r6, pc}
          pHandle->syncBuffer.state = pending;
 80013e8:	2302      	movs	r3, #2
 80013ea:	f88c 302e 	strb.w	r3, [ip, #46]	; 0x2e
          pHandle->syncBuffer.length = bufferLength;
 80013ee:	f8ac 202c 	strh.w	r2, [ip, #44]	; 0x2c
  uint8_t result = ASPEP_OK;
 80013f2:	2000      	movs	r0, #0
}
 80013f4:	bd70      	pop	{r4, r5, r6, pc}
        pHandle->lastRequestedAsyncBuff->state = readLock;
 80013f6:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 80013fa:	2103      	movs	r1, #3
 80013fc:	7199      	strb	r1, [r3, #6]
        pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 80013fe:	e7e0      	b.n	80013c2 <ASPEP_sendPacket+0xce>
          pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 8001400:	f8cc 3044 	str.w	r3, [ip, #68]	; 0x44
 8001404:	e7cb      	b.n	800139e <ASPEP_sendPacket+0xaa>
 8001406:	bf00      	nop
 8001408:	0800ef50 	.word	0x0800ef50
 800140c:	0800ef40 	.word	0x0800ef40

08001410 <ASPEP_HWDataTransmittedIT>:
  * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
{
 8001410:	b510      	push	{r4, lr}
  }
  else
  {
#endif
    /* First free previous readLock buffer */
    if (pHandle->ctrlBuffer.state == readLock)
 8001412:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001416:	2b03      	cmp	r3, #3
{
 8001418:	4604      	mov	r4, r0
    if (pHandle->ctrlBuffer.state == readLock)
 800141a:	d013      	beq.n	8001444 <ASPEP_HWDataTransmittedIT+0x34>
      pHandle->ctrlBuffer.state = available;
    }
    else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
    {
      MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
      tempBuff->state = available;
 800141c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800141e:	2100      	movs	r1, #0
 8001420:	7191      	strb	r1, [r2, #6]
    }
    if (pHandle->syncBuffer.state == pending)
 8001422:	f890 202e 	ldrb.w	r2, [r0, #46]	; 0x2e
 8001426:	2a02      	cmp	r2, #2
 8001428:	d013      	beq.n	8001452 <ASPEP_HWDataTransmittedIT+0x42>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
      pHandle->syncBuffer.state = readLock;
    }
    /* Second prepare transfer of pending buffer */
    else if (pHandle->ctrlBuffer.state == pending)
 800142a:	2b02      	cmp	r3, #2
 800142c:	d11d      	bne.n	800146a <ASPEP_HWDataTransmittedIT+0x5a>
    {
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 800142e:	f100 0120 	add.w	r1, r0, #32
      pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8001432:	6d83      	ldr	r3, [r0, #88]	; 0x58
      pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 8001434:	6481      	str	r1, [r0, #72]	; 0x48
      pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 8001436:	2204      	movs	r2, #4
 8001438:	6940      	ldr	r0, [r0, #20]
 800143a:	4798      	blx	r3
      pHandle->ctrlBuffer.state = readLock;
 800143c:	2303      	movs	r3, #3
 800143e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      __enable_irq();
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001442:	bd10      	pop	{r4, pc}
    if (pHandle->syncBuffer.state == pending)
 8001444:	f890 302e 	ldrb.w	r3, [r0, #46]	; 0x2e
      pHandle->ctrlBuffer.state = available;
 8001448:	2200      	movs	r2, #0
    if (pHandle->syncBuffer.state == pending)
 800144a:	2b02      	cmp	r3, #2
      pHandle->ctrlBuffer.state = available;
 800144c:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    if (pHandle->syncBuffer.state == pending)
 8001450:	d10b      	bne.n	800146a <ASPEP_HWDataTransmittedIT+0x5a>
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8001452:	f104 0028 	add.w	r0, r4, #40	; 0x28
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 8001456:	6da3      	ldr	r3, [r4, #88]	; 0x58
      pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 8001458:	64a0      	str	r0, [r4, #72]	; 0x48
      pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 800145a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800145c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800145e:	6960      	ldr	r0, [r4, #20]
 8001460:	4798      	blx	r3
      pHandle->syncBuffer.state = readLock;
 8001462:	2303      	movs	r3, #3
 8001464:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
}
 8001468:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 800146a:	b672      	cpsid	i
      if (pHandle->asyncNextBuffer != NULL)
 800146c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800146e:	b1cb      	cbz	r3, 80014a4 <ASPEP_HWDataTransmittedIT+0x94>
        pHandle->asyncNextBuffer->state = readLock;
 8001470:	2203      	movs	r2, #3
        pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 8001472:	64a3      	str	r3, [r4, #72]	; 0x48
        pHandle->asyncNextBuffer->state = readLock;
 8001474:	719a      	strb	r2, [r3, #6]
        pHandle->fASPEP_send(pHandle ->HWIp, pHandle->asyncNextBuffer->buffer, pHandle->asyncNextBuffer->length);
 8001476:	6819      	ldr	r1, [r3, #0]
 8001478:	889a      	ldrh	r2, [r3, #4]
 800147a:	6960      	ldr	r0, [r4, #20]
 800147c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800147e:	4798      	blx	r3
        if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 8001480:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 8001484:	2b02      	cmp	r3, #2
 8001486:	d007      	beq.n	8001498 <ASPEP_HWDataTransmittedIT+0x88>
 8001488:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 800148c:	2b02      	cmp	r3, #2
 800148e:	d003      	beq.n	8001498 <ASPEP_HWDataTransmittedIT+0x88>
          pHandle->asyncNextBuffer = NULL;
 8001490:	2300      	movs	r3, #0
 8001492:	6463      	str	r3, [r4, #68]	; 0x44
  __ASM volatile ("cpsie i" : : : "memory");
 8001494:	b662      	cpsie	i
}
 8001496:	bd10      	pop	{r4, pc}
          uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 8001498:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800149a:	0063      	lsls	r3, r4, #1
 800149c:	3368      	adds	r3, #104	; 0x68
 800149e:	1a9b      	subs	r3, r3, r2
          pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 80014a0:	6463      	str	r3, [r4, #68]	; 0x44
        {
 80014a2:	e7f7      	b.n	8001494 <ASPEP_HWDataTransmittedIT+0x84>
        pHandle->lockBuffer = NULL;
 80014a4:	64a3      	str	r3, [r4, #72]	; 0x48
 80014a6:	e7f5      	b.n	8001494 <ASPEP_HWDataTransmittedIT+0x84>

080014a8 <ASPEP_RXframeProcess>:
    uint16_t packetNumber;
#if VALID_CRC_DATA
    bool validCRCData = true;
#endif
    *packetLength = 0;
    if (pHandle->NewPacketAvailable)
 80014a8:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 80014ac:	69c2      	ldr	r2, [r0, #28]
{
 80014ae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    *packetLength = 0;
 80014b2:	2500      	movs	r5, #0
{
 80014b4:	4604      	mov	r4, r0
    *packetLength = 0;
 80014b6:	800d      	strh	r5, [r1, #0]
    if (pHandle->NewPacketAvailable)
 80014b8:	b193      	cbz	r3, 80014e0 <ASPEP_RXframeProcess+0x38>
    {
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
      switch (pHandle->ASPEP_State)
 80014ba:	f890 6064 	ldrb.w	r6, [r0, #100]	; 0x64
      pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 80014be:	f880 5061 	strb.w	r5, [r0, #97]	; 0x61
      switch (pHandle->ASPEP_State)
 80014c2:	2e01      	cmp	r6, #1
 80014c4:	d054      	beq.n	8001570 <ASPEP_RXframeProcess+0xc8>
 80014c6:	2e02      	cmp	r6, #2
 80014c8:	d03e      	beq.n	8001548 <ASPEP_RXframeProcess+0xa0>
 80014ca:	2e00      	cmp	r6, #0
 80014cc:	d033      	beq.n	8001536 <ASPEP_RXframeProcess+0x8e>

        default:
          break;
      }
      /* The valid received packet is now safely consumes, we are ready to receive a new packet */
      pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 80014ce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80014d0:	6960      	ldr	r0, [r4, #20]
 80014d2:	2204      	movs	r2, #4
 80014d4:	f104 011c 	add.w	r1, r4, #28
 80014d8:	4798      	blx	r3
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
  return (result);
}
 80014da:	4628      	mov	r0, r5
 80014dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if (pHandle->badPacketFlag > ASPEP_OK)
 80014e0:	f890 5062 	ldrb.w	r5, [r0, #98]	; 0x62
 80014e4:	2d00      	cmp	r5, #0
 80014e6:	d0f8      	beq.n	80014da <ASPEP_RXframeProcess+0x32>
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 80014e8:	042b      	lsls	r3, r5, #16
 80014ea:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80014ee:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80014f2:	489b      	ldr	r0, [pc, #620]	; (8001760 <ASPEP_RXframeProcess+0x2b8>)
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 80014f4:	4d9b      	ldr	r5, [pc, #620]	; (8001764 <ASPEP_RXframeProcess+0x2bc>)
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 80014f6:	f082 0209 	eor.w	r2, r2, #9
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 80014fa:	5c81      	ldrb	r1, [r0, r2]
  *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 16U);
 80014fc:	f043 020f 	orr.w	r2, r3, #15
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001500:	ea81 4313 	eor.w	r3, r1, r3, lsr #16
  crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 8001504:	5cc3      	ldrb	r3, [r0, r3]
  *headerPtr |= (uint32_t)crc << 28;
 8001506:	5ceb      	ldrb	r3, [r5, r3]
 8001508:	ea42 7303 	orr.w	r3, r2, r3, lsl #28
 800150c:	6223      	str	r3, [r4, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800150e:	b672      	cpsid	i
    if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 8001510:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001512:	2b00      	cmp	r3, #0
 8001514:	d03a      	beq.n	800158c <ASPEP_RXframeProcess+0xe4>
  __ASM volatile ("cpsie i" : : : "memory");
 8001516:	b662      	cpsie	i
        if (pHandle->ctrlBuffer.state != available)
 8001518:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800151c:	b913      	cbnz	r3, 8001524 <ASPEP_RXframeProcess+0x7c>
          pHandle->ctrlBuffer.state = pending;
 800151e:	2302      	movs	r3, #2
 8001520:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      pHandle->badPacketFlag = ASPEP_OK;
 8001524:	2500      	movs	r5, #0
      pHandle->fASPEP_HWSync(pHandle->HWIp);
 8001526:	6960      	ldr	r0, [r4, #20]
 8001528:	6d23      	ldr	r3, [r4, #80]	; 0x50
      pHandle->badPacketFlag = ASPEP_OK;
 800152a:	f884 5062 	strb.w	r5, [r4, #98]	; 0x62
      pHandle->fASPEP_HWSync(pHandle->HWIp);
 800152e:	4798      	blx	r3
}
 8001530:	4628      	mov	r0, r5
 8001532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          if (BEACON == pHandle->rxPacketType)
 8001536:	6e81      	ldr	r1, [r0, #104]	; 0x68
 8001538:	2905      	cmp	r1, #5
 800153a:	f000 809e 	beq.w	800167a <ASPEP_RXframeProcess+0x1d2>
          else if (PING == pHandle->rxPacketType)
 800153e:	2906      	cmp	r1, #6
 8001540:	f000 80e3 	beq.w	800170a <ASPEP_RXframeProcess+0x262>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001544:	4635      	mov	r5, r6
 8001546:	e7c2      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
          if (BEACON == pHandle->rxPacketType)
 8001548:	6e86      	ldr	r6, [r0, #104]	; 0x68
 800154a:	2e05      	cmp	r6, #5
 800154c:	d060      	beq.n	8001610 <ASPEP_RXframeProcess+0x168>
          else if (PING == pHandle->rxPacketType)
 800154e:	2e06      	cmp	r6, #6
 8001550:	f000 80e2 	beq.w	8001718 <ASPEP_RXframeProcess+0x270>
          else if (DATA_PACKET == pHandle->rxPacketType)
 8001554:	2e09      	cmp	r6, #9
 8001556:	d1ba      	bne.n	80014ce <ASPEP_RXframeProcess+0x26>
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001558:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
              *packetLength = pHandle->rxLength;
 800155c:	f8b0 205c 	ldrh.w	r2, [r0, #92]	; 0x5c
              result = pHandle->rxBuffer;
 8001560:	69a5      	ldr	r5, [r4, #24]
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001562:	3301      	adds	r3, #1
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 8001564:	2001      	movs	r0, #1
              pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet received from controller */
 8001566:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
              pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 800156a:	7420      	strb	r0, [r4, #16]
              *packetLength = pHandle->rxLength;
 800156c:	800a      	strh	r2, [r1, #0]
              result = pHandle->rxBuffer;
 800156e:	e7ae      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
          if (BEACON == pHandle->rxPacketType)
 8001570:	6e81      	ldr	r1, [r0, #104]	; 0x68
 8001572:	2905      	cmp	r1, #5
 8001574:	d016      	beq.n	80015a4 <ASPEP_RXframeProcess+0xfc>
          else if (PING == pHandle->rxPacketType)
 8001576:	2906      	cmp	r1, #6
 8001578:	d1a9      	bne.n	80014ce <ASPEP_RXframeProcess+0x26>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 800157a:	f3c2 320f 	ubfx	r2, r2, #12, #16
 800157e:	4631      	mov	r1, r6
 8001580:	f7ff fe3c 	bl	80011fc <ASPEP_sendPing>
            pHandle->ASPEP_State = ASPEP_CONNECTED;
 8001584:	2302      	movs	r3, #2
 8001586:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800158a:	e7a0      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 800158c:	f104 0120 	add.w	r1, r4, #32
        pHandle->ctrlBuffer.state = readLock;
 8001590:	2303      	movs	r3, #3
 8001592:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 8001596:	64a1      	str	r1, [r4, #72]	; 0x48
 8001598:	b662      	cpsie	i
      pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 800159a:	2204      	movs	r2, #4
 800159c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800159e:	6960      	ldr	r0, [r4, #20]
 80015a0:	4798      	blx	r3
  return (result);
 80015a2:	e7bf      	b.n	8001524 <ASPEP_RXframeProcess+0x7c>
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80015a4:	7f03      	ldrb	r3, [r0, #28]
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80015a6:	7f40      	ldrb	r0, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80015a8:	f894 106d 	ldrb.w	r1, [r4, #109]	; 0x6d
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015ac:	f894 606c 	ldrb.w	r6, [r4, #108]	; 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015b0:	f894 706e 	ldrb.w	r7, [r4, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015b4:	f894 e06f 	ldrb.w	lr, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 80015b8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 80015bc:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 80015be:	4281      	cmp	r1, r0
 80015c0:	bf28      	it	cs
 80015c2:	4601      	movcs	r1, r0
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015c4:	42b3      	cmp	r3, r6
 80015c6:	469c      	mov	ip, r3
 80015c8:	bf28      	it	cs
 80015ca:	46b4      	movcs	ip, r6
 80015cc:	f36c 0507 	bfi	r5, ip, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 80015d0:	f3c2 3c86 	ubfx	ip, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80015d4:	f3c2 5846 	ubfx	r8, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015d8:	45bc      	cmp	ip, r7
 80015da:	46e1      	mov	r9, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015dc:	f361 250f 	bfi	r5, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80015e0:	bf28      	it	cs
 80015e2:	46b9      	movcs	r9, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015e4:	45f0      	cmp	r8, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015e6:	f369 4517 	bfi	r5, r9, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80015ea:	46c1      	mov	r9, r8
 80015ec:	bf28      	it	cs
 80015ee:	46f1      	movcs	r9, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015f0:	f369 651f 	bfi	r5, r9, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80015f4:	42b3      	cmp	r3, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80015f6:	66e5      	str	r5, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80015f8:	f240 8093 	bls.w	8001722 <ASPEP_RXframeProcess+0x27a>
              pHandle->ASPEP_State = ASPEP_IDLE;
 80015fc:	2300      	movs	r3, #0
 80015fe:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8001602:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 8001606:	4620      	mov	r0, r4
 8001608:	f7ff fdb2 	bl	8001170 <ASPEP_sendBeacon>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 800160c:	2500      	movs	r5, #0
 800160e:	e75e      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8001610:	7f46      	ldrb	r6, [r0, #29]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001612:	f890 c06c 	ldrb.w	ip, [r0, #108]	; 0x6c
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001616:	7f03      	ldrb	r3, [r0, #28]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8001618:	f890 006d 	ldrb.w	r0, [r0, #109]	; 0x6d
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 800161c:	f894 e06e 	ldrb.w	lr, [r4, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001620:	f894 806f 	ldrb.w	r8, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 8001624:	f006 063f 	and.w	r6, r6, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001628:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 800162a:	42b0      	cmp	r0, r6
 800162c:	bf28      	it	cs
 800162e:	4630      	movcs	r0, r6
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001630:	4563      	cmp	r3, ip
 8001632:	461f      	mov	r7, r3
 8001634:	4629      	mov	r1, r5
 8001636:	bf28      	it	cs
 8001638:	4667      	movcs	r7, ip
 800163a:	f367 0107 	bfi	r1, r7, #0, #8
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 800163e:	f3c2 3786 	ubfx	r7, r2, #14, #7
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 8001642:	f3c2 5946 	ubfx	r9, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8001646:	4577      	cmp	r7, lr
 8001648:	46ba      	mov	sl, r7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800164a:	f360 210f 	bfi	r1, r0, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 800164e:	bf28      	it	cs
 8001650:	46f2      	movcs	sl, lr
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001652:	45c1      	cmp	r9, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001654:	f36a 4117 	bfi	r1, sl, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 8001658:	46ca      	mov	sl, r9
 800165a:	bf28      	it	cs
 800165c:	46c2      	movcs	sl, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800165e:	f36a 611f 	bfi	r1, sl, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8001662:	4563      	cmp	r3, ip
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001664:	66e1      	str	r1, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 8001666:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 800166a:	d96b      	bls.n	8001744 <ASPEP_RXframeProcess+0x29c>
 800166c:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64
            ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 8001670:	4620      	mov	r0, r4
 8001672:	f7ff fd7d 	bl	8001170 <ASPEP_sendBeacon>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001676:	2500      	movs	r5, #0
 8001678:	e729      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800167a:	7f45      	ldrb	r5, [r0, #29]
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 800167c:	f890 106d 	ldrb.w	r1, [r0, #109]	; 0x6d
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001680:	7f03      	ldrb	r3, [r0, #28]
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 8001682:	f890 e06c 	ldrb.w	lr, [r0, #108]	; 0x6c
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 8001686:	f890 706e 	ldrb.w	r7, [r0, #110]	; 0x6e
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 800168a:	f894 906f 	ldrb.w	r9, [r4, #111]	; 0x6f
  MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 800168e:	f005 053f 	and.w	r5, r5, #63	; 0x3f
  MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 8001692:	09db      	lsrs	r3, r3, #7
  pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_maxSize);
 8001694:	42a9      	cmp	r1, r5
 8001696:	bf28      	it	cs
 8001698:	4629      	movcs	r1, r5
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 800169a:	4573      	cmp	r3, lr
 800169c:	4618      	mov	r0, r3
  MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 800169e:	f3c2 3886 	ubfx	r8, r2, #14, #7
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016a2:	bf28      	it	cs
 80016a4:	4670      	movcs	r0, lr
 80016a6:	f360 0607 	bfi	r6, r0, #0, #8
  MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 80016aa:	f3c2 5a46 	ubfx	sl, r2, #21, #7
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80016ae:	45b8      	cmp	r8, r7
 80016b0:	4640      	mov	r0, r8
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016b2:	f361 260f 	bfi	r6, r1, #8, #8
  pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS_maxSize);
 80016b6:	bf28      	it	cs
 80016b8:	4638      	movcs	r0, r7
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80016ba:	45ca      	cmp	sl, r9
 80016bc:	46d4      	mov	ip, sl
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016be:	f360 4617 	bfi	r6, r0, #16, #8
  pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA_maxSize);
 80016c2:	bf28      	it	cs
 80016c4:	46cc      	movcs	ip, r9
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016c6:	f36c 661f 	bfi	r6, ip, #24, #8
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80016ca:	4573      	cmp	r3, lr
  pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC);
 80016cc:	66e6      	str	r6, [r4, #108]	; 0x6c
  if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 80016ce:	d898      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 80016d0:	428d      	cmp	r5, r1
 80016d2:	d896      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 80016d4:	45b8      	cmp	r8, r7
 80016d6:	d894      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 80016d8:	45ca      	cmp	sl, r9
 80016da:	d892      	bhi.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 80016dc:	f3c2 1302 	ubfx	r3, r2, #4, #3
 80016e0:	f894 2070 	ldrb.w	r2, [r4, #112]	; 0x70
 80016e4:	429a      	cmp	r2, r3
 80016e6:	d18c      	bne.n	8001602 <ASPEP_RXframeProcess+0x15a>
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016e8:	1c4b      	adds	r3, r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016ea:	1c42      	adds	r2, r0, #1
 80016ec:	b2d2      	uxtb	r2, r2
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016ee:	b2db      	uxtb	r3, r3
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016f0:	0152      	lsls	r2, r2, #5
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 80016f2:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016f6:	015b      	lsls	r3, r3, #5
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 80016f8:	2101      	movs	r1, #1
              pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (uint16_t)32U;
 80016fa:	81a2      	strh	r2, [r4, #12]
              pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 80016fc:	f8a4 c00e 	strh.w	ip, [r4, #14]
              pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t)32U;
 8001700:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
              pHandle->ASPEP_State = ASPEP_CONFIGURED;
 8001704:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
 8001708:	e77b      	b.n	8001602 <ASPEP_RXframeProcess+0x15a>
            ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 800170a:	f3c2 320f 	ubfx	r2, r2, #12, #16
 800170e:	4631      	mov	r1, r6
 8001710:	f7ff fd74 	bl	80011fc <ASPEP_sendPing>
  uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 8001714:	4635      	mov	r5, r6
 8001716:	e6da      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
            ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 8001718:	7f42      	ldrb	r2, [r0, #29]
 800171a:	2101      	movs	r1, #1
 800171c:	f7ff fd6e 	bl	80011fc <ASPEP_sendPing>
 8001720:	e6d5      	b.n	80014ce <ASPEP_RXframeProcess+0x26>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8001722:	4288      	cmp	r0, r1
 8001724:	f63f af6a 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8001728:	45bc      	cmp	ip, r7
 800172a:	f63f af67 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 800172e:	45f0      	cmp	r8, lr
 8001730:	f63f af64 	bhi.w	80015fc <ASPEP_RXframeProcess+0x154>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8001734:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
 8001738:	f3c2 1302 	ubfx	r3, r2, #4, #3
 800173c:	4299      	cmp	r1, r3
 800173e:	f47f af5d 	bne.w	80015fc <ASPEP_RXframeProcess+0x154>
 8001742:	e75e      	b.n	8001602 <ASPEP_RXframeProcess+0x15a>
   || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 8001744:	4286      	cmp	r6, r0
 8001746:	d891      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 8001748:	4577      	cmp	r7, lr
 800174a:	d88f      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 800174c:	45c1      	cmp	r9, r8
 800174e:	d88d      	bhi.n	800166c <ASPEP_RXframeProcess+0x1c4>
   || (MasterCapabilities.version != pHandle->Capabilities.version) )
 8001750:	f894 5070 	ldrb.w	r5, [r4, #112]	; 0x70
 8001754:	f3c2 1302 	ubfx	r3, r2, #4, #3
              pHandle->ASPEP_State = ASPEP_IDLE;
 8001758:	1aeb      	subs	r3, r5, r3
 800175a:	425d      	negs	r5, r3
 800175c:	415d      	adcs	r5, r3
 800175e:	e785      	b.n	800166c <ASPEP_RXframeProcess+0x1c4>
 8001760:	0800ef50 	.word	0x0800ef50
 8001764:	0800ef40 	.word	0x0800ef40

08001768 <ASPEP_HWDataReceivedIT>:
  * If the packet received contains an error in the header, the HW IP will be re-synchronised first, and DMA will be configured after.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDataReceivedIT(ASPEP_Handle_t *pHandle)
{
 8001768:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    switch (pHandle->ASPEP_TL_State)
 800176a:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
{
 800176e:	4604      	mov	r4, r0
    switch (pHandle->ASPEP_TL_State)
 8001770:	b13b      	cbz	r3, 8001782 <ASPEP_HWDataReceivedIT+0x1a>
 8001772:	2b01      	cmp	r3, #1
 8001774:	d104      	bne.n	8001780 <ASPEP_HWDataReceivedIT+0x18>
        break;
      }

      case WAITING_PAYLOAD:
      {
        pHandle->ASPEP_TL_State = WAITING_PACKET;
 8001776:	2200      	movs	r2, #0
 8001778:	f880 2065 	strb.w	r2, [r0, #101]	; 0x65
        /* Payload received, */
        pHandle->NewPacketAvailable = true;
 800177c:	f880 3061 	strb.w	r3, [r0, #97]	; 0x61
        break;
    }
#ifdef NULL_PTR_CHECK_ASP
  }
#endif
}
 8001780:	bd10      	pop	{r4, pc}
        if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-11.3
 8001782:	69c1      	ldr	r1, [r0, #28]
  crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 8001784:	4a1e      	ldr	r2, [pc, #120]	; (8001800 <ASPEP_HWDataReceivedIT+0x98>)
 8001786:	b2cb      	uxtb	r3, r1
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 8001788:	5cd3      	ldrb	r3, [r2, r3]
 800178a:	ea83 2311 	eor.w	r3, r3, r1, lsr #8
 800178e:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 8001790:	5cd3      	ldrb	r3, [r2, r3]
 8001792:	ea83 4311 	eor.w	r3, r3, r1, lsr #16
 8001796:	b2db      	uxtb	r3, r3
  crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 8001798:	5cd3      	ldrb	r3, [r2, r3]
 800179a:	ea83 6311 	eor.w	r3, r3, r1, lsr #24
        if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-11.3
 800179e:	5cd3      	ldrb	r3, [r2, r3]
 80017a0:	b95b      	cbnz	r3, 80017ba <ASPEP_HWDataReceivedIT+0x52>
          pHandle->rxPacketType = (ASPEP_packetType)(((uint32_t)pHandle->rxHeader[0]) & ID_MASK);
 80017a2:	7f03      	ldrb	r3, [r0, #28]
 80017a4:	f003 030f 	and.w	r3, r3, #15
 80017a8:	2b06      	cmp	r3, #6
 80017aa:	6683      	str	r3, [r0, #104]	; 0x68
          switch (pHandle->rxPacketType)
 80017ac:	d809      	bhi.n	80017c2 <ASPEP_HWDataReceivedIT+0x5a>
 80017ae:	2b04      	cmp	r3, #4
 80017b0:	d81e      	bhi.n	80017f0 <ASPEP_HWDataReceivedIT+0x88>
              pHandle->badPacketFlag = ASPEP_BAD_PACKET_TYPE;
 80017b2:	2301      	movs	r3, #1
 80017b4:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
}
 80017b8:	bd10      	pop	{r4, pc}
          pHandle->badPacketFlag = ASPEP_BAD_CRC_HEADER;
 80017ba:	2304      	movs	r3, #4
 80017bc:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
}
 80017c0:	bd10      	pop	{r4, pc}
 80017c2:	2b09      	cmp	r3, #9
 80017c4:	d1f5      	bne.n	80017b2 <ASPEP_HWDataReceivedIT+0x4a>
              pHandle->rxLength = (uint16_t)((*((uint16_t *)pHandle->rxHeader) & 0x1FFF0U) >> (uint16_t)4);
 80017c6:	8b83      	ldrh	r3, [r0, #28]
 80017c8:	091b      	lsrs	r3, r3, #4
 80017ca:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
              if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 80017ce:	b17b      	cbz	r3, 80017f0 <ASPEP_HWDataReceivedIT+0x88>
              else if (pHandle->rxLength <= pHandle->maxRXPayload)
 80017d0:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 80017d4:	429a      	cmp	r2, r3
 80017d6:	d30f      	bcc.n	80017f8 <ASPEP_HWDataReceivedIT+0x90>
                pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxBuffer,  /* need to read + 2 bytes CRC*/
 80017d8:	f890 206c 	ldrb.w	r2, [r0, #108]	; 0x6c
 80017dc:	6981      	ldr	r1, [r0, #24]
 80017de:	6940      	ldr	r0, [r0, #20]
 80017e0:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 80017e4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80017e6:	4798      	blx	r3
                pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 80017e8:	2301      	movs	r3, #1
 80017ea:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
}
 80017ee:	bd10      	pop	{r4, pc}
              pHandle->NewPacketAvailable = true;
 80017f0:	2301      	movs	r3, #1
 80017f2:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
}
 80017f6:	bd10      	pop	{r4, pc}
                pHandle->badPacketFlag = ASPEP_BAD_PACKET_SIZE;
 80017f8:	2302      	movs	r3, #2
 80017fa:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
}
 80017fe:	bd10      	pop	{r4, pc}
 8001800:	0800ef50 	.word	0x0800ef50

08001804 <ASPEP_HWDMAReset>:
  * @brief  Resets DMA after debugger has stopped the MCU.
  *
  * @param  *pHandle Handler of the current instance of the ASPEP component
  */
void ASPEP_HWDMAReset(ASPEP_Handle_t *pHandle)
{
 8001804:	4601      	mov	r1, r0
  {
#endif
    /* We must reset the RX state machine to be sure to not be in Waiting packet state */
    /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
    /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
    pHandle->ASPEP_TL_State = WAITING_PACKET;
 8001806:	2200      	movs	r2, #0
 8001808:	f880 2065 	strb.w	r2, [r0, #101]	; 0x65
    pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 800180c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800180e:	6940      	ldr	r0, [r0, #20]
 8001810:	2204      	movs	r2, #4
 8001812:	311c      	adds	r1, #28
 8001814:	4718      	bx	r3
 8001816:	bf00      	nop

08001818 <MX_CORDIC_Init>:
  /* USER CODE END CORDIC_Init 0 */

  /* USER CODE BEGIN CORDIC_Init 1 */

  /* USER CODE END CORDIC_Init 1 */
  hcordic.Instance = CORDIC;
 8001818:	4805      	ldr	r0, [pc, #20]	; (8001830 <MX_CORDIC_Init+0x18>)
{
 800181a:	b508      	push	{r3, lr}
  hcordic.Instance = CORDIC;
 800181c:	4b05      	ldr	r3, [pc, #20]	; (8001834 <MX_CORDIC_Init+0x1c>)
 800181e:	6003      	str	r3, [r0, #0]
  if (HAL_CORDIC_Init(&hcordic) != HAL_OK)
 8001820:	f004 fd74 	bl	800630c <HAL_CORDIC_Init>
 8001824:	b900      	cbnz	r0, 8001828 <MX_CORDIC_Init+0x10>
  }
  /* USER CODE BEGIN CORDIC_Init 2 */

  /* USER CODE END CORDIC_Init 2 */

}
 8001826:	bd08      	pop	{r3, pc}
 8001828:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 800182c:	f000 b9e0 	b.w	8001bf0 <Error_Handler>
 8001830:	200019f8 	.word	0x200019f8
 8001834:	40020c00 	.word	0x40020c00

08001838 <HAL_CORDIC_MspInit>:

void HAL_CORDIC_MspInit(CORDIC_HandleTypeDef* cordicHandle)
{

  if(cordicHandle->Instance==CORDIC)
 8001838:	4b0a      	ldr	r3, [pc, #40]	; (8001864 <HAL_CORDIC_MspInit+0x2c>)
 800183a:	6802      	ldr	r2, [r0, #0]
 800183c:	429a      	cmp	r2, r3
 800183e:	d000      	beq.n	8001842 <HAL_CORDIC_MspInit+0xa>
 8001840:	4770      	bx	lr
  {
  /* USER CODE BEGIN CORDIC_MspInit 0 */

  /* USER CODE END CORDIC_MspInit 0 */
    /* CORDIC clock enable */
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8001842:	f8d3 2448 	ldr.w	r2, [r3, #1096]	; 0x448
 8001846:	f042 0208 	orr.w	r2, r2, #8
 800184a:	f8c3 2448 	str.w	r2, [r3, #1096]	; 0x448
 800184e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
{
 8001852:	b082      	sub	sp, #8
    __HAL_RCC_CORDIC_CLK_ENABLE();
 8001854:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001856:	f003 0308 	and.w	r3, r3, #8
 800185a:	9301      	str	r3, [sp, #4]
 800185c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CORDIC_MspInit 1 */

  /* USER CODE END CORDIC_MspInit 1 */
  }
}
 800185e:	b002      	add	sp, #8
 8001860:	4770      	bx	lr
 8001862:	bf00      	nop
 8001864:	40020c00 	.word	0x40020c00

08001868 <MX_CRC_Init>:
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 8001868:	4808      	ldr	r0, [pc, #32]	; (800188c <MX_CRC_Init+0x24>)
 800186a:	4909      	ldr	r1, [pc, #36]	; (8001890 <MX_CRC_Init+0x28>)
{
 800186c:	b508      	push	{r3, lr}
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800186e:	2300      	movs	r3, #0
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 8001870:	2201      	movs	r2, #1
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 8001872:	8083      	strh	r3, [r0, #4]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8001874:	e9c0 3305 	strd	r3, r3, [r0, #20]
  hcrc.Instance = CRC;
 8001878:	6001      	str	r1, [r0, #0]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 800187a:	6202      	str	r2, [r0, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800187c:	f004 fdde 	bl	800643c <HAL_CRC_Init>
 8001880:	b900      	cbnz	r0, 8001884 <MX_CRC_Init+0x1c>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 8001882:	bd08      	pop	{r3, pc}
 8001884:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8001888:	f000 b9b2 	b.w	8001bf0 <Error_Handler>
 800188c:	20001a20 	.word	0x20001a20
 8001890:	40023000 	.word	0x40023000

08001894 <HAL_CRC_MspInit>:

void HAL_CRC_MspInit(CRC_HandleTypeDef* crcHandle)
{

  if(crcHandle->Instance==CRC)
 8001894:	4b09      	ldr	r3, [pc, #36]	; (80018bc <HAL_CRC_MspInit+0x28>)
 8001896:	6802      	ldr	r2, [r0, #0]
 8001898:	429a      	cmp	r2, r3
 800189a:	d000      	beq.n	800189e <HAL_CRC_MspInit+0xa>
 800189c:	4770      	bx	lr
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* CRC clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 800189e:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
{
 80018a2:	b082      	sub	sp, #8
    __HAL_RCC_CRC_CLK_ENABLE();
 80018a4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018a6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80018aa:	649a      	str	r2, [r3, #72]	; 0x48
 80018ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80018ae:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80018b2:	9301      	str	r3, [sp, #4]
 80018b4:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }
}
 80018b6:	b002      	add	sp, #8
 80018b8:	4770      	bx	lr
 80018ba:	bf00      	nop
 80018bc:	40023000 	.word	0x40023000

080018c0 <MX_DMA_Init>:
  */
void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 80018c0:	4b0a      	ldr	r3, [pc, #40]	; (80018ec <MX_DMA_Init+0x2c>)
 80018c2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018c4:	f042 0204 	orr.w	r2, r2, #4
 80018c8:	649a      	str	r2, [r3, #72]	; 0x48
 80018ca:	6c9a      	ldr	r2, [r3, #72]	; 0x48
{
 80018cc:	b082      	sub	sp, #8
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 80018ce:	f002 0204 	and.w	r2, r2, #4
 80018d2:	9200      	str	r2, [sp, #0]
 80018d4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80018d6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80018d8:	f042 0201 	orr.w	r2, r2, #1
 80018dc:	649a      	str	r2, [r3, #72]	; 0x48
 80018de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80018e0:	f003 0301 	and.w	r3, r3, #1
 80018e4:	9301      	str	r3, [sp, #4]
 80018e6:	9b01      	ldr	r3, [sp, #4]

}
 80018e8:	b002      	add	sp, #8
 80018ea:	4770      	bx	lr
 80018ec:	40021000 	.word	0x40021000

080018f0 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 80018f0:	b500      	push	{lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018f2:	2200      	movs	r2, #0
{
 80018f4:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018f6:	e9cd 2206 	strd	r2, r2, [sp, #24]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80018fa:	4b1b      	ldr	r3, [pc, #108]	; (8001968 <MX_GPIO_Init+0x78>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018fc:	9208      	str	r2, [sp, #32]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80018fe:	6cda      	ldr	r2, [r3, #76]	; 0x4c

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = Start_Stop_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8001900:	481a      	ldr	r0, [pc, #104]	; (800196c <MX_GPIO_Init+0x7c>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001902:	f042 0204 	orr.w	r2, r2, #4
 8001906:	64da      	str	r2, [r3, #76]	; 0x4c
 8001908:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800190a:	f002 0204 	and.w	r2, r2, #4
 800190e:	9200      	str	r2, [sp, #0]
 8001910:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001912:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001914:	f042 0220 	orr.w	r2, r2, #32
 8001918:	64da      	str	r2, [r3, #76]	; 0x4c
 800191a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800191c:	f002 0220 	and.w	r2, r2, #32
 8001920:	9201      	str	r2, [sp, #4]
 8001922:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001924:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001926:	f042 0201 	orr.w	r2, r2, #1
 800192a:	64da      	str	r2, [r3, #76]	; 0x4c
 800192c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800192e:	f002 0201 	and.w	r2, r2, #1
 8001932:	9202      	str	r2, [sp, #8]
 8001934:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001936:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001938:	f042 0202 	orr.w	r2, r2, #2
 800193c:	64da      	str	r2, [r3, #76]	; 0x4c
 800193e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 8001940:	ed9f 7b07 	vldr	d7, [pc, #28]	; 8001960 <MX_GPIO_Init+0x70>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001944:	f003 0302 	and.w	r3, r3, #2
 8001948:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 800194a:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = Start_Stop_Pin;
 800194c:	ed8d 7b04 	vstr	d7, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001950:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_Init(Start_Stop_GPIO_Port, &GPIO_InitStruct);
 8001952:	f004 fe7b 	bl	800664c <HAL_GPIO_Init>

}
 8001956:	b00b      	add	sp, #44	; 0x2c
 8001958:	f85d fb04 	ldr.w	pc, [sp], #4
 800195c:	f3af 8000 	nop.w
 8001960:	00002000 	.word	0x00002000
 8001964:	00210000 	.word	0x00210000
 8001968:	40021000 	.word	0x40021000
 800196c:	48000800 	.word	0x48000800

08001970 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001970:	b510      	push	{r4, lr}
 8001972:	b094      	sub	sp, #80	; 0x50
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001974:	2238      	movs	r2, #56	; 0x38
 8001976:	2100      	movs	r1, #0
 8001978:	a806      	add	r0, sp, #24
 800197a:	f00b fea3 	bl	800d6c4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800197e:	2000      	movs	r0, #0
 8001980:	e9cd 0001 	strd	r0, r0, [sp, #4]
 8001984:	e9cd 0003 	strd	r0, r0, [sp, #12]
 8001988:	9005      	str	r0, [sp, #20]

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 800198a:	f004 ff59 	bl	8006840 <HAL_PWREx_ControlVoltageScaling>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800198e:	2001      	movs	r0, #1
 8001990:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 8001994:	2206      	movs	r2, #6
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001996:	e9cd 0106 	strd	r0, r1, [sp, #24]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800199a:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800199c:	2403      	movs	r4, #3
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV6;
 800199e:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 85;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 80019a0:	2155      	movs	r1, #85	; 0x55
 80019a2:	2208      	movs	r2, #8
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019a4:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80019a6:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV8;
 80019aa:	e9cd 1210 	strd	r1, r2, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80019ae:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80019b2:	f004 ffc3 	bl	800693c <HAL_RCC_OscConfig>
 80019b6:	b108      	cbz	r0, 80019bc <SystemClock_Config+0x4c>
  __ASM volatile ("cpsid i" : : : "memory");
 80019b8:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80019ba:	e7fe      	b.n	80019ba <SystemClock_Config+0x4a>
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019bc:	2104      	movs	r1, #4
 80019be:	4603      	mov	r3, r0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80019c0:	220f      	movs	r2, #15
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019c2:	eb0d 0001 	add.w	r0, sp, r1
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80019c6:	e9cd 2401 	strd	r2, r4, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80019ca:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80019ce:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80019d0:	f005 fa38 	bl	8006e44 <HAL_RCC_ClockConfig>
 80019d4:	b108      	cbz	r0, 80019da <SystemClock_Config+0x6a>
 80019d6:	b672      	cpsid	i
  while (1)
 80019d8:	e7fe      	b.n	80019d8 <SystemClock_Config+0x68>
  HAL_RCC_EnableCSS();
 80019da:	f005 fb61 	bl	80070a0 <HAL_RCC_EnableCSS>
}
 80019de:	b014      	add	sp, #80	; 0x50
 80019e0:	bd10      	pop	{r4, pc}
 80019e2:	bf00      	nop
 80019e4:	0000      	movs	r0, r0
	...

080019e8 <main>:
{
 80019e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  data_flag=0;
 80019ec:	4d70      	ldr	r5, [pc, #448]	; (8001bb0 <main+0x1c8>)
 80019ee:	f8df 81f0 	ldr.w	r8, [pc, #496]	; 8001be0 <main+0x1f8>
 80019f2:	4f70      	ldr	r7, [pc, #448]	; (8001bb4 <main+0x1cc>)
 80019f4:	f8df b1ec 	ldr.w	fp, [pc, #492]	; 8001be4 <main+0x1fc>
 80019f8:	4e6f      	ldr	r6, [pc, #444]	; (8001bb8 <main+0x1d0>)
 80019fa:	f8df a1ec 	ldr.w	sl, [pc, #492]	; 8001be8 <main+0x200>
 80019fe:	4c6f      	ldr	r4, [pc, #444]	; (8001bbc <main+0x1d4>)
      HAL_TIM_Base_Start(&htim3);
 8001a00:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 8001bec <main+0x204>
{
 8001a04:	ed2d 8b02 	vpush	{d8}
  data_flag=0;
 8001a08:	f04f 0300 	mov.w	r3, #0
 8001a0c:	702b      	strb	r3, [r5, #0]
  HAL_Init();
 8001a0e:	f003 fcd5 	bl	80053bc <HAL_Init>
  SystemClock_Config();
 8001a12:	f7ff ffad 	bl	8001970 <SystemClock_Config>
  MX_GPIO_Init();
 8001a16:	f7ff ff6b 	bl	80018f0 <MX_GPIO_Init>
  MX_DMA_Init();
 8001a1a:	f7ff ff51 	bl	80018c0 <MX_DMA_Init>
  MX_ADC1_Init();
 8001a1e:	f7ff fa15 	bl	8000e4c <MX_ADC1_Init>
  MX_CORDIC_Init();
 8001a22:	f7ff fef9 	bl	8001818 <MX_CORDIC_Init>
  MX_TIM1_Init();
 8001a26:	f003 fa93 	bl	8004f50 <MX_TIM1_Init>
  MX_TIM2_Init();
 8001a2a:	f003 f913 	bl	8004c54 <MX_TIM2_Init>
  MX_USART2_UART_Init();
 8001a2e:	f003 fb49 	bl	80050c4 <MX_USART2_UART_Init>
  MX_MotorControl_Init();
 8001a32:	f001 f903 	bl	8002c3c <MX_MotorControl_Init>
  MX_CRC_Init();
 8001a36:	f7ff ff17 	bl	8001868 <MX_CRC_Init>
  MX_TIM3_Init();
 8001a3a:	f003 f941 	bl	8004cc0 <MX_TIM3_Init>
  MX_TIM5_Init();
 8001a3e:	f003 f97b 	bl	8004d38 <MX_TIM5_Init>
  MX_X_CUBE_AI_Init();
 8001a42:	f7ff faef 	bl	8001024 <MX_X_CUBE_AI_Init>
  HAL_NVIC_SetPriority(USART2_IRQn, 3, 1);
 8001a46:	2103      	movs	r1, #3
 8001a48:	2201      	movs	r2, #1
 8001a4a:	2026      	movs	r0, #38	; 0x26
 8001a4c:	f004 fc8a 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001a50:	2026      	movs	r0, #38	; 0x26
 8001a52:	f004 fcc5 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 8001a56:	2200      	movs	r2, #0
 8001a58:	2103      	movs	r1, #3
 8001a5a:	200b      	movs	r0, #11
 8001a5c:	f004 fc82 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8001a60:	200b      	movs	r0, #11
 8001a62:	f004 fcbd 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_BRK_TIM15_IRQn, 4, 1);
 8001a66:	2201      	movs	r2, #1
 8001a68:	2104      	movs	r1, #4
 8001a6a:	2018      	movs	r0, #24
 8001a6c:	f004 fc7a 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_BRK_TIM15_IRQn);
 8001a70:	2018      	movs	r0, #24
 8001a72:	f004 fcb5 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 0, 0);
 8001a76:	2200      	movs	r2, #0
 8001a78:	4611      	mov	r1, r2
 8001a7a:	2019      	movs	r0, #25
 8001a7c:	f004 fc72 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 8001a80:	2019      	movs	r0, #25
 8001a82:	f004 fcad 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(ADC1_2_IRQn, 2, 0);
 8001a86:	2200      	movs	r2, #0
 8001a88:	2102      	movs	r1, #2
 8001a8a:	2012      	movs	r0, #18
 8001a8c:	f004 fc6a 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 8001a90:	2012      	movs	r0, #18
 8001a92:	f004 fca5 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);
 8001a96:	2200      	movs	r2, #0
 8001a98:	2103      	movs	r1, #3
 8001a9a:	201c      	movs	r0, #28
 8001a9c:	f004 fc62 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8001aa0:	201c      	movs	r0, #28
 8001aa2:	f004 fc9d 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 3, 0);
 8001aa6:	2200      	movs	r2, #0
 8001aa8:	2103      	movs	r1, #3
 8001aaa:	2028      	movs	r0, #40	; 0x28
 8001aac:	f004 fc5a 	bl	8006364 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8001ab0:	2028      	movs	r0, #40	; 0x28
 8001ab2:	f004 fc95 	bl	80063e0 <HAL_NVIC_EnableIRQ>
  MC_StartMotor1();
 8001ab6:	f000 f89d 	bl	8001bf4 <MC_StartMotor1>
  MC_ProgramTorqueRampMotor1_F(0.0, 0);
 8001aba:	ed9f 0a41 	vldr	s0, [pc, #260]	; 8001bc0 <main+0x1d8>
      float enc_mec_angle = (float)ENCODER_M1._Super.hMecAngle/65536*2*M_PI;
 8001abe:	eddf 8a41 	vldr	s17, [pc, #260]	; 8001bc4 <main+0x1dc>
  MC_ProgramTorqueRampMotor1_F(0.0, 0);
 8001ac2:	2000      	movs	r0, #0
 8001ac4:	f000 f8a2 	bl	8001c0c <MC_ProgramTorqueRampMotor1_F>
  HAL_TIM_Base_Start_IT(&htim5);
 8001ac8:	483f      	ldr	r0, [pc, #252]	; (8001bc8 <main+0x1e0>)
 8001aca:	f005 fe45 	bl	8007758 <HAL_TIM_Base_Start_IT>
    if(data_flag)
 8001ace:	782b      	ldrb	r3, [r5, #0]
 8001ad0:	2b00      	cmp	r3, #0
 8001ad2:	d0fc      	beq.n	8001ace <main+0xe6>
      TIM3->CNT = 0;
 8001ad4:	4b3d      	ldr	r3, [pc, #244]	; (8001bcc <main+0x1e4>)
 8001ad6:	2200      	movs	r2, #0
 8001ad8:	625a      	str	r2, [r3, #36]	; 0x24
      HAL_TIM_Base_Start(&htim3);
 8001ada:	4648      	mov	r0, r9
 8001adc:	f005 fdec 	bl	80076b8 <HAL_TIM_Base_Start>
      float enc_mec_angle = (float)ENCODER_M1._Super.hMecAngle/65536*2*M_PI;
 8001ae0:	4b3b      	ldr	r3, [pc, #236]	; (8001bd0 <main+0x1e8>)
 8001ae2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8001ae6:	ee07 3a90 	vmov	s15, r3
 8001aea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001aee:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8001af2:	ee17 0a90 	vmov	r0, s15
 8001af6:	f7fe fd47 	bl	8000588 <__aeabi_f2d>
 8001afa:	a329      	add	r3, pc, #164	; (adr r3, 8001ba0 <main+0x1b8>)
 8001afc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001b00:	f7fe fd9a 	bl	8000638 <__aeabi_dmul>
 8001b04:	f7fe ffaa 	bl	8000a5c <__aeabi_d2f>
    *sin_component = sinf(angle);
 8001b08:	ee00 0a10 	vmov	s0, r0
      float enc_mec_angle = (float)ENCODER_M1._Super.hMecAngle/65536*2*M_PI;
 8001b0c:	ee08 0a10 	vmov	s16, r0
    *sin_component = sinf(angle);
 8001b10:	f00c fb46 	bl	800e1a0 <sinf>
 8001b14:	eef0 7a40 	vmov.f32	s15, s0
    *cos_component = cosf(angle);
 8001b18:	eeb0 0a48 	vmov.f32	s0, s16
    *sin_component = sinf(angle);
 8001b1c:	edc8 7a00 	vstr	s15, [r8]
    *cos_component = cosf(angle);
 8001b20:	f00c faf2 	bl	800e108 <cosf>
 8001b24:	ed87 0a00 	vstr	s0, [r7]
      vel_scaled = scale_vel(MC_GetAverageMecSpeedMotor1_F());
 8001b28:	f000 f878 	bl	8001c1c <MC_GetAverageMecSpeedMotor1_F>
 8001b2c:	ee10 0a10 	vmov	r0, s0
    return rpm * (2 * M_PI / 60) / VEL_SCALE;
 8001b30:	f7fe fd2a 	bl	8000588 <__aeabi_f2d>
 8001b34:	a31c      	add	r3, pc, #112	; (adr r3, 8001ba8 <main+0x1c0>)
 8001b36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001b3a:	f7fe fd7d 	bl	8000638 <__aeabi_dmul>
 8001b3e:	f7fe ff8d 	bl	8000a5c <__aeabi_d2f>
      in_data1[0] = sin_encode; // Sin Encoding
 8001b42:	f8d8 3000 	ldr.w	r3, [r8]
 8001b46:	6033      	str	r3, [r6, #0]
      in_data1[1] = cos_encode; // Cosine Encoding
 8001b48:	683b      	ldr	r3, [r7, #0]
      vel_scaled = scale_vel(MC_GetAverageMecSpeedMotor1_F());
 8001b4a:	f8cb 0000 	str.w	r0, [fp]
      in_data1[2] = vel_scaled; // Velocity
 8001b4e:	60b0      	str	r0, [r6, #8]
      in_data1[1] = cos_encode; // Cosine Encoding
 8001b50:	6073      	str	r3, [r6, #4]
      MX_X_CUBE_AI_Process();
 8001b52:	f7ff faa7 	bl	80010a4 <MX_X_CUBE_AI_Process>
      action = -out_data1[0] * MAX_EFFORT;
 8001b56:	ed9a 0a00 	vldr	s0, [sl]
 8001b5a:	4b1e      	ldr	r3, [pc, #120]	; (8001bd4 <main+0x1ec>)
 8001b5c:	eefd 7a00 	vmov.f32	s15, #208	; 0xbe800000 -0.250
 8001b60:	ee20 0a27 	vmul.f32	s0, s0, s15
      MC_ProgramTorqueRampMotor1_F(action, 0);
 8001b64:	2000      	movs	r0, #0
      action = -out_data1[0] * MAX_EFFORT;
 8001b66:	ed83 0a00 	vstr	s0, [r3]
      MC_ProgramTorqueRampMotor1_F(action, 0);
 8001b6a:	f000 f84f 	bl	8001c0c <MC_ProgramTorqueRampMotor1_F>
      HAL_TIM_Base_Stop(&htim3);
 8001b6e:	4648      	mov	r0, r9
 8001b70:	f005 fdde 	bl	8007730 <HAL_TIM_Base_Stop>
      data_flag = 0;
 8001b74:	f04f 0300 	mov.w	r3, #0
 8001b78:	702b      	strb	r3, [r5, #0]
      data.floatValue[0] = out_data1[0]; // Value
 8001b7a:	f8da 3000 	ldr.w	r3, [sl]
 8001b7e:	6023      	str	r3, [r4, #0]
      data.floatValue[1] = out_data2[0]; // Mu
 8001b80:	4b15      	ldr	r3, [pc, #84]	; (8001bd8 <main+0x1f0>)
 8001b82:	681b      	ldr	r3, [r3, #0]
 8001b84:	6063      	str	r3, [r4, #4]
      data.floatValue[2] = out_data3[0]; // STD
 8001b86:	4b15      	ldr	r3, [pc, #84]	; (8001bdc <main+0x1f4>)
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	60a3      	str	r3, [r4, #8]
      data.floatValue[5] = sin_encode;
 8001b8c:	f8d8 3000 	ldr.w	r3, [r8]
 8001b90:	6163      	str	r3, [r4, #20]
      data.floatValue[6] = cos_encode;
 8001b92:	683b      	ldr	r3, [r7, #0]
 8001b94:	61a3      	str	r3, [r4, #24]
      data.floatValue[7] = vel_scaled;
 8001b96:	f8db 3000 	ldr.w	r3, [fp]
 8001b9a:	61e3      	str	r3, [r4, #28]
      data_flag = 0;
 8001b9c:	e797      	b.n	8001ace <main+0xe6>
 8001b9e:	bf00      	nop
 8001ba0:	54442d18 	.word	0x54442d18
 8001ba4:	400921fb 	.word	0x400921fb
 8001ba8:	c2c98978 	.word	0xc2c98978
 8001bac:	3f757254 	.word	0x3f757254
 8001bb0:	20001a6c 	.word	0x20001a6c
 8001bb4:	20001a48 	.word	0x20001a48
 8001bb8:	20001a70 	.word	0x20001a70
 8001bbc:	20001a4c 	.word	0x20001a4c
 8001bc0:	00000000 	.word	0x00000000
 8001bc4:	38000000 	.word	0x38000000
 8001bc8:	20002f08 	.word	0x20002f08
 8001bcc:	40000400 	.word	0x40000400
 8001bd0:	20000024 	.word	0x20000024
 8001bd4:	20001a44 	.word	0x20001a44
 8001bd8:	20001a80 	.word	0x20001a80
 8001bdc:	20001a84 	.word	0x20001a84
 8001be0:	20001a88 	.word	0x20001a88
 8001be4:	20001a8c 	.word	0x20001a8c
 8001be8:	20001a7c 	.word	0x20001a7c
 8001bec:	20002ebc 	.word	0x20002ebc

08001bf0 <Error_Handler>:
 8001bf0:	b672      	cpsid	i
  while (1)
 8001bf2:	e7fe      	b.n	8001bf2 <Error_Handler+0x2>

08001bf4 <MC_StartMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StartMotor1(void)
{
  return (MCI_StartMotor(pMCI[M1]));
 8001bf4:	4b01      	ldr	r3, [pc, #4]	; (8001bfc <MC_StartMotor1+0x8>)
 8001bf6:	6818      	ldr	r0, [r3, #0]
 8001bf8:	f000 b8ae 	b.w	8001d58 <MCI_StartMotor>
 8001bfc:	20002c88 	.word	0x20002c88

08001c00 <MC_StopMotor1>:
  *
  * @retval returns true if the command is successfully executed, false otherwise.
  */
__weak bool MC_StopMotor1(void)
{
  return (MCI_StopMotor(pMCI[M1]));
 8001c00:	4b01      	ldr	r3, [pc, #4]	; (8001c08 <MC_StopMotor1+0x8>)
 8001c02:	6818      	ldr	r0, [r3, #0]
 8001c04:	f000 b8d8 	b.w	8001db8 <MCI_StopMotor>
 8001c08:	20002c88 	.word	0x20002c88

08001c0c <MC_ProgramTorqueRampMotor1_F>:
  *         is possible to set 0 to perform an instantaneous change in the torque
  *         value.
  */
__weak void MC_ProgramTorqueRampMotor1_F(float_t FinalTorque, uint16_t hDurationms)
{
  MCI_ExecTorqueRamp_F(pMCI[M1], FinalTorque, hDurationms);
 8001c0c:	4b02      	ldr	r3, [pc, #8]	; (8001c18 <MC_ProgramTorqueRampMotor1_F+0xc>)
{
 8001c0e:	4601      	mov	r1, r0
  MCI_ExecTorqueRamp_F(pMCI[M1], FinalTorque, hDurationms);
 8001c10:	6818      	ldr	r0, [r3, #0]
 8001c12:	f000 b839 	b.w	8001c88 <MCI_ExecTorqueRamp_F>
 8001c16:	bf00      	nop
 8001c18:	20002c88 	.word	0x20002c88

08001c1c <MC_GetAverageMecSpeedMotor1_F>:
/**
 * @brief Returns the last computed average mechanical rotor speed for Motor 1, expressed in rpm.
 */
__weak float_t MC_GetAverageMecSpeedMotor1_F(void)
{
  return (MCI_GetAvrgMecSpeed_F(pMCI[M1]));
 8001c1c:	4b01      	ldr	r3, [pc, #4]	; (8001c24 <MC_GetAverageMecSpeedMotor1_F+0x8>)
 8001c1e:	6818      	ldr	r0, [r3, #0]
 8001c20:	f000 b91c 	b.w	8001e5c <MCI_GetAvrgMecSpeed_F>
 8001c24:	20002c88 	.word	0x20002c88

08001c28 <MC_GetSTMStateMotor1>:
/**
 * @brief returns the current state of Motor 1 state machine
 */
__weak MCI_State_t MC_GetSTMStateMotor1(void)
{
  return (MCI_GetSTMState(pMCI[M1]));
 8001c28:	4b01      	ldr	r3, [pc, #4]	; (8001c30 <MC_GetSTMStateMotor1+0x8>)
 8001c2a:	6818      	ldr	r0, [r3, #0]
 8001c2c:	f000 b88e 	b.w	8001d4c <MCI_GetSTMState>
 8001c30:	20002c88 	.word	0x20002c88

08001c34 <MC_ProfilerCommand>:
 * @brief Not implemented MC_Profiler function.
 *  */ //cstat !MISRAC2012-Rule-2.7 !RED-unused-param  !MISRAC2012-Rule-2.7  !MISRAC2012-Rule-8.13
__weak uint8_t MC_ProfilerCommand(uint16_t rxLength, uint8_t *rxBuffer, int16_t txSyncFreeSpace, uint16_t *txLength, uint8_t *txBuffer)
{
  return (MCP_CMD_UNKNOWN);
}
 8001c34:	2002      	movs	r0, #2
 8001c36:	4770      	bx	lr

08001c38 <MC_APP_BootHook>:
   */

/* USER CODE BEGIN BootHook */

/* USER CODE END BootHook */
}
 8001c38:	4770      	bx	lr
 8001c3a:	bf00      	nop

08001c3c <MC_APP_PostMediumFrequencyHook_M1>:
 8001c3c:	4770      	bx	lr
 8001c3e:	bf00      	nop

08001c40 <MCI_Init>:
  *         (only present if position control is enabled)
  * @param  pPWMHandle pointer to the PWM & current feedback component to be used by the MCI.
  */
__weak void MCI_Init(MCI_Handle_t *pHandle, SpeednTorqCtrl_Handle_t *pSTC, pFOCVars_t pFOCVars,
                     PWMC_Handle_t *pPWMHandle )
{
 8001c40:	b410      	push	{r4}
    pHandle->pSTC = pSTC;
    pHandle->pFOCVars = pFOCVars;
    pHandle->pPWM = pPWMHandle;

    /* Buffer related initialization */
    pHandle->lastCommand = MCI_NOCOMMANDSYET;
 8001c42:	2400      	movs	r4, #0
    pHandle->hFinalTorque = 0;
    pHandle->hDurationms = 0;
    pHandle->CommandState = MCI_BUFFER_EMPTY;
    pHandle->DirectCommand = MCI_NO_COMMAND;
    pHandle->State = IDLE;
    pHandle->CurrentFaults = MC_NO_FAULTS;
 8001c44:	e9c0 4407 	strd	r4, r4, [r0, #28]
    pHandle->lastCommand = MCI_NOCOMMANDSYET;
 8001c48:	7304      	strb	r4, [r0, #12]
    pHandle->hFinalSpeed = 0;
 8001c4a:	f8c0 400e 	str.w	r4, [r0, #14]
    pHandle->CommandState = MCI_BUFFER_EMPTY;
 8001c4e:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    pHandle->pFOCVars = pFOCVars;
 8001c52:	e9c0 1200 	strd	r1, r2, [r0]
    pHandle->PastFaults = MC_NO_FAULTS;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001c56:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->pPWM = pPWMHandle;
 8001c5a:	6083      	str	r3, [r0, #8]
}
 8001c5c:	4770      	bx	lr
 8001c5e:	bf00      	nop

08001c60 <MCI_ExecSpeedRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 8001c60:	f04f 0c01 	mov.w	ip, #1
    pHandle->hFinalSpeed = hFinalSpeed;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001c64:	f240 3301 	movw	r3, #769	; 0x301
    pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 8001c68:	f880 c00c 	strb.w	ip, [r0, #12]
    pHandle->hFinalSpeed = hFinalSpeed;
 8001c6c:	81c1      	strh	r1, [r0, #14]
    pHandle->hDurationms = hDurationms;
 8001c6e:	8382      	strh	r2, [r0, #28]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001c70:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_SPEED_MODE;

#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001c72:	4770      	bx	lr

08001c74 <MCI_ExecTorqueRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 8001c74:	f04f 0c02 	mov.w	ip, #2
    pHandle->hFinalTorque = hFinalTorque;
    pHandle->hDurationms = hDurationms;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001c78:	f240 4301 	movw	r3, #1025	; 0x401
    pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 8001c7c:	f880 c00c 	strb.w	ip, [r0, #12]
    pHandle->hFinalTorque = hFinalTorque;
 8001c80:	8201      	strh	r1, [r0, #16]
    pHandle->hDurationms = hDurationms;
 8001c82:	8382      	strh	r2, [r0, #28]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001c84:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001c86:	4770      	bx	lr

08001c88 <MCI_ExecTorqueRamp_F>:
    /* Nothing to do */
  }
  else
  {
#endif
    int16_t hFinalTorque = (int16_t)(FinalTorque * (int16_t)CURRENT_CONV_FACTOR);
 8001c88:	eddf 7a06 	vldr	s15, [pc, #24]	; 8001ca4 <MCI_ExecTorqueRamp_F+0x1c>
 8001c8c:	ee20 0a27 	vmul.f32	s0, s0, s15
{
 8001c90:	b508      	push	{r3, lr}
    int16_t hFinalTorque = (int16_t)(FinalTorque * (int16_t)CURRENT_CONV_FACTOR);
 8001c92:	eebd 0ac0 	vcvt.s32.f32	s0, s0
{
 8001c96:	460a      	mov	r2, r1
    MCI_ExecTorqueRamp(pHandle, hFinalTorque, hDurationms);
 8001c98:	ee10 3a10 	vmov	r3, s0
 8001c9c:	b219      	sxth	r1, r3
 8001c9e:	f7ff ffe9 	bl	8001c74 <MCI_ExecTorqueRamp>
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001ca2:	bd08      	pop	{r3, pc}
 8001ca4:	452dc000 	.word	0x452dc000

08001ca8 <MCI_SetCurrentReferences>:
  * function.

  @sa MCI_SetCurrentReferences_F
  */
__weak void MCI_SetCurrentReferences(MCI_Handle_t *pHandle, qd_t Iqdref)
{
 8001ca8:	b082      	sub	sp, #8
  }
  else
  {
#endif

    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001caa:	2203      	movs	r2, #3
    pHandle->Iqdref.q = Iqdref.q;
    pHandle->Iqdref.d = Iqdref.d;
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cac:	f240 4301 	movw	r3, #1025	; 0x401
    pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 8001cb0:	7302      	strb	r2, [r0, #12]
    pHandle->Iqdref.q = Iqdref.q;
 8001cb2:	f8c0 1012 	str.w	r1, [r0, #18]
    pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001cb6:	8483      	strh	r3, [r0, #36]	; 0x24
    pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cb8:	b002      	add	sp, #8
 8001cba:	4770      	bx	lr

08001cbc <MCI_FaultProcessing>:
  }
  else
  {
#endif
    /* Set current errors */
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001cbc:	8c03      	ldrh	r3, [r0, #32]
    pHandle->PastFaults |= hSetErrors;
 8001cbe:	f8b0 c022 	ldrh.w	ip, [r0, #34]	; 0x22
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001cc2:	430b      	orrs	r3, r1
 8001cc4:	ea23 0302 	bic.w	r3, r3, r2
    pHandle->PastFaults |= hSetErrors;
 8001cc8:	ea41 010c 	orr.w	r1, r1, ip
    pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 8001ccc:	8403      	strh	r3, [r0, #32]
    pHandle->PastFaults |= hSetErrors;
 8001cce:	8441      	strh	r1, [r0, #34]	; 0x22
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cd0:	4770      	bx	lr
 8001cd2:	bf00      	nop

08001cd4 <MCI_ExecBufferedCommands>:
    /* Nothing to do */
  }
  else
  {
#endif
    if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 8001cd4:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001cd8:	2b01      	cmp	r3, #1
 8001cda:	d000      	beq.n	8001cde <MCI_ExecBufferedCommands+0xa>
 8001cdc:	4770      	bx	lr
{
 8001cde:	b510      	push	{r4, lr}
    {
      bool commandHasBeenExecuted = false;
      switch (pHandle->lastCommand)
 8001ce0:	7b02      	ldrb	r2, [r0, #12]
 8001ce2:	2a02      	cmp	r2, #2
 8001ce4:	4604      	mov	r4, r0
 8001ce6:	d007      	beq.n	8001cf8 <MCI_ExecBufferedCommands+0x24>
 8001ce8:	2a03      	cmp	r2, #3
 8001cea:	d028      	beq.n	8001d3e <MCI_ExecBufferedCommands+0x6a>
 8001cec:	2a01      	cmp	r2, #1
 8001cee:	d017      	beq.n	8001d20 <MCI_ExecBufferedCommands+0x4c>
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
      }
      else
      {
        pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 8001cf0:	2303      	movs	r3, #3
 8001cf2:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
      }
    }
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001cf6:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001cf8:	6843      	ldr	r3, [r0, #4]
 8001cfa:	2200      	movs	r2, #0
 8001cfc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 8001d00:	6800      	ldr	r0, [r0, #0]
 8001d02:	2104      	movs	r1, #4
 8001d04:	f008 fb64 	bl	800a3d0 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDurationms);
 8001d08:	8ba2      	ldrh	r2, [r4, #28]
 8001d0a:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
 8001d0e:	6820      	ldr	r0, [r4, #0]
 8001d10:	f008 fb62 	bl	800a3d8 <STC_ExecRamp>
      if (commandHasBeenExecuted)
 8001d14:	2800      	cmp	r0, #0
 8001d16:	d0eb      	beq.n	8001cf0 <MCI_ExecBufferedCommands+0x1c>
        pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
 8001d18:	2302      	movs	r3, #2
 8001d1a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8001d1e:	bd10      	pop	{r4, pc}
          pHandle->pFOCVars->bDriveInput = INTERNAL;
 8001d20:	6843      	ldr	r3, [r0, #4]
 8001d22:	2200      	movs	r2, #0
 8001d24:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 8001d28:	6800      	ldr	r0, [r0, #0]
 8001d2a:	2103      	movs	r1, #3
 8001d2c:	f008 fb50 	bl	800a3d0 <STC_SetControlMode>
          commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDurationms);
 8001d30:	8ba2      	ldrh	r2, [r4, #28]
 8001d32:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8001d36:	6820      	ldr	r0, [r4, #0]
 8001d38:	f008 fb4e 	bl	800a3d8 <STC_ExecRamp>
          break;
 8001d3c:	e7ea      	b.n	8001d14 <MCI_ExecBufferedCommands+0x40>
          pHandle->pFOCVars->bDriveInput = EXTERNAL;
 8001d3e:	6842      	ldr	r2, [r0, #4]
 8001d40:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
          pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 8001d44:	f8d0 3012 	ldr.w	r3, [r0, #18]
 8001d48:	6113      	str	r3, [r2, #16]
      if (commandHasBeenExecuted)
 8001d4a:	e7e5      	b.n	8001d18 <MCI_ExecBufferedCommands+0x44>

08001d4c <MCI_GetSTMState>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
#else
  return (pHandle->State);
#endif
}
 8001d4c:	7fc0      	ldrb	r0, [r0, #31]
 8001d4e:	4770      	bx	lr

08001d50 <MCI_GetOccurredFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
#else
  return ((uint16_t)pHandle->PastFaults);
#endif
}
 8001d50:	8c40      	ldrh	r0, [r0, #34]	; 0x22
 8001d52:	4770      	bx	lr

08001d54 <MCI_GetCurrentFaults>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
#else
  return ((uint16_t)pHandle->CurrentFaults);
#endif
}
 8001d54:	8c00      	ldrh	r0, [r0, #32]
 8001d56:	4770      	bx	lr

08001d58 <MCI_StartMotor>:
{
 8001d58:	b510      	push	{r4, lr}
 8001d5a:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001d5c:	f7ff fff6 	bl	8001d4c <MCI_GetSTMState>
 8001d60:	b108      	cbz	r0, 8001d66 <MCI_StartMotor+0xe>
  bool retVal = false;
 8001d62:	2000      	movs	r0, #0
}
 8001d64:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001d66:	4620      	mov	r0, r4
 8001d68:	f7ff fff2 	bl	8001d50 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001d6c:	2800      	cmp	r0, #0
 8001d6e:	d1f8      	bne.n	8001d62 <MCI_StartMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001d70:	4620      	mov	r0, r4
 8001d72:	f7ff ffef 	bl	8001d54 <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001d76:	2800      	cmp	r0, #0
 8001d78:	d1f3      	bne.n	8001d62 <MCI_StartMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 8001d7a:	2001      	movs	r0, #1
 8001d7c:	77a0      	strb	r0, [r4, #30]
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001d7e:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
}
 8001d82:	bd10      	pop	{r4, pc}

08001d84 <MCI_StartWithPolarizationMotor>:
{
 8001d84:	b510      	push	{r4, lr}
 8001d86:	4604      	mov	r4, r0
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001d88:	f7ff ffe0 	bl	8001d4c <MCI_GetSTMState>
 8001d8c:	b108      	cbz	r0, 8001d92 <MCI_StartWithPolarizationMotor+0xe>
  bool retVal = true;
 8001d8e:	2001      	movs	r0, #1
}
 8001d90:	bd10      	pop	{r4, pc}
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001d92:	4620      	mov	r0, r4
 8001d94:	f7ff ffdc 	bl	8001d50 <MCI_GetOccurredFaults>
    if ((IDLE == MCI_GetSTMState(pHandle)) &&
 8001d98:	2800      	cmp	r0, #0
 8001d9a:	d1f8      	bne.n	8001d8e <MCI_StartWithPolarizationMotor+0xa>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001d9c:	4620      	mov	r0, r4
 8001d9e:	f7ff ffd9 	bl	8001d54 <MCI_GetCurrentFaults>
        (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001da2:	2800      	cmp	r0, #0
 8001da4:	d1f3      	bne.n	8001d8e <MCI_StartWithPolarizationMotor+0xa>
      pHandle->DirectCommand = MCI_START;
 8001da6:	2201      	movs	r2, #1
      pHandle->pPWM->offsetCalibStatus = false;
 8001da8:	68a1      	ldr	r1, [r4, #8]
      pHandle->DirectCommand = MCI_START;
 8001daa:	77a2      	strb	r2, [r4, #30]
      pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 8001dac:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      pHandle->pPWM->offsetCalibStatus = false;
 8001db0:	f881 0081 	strb.w	r0, [r1, #129]	; 0x81
}
 8001db4:	bd10      	pop	{r4, pc}
 8001db6:	bf00      	nop

08001db8 <MCI_StopMotor>:
{
 8001db8:	b538      	push	{r3, r4, r5, lr}
 8001dba:	4605      	mov	r5, r0
    State = MCI_GetSTMState(pHandle);
 8001dbc:	f7ff ffc6 	bl	8001d4c <MCI_GetSTMState>
    if ((IDLE == State) || (ICLWAIT == State))
 8001dc0:	b150      	cbz	r0, 8001dd8 <MCI_StopMotor+0x20>
 8001dc2:	f1b0 040c 	subs.w	r4, r0, #12
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dc6:	4628      	mov	r0, r5
    if ((IDLE == State) || (ICLWAIT == State))
 8001dc8:	bf18      	it	ne
 8001dca:	2401      	movne	r4, #1
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dcc:	f7ff ffc0 	bl	8001d50 <MCI_GetOccurredFaults>
 8001dd0:	b140      	cbz	r0, 8001de4 <MCI_StopMotor+0x2c>
  bool retVal = false;
 8001dd2:	2400      	movs	r4, #0
}
 8001dd4:	4620      	mov	r0, r4
 8001dd6:	bd38      	pop	{r3, r4, r5, pc}
      status = false;
 8001dd8:	4604      	mov	r4, r0
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dda:	4628      	mov	r0, r5
 8001ddc:	f7ff ffb8 	bl	8001d50 <MCI_GetOccurredFaults>
 8001de0:	2800      	cmp	r0, #0
 8001de2:	d1f6      	bne.n	8001dd2 <MCI_StopMotor+0x1a>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 8001de4:	4628      	mov	r0, r5
 8001de6:	f7ff ffb5 	bl	8001d54 <MCI_GetCurrentFaults>
    if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 8001dea:	2800      	cmp	r0, #0
 8001dec:	d1f1      	bne.n	8001dd2 <MCI_StopMotor+0x1a>
        (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 8001dee:	2c00      	cmp	r4, #0
 8001df0:	d0ef      	beq.n	8001dd2 <MCI_StopMotor+0x1a>
      pHandle->DirectCommand = MCI_STOP;
 8001df2:	2305      	movs	r3, #5
 8001df4:	77ab      	strb	r3, [r5, #30]
      retVal = true;
 8001df6:	e7ed      	b.n	8001dd4 <MCI_StopMotor+0x1c>

08001df8 <MCI_FaultAcknowledged>:
{
 8001df8:	b510      	push	{r4, lr}
 8001dfa:	4604      	mov	r4, r0
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001dfc:	f7ff ffa6 	bl	8001d4c <MCI_GetSTMState>
 8001e00:	280b      	cmp	r0, #11
 8001e02:	d001      	beq.n	8001e08 <MCI_FaultAcknowledged+0x10>
  bool reVal = false;
 8001e04:	2000      	movs	r0, #0
}
 8001e06:	bd10      	pop	{r4, pc}
    if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 8001e08:	4620      	mov	r0, r4
 8001e0a:	f7ff ffa3 	bl	8001d54 <MCI_GetCurrentFaults>
 8001e0e:	2800      	cmp	r0, #0
 8001e10:	d1f8      	bne.n	8001e04 <MCI_FaultAcknowledged+0xc>
      pHandle->DirectCommand = MCI_ACK_FAULTS;
 8001e12:	2302      	movs	r3, #2
 8001e14:	77a3      	strb	r3, [r4, #30]
      pHandle->PastFaults = MC_NO_FAULTS;
 8001e16:	8460      	strh	r0, [r4, #34]	; 0x22
      reVal = true;
 8001e18:	2001      	movs	r0, #1
}
 8001e1a:	bd10      	pop	{r4, pc}

08001e1c <MCI_GetFaultState>:
    LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
  }
  else
  {
#endif
    LocalFaultState = (uint32_t)(pHandle->PastFaults);
 8001e1c:	8c43      	ldrh	r3, [r0, #34]	; 0x22
    LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 8001e1e:	8c00      	ldrh	r0, [r0, #32]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (LocalFaultState);
}
 8001e20:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001e24:	4770      	bx	lr
 8001e26:	bf00      	nop

08001e28 <MCI_GetControlMode>:
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
#else
  return (pHandle->LastModalitySetByUser);
#endif
}
 8001e28:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
 8001e2c:	4770      	bx	lr
 8001e2e:	bf00      	nop

08001e30 <MCI_GetLastRampFinalSpeed>:
  }
  return (retVal);
#else
  return (pHandle->hFinalSpeed);
#endif
}
 8001e30:	f9b0 000e 	ldrsh.w	r0, [r0, #14]
 8001e34:	4770      	bx	lr
 8001e36:	bf00      	nop

08001e38 <MCI_GetLastRampFinalTorque>:
  }
  return (retVal);
#else
  return (pHandle->hFinalTorque);
#endif
}
 8001e38:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
 8001e3c:	4770      	bx	lr
 8001e3e:	bf00      	nop

08001e40 <MCI_GetLastRampFinalDuration>:
  }
  return (retVal);
#else
  return (pHandle->hDurationms);
#endif
}
 8001e40:	8b80      	ldrh	r0, [r0, #28]
 8001e42:	4770      	bx	lr

08001e44 <MCI_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    STC_StopRamp(pHandle->pSTC);
 8001e44:	6800      	ldr	r0, [r0, #0]
 8001e46:	f008 bb0b 	b.w	800a460 <STC_StopRamp>
 8001e4a:	bf00      	nop

08001e4c <MCI_GetAvrgMecSpeedUnit>:
  *         the unit defined by #SPEED_UNIT and related to the sensor actually
  *         used by FOC algorithm
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak int16_t MCI_GetAvrgMecSpeedUnit(MCI_Handle_t *pHandle)
{
 8001e4c:	b508      	push	{r3, lr}
    temp_speed = 0;
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 8001e4e:	6800      	ldr	r0, [r0, #0]
 8001e50:	f008 faac 	bl	800a3ac <STC_GetSpeedSensor>
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (temp_speed);
}
 8001e54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 8001e58:	f008 ba50 	b.w	800a2fc <SPD_GetAvrgMecSpeedUnit>

08001e5c <MCI_GetAvrgMecSpeed_F>:
  * @brief  Returns the last computed average mechanical speed, expressed in rpm
  *         and related to the sensor actually used by FOC algorithm.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak float_t MCI_GetAvrgMecSpeed_F(MCI_Handle_t *pHandle)
{
 8001e5c:	b508      	push	{r3, lr}
    returnAvrgSpeed = 0.0f;
  }
  else
  {
#endif
    SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 8001e5e:	6800      	ldr	r0, [r0, #0]
 8001e60:	f008 faa4 	bl	800a3ac <STC_GetSpeedSensor>
    returnAvrgSpeed = (((float_t)SPD_GetAvrgMecSpeedUnit(SpeedSensor) * (float_t)U_RPM) / (float_t)SPEED_UNIT);
 8001e64:	f008 fa4a 	bl	800a2fc <SPD_GetAvrgMecSpeedUnit>
 8001e68:	ee07 0a90 	vmov	s15, r0
 8001e6c:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 8001e70:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
  return (returnAvrgSpeed);
}
 8001e74:	ee20 0a27 	vmul.f32	s0, s0, s15
 8001e78:	bd08      	pop	{r3, pc}
 8001e7a:	bf00      	nop

08001e7c <MCI_GetMecSpeedRefUnit>:
__weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
#else
  return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 8001e7c:	6800      	ldr	r0, [r0, #0]
 8001e7e:	f008 ba9f 	b.w	800a3c0 <STC_GetMecSpeedRefUnit>
 8001e82:	bf00      	nop

08001e84 <MCI_GetIab>:
  {
    tempVal = pHandle->pFOCVars->Iab;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iab);
 8001e84:	6842      	ldr	r2, [r0, #4]
 8001e86:	6810      	ldr	r0, [r2, #0]
 8001e88:	2300      	movs	r3, #0
 8001e8a:	b282      	uxth	r2, r0
 8001e8c:	f362 030f 	bfi	r3, r2, #0, #16
 8001e90:	0c00      	lsrs	r0, r0, #16
 8001e92:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001e96:	b082      	sub	sp, #8
#endif
}
 8001e98:	4618      	mov	r0, r3
 8001e9a:	b002      	add	sp, #8
 8001e9c:	4770      	bx	lr
 8001e9e:	bf00      	nop

08001ea0 <MCI_GetIalphabeta>:
  {
    tempVal = pHandle->pFOCVars->Ialphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Ialphabeta);
 8001ea0:	6842      	ldr	r2, [r0, #4]
 8001ea2:	6850      	ldr	r0, [r2, #4]
 8001ea4:	2300      	movs	r3, #0
 8001ea6:	b282      	uxth	r2, r0
 8001ea8:	f362 030f 	bfi	r3, r2, #0, #16
 8001eac:	0c00      	lsrs	r0, r0, #16
 8001eae:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001eb2:	b082      	sub	sp, #8
#endif
}
 8001eb4:	4618      	mov	r0, r3
 8001eb6:	b002      	add	sp, #8
 8001eb8:	4770      	bx	lr
 8001eba:	bf00      	nop

08001ebc <MCI_GetIqd>:
  {
    tempVal = pHandle->pFOCVars->Iqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqd);
 8001ebc:	6842      	ldr	r2, [r0, #4]
 8001ebe:	68d0      	ldr	r0, [r2, #12]
 8001ec0:	2300      	movs	r3, #0
 8001ec2:	b282      	uxth	r2, r0
 8001ec4:	f362 030f 	bfi	r3, r2, #0, #16
 8001ec8:	0c00      	lsrs	r0, r0, #16
 8001eca:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001ece:	b082      	sub	sp, #8
#endif
}
 8001ed0:	4618      	mov	r0, r3
 8001ed2:	b002      	add	sp, #8
 8001ed4:	4770      	bx	lr
 8001ed6:	bf00      	nop

08001ed8 <MCI_GetIqdref>:
  {
    tempVal = pHandle->pFOCVars->Iqdref;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Iqdref);
 8001ed8:	6842      	ldr	r2, [r0, #4]
 8001eda:	6910      	ldr	r0, [r2, #16]
 8001edc:	2300      	movs	r3, #0
 8001ede:	b282      	uxth	r2, r0
 8001ee0:	f362 030f 	bfi	r3, r2, #0, #16
 8001ee4:	0c00      	lsrs	r0, r0, #16
 8001ee6:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001eea:	b082      	sub	sp, #8
#endif
}
 8001eec:	4618      	mov	r0, r3
 8001eee:	b002      	add	sp, #8
 8001ef0:	4770      	bx	lr
 8001ef2:	bf00      	nop

08001ef4 <MCI_GetVqd>:
  {
    tempVal = pHandle->pFOCVars->Vqd;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Vqd);
 8001ef4:	6842      	ldr	r2, [r0, #4]
 8001ef6:	f8d2 0016 	ldr.w	r0, [r2, #22]
 8001efa:	2300      	movs	r3, #0
 8001efc:	b282      	uxth	r2, r0
 8001efe:	f362 030f 	bfi	r3, r2, #0, #16
 8001f02:	0c00      	lsrs	r0, r0, #16
 8001f04:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f08:	b082      	sub	sp, #8
#endif
}
 8001f0a:	4618      	mov	r0, r3
 8001f0c:	b002      	add	sp, #8
 8001f0e:	4770      	bx	lr

08001f10 <MCI_GetValphabeta>:
  {
    tempVal = pHandle->pFOCVars->Valphabeta;
  }
  return (tempVal);
#else
  return (pHandle->pFOCVars->Valphabeta);
 8001f10:	6842      	ldr	r2, [r0, #4]
 8001f12:	f8d2 001a 	ldr.w	r0, [r2, #26]
 8001f16:	2300      	movs	r3, #0
 8001f18:	b282      	uxth	r2, r0
 8001f1a:	f362 030f 	bfi	r3, r2, #0, #16
 8001f1e:	0c00      	lsrs	r0, r0, #16
 8001f20:	f360 431f 	bfi	r3, r0, #16, #16
{
 8001f24:	b082      	sub	sp, #8
#endif
}
 8001f26:	4618      	mov	r0, r3
 8001f28:	b002      	add	sp, #8
 8001f2a:	4770      	bx	lr

08001f2c <MCI_GetTeref>:
__weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
{
#ifdef NULL_PTR_CHECK_MC_INT
  return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
#else
  return (pHandle->pFOCVars->hTeref);
 8001f2c:	6843      	ldr	r3, [r0, #4]
#endif
}
 8001f2e:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
 8001f32:	4770      	bx	lr

08001f34 <MCI_Clear_Iqdref>:
/**
  * @brief  It re-initializes Iqdref variables with their default values.
  * @param  pHandle Pointer on the component instance to work on.
  */
__weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
{
 8001f34:	b510      	push	{r4, lr}
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 8001f36:	e9d0 0400 	ldrd	r0, r4, [r0]
 8001f3a:	f008 fac3 	bl	800a4c4 <STC_GetDefaultIqdref>
 8001f3e:	f3c0 430f 	ubfx	r3, r0, #16, #16
 8001f42:	8220      	strh	r0, [r4, #16]
 8001f44:	8263      	strh	r3, [r4, #18]
#ifdef NULL_PTR_CHECK_MC_INT
  }
#endif
}
 8001f46:	bd10      	pop	{r4, pc}

08001f48 <MCM_Clarke>:
  /* qIalpha = qIas*/
  Output.alpha = Input.a;

  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);

  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 8001f48:	f644 11e6 	movw	r1, #18918	; 0x49e6
 8001f4c:	b203      	sxth	r3, r0
  a_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.a);
 8001f4e:	fb13 f201 	smulbb	r2, r3, r1
{
 8001f52:	f3c0 400f 	ubfx	r0, r0, #16, #16
  b_divSQRT3_tmp = divSQRT_3 * ((int32_t)Input.b);
 8001f56:	fb10 f001 	smulbb	r0, r0, r1
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
  /* WARNING: the below instruction is not MISRA compliant, user should verify
    that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    the compiler to perform the shift (instead of LSR logical shift right) */
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) >> 15;
 8001f5a:	4252      	negs	r2, r2
 8001f5c:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
#else
  wbeta_tmp = (-(a_divSQRT3_tmp) - (b_divSQRT3_tmp) - (b_divSQRT3_tmp)) / 32768;
#endif

  /* Check saturation of Ibeta */
  if (wbeta_tmp > INT16_MAX)
 8001f60:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
{
 8001f64:	b084      	sub	sp, #16
  if (wbeta_tmp > INT16_MAX)
 8001f66:	da05      	bge.n	8001f74 <MCM_Clarke+0x2c>
 8001f68:	13d1      	asrs	r1, r2, #15
  {
    hbeta_tmp = INT16_MAX;
  }
  else if (wbeta_tmp < (-32768))
 8001f6a:	f511 4f00 	cmn.w	r1, #32768	; 0x8000
 8001f6e:	da0c      	bge.n	8001f8a <MCM_Clarke+0x42>
 8001f70:	4a09      	ldr	r2, [pc, #36]	; (8001f98 <MCM_Clarke+0x50>)
 8001f72:	e001      	b.n	8001f78 <MCM_Clarke+0x30>
 8001f74:	f647 72ff 	movw	r2, #32767	; 0x7fff
  else
  {
    /* Nothing to do */
  }

  return (Output);
 8001f78:	b29b      	uxth	r3, r3
 8001f7a:	2000      	movs	r0, #0
 8001f7c:	f363 000f 	bfi	r0, r3, #0, #16
 8001f80:	b293      	uxth	r3, r2
 8001f82:	f363 401f 	bfi	r0, r3, #16, #16
}
 8001f86:	b004      	add	sp, #16
 8001f88:	4770      	bx	lr
    hbeta_tmp = ((int16_t)wbeta_tmp);
 8001f8a:	4803      	ldr	r0, [pc, #12]	; (8001f98 <MCM_Clarke+0x50>)
 8001f8c:	b20a      	sxth	r2, r1
 8001f8e:	4282      	cmp	r2, r0
 8001f90:	bfb8      	it	lt
 8001f92:	4602      	movlt	r2, r0
 8001f94:	e7f0      	b.n	8001f78 <MCM_Clarke+0x30>
 8001f96:	bf00      	nop
 8001f98:	ffff8001 	.word	0xffff8001

08001f9c <MCM_Trig_Functions>:
  } CosSin;
  //cstat +MISRAC2012-Rule-19.2
  /* Configure CORDIC */
  /* Misra  violation Rule 11.4 A�Conversion�should�not�be�performed�between�a�
   * pointer�to�object and an integer type */
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001f9c:	4b09      	ldr	r3, [pc, #36]	; (8001fc4 <MCM_Trig_Functions+0x28>)
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed�between�a
   * pointer�to�object and an integer type */
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 8001f9e:	f100 40ff 	add.w	r0, r0, #2139095040	; 0x7f800000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001fa2:	f04f 1260 	mov.w	r2, #6291552	; 0x600060
  LL_CORDIC_WriteData(CORDIC, ((uint32_t)0x7FFF0000) + ((uint32_t)hAngle));
 8001fa6:	f500 00fe 	add.w	r0, r0, #8323072	; 0x7f0000
  WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_COSINE);
 8001faa:	601a      	str	r2, [r3, #0]
  * @param  InData 0 .. 0xFFFFFFFF : 32-bit value to be provided as input data for CORDIC processing.
  * @retval None
  */
__STATIC_INLINE void LL_CORDIC_WriteData(CORDIC_TypeDef *CORDICx, uint32_t InData)
{
  WRITE_REG(CORDICx->WDATA, InData);
 8001fac:	6058      	str	r0, [r3, #4]
  * @param  CORDICx CORDIC Instance
  * @retval 32-bit output data of CORDIC processing.
  */
__STATIC_INLINE uint32_t LL_CORDIC_ReadData(CORDIC_TypeDef *CORDICx)
{
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 8001fae:	689b      	ldr	r3, [r3, #8]
  /* Read angle */
  /* Misra  violation Rule�11.4 A�Conversion�should�not�be�performed between�a
   * pointer�to object and an integer type */
  CosSin.CordicRdata = LL_CORDIC_ReadData(CORDIC);
  return (CosSin.Components); //cstat !UNION-type-punning
 8001fb0:	2000      	movs	r0, #0
 8001fb2:	b29a      	uxth	r2, r3
 8001fb4:	f362 000f 	bfi	r0, r2, #0, #16
 8001fb8:	0c1b      	lsrs	r3, r3, #16
{
 8001fba:	b082      	sub	sp, #8
  return (CosSin.Components); //cstat !UNION-type-punning
 8001fbc:	f363 401f 	bfi	r0, r3, #16, #16
}
 8001fc0:	b002      	add	sp, #8
 8001fc2:	4770      	bx	lr
 8001fc4:	40020c00 	.word	0x40020c00

08001fc8 <MCM_Park>:
{
 8001fc8:	b530      	push	{r4, r5, lr}
 8001fca:	b085      	sub	sp, #20
 8001fcc:	4604      	mov	r4, r0
 8001fce:	4605      	mov	r5, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8001fd0:	4608      	mov	r0, r1
{
 8001fd2:	9401      	str	r4, [sp, #4]
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8001fd4:	f7ff ffe2 	bl	8001f9c <MCM_Trig_Functions>
 8001fd8:	b22d      	sxth	r5, r5
 8001fda:	b201      	sxth	r1, r0
 8001fdc:	1424      	asrs	r4, r4, #16
 8001fde:	1400      	asrs	r0, r0, #16
  q_tmp_1 = Input.alpha * ((int32_t )Local_Vector_Components.hCos);
 8001fe0:	fb05 f301 	mul.w	r3, r5, r1
  wqd_tmp = (q_tmp_1 - q_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8001fe4:	fb04 3310 	mls	r3, r4, r0, r3
  if (wqd_tmp > INT16_MAX)
 8001fe8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001fec:	da05      	bge.n	8001ffa <MCM_Park+0x32>
 8001fee:	13da      	asrs	r2, r3, #15
  else if (wqd_tmp < (-32768))
 8001ff0:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 8001ff4:	da22      	bge.n	800203c <MCM_Park+0x74>
 8001ff6:	4a14      	ldr	r2, [pc, #80]	; (8002048 <MCM_Park+0x80>)
 8001ff8:	e001      	b.n	8001ffe <MCM_Park+0x36>
 8001ffa:	f647 72ff 	movw	r2, #32767	; 0x7fff
  d_tmp_2 = Input.beta * ((int32_t )Local_Vector_Components.hCos);
 8001ffe:	fb01 f404 	mul.w	r4, r1, r4
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8002002:	fb05 4400 	mla	r4, r5, r0, r4
  if (wqd_tmp > INT16_MAX)
 8002006:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
  wqd_tmp = (d_tmp_1 + d_tmp_2) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800200a:	ea4f 33e4 	mov.w	r3, r4, asr #15
  if (wqd_tmp > INT16_MAX)
 800200e:	da04      	bge.n	800201a <MCM_Park+0x52>
  else if (wqd_tmp < (-32768))
 8002010:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8002014:	da0c      	bge.n	8002030 <MCM_Park+0x68>
 8002016:	4b0c      	ldr	r3, [pc, #48]	; (8002048 <MCM_Park+0x80>)
 8002018:	e001      	b.n	800201e <MCM_Park+0x56>
 800201a:	f647 73ff 	movw	r3, #32767	; 0x7fff
  return (Output);
 800201e:	b292      	uxth	r2, r2
 8002020:	2000      	movs	r0, #0
 8002022:	f362 000f 	bfi	r0, r2, #0, #16
 8002026:	b29b      	uxth	r3, r3
 8002028:	f363 401f 	bfi	r0, r3, #16, #16
}
 800202c:	b005      	add	sp, #20
 800202e:	bd30      	pop	{r4, r5, pc}
    hqd_tmp = ((int16_t)wqd_tmp);
 8002030:	4905      	ldr	r1, [pc, #20]	; (8002048 <MCM_Park+0x80>)
 8002032:	b21b      	sxth	r3, r3
 8002034:	428b      	cmp	r3, r1
 8002036:	bfb8      	it	lt
 8002038:	460b      	movlt	r3, r1
 800203a:	e7f0      	b.n	800201e <MCM_Park+0x56>
    hqd_tmp = ((int16_t)wqd_tmp);
 800203c:	4b02      	ldr	r3, [pc, #8]	; (8002048 <MCM_Park+0x80>)
 800203e:	b212      	sxth	r2, r2
 8002040:	429a      	cmp	r2, r3
 8002042:	bfb8      	it	lt
 8002044:	461a      	movlt	r2, r3
 8002046:	e7da      	b.n	8001ffe <MCM_Park+0x36>
 8002048:	ffff8001 	.word	0xffff8001

0800204c <MCM_Rev_Park>:
{
 800204c:	b530      	push	{r4, r5, lr}
 800204e:	b085      	sub	sp, #20
 8002050:	4604      	mov	r4, r0
 8002052:	4605      	mov	r5, r0
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8002054:	4608      	mov	r0, r1
{
 8002056:	9401      	str	r4, [sp, #4]
  Local_Vector_Components = MCM_Trig_Functions(Theta);
 8002058:	f7ff ffa0 	bl	8001f9c <MCM_Trig_Functions>
 800205c:	1424      	asrs	r4, r4, #16
 800205e:	1402      	asrs	r2, r0, #16
 8002060:	b22d      	sxth	r5, r5
 8002062:	b200      	sxth	r0, r0
  alpha_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hSin);
 8002064:	fb04 f302 	mul.w	r3, r4, r2
  Output.alpha = (int16_t)(((alpha_tmp1) + (alpha_tmp2)) >> 15);
 8002068:	fb05 3300 	mla	r3, r5, r0, r3
  beta_tmp2 = Input.d * ((int32_t)Local_Vector_Components.hCos);
 800206c:	fb00 f404 	mul.w	r4, r0, r4
  Output.beta = (int16_t)((beta_tmp2 - beta_tmp1) >> 15);
 8002070:	fb05 4412 	mls	r4, r5, r2, r4
  return (Output);
 8002074:	f3c3 33cf 	ubfx	r3, r3, #15, #16
 8002078:	2000      	movs	r0, #0
 800207a:	f363 000f 	bfi	r0, r3, #0, #16
 800207e:	f3c4 34cf 	ubfx	r4, r4, #15, #16
 8002082:	f364 401f 	bfi	r0, r4, #16, #16
}
 8002086:	b005      	add	sp, #20
 8002088:	bd30      	pop	{r4, r5, pc}
 800208a:	bf00      	nop

0800208c <MCM_Sqrt>:
  */
__weak int32_t MCM_Sqrt(int32_t wInput)
{
  int32_t wtemprootnew;

  if (wInput > 0)
 800208c:	2800      	cmp	r0, #0
 800208e:	dd09      	ble.n	80020a4 <MCM_Sqrt+0x18>
 8002090:	b672      	cpsid	i
  {
    uint32_t retVal;
    /* Disable Irq as sqrt is used in MF and HF task */
    __disable_irq();
    /* Configure CORDIC */
    WRITE_REG(CORDIC->CSR, CORDIC_CONFIG_SQRT);
 8002092:	4b05      	ldr	r3, [pc, #20]	; (80020a8 <MCM_Sqrt+0x1c>)
 8002094:	f240 1269 	movw	r2, #361	; 0x169
 8002098:	601a      	str	r2, [r3, #0]
  WRITE_REG(CORDICx->WDATA, InData);
 800209a:	6058      	str	r0, [r3, #4]
  return (uint32_t)(READ_REG(CORDICx->RDATA));
 800209c:	6898      	ldr	r0, [r3, #8]
    LL_CORDIC_WriteData(CORDIC, ((uint32_t)wInput));
    /* Read sqrt and return */
#ifndef FULL_MISRA_C_COMPLIANCY_MC_MATH
    retVal = (LL_CORDIC_ReadData(CORDIC)) >> 15; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800209e:	0bc0      	lsrs	r0, r0, #15
  __ASM volatile ("cpsie i" : : : "memory");
 80020a0:	b662      	cpsie	i
}
 80020a2:	4770      	bx	lr
    __enable_irq();

  }
  else
  {
    wtemprootnew = (int32_t)0;
 80020a4:	2000      	movs	r0, #0
  }

  return (wtemprootnew);
}
 80020a6:	4770      	bx	lr
 80020a8:	40020c00 	.word	0x40020c00

080020ac <FOC_Clear>:
  ab_t NULL_ab = {((int16_t)0), ((int16_t)0)};
  qd_t NULL_qd = {((int16_t)0), ((int16_t)0)};
  alphabeta_t NULL_alphabeta = {((int16_t)0), ((int16_t)0)};

  FOCVars[bMotor].Iab = NULL_ab;
  FOCVars[bMotor].Ialphabeta = NULL_alphabeta;
 80020ac:	2226      	movs	r2, #38	; 0x26
{
 80020ae:	b538      	push	{r3, r4, r5, lr}
 80020b0:	fb00 f202 	mul.w	r2, r0, r2
 80020b4:	4b15      	ldr	r3, [pc, #84]	; (800210c <FOC_Clear+0x60>)
  FOCVars[bMotor].Iab = NULL_ab;
 80020b6:	2400      	movs	r4, #0
 80020b8:	509c      	str	r4, [r3, r2]
{
 80020ba:	4605      	mov	r5, r0
 80020bc:	f102 0108 	add.w	r1, r2, #8
 80020c0:	1898      	adds	r0, r3, r2
 80020c2:	3210      	adds	r2, #16
 80020c4:	4419      	add	r1, r3
 80020c6:	4413      	add	r3, r2
  FOCVars[bMotor].hTeref = (int16_t)0;
  FOCVars[bMotor].Vqd = NULL_qd;
  FOCVars[bMotor].Valphabeta = NULL_alphabeta;
  FOCVars[bMotor].hElAngle = (int16_t)0;

  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80020c8:	4a11      	ldr	r2, [pc, #68]	; (8002110 <FOC_Clear+0x64>)
  FOCVars[bMotor].Iab = NULL_ab;
 80020ca:	6044      	str	r4, [r0, #4]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80020cc:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
  FOCVars[bMotor].Iqd = NULL_qd;
 80020d0:	604c      	str	r4, [r1, #4]
 80020d2:	608c      	str	r4, [r1, #8]
  FOCVars[bMotor].Vqd = NULL_qd;
 80020d4:	f8c3 4006 	str.w	r4, [r3, #6]
 80020d8:	f8c3 400a 	str.w	r4, [r3, #10]
 80020dc:	f8c3 400e 	str.w	r4, [r3, #14]
  PID_SetIntegralTerm(pPIDIq[bMotor], ((int32_t)0));
 80020e0:	4621      	mov	r1, r4
 80020e2:	f007 f855 	bl	8009190 <PID_SetIntegralTerm>
  PID_SetIntegralTerm(pPIDId[bMotor], ((int32_t)0));
 80020e6:	4b0b      	ldr	r3, [pc, #44]	; (8002114 <FOC_Clear+0x68>)
 80020e8:	4621      	mov	r1, r4
 80020ea:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80020ee:	f007 f84f 	bl	8009190 <PID_SetIntegralTerm>

  STC_Clear(pSTC[bMotor]);
 80020f2:	4b09      	ldr	r3, [pc, #36]	; (8002118 <FOC_Clear+0x6c>)
 80020f4:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80020f8:	f008 f95a 	bl	800a3b0 <STC_Clear>

  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 80020fc:	4b07      	ldr	r3, [pc, #28]	; (800211c <FOC_Clear+0x70>)
 80020fe:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]

  /* USER CODE BEGIN FOC_Clear 1 */

  /* USER CODE END FOC_Clear 1 */
}
 8002102:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 8002106:	f001 b931 	b.w	800336c <PWMC_SwitchOffPWM>
 800210a:	bf00      	nop
 800210c:	20001ac4 	.word	0x20001ac4
 8002110:	200003d8 	.word	0x200003d8
 8002114:	200003d4 	.word	0x200003d4
 8002118:	200003dc 	.word	0x200003dc
 800211c:	20001af8 	.word	0x20001af8

08002120 <MCboot>:
  if (MC_NULL == pMCIList)
 8002120:	2800      	cmp	r0, #0
 8002122:	d073      	beq.n	800220c <MCboot+0xec>
{
 8002124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bMCBootCompleted = (uint8_t )0;
 8002128:	f8df 9130 	ldr.w	r9, [pc, #304]	; 800225c <MCboot+0x13c>
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 800212c:	f8df b130 	ldr.w	fp, [pc, #304]	; 8002260 <MCboot+0x140>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8002130:	4d37      	ldr	r5, [pc, #220]	; (8002210 <MCboot+0xf0>)
 8002132:	4e38      	ldr	r6, [pc, #224]	; (8002214 <MCboot+0xf4>)
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 8002134:	4f38      	ldr	r7, [pc, #224]	; (8002218 <MCboot+0xf8>)
{
 8002136:	b083      	sub	sp, #12
    bMCBootCompleted = (uint8_t )0;
 8002138:	f04f 0800 	mov.w	r8, #0
 800213c:	4604      	mov	r4, r0
    pwmcHandle[M1] = &PWM_Handle_M1._Super;
 800213e:	4837      	ldr	r0, [pc, #220]	; (800221c <MCboot+0xfc>)
 8002140:	f8cb 0000 	str.w	r0, [fp]
    bMCBootCompleted = (uint8_t )0;
 8002144:	f889 8000 	strb.w	r8, [r9]
    R3_1_Init(&PWM_Handle_M1);
 8002148:	f007 fbf8 	bl	800993c <R3_1_Init>
    ASPEP_start(&aspepOverUartA);
 800214c:	4834      	ldr	r0, [pc, #208]	; (8002220 <MCboot+0x100>)
 800214e:	f7fe fffb 	bl	8001148 <ASPEP_start>
    startTimers();
 8002152:	f007 f8cd 	bl	80092f0 <startTimers>
    PID_HandleInit(&PIDSpeedHandle_M1);
 8002156:	4833      	ldr	r0, [pc, #204]	; (8002224 <MCboot+0x104>)
 8002158:	f007 f806 	bl	8009168 <PID_HandleInit>
    ENC_Init (&ENCODER_M1);
 800215c:	4832      	ldr	r0, [pc, #200]	; (8002228 <MCboot+0x108>)
 800215e:	f006 fd19 	bl	8008b94 <ENC_Init>
    EAC_Init(&EncAlignCtrlM1,pSTC[M1],&VirtualSpeedSensorM1,&ENCODER_M1);
 8002162:	6829      	ldr	r1, [r5, #0]
 8002164:	4b30      	ldr	r3, [pc, #192]	; (8002228 <MCboot+0x108>)
 8002166:	4a31      	ldr	r2, [pc, #196]	; (800222c <MCboot+0x10c>)
 8002168:	4630      	mov	r0, r6
 800216a:	f006 fcc7 	bl	8008afc <EAC_Init>
    pEAC[M1] = &EncAlignCtrlM1;
 800216e:	4b30      	ldr	r3, [pc, #192]	; (8002230 <MCboot+0x110>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 8002170:	4a2d      	ldr	r2, [pc, #180]	; (8002228 <MCboot+0x108>)
 8002172:	492c      	ldr	r1, [pc, #176]	; (8002224 <MCboot+0x104>)
    pEAC[M1] = &EncAlignCtrlM1;
 8002174:	601e      	str	r6, [r3, #0]
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 8002176:	6828      	ldr	r0, [r5, #0]
    RVBS_Init(&BusVoltageSensor_M1);
 8002178:	4e2e      	ldr	r6, [pc, #184]	; (8002234 <MCboot+0x114>)
    STC_Init(pSTC[M1],&PIDSpeedHandle_M1, &ENCODER_M1._Super);
 800217a:	f008 f8ff 	bl	800a37c <STC_Init>
    STO_PLL_Init (&STO_PLL_M1);
 800217e:	482e      	ldr	r0, [pc, #184]	; (8002238 <MCboot+0x118>)
 8002180:	f008 fba8 	bl	800a8d4 <STO_PLL_Init>
    VSS_Init(&VirtualSpeedSensorM1);
 8002184:	4829      	ldr	r0, [pc, #164]	; (800222c <MCboot+0x10c>)
 8002186:	f008 fc21 	bl	800a9cc <VSS_Init>
    PID_HandleInit(&PIDIqHandle_M1);
 800218a:	482c      	ldr	r0, [pc, #176]	; (800223c <MCboot+0x11c>)
 800218c:	f006 ffec 	bl	8009168 <PID_HandleInit>
    PID_HandleInit(&PIDIdHandle_M1);
 8002190:	482b      	ldr	r0, [pc, #172]	; (8002240 <MCboot+0x120>)
 8002192:	f006 ffe9 	bl	8009168 <PID_HandleInit>
    (void)RCM_RegisterRegConv(&VbusRegConv_M1);
 8002196:	482b      	ldr	r0, [pc, #172]	; (8002244 <MCboot+0x124>)
 8002198:	f002 f988 	bl	80044ac <RCM_RegisterRegConv>
    RVBS_Init(&BusVoltageSensor_M1);
 800219c:	4630      	mov	r0, r6
 800219e:	f008 f847 	bl	800a230 <RVBS_Init>
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 80021a2:	4b29      	ldr	r3, [pc, #164]	; (8002248 <MCboot+0x128>)
    NTC_Init(&TempSensor_M1);
 80021a4:	4829      	ldr	r0, [pc, #164]	; (800224c <MCboot+0x12c>)
    pMPM[M1]->pVBS = &(BusVoltageSensor_M1._Super);
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	60de      	str	r6, [r3, #12]
    pMPM[M1]->pFOCVars = &FOCVars[M1];
 80021aa:	4e29      	ldr	r6, [pc, #164]	; (8002250 <MCboot+0x130>)
 80021ac:	609e      	str	r6, [r3, #8]
    NTC_Init(&TempSensor_M1);
 80021ae:	f006 ffbd 	bl	800912c <NTC_Init>
    REMNG_Init(pREMNG[M1]);
 80021b2:	4828      	ldr	r0, [pc, #160]	; (8002254 <MCboot+0x134>)
 80021b4:	f008 f896 	bl	800a2e4 <REMNG_Init>
    FOCVars[M1].bDriveInput = EXTERNAL;
 80021b8:	f04f 0a01 	mov.w	sl, #1
    FOC_Clear(M1);
 80021bc:	4640      	mov	r0, r8
 80021be:	f7ff ff75 	bl	80020ac <FOC_Clear>
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 80021c2:	6828      	ldr	r0, [r5, #0]
    FOCVars[M1].bDriveInput = EXTERNAL;
 80021c4:	f886 a024 	strb.w	sl, [r6, #36]	; 0x24
    FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
 80021c8:	f008 f97c 	bl	800a4c4 <STC_GetDefaultIqdref>
 80021cc:	6130      	str	r0, [r6, #16]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 80021ce:	6828      	ldr	r0, [r5, #0]
 80021d0:	f008 f978 	bl	800a4c4 <STC_GetDefaultIqdref>
 80021d4:	f3c0 400f 	ubfx	r0, r0, #16, #16
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 80021d8:	6829      	ldr	r1, [r5, #0]
 80021da:	f8db 3000 	ldr.w	r3, [fp]
    FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
 80021de:	82b0      	strh	r0, [r6, #20]
    MCI_Init(&Mci[M1], pSTC[M1], &FOCVars[M1],pwmcHandle[M1] );
 80021e0:	4632      	mov	r2, r6
 80021e2:	4638      	mov	r0, r7
 80021e4:	f7ff fd2c 	bl	8001c40 <MCI_Init>
   Mci[M1].pScale = &scaleParams_M1;
 80021e8:	4b1b      	ldr	r3, [pc, #108]	; (8002258 <MCboot+0x138>)
    MCI_ExecSpeedRamp(&Mci[M1],
 80021ea:	6828      	ldr	r0, [r5, #0]
   Mci[M1].pScale = &scaleParams_M1;
 80021ec:	61bb      	str	r3, [r7, #24]
    MCI_ExecSpeedRamp(&Mci[M1],
 80021ee:	f008 f965 	bl	800a4bc <STC_GetMecSpeedRefUnitDefault>
 80021f2:	4642      	mov	r2, r8
 80021f4:	4601      	mov	r1, r0
 80021f6:	4638      	mov	r0, r7
 80021f8:	f7ff fd32 	bl	8001c60 <MCI_ExecSpeedRamp>
    pMCIList[M1] = &Mci[M1];
 80021fc:	6027      	str	r7, [r4, #0]
    MC_APP_BootHook();
 80021fe:	f7ff fd1b 	bl	8001c38 <MC_APP_BootHook>
    bMCBootCompleted = 1U;
 8002202:	f889 a000 	strb.w	sl, [r9]
}
 8002206:	b003      	add	sp, #12
 8002208:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800220c:	4770      	bx	lr
 800220e:	bf00      	nop
 8002210:	200003dc 	.word	0x200003dc
 8002214:	200000a4 	.word	0x200000a4
 8002218:	20001a90 	.word	0x20001a90
 800221c:	20000154 	.word	0x20000154
 8002220:	20000450 	.word	0x20000450
 8002224:	20000118 	.word	0x20000118
 8002228:	20000024 	.word	0x20000024
 800222c:	20000398 	.word	0x20000398
 8002230:	20001af4 	.word	0x20001af4
 8002234:	20000004 	.word	0x20000004
 8002238:	20000210 	.word	0x20000210
 800223c:	200000ec 	.word	0x200000ec
 8002240:	200000c0 	.word	0x200000c0
 8002244:	20000388 	.word	0x20000388
 8002248:	200003d0 	.word	0x200003d0
 800224c:	2000036c 	.word	0x2000036c
 8002250:	20001ac4 	.word	0x20001ac4
 8002254:	200001f8 	.word	0x200001f8
 8002258:	200003f0 	.word	0x200003f0
 800225c:	20001aea 	.word	0x20001aea
 8002260:	20001af8 	.word	0x20001af8

08002264 <FOC_InitAdditionalMethods>:
    {
  /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */

  /* USER CODE END FOC_InitAdditionalMethods 0 */
    }
}
 8002264:	4770      	bx	lr
 8002266:	bf00      	nop

08002268 <FOC_CalcCurrRef>:
  *         MTPA algorithm(s). It must be called with the periodicity specified
  *         in oTSC parameters.
  * @param  bMotor related motor it can be M1 or M2.
  */
__weak void FOC_CalcCurrRef(uint8_t bMotor)
{
 8002268:	b510      	push	{r4, lr}

  /* USER CODE BEGIN FOC_CalcCurrRef 0 */

  /* USER CODE END FOC_CalcCurrRef 0 */
  if (INTERNAL == FOCVars[bMotor].bDriveInput)
 800226a:	4c08      	ldr	r4, [pc, #32]	; (800228c <FOC_CalcCurrRef+0x24>)
 800226c:	2326      	movs	r3, #38	; 0x26
 800226e:	fb03 4400 	mla	r4, r3, r0, r4
 8002272:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8002276:	b103      	cbz	r3, 800227a <FOC_CalcCurrRef+0x12>
    /* Nothing to do */
  }
  /* USER CODE BEGIN FOC_CalcCurrRef 1 */

  /* USER CODE END FOC_CalcCurrRef 1 */
}
 8002278:	bd10      	pop	{r4, pc}
    FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
 800227a:	4b05      	ldr	r3, [pc, #20]	; (8002290 <FOC_CalcCurrRef+0x28>)
 800227c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8002280:	f008 f8f2 	bl	800a468 <STC_CalcTorqueReference>
 8002284:	83e0      	strh	r0, [r4, #30]
    FOCVars[bMotor].Iqdref.q = FOCVars[bMotor].hTeref;
 8002286:	8220      	strh	r0, [r4, #16]
}
 8002288:	bd10      	pop	{r4, pc}
 800228a:	bf00      	nop
 800228c:	20001ac4 	.word	0x20001ac4
 8002290:	200003dc 	.word	0x200003dc

08002294 <TSK_SetChargeBootCapDelayM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount)
{
   hBootCapDelayCounterM1 = hTickCount;
 8002294:	4b01      	ldr	r3, [pc, #4]	; (800229c <TSK_SetChargeBootCapDelayM1+0x8>)
 8002296:	8018      	strh	r0, [r3, #0]
}
 8002298:	4770      	bx	lr
 800229a:	bf00      	nop
 800229c:	20001aec 	.word	0x20001aec

080022a0 <TSK_ChargeBootCapDelayHasElapsedM1>:
  * @retval bool true if time has elapsed, false otherwise.
  */
__weak bool TSK_ChargeBootCapDelayHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hBootCapDelayCounterM1)
 80022a0:	4b03      	ldr	r3, [pc, #12]	; (80022b0 <TSK_ChargeBootCapDelayHasElapsedM1+0x10>)
 80022a2:	8818      	ldrh	r0, [r3, #0]
 80022a4:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 80022a6:	fab0 f080 	clz	r0, r0
 80022aa:	0940      	lsrs	r0, r0, #5
 80022ac:	4770      	bx	lr
 80022ae:	bf00      	nop
 80022b0:	20001aec 	.word	0x20001aec

080022b4 <TSK_SetStopPermanencyTimeM1>:
  * @param  hTickCount number of ticks to be counted.
  * @retval void
  */
__weak void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount)
{
  hStopPermanencyCounterM1 = hTickCount;
 80022b4:	4b01      	ldr	r3, [pc, #4]	; (80022bc <TSK_SetStopPermanencyTimeM1+0x8>)
 80022b6:	8018      	strh	r0, [r3, #0]
}
 80022b8:	4770      	bx	lr
 80022ba:	bf00      	nop
 80022bc:	20001af0 	.word	0x20001af0

080022c0 <TSK_StopPermanencyTimeHasElapsedM1>:
  * @retval bool true if time is elapsed, false otherwise.
  */
__weak bool TSK_StopPermanencyTimeHasElapsedM1(void)
{
  bool retVal = false;
  if (((uint16_t)0) == hStopPermanencyCounterM1)
 80022c0:	4b03      	ldr	r3, [pc, #12]	; (80022d0 <TSK_StopPermanencyTimeHasElapsedM1+0x10>)
 80022c2:	8818      	ldrh	r0, [r3, #0]
 80022c4:	b280      	uxth	r0, r0
  {
    retVal = true;
  }
  return (retVal);
}
 80022c6:	fab0 f080 	clz	r0, r0
 80022ca:	0940      	lsrs	r0, r0, #5
 80022cc:	4770      	bx	lr
 80022ce:	bf00      	nop
 80022d0:	20001af0 	.word	0x20001af0

080022d4 <TSK_MediumFrequencyTaskM1>:
{
 80022d4:	b570      	push	{r4, r5, r6, lr}
 80022d6:	b082      	sub	sp, #8
  int16_t wAux = 0;
 80022d8:	2300      	movs	r3, #0
  (void)STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 80022da:	f10d 0106 	add.w	r1, sp, #6
 80022de:	48a1      	ldr	r0, [pc, #644]	; (8002564 <TSK_MediumFrequencyTaskM1+0x290>)
  PQD_CalcElMotorPower(pMPM[M1]);
 80022e0:	4da1      	ldr	r5, [pc, #644]	; (8002568 <TSK_MediumFrequencyTaskM1+0x294>)
  int16_t wAux = 0;
 80022e2:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 80022e6:	4ca1      	ldr	r4, [pc, #644]	; (800256c <TSK_MediumFrequencyTaskM1+0x298>)
  (void)STO_PLL_CalcAvrgMecSpeedUnit(&STO_PLL_M1, &wAux);
 80022e8:	f008 f9f4 	bl	800a6d4 <STO_PLL_CalcAvrgMecSpeedUnit>
  (void)ENC_CalcAvrgMecSpeedUnit(&ENCODER_M1, &wAux);
 80022ec:	f10d 0106 	add.w	r1, sp, #6
 80022f0:	489f      	ldr	r0, [pc, #636]	; (8002570 <TSK_MediumFrequencyTaskM1+0x29c>)
 80022f2:	f006 fcb3 	bl	8008c5c <ENC_CalcAvrgMecSpeedUnit>
  PQD_CalcElMotorPower(pMPM[M1]);
 80022f6:	6828      	ldr	r0, [r5, #0]
 80022f8:	f006 ffc0 	bl	800927c <PQD_CalcElMotorPower>
  if (MCI_GetCurrentFaults(&Mci[M1]) == MC_NO_FAULTS)
 80022fc:	4620      	mov	r0, r4
 80022fe:	f7ff fd29 	bl	8001d54 <MCI_GetCurrentFaults>
 8002302:	b118      	cbz	r0, 800230c <TSK_MediumFrequencyTaskM1+0x38>
    Mci[M1].State = FAULT_NOW;
 8002304:	230a      	movs	r3, #10
 8002306:	77e3      	strb	r3, [r4, #31]
}
 8002308:	b002      	add	sp, #8
 800230a:	bd70      	pop	{r4, r5, r6, pc}
    if (MCI_GetOccurredFaults(&Mci[M1]) == MC_NO_FAULTS)
 800230c:	4620      	mov	r0, r4
 800230e:	f7ff fd1f 	bl	8001d50 <MCI_GetOccurredFaults>
 8002312:	bb78      	cbnz	r0, 8002374 <TSK_MediumFrequencyTaskM1+0xa0>
      switch (Mci[M1].State)
 8002314:	7fe3      	ldrb	r3, [r4, #31]
 8002316:	2b14      	cmp	r3, #20
 8002318:	d8f6      	bhi.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
 800231a:	a201      	add	r2, pc, #4	; (adr r2, 8002320 <TSK_MediumFrequencyTaskM1+0x4c>)
 800231c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002320:	080024c5 	.word	0x080024c5
 8002324:	08002309 	.word	0x08002309
 8002328:	08002473 	.word	0x08002473
 800232c:	08002309 	.word	0x08002309
 8002330:	08002309 	.word	0x08002309
 8002334:	08002309 	.word	0x08002309
 8002338:	0800245f 	.word	0x0800245f
 800233c:	08002309 	.word	0x08002309
 8002340:	08002453 	.word	0x08002453
 8002344:	08002309 	.word	0x08002309
 8002348:	08002375 	.word	0x08002375
 800234c:	08002445 	.word	0x08002445
 8002350:	08002309 	.word	0x08002309
 8002354:	08002309 	.word	0x08002309
 8002358:	08002309 	.word	0x08002309
 800235c:	08002309 	.word	0x08002309
 8002360:	080023ed 	.word	0x080023ed
 8002364:	080023bb 	.word	0x080023bb
 8002368:	08002309 	.word	0x08002309
 800236c:	08002309 	.word	0x08002309
 8002370:	0800237d 	.word	0x0800237d
      Mci[M1].State = FAULT_OVER;
 8002374:	230b      	movs	r3, #11
 8002376:	77e3      	strb	r3, [r4, #31]
}
 8002378:	b002      	add	sp, #8
 800237a:	bd70      	pop	{r4, r5, r6, pc}
          if (MCI_STOP == Mci[M1].DirectCommand)
 800237c:	7fa3      	ldrb	r3, [r4, #30]
 800237e:	2b05      	cmp	r3, #5
 8002380:	f000 80b0 	beq.w	80024e4 <TSK_MediumFrequencyTaskM1+0x210>
            if (TSK_StopPermanencyTimeHasElapsedM1())
 8002384:	f7ff ff9c 	bl	80022c0 <TSK_StopPermanencyTimeHasElapsedM1>
 8002388:	2800      	cmp	r0, #0
 800238a:	d0bd      	beq.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
              ENC_Clear(&ENCODER_M1);
 800238c:	4878      	ldr	r0, [pc, #480]	; (8002570 <TSK_MediumFrequencyTaskM1+0x29c>)
 800238e:	f006 fc3d 	bl	8008c0c <ENC_Clear>
              R3_1_SwitchOnPWM(pwmcHandle[M1]);
 8002392:	4b78      	ldr	r3, [pc, #480]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
 8002394:	6818      	ldr	r0, [r3, #0]
 8002396:	f007 f92b 	bl	80095f0 <R3_1_SwitchOnPWM>
              FOC_InitAdditionalMethods(M1);
 800239a:	2000      	movs	r0, #0
 800239c:	f7ff ff62 	bl	8002264 <FOC_InitAdditionalMethods>
              STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 80023a0:	4b75      	ldr	r3, [pc, #468]	; (8002578 <TSK_MediumFrequencyTaskM1+0x2a4>)
 80023a2:	6818      	ldr	r0, [r3, #0]
 80023a4:	f008 f89c 	bl	800a4e0 <STC_ForceSpeedReferenceToCurrentSpeed>
              MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 80023a8:	4870      	ldr	r0, [pc, #448]	; (800256c <TSK_MediumFrequencyTaskM1+0x298>)
 80023aa:	f7ff fc93 	bl	8001cd4 <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 80023ae:	2000      	movs	r0, #0
 80023b0:	f7ff ff5a 	bl	8002268 <FOC_CalcCurrRef>
              Mci[M1].State = RUN;
 80023b4:	2306      	movs	r3, #6
 80023b6:	77e3      	strb	r3, [r4, #31]
 80023b8:	e7a6      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 80023ba:	7fa3      	ldrb	r3, [r4, #30]
 80023bc:	2b05      	cmp	r3, #5
 80023be:	f000 8091 	beq.w	80024e4 <TSK_MediumFrequencyTaskM1+0x210>
            if (PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC))
 80023c2:	4e6c      	ldr	r6, [pc, #432]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
 80023c4:	2101      	movs	r1, #1
 80023c6:	6830      	ldr	r0, [r6, #0]
 80023c8:	f000 ffd4 	bl	8003374 <PWMC_CurrentReadingCalibr>
 80023cc:	2800      	cmp	r0, #0
 80023ce:	d09b      	beq.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
              if (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand)
 80023d0:	7fa3      	ldrb	r3, [r4, #30]
 80023d2:	2b03      	cmp	r3, #3
 80023d4:	f000 80a6 	beq.w	8002524 <TSK_MediumFrequencyTaskM1+0x250>
                R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 80023d8:	6830      	ldr	r0, [r6, #0]
 80023da:	2100      	movs	r1, #0
 80023dc:	f007 fa10 	bl	8009800 <R3_1_TurnOnLowSides>
                TSK_SetChargeBootCapDelayM1(M1_CHARGE_BOOT_CAP_TICKS);
 80023e0:	2014      	movs	r0, #20
 80023e2:	f7ff ff57 	bl	8002294 <TSK_SetChargeBootCapDelayM1>
                Mci[M1].State = CHARGE_BOOT_CAP;
 80023e6:	2310      	movs	r3, #16
 80023e8:	77e3      	strb	r3, [r4, #31]
 80023ea:	e78d      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 80023ec:	7fa3      	ldrb	r3, [r4, #30]
 80023ee:	2b05      	cmp	r3, #5
 80023f0:	d078      	beq.n	80024e4 <TSK_MediumFrequencyTaskM1+0x210>
            if (TSK_ChargeBootCapDelayHasElapsedM1())
 80023f2:	f7ff ff55 	bl	80022a0 <TSK_ChargeBootCapDelayHasElapsedM1>
 80023f6:	2800      	cmp	r0, #0
 80023f8:	d086      	beq.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 80023fa:	4d5e      	ldr	r5, [pc, #376]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 80023fc:	4e5e      	ldr	r6, [pc, #376]	; (8002578 <TSK_MediumFrequencyTaskM1+0x2a4>)
              R3_1_SwitchOffPWM(pwmcHandle[M1]);
 80023fe:	6828      	ldr	r0, [r5, #0]
 8002400:	f007 f942 	bl	8009688 <R3_1_SwitchOffPWM>
              FOCVars[M1].bDriveInput = EXTERNAL;
 8002404:	4b5d      	ldr	r3, [pc, #372]	; (800257c <TSK_MediumFrequencyTaskM1+0x2a8>)
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8002406:	495e      	ldr	r1, [pc, #376]	; (8002580 <TSK_MediumFrequencyTaskM1+0x2ac>)
 8002408:	6830      	ldr	r0, [r6, #0]
              FOCVars[M1].bDriveInput = EXTERNAL;
 800240a:	2201      	movs	r2, #1
 800240c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
 8002410:	f007 ffca 	bl	800a3a8 <STC_SetSpeedSensor>
              ENC_Clear(&ENCODER_M1);
 8002414:	4856      	ldr	r0, [pc, #344]	; (8002570 <TSK_MediumFrequencyTaskM1+0x29c>)
 8002416:	f006 fbf9 	bl	8008c0c <ENC_Clear>
              STO_PLL_Clear(&STO_PLL_M1);
 800241a:	4852      	ldr	r0, [pc, #328]	; (8002564 <TSK_MediumFrequencyTaskM1+0x290>)
 800241c:	f008 fa34 	bl	800a888 <STO_PLL_Clear>
              FOC_Clear( M1 );
 8002420:	2000      	movs	r0, #0
 8002422:	f7ff fe43 	bl	80020ac <FOC_Clear>
              if (EAC_IsAligned(&EncAlignCtrlM1) == false)
 8002426:	4857      	ldr	r0, [pc, #348]	; (8002584 <TSK_MediumFrequencyTaskM1+0x2b0>)
 8002428:	f006 fbb0 	bl	8008b8c <EAC_IsAligned>
 800242c:	2800      	cmp	r0, #0
 800242e:	f040 8082 	bne.w	8002536 <TSK_MediumFrequencyTaskM1+0x262>
                EAC_StartAlignment(&EncAlignCtrlM1);
 8002432:	4854      	ldr	r0, [pc, #336]	; (8002584 <TSK_MediumFrequencyTaskM1+0x2b0>)
 8002434:	f006 fb6a 	bl	8008b0c <EAC_StartAlignment>
                Mci[M1].State = ALIGNMENT;
 8002438:	2302      	movs	r3, #2
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 800243a:	6828      	ldr	r0, [r5, #0]
                Mci[M1].State = ALIGNMENT;
 800243c:	77e3      	strb	r3, [r4, #31]
              PWMC_SwitchOnPWM(pwmcHandle[M1]);
 800243e:	f000 ff97 	bl	8003370 <PWMC_SwitchOnPWM>
 8002442:	e761      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_ACK_FAULTS == Mci[M1].DirectCommand)
 8002444:	7fa3      	ldrb	r3, [r4, #30]
 8002446:	2b02      	cmp	r3, #2
 8002448:	f47f af5e 	bne.w	8002308 <TSK_MediumFrequencyTaskM1+0x34>
            Mci[M1].DirectCommand = MCI_NO_COMMAND;
 800244c:	2300      	movs	r3, #0
 800244e:	83e3      	strh	r3, [r4, #30]
 8002450:	e75a      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if (TSK_StopPermanencyTimeHasElapsedM1())
 8002452:	f7ff ff35 	bl	80022c0 <TSK_StopPermanencyTimeHasElapsedM1>
 8002456:	2800      	cmp	r0, #0
 8002458:	f43f af56 	beq.w	8002308 <TSK_MediumFrequencyTaskM1+0x34>
 800245c:	e7f6      	b.n	800244c <TSK_MediumFrequencyTaskM1+0x178>
          if (MCI_STOP == Mci[M1].DirectCommand)
 800245e:	7fa3      	ldrb	r3, [r4, #30]
 8002460:	2b05      	cmp	r3, #5
 8002462:	d03f      	beq.n	80024e4 <TSK_MediumFrequencyTaskM1+0x210>
            MCI_ExecBufferedCommands(&Mci[M1]);
 8002464:	4841      	ldr	r0, [pc, #260]	; (800256c <TSK_MediumFrequencyTaskM1+0x298>)
 8002466:	f7ff fc35 	bl	8001cd4 <MCI_ExecBufferedCommands>
              FOC_CalcCurrRef(M1);
 800246a:	2000      	movs	r0, #0
 800246c:	f7ff fefc 	bl	8002268 <FOC_CalcCurrRef>
 8002470:	e74a      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if (MCI_STOP == Mci[M1].DirectCommand)
 8002472:	7fa3      	ldrb	r3, [r4, #30]
 8002474:	2b05      	cmp	r3, #5
 8002476:	d035      	beq.n	80024e4 <TSK_MediumFrequencyTaskM1+0x210>
            bool isAligned = EAC_IsAligned(&EncAlignCtrlM1);
 8002478:	4842      	ldr	r0, [pc, #264]	; (8002584 <TSK_MediumFrequencyTaskM1+0x2b0>)
 800247a:	f006 fb87 	bl	8008b8c <EAC_IsAligned>
 800247e:	4605      	mov	r5, r0
            bool EACDone = EAC_Exec(&EncAlignCtrlM1);
 8002480:	4840      	ldr	r0, [pc, #256]	; (8002584 <TSK_MediumFrequencyTaskM1+0x2b0>)
 8002482:	f006 fb6b 	bl	8008b5c <EAC_Exec>
 8002486:	4606      	mov	r6, r0
            if ((isAligned == false)  && (EACDone == false))
 8002488:	b90d      	cbnz	r5, 800248e <TSK_MediumFrequencyTaskM1+0x1ba>
 800248a:	2800      	cmp	r0, #0
 800248c:	d042      	beq.n	8002514 <TSK_MediumFrequencyTaskM1+0x240>
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 800248e:	4d39      	ldr	r5, [pc, #228]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8002490:	4e39      	ldr	r6, [pc, #228]	; (8002578 <TSK_MediumFrequencyTaskM1+0x2a4>)
              R3_1_SwitchOffPWM( pwmcHandle[M1] );
 8002492:	6828      	ldr	r0, [r5, #0]
 8002494:	f007 f8f8 	bl	8009688 <R3_1_SwitchOffPWM>
              STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8002498:	6830      	ldr	r0, [r6, #0]
 800249a:	2103      	movs	r1, #3
 800249c:	f007 ff98 	bl	800a3d0 <STC_SetControlMode>
              STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 80024a0:	4933      	ldr	r1, [pc, #204]	; (8002570 <TSK_MediumFrequencyTaskM1+0x29c>)
 80024a2:	6830      	ldr	r0, [r6, #0]
 80024a4:	f007 ff80 	bl	800a3a8 <STC_SetSpeedSensor>
              FOC_Clear(M1);
 80024a8:	2000      	movs	r0, #0
 80024aa:	f7ff fdff 	bl	80020ac <FOC_Clear>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 80024ae:	6828      	ldr	r0, [r5, #0]
 80024b0:	2100      	movs	r1, #0
 80024b2:	f007 f9a5 	bl	8009800 <R3_1_TurnOnLowSides>
              TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 80024b6:	f44f 7048 	mov.w	r0, #800	; 0x320
 80024ba:	f7ff fefb 	bl	80022b4 <TSK_SetStopPermanencyTimeM1>
              Mci[M1].State = WAIT_STOP_MOTOR;
 80024be:	2314      	movs	r3, #20
 80024c0:	77e3      	strb	r3, [r4, #31]
 80024c2:	e721      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
          if ((MCI_START == Mci[M1].DirectCommand) || (MCI_MEASURE_OFFSETS == Mci[M1].DirectCommand))
 80024c4:	7fa3      	ldrb	r3, [r4, #30]
 80024c6:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 80024ca:	2b01      	cmp	r3, #1
 80024cc:	f47f af1c 	bne.w	8002308 <TSK_MediumFrequencyTaskM1+0x34>
            if (pwmcHandle[M1]->offsetCalibStatus == false)
 80024d0:	4d28      	ldr	r5, [pc, #160]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
 80024d2:	6828      	ldr	r0, [r5, #0]
 80024d4:	f890 1081 	ldrb.w	r1, [r0, #129]	; 0x81
 80024d8:	b9a9      	cbnz	r1, 8002506 <TSK_MediumFrequencyTaskM1+0x232>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_START);
 80024da:	f000 ff4b 	bl	8003374 <PWMC_CurrentReadingCalibr>
              Mci[M1].State = OFFSET_CALIB;
 80024de:	2311      	movs	r3, #17
 80024e0:	77e3      	strb	r3, [r4, #31]
 80024e2:	e711      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
    R3_1_SwitchOffPWM(pwmcHandle[motor]);
 80024e4:	4b23      	ldr	r3, [pc, #140]	; (8002574 <TSK_MediumFrequencyTaskM1+0x2a0>)
 80024e6:	6818      	ldr	r0, [r3, #0]
 80024e8:	f007 f8ce 	bl	8009688 <R3_1_SwitchOffPWM>
  FOC_Clear(motor);
 80024ec:	2000      	movs	r0, #0
 80024ee:	f7ff fddd 	bl	80020ac <FOC_Clear>
  PQD_Clear(pMPM[motor]);
 80024f2:	6828      	ldr	r0, [r5, #0]
 80024f4:	f006 fede 	bl	80092b4 <PQD_Clear>
  TSK_SetStopPermanencyTimeM1(STOPPERMANENCY_TICKS);
 80024f8:	f44f 7048 	mov.w	r0, #800	; 0x320
 80024fc:	f7ff feda 	bl	80022b4 <TSK_SetStopPermanencyTimeM1>
  Mci[motor].State = STOP;
 8002500:	2308      	movs	r3, #8
 8002502:	77e3      	strb	r3, [r4, #31]
}
 8002504:	e700      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 8002506:	4619      	mov	r1, r3
              pwmcHandle[M1]->OffCalibrWaitTimeCounter = 1u;
 8002508:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
              (void)PWMC_CurrentReadingCalibr(pwmcHandle[M1], CRC_EXEC);
 800250c:	f000 ff32 	bl	8003374 <PWMC_CurrentReadingCalibr>
              R3_1_TurnOnLowSides(pwmcHandle[M1],M1_CHARGE_BOOT_CAP_DUTY_CYCLES);
 8002510:	6828      	ldr	r0, [r5, #0]
 8002512:	e762      	b.n	80023da <TSK_MediumFrequencyTaskM1+0x106>
              IqdRef.d = STC_CalcTorqueReference(pSTC[M1]);
 8002514:	4b18      	ldr	r3, [pc, #96]	; (8002578 <TSK_MediumFrequencyTaskM1+0x2a4>)
 8002516:	6818      	ldr	r0, [r3, #0]
 8002518:	f007 ffa6 	bl	800a468 <STC_CalcTorqueReference>
              FOCVars[M1].Iqdref = IqdRef;
 800251c:	4b17      	ldr	r3, [pc, #92]	; (800257c <TSK_MediumFrequencyTaskM1+0x2a8>)
 800251e:	821e      	strh	r6, [r3, #16]
 8002520:	8258      	strh	r0, [r3, #18]
            {
 8002522:	e6f1      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
                FOC_Clear(M1);
 8002524:	2000      	movs	r0, #0
 8002526:	f7ff fdc1 	bl	80020ac <FOC_Clear>
                PQD_Clear(pMPM[M1]);
 800252a:	6828      	ldr	r0, [r5, #0]
 800252c:	f006 fec2 	bl	80092b4 <PQD_Clear>
                Mci[M1].DirectCommand = MCI_NO_COMMAND;
 8002530:	2300      	movs	r3, #0
 8002532:	83e3      	strh	r3, [r4, #30]
 8002534:	e6e8      	b.n	8002308 <TSK_MediumFrequencyTaskM1+0x34>
                STC_SetControlMode(pSTC[M1], MCM_SPEED_MODE);
 8002536:	6830      	ldr	r0, [r6, #0]
 8002538:	2103      	movs	r1, #3
 800253a:	f007 ff49 	bl	800a3d0 <STC_SetControlMode>
                STC_SetSpeedSensor(pSTC[M1], &ENCODER_M1._Super);
 800253e:	490c      	ldr	r1, [pc, #48]	; (8002570 <TSK_MediumFrequencyTaskM1+0x29c>)
 8002540:	6830      	ldr	r0, [r6, #0]
 8002542:	f007 ff31 	bl	800a3a8 <STC_SetSpeedSensor>
                FOC_InitAdditionalMethods(M1);
 8002546:	2000      	movs	r0, #0
 8002548:	f7ff fe8c 	bl	8002264 <FOC_InitAdditionalMethods>
                FOC_CalcCurrRef(M1);
 800254c:	2000      	movs	r0, #0
 800254e:	f7ff fe8b 	bl	8002268 <FOC_CalcCurrRef>
                STC_ForceSpeedReferenceToCurrentSpeed(pSTC[M1]); /* Init the reference speed to current speed */
 8002552:	6830      	ldr	r0, [r6, #0]
 8002554:	f007 ffc4 	bl	800a4e0 <STC_ForceSpeedReferenceToCurrentSpeed>
                MCI_ExecBufferedCommands(&Mci[M1]); /* Exec the speed ramp after changing of the speed sensor */
 8002558:	4804      	ldr	r0, [pc, #16]	; (800256c <TSK_MediumFrequencyTaskM1+0x298>)
 800255a:	f7ff fbbb 	bl	8001cd4 <MCI_ExecBufferedCommands>
 800255e:	2306      	movs	r3, #6
 8002560:	e76b      	b.n	800243a <TSK_MediumFrequencyTaskM1+0x166>
 8002562:	bf00      	nop
 8002564:	20000210 	.word	0x20000210
 8002568:	200003d0 	.word	0x200003d0
 800256c:	20001a90 	.word	0x20001a90
 8002570:	20000024 	.word	0x20000024
 8002574:	20001af8 	.word	0x20001af8
 8002578:	200003dc 	.word	0x200003dc
 800257c:	20001ac4 	.word	0x20001ac4
 8002580:	20000398 	.word	0x20000398
 8002584:	200000a4 	.word	0x200000a4

08002588 <MC_Scheduler>:
  if (((uint8_t)1) == bMCBootCompleted)
 8002588:	4b1d      	ldr	r3, [pc, #116]	; (8002600 <MC_Scheduler+0x78>)
 800258a:	781b      	ldrb	r3, [r3, #0]
 800258c:	2b01      	cmp	r3, #1
 800258e:	d000      	beq.n	8002592 <MC_Scheduler+0xa>
 8002590:	4770      	bx	lr
{
 8002592:	b570      	push	{r4, r5, r6, lr}
    if(hMFTaskCounterM1 > 0u)
 8002594:	4c1b      	ldr	r4, [pc, #108]	; (8002604 <MC_Scheduler+0x7c>)
 8002596:	8823      	ldrh	r3, [r4, #0]
 8002598:	b19b      	cbz	r3, 80025c2 <MC_Scheduler+0x3a>
      hMFTaskCounterM1--;
 800259a:	3b01      	subs	r3, #1
 800259c:	b29b      	uxth	r3, r3
    if(hBootCapDelayCounterM1 > 0U)
 800259e:	4a1a      	ldr	r2, [pc, #104]	; (8002608 <MC_Scheduler+0x80>)
      hMFTaskCounterM1--;
 80025a0:	8023      	strh	r3, [r4, #0]
    if(hBootCapDelayCounterM1 > 0U)
 80025a2:	8813      	ldrh	r3, [r2, #0]
 80025a4:	b29b      	uxth	r3, r3
 80025a6:	b11b      	cbz	r3, 80025b0 <MC_Scheduler+0x28>
      hBootCapDelayCounterM1--;
 80025a8:	8813      	ldrh	r3, [r2, #0]
 80025aa:	3b01      	subs	r3, #1
 80025ac:	b29b      	uxth	r3, r3
 80025ae:	8013      	strh	r3, [r2, #0]
    if(hStopPermanencyCounterM1 > 0U)
 80025b0:	4a16      	ldr	r2, [pc, #88]	; (800260c <MC_Scheduler+0x84>)
 80025b2:	8813      	ldrh	r3, [r2, #0]
 80025b4:	b29b      	uxth	r3, r3
 80025b6:	b11b      	cbz	r3, 80025c0 <MC_Scheduler+0x38>
      hStopPermanencyCounterM1--;
 80025b8:	8813      	ldrh	r3, [r2, #0]
 80025ba:	3b01      	subs	r3, #1
 80025bc:	b29b      	uxth	r3, r3
 80025be:	8013      	strh	r3, [r2, #0]
}
 80025c0:	bd70      	pop	{r4, r5, r6, pc}
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 80025c2:	4d13      	ldr	r5, [pc, #76]	; (8002610 <MC_Scheduler+0x88>)
      TSK_MediumFrequencyTaskM1();
 80025c4:	f7ff fe86 	bl	80022d4 <TSK_MediumFrequencyTaskM1>
      MC_APP_PostMediumFrequencyHook_M1();
 80025c8:	f7ff fb38 	bl	8001c3c <MC_APP_PostMediumFrequencyHook_M1>
      MCP_Over_UartA.rxBuffer = MCP_Over_UartA.pTransportLayer->fRXPacketProcess(MCP_Over_UartA.pTransportLayer,
 80025cc:	4629      	mov	r1, r5
 80025ce:	f851 0b0c 	ldr.w	r0, [r1], #12
 80025d2:	6883      	ldr	r3, [r0, #8]
 80025d4:	4798      	blx	r3
 80025d6:	6068      	str	r0, [r5, #4]
      if ( 0U == MCP_Over_UartA.rxBuffer)
 80025d8:	b130      	cbz	r0, 80025e8 <MC_Scheduler+0x60>
        if (0U == MCP_Over_UartA.pTransportLayer->fGetBuffer(MCP_Over_UartA.pTransportLayer,
 80025da:	4629      	mov	r1, r5
 80025dc:	220a      	movs	r2, #10
 80025de:	f851 0b08 	ldr.w	r0, [r1], #8
 80025e2:	6803      	ldr	r3, [r0, #0]
 80025e4:	4798      	blx	r3
 80025e6:	b908      	cbnz	r0, 80025ec <MC_Scheduler+0x64>
{
 80025e8:	2301      	movs	r3, #1
 80025ea:	e7d8      	b.n	800259e <MC_Scheduler+0x16>
          MCP_ReceivedPacket(&MCP_Over_UartA);
 80025ec:	4628      	mov	r0, r5
 80025ee:	f000 fa59 	bl	8002aa4 <MCP_ReceivedPacket>
          MCP_Over_UartA.pTransportLayer->fSendPacket(MCP_Over_UartA.pTransportLayer, MCP_Over_UartA.txBuffer,
 80025f2:	6828      	ldr	r0, [r5, #0]
 80025f4:	89ea      	ldrh	r2, [r5, #14]
 80025f6:	6846      	ldr	r6, [r0, #4]
 80025f8:	68a9      	ldr	r1, [r5, #8]
 80025fa:	230a      	movs	r3, #10
 80025fc:	47b0      	blx	r6
 80025fe:	e7f3      	b.n	80025e8 <MC_Scheduler+0x60>
 8002600:	20001aea 	.word	0x20001aea
 8002604:	20001aee 	.word	0x20001aee
 8002608:	20001aec 	.word	0x20001aec
 800260c:	20001af0 	.word	0x20001af0
 8002610:	2000042c 	.word	0x2000042c

08002614 <TSK_HighFrequencyTask>:
  * subsystem (see the state machine(s)).
  *
  * @retval Number of the  motor instance which FOC loop was executed.
  */
__weak uint8_t TSK_HighFrequencyTask(void)
{
 8002614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* USER CODE BEGIN HighFrequencyTask 0 */

  /* USER CODE END HighFrequencyTask 0 */

  Observer_Inputs_t STO_aux_Inputs; /* Only if sensorless aux */
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8002618:	4c3e      	ldr	r4, [pc, #248]	; (8002714 <TSK_HighFrequencyTask+0x100>)
  int16_t hElAngle;
  uint16_t hCodeError;
  SpeednPosFdbk_Handle_t *speedHandle;
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
  hElAngle = SPD_GetElAngle(speedHandle);
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 800261a:	4f3f      	ldr	r7, [pc, #252]	; (8002718 <TSK_HighFrequencyTask+0x104>)
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 800261c:	f8d4 001a 	ldr.w	r0, [r4, #26]
{
 8002620:	b088      	sub	sp, #32
  STO_aux_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* Only if sensorless */
 8002622:	9005      	str	r0, [sp, #20]
  (void)ENC_CalcAngle(&ENCODER_M1);   /* If not sensorless then 2nd parameter is MC_NULL */
 8002624:	483d      	ldr	r0, [pc, #244]	; (800271c <TSK_HighFrequencyTask+0x108>)
 8002626:	f006 faff 	bl	8008c28 <ENC_CalcAngle>
  speedHandle = STC_GetSpeedSensor(pSTC[M1]);
 800262a:	4b3d      	ldr	r3, [pc, #244]	; (8002720 <TSK_HighFrequencyTask+0x10c>)
 800262c:	6818      	ldr	r0, [r3, #0]
 800262e:	f007 febd 	bl	800a3ac <STC_GetSpeedSensor>
 8002632:	4680      	mov	r8, r0
  hElAngle = SPD_GetElAngle(speedHandle);
 8002634:	f007 fe5e 	bl	800a2f4 <SPD_GetElAngle>
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 8002638:	a902      	add	r1, sp, #8
  hElAngle = SPD_GetElAngle(speedHandle);
 800263a:	4605      	mov	r5, r0
  PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
 800263c:	6838      	ldr	r0, [r7, #0]
 800263e:	f000 fd01 	bl	8003044 <PWMC_GetPhaseCurrents>
  RCM_ReadOngoingConv();
 8002642:	f002 f989 	bl	8004958 <RCM_ReadOngoingConv>
  RCM_ExecNextConv();
 8002646:	f002 f937 	bl	80048b8 <RCM_ExecNextConv>
  Ialphabeta = MCM_Clarke(Iab);
 800264a:	9802      	ldr	r0, [sp, #8]
 800264c:	f7ff fc7c 	bl	8001f48 <MCM_Clarke>
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8002650:	4629      	mov	r1, r5
  Ialphabeta = MCM_Clarke(Iab);
 8002652:	9003      	str	r0, [sp, #12]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 8002654:	f7ff fcb8 	bl	8001fc8 <MCM_Park>
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8002658:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
  Iqd = MCM_Park(Ialphabeta, hElAngle);
 800265c:	9000      	str	r0, [sp, #0]
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 800265e:	b203      	sxth	r3, r0
 8002660:	1ac9      	subs	r1, r1, r3
 8002662:	4b30      	ldr	r3, [pc, #192]	; (8002724 <TSK_HighFrequencyTask+0x110>)
 8002664:	6818      	ldr	r0, [r3, #0]
 8002666:	f006 fdc5 	bl	80091f4 <PI_Controller>
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 800266a:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 800266e:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8002672:	1ac9      	subs	r1, r1, r3
 8002674:	4b2c      	ldr	r3, [pc, #176]	; (8002728 <TSK_HighFrequencyTask+0x114>)
  Vqd.q = PI_Controller(pPIDIq[M1], (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
 8002676:	4606      	mov	r6, r0
  Vqd.d = PI_Controller(pPIDId[M1], (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
 8002678:	6818      	ldr	r0, [r3, #0]
 800267a:	f006 fdbb 	bl	80091f4 <PI_Controller>
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 800267e:	f8ad 6004 	strh.w	r6, [sp, #4]
 8002682:	f8ad 0006 	strh.w	r0, [sp, #6]
 8002686:	9901      	ldr	r1, [sp, #4]
 8002688:	4828      	ldr	r0, [pc, #160]	; (800272c <TSK_HighFrequencyTask+0x118>)
 800268a:	f006 fa07 	bl	8008a9c <Circle_Limitation>
 800268e:	4606      	mov	r6, r0
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
 8002690:	4640      	mov	r0, r8
  Vqd = Circle_Limitation(&CircleLimitationM1, Vqd);
 8002692:	9601      	str	r6, [sp, #4]
  hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
 8002694:	f007 fe36 	bl	800a304 <SPD_GetInstElSpeedDpp>
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 8002698:	4629      	mov	r1, r5
 800269a:	9801      	ldr	r0, [sp, #4]
 800269c:	f7ff fcd6 	bl	800204c <MCM_Rev_Park>
 80026a0:	4601      	mov	r1, r0
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026a2:	6838      	ldr	r0, [r7, #0]
  Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
 80026a4:	9104      	str	r1, [sp, #16]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026a6:	f000 fccf 	bl	8003048 <PWMC_SetPhaseVoltage>

  FOCVars[M1].Vqd = Vqd;
  FOCVars[M1].Iab = Iab;
  FOCVars[M1].Ialphabeta = Ialphabeta;
 80026aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
 80026ae:	4601      	mov	r1, r0
  FOCVars[M1].Ialphabeta = Ialphabeta;
 80026b0:	e9c4 2300 	strd	r2, r3, [r4]
  FOCVars[M1].Iqd = Iqd;
  FOCVars[M1].Valphabeta = Valphabeta;
 80026b4:	9804      	ldr	r0, [sp, #16]
  FOCVars[M1].Iqd = Iqd;
 80026b6:	9a00      	ldr	r2, [sp, #0]
  FOCVars[M1].hElAngle = hElAngle;
 80026b8:	8425      	strh	r5, [r4, #32]
  if(hFOCreturn == MC_DURATION)
 80026ba:	2901      	cmp	r1, #1
  FOCVars[M1].Vqd = Vqd;
 80026bc:	f8c4 6016 	str.w	r6, [r4, #22]
  FOCVars[M1].Iqd = Iqd;
 80026c0:	60e2      	str	r2, [r4, #12]
  FOCVars[M1].Valphabeta = Valphabeta;
 80026c2:	f8c4 001a 	str.w	r0, [r4, #26]
  if(hFOCreturn == MC_DURATION)
 80026c6:	d019      	beq.n	80026fc <TSK_HighFrequencyTask+0xe8>
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 80026c8:	4819      	ldr	r0, [pc, #100]	; (8002730 <TSK_HighFrequencyTask+0x11c>)
    STO_aux_Inputs.Ialfa_beta = FOCVars[M1].Ialphabeta; /* Only if sensorless */
 80026ca:	9306      	str	r3, [sp, #24]
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 80026cc:	f006 f9de 	bl	8008a8c <VBS_GetAvBusVoltage_d>
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 80026d0:	a905      	add	r1, sp, #20
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 80026d2:	4603      	mov	r3, r0
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 80026d4:	4817      	ldr	r0, [pc, #92]	; (8002734 <TSK_HighFrequencyTask+0x120>)
    STO_aux_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(BusVoltageSensor_M1._Super)); /* Only for sensorless */
 80026d6:	f8ad 301c 	strh.w	r3, [sp, #28]
    (void)( void )STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_aux_Inputs);
 80026da:	f007 ff09 	bl	800a4f0 <STO_PLL_CalcElAngle>
    STO_PLL_CalcAvrgElSpeedDpp (&STO_PLL_M1);
 80026de:	4815      	ldr	r0, [pc, #84]	; (8002734 <TSK_HighFrequencyTask+0x120>)
 80026e0:	f008 f8a0 	bl	800a824 <STO_PLL_CalcAvrgElSpeedDpp>
  GLOBAL_TIMESTAMP++;
 80026e4:	4a14      	ldr	r2, [pc, #80]	; (8002738 <TSK_HighFrequencyTask+0x124>)
  if (0U == MCPA_UART_A.Mark)
 80026e6:	4815      	ldr	r0, [pc, #84]	; (800273c <TSK_HighFrequencyTask+0x128>)
  GLOBAL_TIMESTAMP++;
 80026e8:	6813      	ldr	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 80026ea:	f890 1029 	ldrb.w	r1, [r0, #41]	; 0x29
  GLOBAL_TIMESTAMP++;
 80026ee:	3301      	adds	r3, #1
 80026f0:	6013      	str	r3, [r2, #0]
  if (0U == MCPA_UART_A.Mark)
 80026f2:	b941      	cbnz	r1, 8002706 <TSK_HighFrequencyTask+0xf2>
}
 80026f4:	2000      	movs	r0, #0
 80026f6:	b008      	add	sp, #32
 80026f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MCI_FaultProcessing(&Mci[M1], MC_DURATION, 0);
 80026fc:	4810      	ldr	r0, [pc, #64]	; (8002740 <TSK_HighFrequencyTask+0x12c>)
 80026fe:	2200      	movs	r2, #0
 8002700:	f7ff fadc 	bl	8001cbc <MCI_FaultProcessing>
 8002704:	e7ee      	b.n	80026e4 <TSK_HighFrequencyTask+0xd0>
    MCPA_dataLog (&MCPA_UART_A);
 8002706:	f006 fba5 	bl	8008e54 <MCPA_dataLog>
}
 800270a:	2000      	movs	r0, #0
 800270c:	b008      	add	sp, #32
 800270e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002712:	bf00      	nop
 8002714:	20001ac4 	.word	0x20001ac4
 8002718:	20001af8 	.word	0x20001af8
 800271c:	20000024 	.word	0x20000024
 8002720:	200003dc 	.word	0x200003dc
 8002724:	200003d8 	.word	0x200003d8
 8002728:	200003d4 	.word	0x200003d4
 800272c:	20000020 	.word	0x20000020
 8002730:	20000004 	.word	0x20000004
 8002734:	20000210 	.word	0x20000210
 8002738:	200030a8 	.word	0x200030a8
 800273c:	20000400 	.word	0x20000400
 8002740:	20001a90 	.word	0x20001a90

08002744 <TSK_SafetyTask_PWMOFF>:
  * @brief  Safety task implementation if  MC.M1_ON_OVER_VOLTAGE == TURN_OFF_PWM.
  * @param  bMotor Motor reference number defined
  *         \link Motors_reference_number here \endlink.
  */
__weak void TSK_SafetyTask_PWMOFF(uint8_t bMotor)
{
 8002744:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE END TSK_SafetyTask_PWMOFF 0 */
  uint16_t CodeReturn = MC_NO_ERROR;
  const uint16_t errMask[NBR_OF_MOTORS] = {VBUS_TEMP_ERR_MASK};
  /* Check for fault if FW protection is activated. It returns MC_OVER_TEMP or MC_NO_ERROR */
  CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[bMotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 8002746:	4e21      	ldr	r6, [pc, #132]	; (80027cc <TSK_SafetyTask_PWMOFF+0x88>)
{
 8002748:	b082      	sub	sp, #8
 800274a:	4604      	mov	r4, r0
  CodeReturn |= PWMC_IsFaultOccurred(pwmcHandle[bMotor]);     /* check for fault. It return MC_OVER_CURR or MC_NO_FAULTS
 800274c:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 8002750:	f000 fe42 	bl	80033d8 <PWMC_IsFaultOccurred>
 8002754:	4605      	mov	r5, r0
                                                    (for STM32F30x can return MC_OVER_VOLT in case of HW Overvoltage) */
  if (M1 == bMotor)
 8002756:	b354      	cbz	r4, 80027ae <TSK_SafetyTask_PWMOFF+0x6a>
  }
  else
  {
    /* Nothing to do */
  }
  MCI_FaultProcessing(&Mci[bMotor], CodeReturn, ~CodeReturn); /* Process faults */
 8002758:	481d      	ldr	r0, [pc, #116]	; (80027d0 <TSK_SafetyTask_PWMOFF+0x8c>)
 800275a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800275e:	43ea      	mvns	r2, r5
 8002760:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 8002764:	b292      	uxth	r2, r2
 8002766:	4629      	mov	r1, r5
 8002768:	9001      	str	r0, [sp, #4]
 800276a:	f7ff faa7 	bl	8001cbc <MCI_FaultProcessing>

  if (MCI_GetFaultState(&Mci[bMotor]) != (uint32_t)MC_NO_FAULTS)
 800276e:	9801      	ldr	r0, [sp, #4]
 8002770:	f7ff fb54 	bl	8001e1c <MCI_GetFaultState>
 8002774:	b1c8      	cbz	r0, 80027aa <TSK_SafetyTask_PWMOFF+0x66>
  {
    /* Reset Encoder state */
    if (pEAC[bMotor] != MC_NULL)
 8002776:	4b17      	ldr	r3, [pc, #92]	; (80027d4 <TSK_SafetyTask_PWMOFF+0x90>)
 8002778:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800277c:	b110      	cbz	r0, 8002784 <TSK_SafetyTask_PWMOFF+0x40>
    {
      EAC_SetRestartState(pEAC[bMotor], false);
 800277e:	2100      	movs	r1, #0
 8002780:	f006 fa06 	bl	8008b90 <EAC_SetRestartState>
    }
    else
    {
      /* Nothing to do */
    }
    PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
 8002784:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8002788:	f000 fdf0 	bl	800336c <PWMC_SwitchOffPWM>
    if (MCPA_UART_A.Mark != 0U)
 800278c:	4812      	ldr	r0, [pc, #72]	; (80027d8 <TSK_SafetyTask_PWMOFF+0x94>)
 800278e:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 8002792:	b9c3      	cbnz	r3, 80027c6 <TSK_SafetyTask_PWMOFF+0x82>
    }
    else
    {
      /* Nothing to do */
    }
    FOC_Clear(bMotor);
 8002794:	4620      	mov	r0, r4
 8002796:	f7ff fc89 	bl	80020ac <FOC_Clear>
    PQD_Clear(pMPM[bMotor]); //cstat !MISRAC2012-Rule-11.3
 800279a:	4b10      	ldr	r3, [pc, #64]	; (80027dc <TSK_SafetyTask_PWMOFF+0x98>)
 800279c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    /* No errors */
  }
  /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 3 */

  /* USER CODE END TSK_SafetyTask_PWMOFF 3 */
}
 80027a0:	b002      	add	sp, #8
 80027a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    PQD_Clear(pMPM[bMotor]); //cstat !MISRAC2012-Rule-11.3
 80027a6:	f006 bd85 	b.w	80092b4 <PQD_Clear>
}
 80027aa:	b002      	add	sp, #8
 80027ac:	bd70      	pop	{r4, r5, r6, pc}
    uint16_t rawValueM1 =  RCM_ExecRegularConv(&VbusRegConv_M1);
 80027ae:	480c      	ldr	r0, [pc, #48]	; (80027e0 <TSK_SafetyTask_PWMOFF+0x9c>)
 80027b0:	f001 ff86 	bl	80046c0 <RCM_ExecRegularConv>
 80027b4:	4601      	mov	r1, r0
    CodeReturn |= errMask[bMotor] & RVBS_CalcAvVbus(&BusVoltageSensor_M1, rawValueM1);
 80027b6:	480b      	ldr	r0, [pc, #44]	; (80027e4 <TSK_SafetyTask_PWMOFF+0xa0>)
 80027b8:	f007 fd66 	bl	800a288 <RVBS_CalcAvVbus>
 80027bc:	f020 0008 	bic.w	r0, r0, #8
 80027c0:	4328      	orrs	r0, r5
 80027c2:	b285      	uxth	r5, r0
 80027c4:	e7c8      	b.n	8002758 <TSK_SafetyTask_PWMOFF+0x14>
      MCPA_flushDataLog (&MCPA_UART_A);
 80027c6:	f006 fc09 	bl	8008fdc <MCPA_flushDataLog>
 80027ca:	e7e3      	b.n	8002794 <TSK_SafetyTask_PWMOFF+0x50>
 80027cc:	20001af8 	.word	0x20001af8
 80027d0:	20001a90 	.word	0x20001a90
 80027d4:	20001af4 	.word	0x20001af4
 80027d8:	20000400 	.word	0x20000400
 80027dc:	200003d0 	.word	0x200003d0
 80027e0:	20000388 	.word	0x20000388
 80027e4:	20000004 	.word	0x20000004

080027e8 <TSK_SafetyTask>:
{
 80027e8:	b508      	push	{r3, lr}
  if (1U == bMCBootCompleted)
 80027ea:	4b06      	ldr	r3, [pc, #24]	; (8002804 <TSK_SafetyTask+0x1c>)
 80027ec:	781b      	ldrb	r3, [r3, #0]
 80027ee:	2b01      	cmp	r3, #1
 80027f0:	d000      	beq.n	80027f4 <TSK_SafetyTask+0xc>
}
 80027f2:	bd08      	pop	{r3, pc}
    TSK_SafetyTask_PWMOFF(M1);
 80027f4:	2000      	movs	r0, #0
 80027f6:	f7ff ffa5 	bl	8002744 <TSK_SafetyTask_PWMOFF>
}
 80027fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCM_ExecUserConv();
 80027fe:	f002 b827 	b.w	8004850 <RCM_ExecUserConv>
 8002802:	bf00      	nop
 8002804:	20001aea 	.word	0x20001aea

08002808 <MC_RunMotorControlTasks>:
{
 8002808:	b508      	push	{r3, lr}
  if (0U == bMCBootCompleted)
 800280a:	4b04      	ldr	r3, [pc, #16]	; (800281c <MC_RunMotorControlTasks+0x14>)
 800280c:	781b      	ldrb	r3, [r3, #0]
 800280e:	b903      	cbnz	r3, 8002812 <MC_RunMotorControlTasks+0xa>
}
 8002810:	bd08      	pop	{r3, pc}
    MC_Scheduler();
 8002812:	f7ff feb9 	bl	8002588 <MC_Scheduler>
    TSK_SafetyTask();
 8002816:	f7ff ffe7 	bl	80027e8 <TSK_SafetyTask>
}
 800281a:	bd08      	pop	{r3, pc}
 800281c:	20001aea 	.word	0x20001aea

08002820 <TSK_HardwareFaultTask>:
  *
  *  This function is to be executed when a general hardware failure has been detected
  * by the microcontroller and is used to put the system in safety condition.
  */
__weak void TSK_HardwareFaultTask(void)
{
 8002820:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TSK_HardwareFaultTask 0 */

  /* USER CODE END TSK_HardwareFaultTask 0 */
  R3_1_SwitchOffPWM(pwmcHandle[M1]);
 8002822:	4b05      	ldr	r3, [pc, #20]	; (8002838 <TSK_HardwareFaultTask+0x18>)
 8002824:	6818      	ldr	r0, [r3, #0]
 8002826:	f006 ff2f 	bl	8009688 <R3_1_SwitchOffPWM>
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);

  /* USER CODE BEGIN TSK_HardwareFaultTask 1 */

  /* USER CODE END TSK_HardwareFaultTask 1 */
}
 800282a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MCI_FaultProcessing(&Mci[M1], MC_SW_ERROR, 0);
 800282e:	4803      	ldr	r0, [pc, #12]	; (800283c <TSK_HardwareFaultTask+0x1c>)
 8002830:	2200      	movs	r2, #0
 8002832:	2180      	movs	r1, #128	; 0x80
 8002834:	f7ff ba42 	b.w	8001cbc <MCI_FaultProcessing>
 8002838:	20001af8 	.word	0x20001af8
 800283c:	20001a90 	.word	0x20001a90

08002840 <UI_HandleStartStopButton_cb>:

__weak void UI_HandleStartStopButton_cb (void)
{
 8002840:	b508      	push	{r3, lr}
/* USER CODE BEGIN START_STOP_BTN */
  if (IDLE == MC_GetSTMStateMotor1())
 8002842:	f7ff f9f1 	bl	8001c28 <MC_GetSTMStateMotor1>
 8002846:	b918      	cbnz	r0, 8002850 <UI_HandleStartStopButton_cb+0x10>
  else
  {
    (void)MC_StopMotor1();
  }
/* USER CODE END START_STOP_BTN */
}
 8002848:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StartMotor1();
 800284c:	f7ff b9d2 	b.w	8001bf4 <MC_StartMotor1>
}
 8002850:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void)MC_StopMotor1();
 8002854:	f7ff b9d4 	b.w	8001c00 <MC_StopMotor1>

08002858 <mc_lock_pins>:

 /**
  * @brief  Locks GPIO pins used for Motor Control to prevent accidental reconfiguration.
  */
__weak void mc_lock_pins (void)
{
 8002858:	b4f0      	push	{r4, r5, r6, r7}
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  __IO uint32_t temp;
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800285a:	4b34      	ldr	r3, [pc, #208]	; (800292c <mc_lock_pins+0xd4>)
 800285c:	4934      	ldr	r1, [pc, #208]	; (8002930 <mc_lock_pins+0xd8>)
 800285e:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002860:	2402      	movs	r4, #2
 8002862:	61dc      	str	r4, [r3, #28]
 8002864:	b08c      	sub	sp, #48	; 0x30
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002866:	61d9      	str	r1, [r3, #28]
  /* Read LCKR register. This read is mandatory to complete key lock sequence */
  temp = READ_REG(GPIOx->LCKR);
 8002868:	69da      	ldr	r2, [r3, #28]
 800286a:	920b      	str	r2, [sp, #44]	; 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800286c:	f04f 1001 	mov.w	r0, #65537	; 0x10001
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002870:	2501      	movs	r5, #1
  (void) temp;
 8002872:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002874:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002876:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002878:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800287a:	69db      	ldr	r3, [r3, #28]
 800287c:	930a      	str	r3, [sp, #40]	; 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800287e:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
  (void) temp;
 8002882:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002884:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002886:	61dc      	str	r4, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002888:	61d9      	str	r1, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800288a:	69da      	ldr	r2, [r3, #28]
 800288c:	9209      	str	r2, [sp, #36]	; 0x24
  (void) temp;
 800288e:	9a09      	ldr	r2, [sp, #36]	; 0x24
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002890:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002892:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002894:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002896:	69da      	ldr	r2, [r3, #28]
 8002898:	9208      	str	r2, [sp, #32]
  (void) temp;
 800289a:	9a08      	ldr	r2, [sp, #32]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800289c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028a0:	f44f 32c0 	mov.w	r2, #98304	; 0x18000
 80028a4:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028a6:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028a8:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028aa:	69de      	ldr	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028ac:	4a21      	ldr	r2, [pc, #132]	; (8002934 <mc_lock_pins+0xdc>)
  temp = READ_REG(GPIOx->LCKR);
 80028ae:	9607      	str	r6, [sp, #28]
  (void) temp;
 80028b0:	9e07      	ldr	r6, [sp, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028b2:	4e21      	ldr	r6, [pc, #132]	; (8002938 <mc_lock_pins+0xe0>)
 80028b4:	61d6      	str	r6, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028b6:	2708      	movs	r7, #8
 80028b8:	61d7      	str	r7, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028ba:	61d6      	str	r6, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028bc:	69d6      	ldr	r6, [r2, #28]
 80028be:	9606      	str	r6, [sp, #24]
  (void) temp;
 80028c0:	9e06      	ldr	r6, [sp, #24]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028c2:	4e1e      	ldr	r6, [pc, #120]	; (800293c <mc_lock_pins+0xe4>)
 80028c4:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028c6:	f44f 7780 	mov.w	r7, #256	; 0x100
 80028ca:	61df      	str	r7, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028cc:	61de      	str	r6, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028ce:	69de      	ldr	r6, [r3, #28]
 80028d0:	9605      	str	r6, [sp, #20]
  (void) temp;
 80028d2:	9e05      	ldr	r6, [sp, #20]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028d4:	f44f 7700 	mov.w	r7, #512	; 0x200
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028d8:	f44f 3681 	mov.w	r6, #66048	; 0x10200
 80028dc:	61de      	str	r6, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028de:	61df      	str	r7, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028e0:	61de      	str	r6, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028e2:	69de      	ldr	r6, [r3, #28]
 80028e4:	9604      	str	r6, [sp, #16]
  (void) temp;
 80028e6:	9e04      	ldr	r6, [sp, #16]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028e8:	61d0      	str	r0, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028ea:	61d5      	str	r5, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028ec:	61d0      	str	r0, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 80028ee:	69d0      	ldr	r0, [r2, #28]
 80028f0:	9003      	str	r0, [sp, #12]
  (void) temp;
 80028f2:	9d03      	ldr	r5, [sp, #12]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028f4:	f44f 3082 	mov.w	r0, #66560	; 0x10400
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028f8:	f44f 6580 	mov.w	r5, #1024	; 0x400
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 80028fc:	61d8      	str	r0, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 80028fe:	61dd      	str	r5, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002900:	61d8      	str	r0, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 8002902:	69d8      	ldr	r0, [r3, #28]
 8002904:	9002      	str	r0, [sp, #8]
  (void) temp;
 8002906:	9802      	ldr	r0, [sp, #8]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002908:	61d1      	str	r1, [r2, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 800290a:	61d4      	str	r4, [r2, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800290c:	61d1      	str	r1, [r2, #28]
  temp = READ_REG(GPIOx->LCKR);
 800290e:	69d1      	ldr	r1, [r2, #28]
 8002910:	9101      	str	r1, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002912:	4a0b      	ldr	r2, [pc, #44]	; (8002940 <mc_lock_pins+0xe8>)
  (void) temp;
 8002914:	9801      	ldr	r0, [sp, #4]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 8002916:	61da      	str	r2, [r3, #28]
  WRITE_REG(GPIOx->LCKR, PinMask);
 8002918:	2180      	movs	r1, #128	; 0x80
 800291a:	61d9      	str	r1, [r3, #28]
  WRITE_REG(GPIOx->LCKR, GPIO_LCKR_LCKK | PinMask);
 800291c:	61da      	str	r2, [r3, #28]
  temp = READ_REG(GPIOx->LCKR);
 800291e:	69db      	ldr	r3, [r3, #28]
 8002920:	9300      	str	r3, [sp, #0]
  (void) temp;
 8002922:	9b00      	ldr	r3, [sp, #0]
LL_GPIO_LockPin(M1_PWM_VH_GPIO_Port, M1_PWM_VH_Pin);
LL_GPIO_LockPin(M1_PWM_VL_GPIO_Port, M1_PWM_VL_Pin);
LL_GPIO_LockPin(M1_PWM_WH_GPIO_Port, M1_PWM_WH_Pin);
LL_GPIO_LockPin(M1_PWM_WL_GPIO_Port, M1_PWM_WL_Pin);
LL_GPIO_LockPin(M1_PWM_UL_GPIO_Port, M1_PWM_UL_Pin);
}
 8002924:	b00c      	add	sp, #48	; 0x30
 8002926:	bcf0      	pop	{r4, r5, r6, r7}
 8002928:	4770      	bx	lr
 800292a:	bf00      	nop
 800292c:	48000800 	.word	0x48000800
 8002930:	00010002 	.word	0x00010002
 8002934:	48000400 	.word	0x48000400
 8002938:	00010008 	.word	0x00010008
 800293c:	00010100 	.word	0x00010100
 8002940:	00010080 	.word	0x00010080

08002944 <RI_SetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_SetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8002944:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002948:	b087      	sub	sp, #28
    uint8_t accessResult;

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*SetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_SetRegisterGlobal, &RI_SetRegisterMotor1};
 800294a:	4b2f      	ldr	r3, [pc, #188]	; (8002a08 <RI_SetRegCommandParser+0xc4>)
 800294c:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8002950:	9304      	str	r3, [sp, #16]
 8002952:	4b2e      	ldr	r3, [pc, #184]	; (8002a0c <RI_SetRegCommandParser+0xc8>)
 8002954:	9305      	str	r3, [sp, #20]
    uint16_t size = 0U;
 8002956:	2600      	movs	r6, #0
    uint8_t * rxData = pHandle->rxBuffer;
 8002958:	f8d0 e004 	ldr.w	lr, [r0, #4]
    int16_t rxLength = pHandle->rxLength;
 800295c:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    uint16_t size = 0U;
 8002960:	f8ad 600e 	strh.w	r6, [sp, #14]
{
 8002964:	4607      	mov	r7, r0
    uint8_t number_of_item =0;
    pHandle->txLength = 0;
 8002966:	81c6      	strh	r6, [r0, #14]
 8002968:	eb08 0901 	add.w	r9, r8, r1
  uint8_t retVal = MCP_CMD_OK;
 800296c:	46b2      	mov	sl, r6

    while (rxLength > 0)
    {
      number_of_item ++;
 800296e:	3601      	adds	r6, #1
    while (rxLength > 0)
 8002970:	2b00      	cmp	r3, #0
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 8002972:	f1a3 0c02 	sub.w	ip, r3, #2
      number_of_item ++;
 8002976:	b2f6      	uxtb	r6, r6
    while (rxLength > 0)
 8002978:	dd43      	ble.n	8002a02 <RI_SetRegCommandParser+0xbe>
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 800297a:	fa0f f18c 	sxth.w	r1, ip
      rxLength = rxLength-MCP_ID_SIZE; // We consume 2 byte in the DataID
 800297e:	fa1f f48c 	uxth.w	r4, ip
      regID = *dataElementID & REG_MASK;
 8002982:	f8be c000 	ldrh.w	ip, [lr]
      rxData = rxData+MCP_ID_SIZE; // Shift buffer to the next data
 8002986:	f10e 0502 	add.w	r5, lr, #2
      if (motorID > NBR_OF_MOTORS)
 800298a:	f01c 0f06 	tst.w	ip, #6
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 800298e:	f10d 030e 	add.w	r3, sp, #14
 8002992:	462a      	mov	r2, r5
      regID = *dataElementID & REG_MASK;
 8002994:	f02c 0007 	bic.w	r0, ip, #7
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8002998:	fa5f fe8c 	uxtb.w	lr, ip
      if (motorID > NBR_OF_MOTORS)
 800299c:	d11e      	bne.n	80029dc <RI_SetRegCommandParser+0x98>
        accessResult = SetRegFcts[motorID](regID, typeID, rxData, &size, rxLength);
 800299e:	9100      	str	r1, [sp, #0]
 80029a0:	f00e 0c07 	and.w	ip, lr, #7
 80029a4:	a906      	add	r1, sp, #24
 80029a6:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 80029aa:	f00e 0138 	and.w	r1, lr, #56	; 0x38
 80029ae:	f85c bc08 	ldr.w	fp, [ip, #-8]
 80029b2:	47d8      	blx	fp
        /* Prepare next data*/
        rxLength = (int16_t) (rxLength - size);
 80029b4:	f8bd e00e 	ldrh.w	lr, [sp, #14]
        rxData = rxData+size;
        /* If there is only one CMD in the buffer, we do not store the result */
        if ((1U == number_of_item) && (0 == rxLength))
 80029b8:	2e01      	cmp	r6, #1
        rxLength = (int16_t) (rxLength - size);
 80029ba:	eba4 0c0e 	sub.w	ip, r4, lr
 80029be:	fa0f f38c 	sxth.w	r3, ip
        if ((1U == number_of_item) && (0 == rxLength))
 80029c2:	d013      	beq.n	80029ec <RI_SetRegCommandParser+0xa8>
        {
          retVal = accessResult;
        }
        else
        {/* Store the result for each access to be able to report failing access */
          if (txSyncFreeSpace !=0 )
 80029c4:	45c1      	cmp	r9, r8
 80029c6:	d00d      	beq.n	80029e4 <RI_SetRegCommandParser+0xa0>
          {
            *txData = accessResult;
 80029c8:	f808 0b01 	strb.w	r0, [r8], #1
            txData = txData+1;
            pHandle->txLength++;
 80029cc:	89fa      	ldrh	r2, [r7, #14]
 80029ce:	3201      	adds	r2, #1
        rxData = rxData+size;
 80029d0:	44ae      	add	lr, r5
            pHandle->txLength++;
 80029d2:	81fa      	strh	r2, [r7, #14]
            txSyncFreeSpace--; /* decrement one by one no wraparound possible */
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 80029d4:	2800      	cmp	r0, #0
 80029d6:	d0ca      	beq.n	800296e <RI_SetRegCommandParser+0x2a>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 80029d8:	2807      	cmp	r0, #7
 80029da:	d10d      	bne.n	80029f8 <RI_SetRegCommandParser+0xb4>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 80029dc:	2001      	movs	r0, #1
    }
  #ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 80029de:	b007      	add	sp, #28
 80029e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 80029e4:	2008      	movs	r0, #8
}
 80029e6:	b007      	add	sp, #28
 80029e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((1U == number_of_item) && (0 == rxLength))
 80029ec:	2b00      	cmp	r3, #0
 80029ee:	d1e9      	bne.n	80029c4 <RI_SetRegCommandParser+0x80>
    if (MCP_CMD_OK == retVal)
 80029f0:	2800      	cmp	r0, #0
 80029f2:	d1f4      	bne.n	80029de <RI_SetRegCommandParser+0x9a>
      pHandle->txLength = 0;
 80029f4:	81f8      	strh	r0, [r7, #14]
 80029f6:	e7f2      	b.n	80029de <RI_SetRegCommandParser+0x9a>
            if ((accessResult == MCP_ERROR_BAD_DATA_TYPE) || (accessResult == MCP_ERROR_BAD_RAW_FORMAT))
 80029f8:	280a      	cmp	r0, #10
 80029fa:	d0ef      	beq.n	80029dc <RI_SetRegCommandParser+0x98>
            retVal = (accessResult != MCP_CMD_OK) ? MCP_CMD_NOK : retVal;
 80029fc:	f04f 0a01 	mov.w	sl, #1
 8002a00:	e7b5      	b.n	800296e <RI_SetRegCommandParser+0x2a>
 8002a02:	4650      	mov	r0, sl
 8002a04:	e7f4      	b.n	80029f0 <RI_SetRegCommandParser+0xac>
 8002a06:	bf00      	nop
 8002a08:	08003411 	.word	0x08003411
 8002a0c:	0800350d 	.word	0x0800350d

08002a10 <RI_GetRegCommandParser>:
  * @param  txSyncFreeSpace Space available for synchronous transmission
  *
  * @retval Returns #MCP_CMD_OK if the command is acknowledged and #MCP_CMD_NOK if not.
  */
uint8_t RI_GetRegCommandParser (MCP_Handle_t * pHandle, uint16_t txSyncFreeSpace)
{
 8002a10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002a14:	b086      	sub	sp, #24
  {
#endif
    uint16_t * dataElementID;
    uint8_t * rxData = pHandle->rxBuffer;
    uint8_t * txData = pHandle->txBuffer;
    uint16_t size = 0U;
 8002a16:	2300      	movs	r3, #0
 8002a18:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t regID;
    uint8_t typeID;
    uint8_t motorID;
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
    pHandle->txLength = 0;
 8002a1c:	81c3      	strh	r3, [r0, #14]
    uint16_t rxLength = pHandle->rxLength;
 8002a1e:	f8b0 800c 	ldrh.w	r8, [r0, #12]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002a22:	4b1e      	ldr	r3, [pc, #120]	; (8002a9c <RI_GetRegCommandParser+0x8c>)
 8002a24:	9304      	str	r3, [sp, #16]
 8002a26:	4b1e      	ldr	r3, [pc, #120]	; (8002aa0 <RI_GetRegCommandParser+0x90>)
    uint8_t * rxData = pHandle->rxBuffer;
 8002a28:	f8d0 9004 	ldr.w	r9, [r0, #4]
    uint8_t * txData = pHandle->txBuffer;
 8002a2c:	6886      	ldr	r6, [r0, #8]
    uint8_t (*GetRegFcts[NBR_OF_MOTORS+1])(uint16_t, uint8_t, uint8_t*, uint16_t*, int16_t) = {&RI_GetRegisterGlobal, &RI_GetRegisterMotor1};
 8002a2e:	9305      	str	r3, [sp, #20]
    while (rxLength > 0U)
 8002a30:	f1b8 0f00 	cmp.w	r8, #0
 8002a34:	d023      	beq.n	8002a7e <RI_GetRegCommandParser+0x6e>
 8002a36:	4607      	mov	r7, r0
 8002a38:	b20d      	sxth	r5, r1
    uint8_t * rxData = pHandle->rxBuffer;
 8002a3a:	464c      	mov	r4, r9
    {
      dataElementID = (uint16_t *) rxData;
      rxLength = rxLength - MCP_ID_SIZE;
      rxData = rxData + MCP_ID_SIZE; // Shift buffer to the next MCP_ID

      regID = *dataElementID & REG_MASK;
 8002a3c:	f834 cb02 	ldrh.w	ip, [r4], #2
      typeID = (uint8_t)*dataElementID & TYPE_MASK;
 8002a40:	fa5f f18c 	uxtb.w	r1, ip
        retVal = MCP_CMD_NOK;
        rxLength = 0;
      }
      else
      {
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a44:	f001 0e07 	and.w	lr, r1, #7
 8002a48:	f10d 0a18 	add.w	sl, sp, #24
      if (motorID > NBR_OF_MOTORS)
 8002a4c:	f01c 0f06 	tst.w	ip, #6
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a50:	4632      	mov	r2, r6
      regID = *dataElementID & REG_MASK;
 8002a52:	f02c 0007 	bic.w	r0, ip, #7
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a56:	f10d 030e 	add.w	r3, sp, #14
 8002a5a:	eb0a 0e8e 	add.w	lr, sl, lr, lsl #2
 8002a5e:	f001 0138 	and.w	r1, r1, #56	; 0x38
      if (motorID > NBR_OF_MOTORS)
 8002a62:	d10c      	bne.n	8002a7e <RI_GetRegCommandParser+0x6e>
        retVal = GetRegFcts[motorID](regID, typeID, txData, &size, freeSpaceS16);
 8002a64:	9500      	str	r5, [sp, #0]
 8002a66:	f85e ac08 	ldr.w	sl, [lr, #-8]
 8002a6a:	47d0      	blx	sl
        if (retVal == MCP_CMD_OK )
 8002a6c:	eba8 0304 	sub.w	r3, r8, r4
    while (rxLength > 0U)
 8002a70:	fa19 f383 	uxtah	r3, r9, r3
 8002a74:	b29b      	uxth	r3, r3
        if (retVal == MCP_CMD_OK )
 8002a76:	b130      	cbz	r0, 8002a86 <RI_GetRegCommandParser+0x76>
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 8002a78:	b006      	add	sp, #24
 8002a7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  uint8_t retVal = MCP_CMD_NOK;
 8002a7e:	2001      	movs	r0, #1
}
 8002a80:	b006      	add	sp, #24
 8002a82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          txData = txData+size;
 8002a86:	f8bd 100e 	ldrh.w	r1, [sp, #14]
          pHandle->txLength += size;
 8002a8a:	89fa      	ldrh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002a8c:	1a6d      	subs	r5, r5, r1
          pHandle->txLength += size;
 8002a8e:	440a      	add	r2, r1
          txData = txData+size;
 8002a90:	440e      	add	r6, r1
          pHandle->txLength += size;
 8002a92:	81fa      	strh	r2, [r7, #14]
          freeSpaceS16 = freeSpaceS16-size;
 8002a94:	b22d      	sxth	r5, r5
    while (rxLength > 0U)
 8002a96:	2b00      	cmp	r3, #0
 8002a98:	d1d0      	bne.n	8002a3c <RI_GetRegCommandParser+0x2c>
 8002a9a:	e7ed      	b.n	8002a78 <RI_GetRegCommandParser+0x68>
 8002a9c:	08003a65 	.word	0x08003a65
 8002aa0:	08003ba1 	.word	0x08003ba1

08002aa4 <MCP_ReceivedPacket>:
  * @brief  Parses the header from the received packet and call the required function depending on the command sent by the controller device.
  *
  * @param  pHandle Handler of the current instance of the MCP component
  */
void MCP_ReceivedPacket(MCP_Handle_t *pHandle)
{
 8002aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* Nothing to do, txBuffer and txLength have not been modified */
  }
  else /* Length is 0, this is a request to send back the last packet */
  {
#endif
    packetHeader = (uint16_t *)pHandle->rxBuffer; //cstat !MISRAC2012-Rule-11.3
 8002aa6:	6845      	ldr	r5, [r0, #4]
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002aa8:	882b      	ldrh	r3, [r5, #0]

    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002aaa:	f403 427f 	and.w	r2, r3, #65280	; 0xff00
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002aae:	f023 0c07 	bic.w	ip, r3, #7
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002ab2:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
{
 8002ab6:	b083      	sub	sp, #12
 8002ab8:	4604      	mov	r4, r0
    command = (uint16_t)(*packetHeader & CMD_MASK);
 8002aba:	fa1f fc8c 	uxth.w	ip, ip
    if ((command & MCP_USER_CMD_MASK) == MCP_USER_CMD)
 8002abe:	d051      	beq.n	8002b64 <MCP_ReceivedPacket+0xc0>
    else
    {
      /* Nothing to do */
    }

    motorID = (uint8_t)((*packetHeader - 1U) & MOTOR_MASK);
 8002ac0:	3b01      	subs	r3, #1
    MCI_Handle_t *pMCI = &Mci[motorID];
 8002ac2:	4f5c      	ldr	r7, [pc, #368]	; (8002c34 <MCP_ReceivedPacket+0x190>)
 8002ac4:	f003 0307 	and.w	r3, r3, #7
 8002ac8:	eb03 0383 	add.w	r3, r3, r3, lsl #2

    /* Removing MCP Header from RxBuffer */
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002acc:	3502      	adds	r5, #2
    MCI_Handle_t *pMCI = &Mci[motorID];
 8002ace:	eb07 07c3 	add.w	r7, r7, r3, lsl #3

    /* Commands requiering payload response must be aware of space available for the payload */
    /* Last byte is reserved for MCP response*/
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002ad2:	6823      	ldr	r3, [r4, #0]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002ad4:	6045      	str	r5, [r0, #4]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002ad6:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002ad8:	899a      	ldrh	r2, [r3, #12]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002ada:	3802      	subs	r0, #2
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002adc:	3a01      	subs	r2, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002ade:	b280      	uxth	r0, r0

    /* Initialization of the tx length, command which send back data has to increment the txLength
     * (case of Read register) */
    pHandle->txLength = 0U;
 8002ae0:	2600      	movs	r6, #0

    switch (command)
 8002ae2:	f1bc 0f38 	cmp.w	ip, #56	; 0x38
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002ae6:	b291      	uxth	r1, r2
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002ae8:	81a0      	strh	r0, [r4, #12]
    pHandle->txLength = 0U;
 8002aea:	81e6      	strh	r6, [r4, #14]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002aec:	b212      	sxth	r2, r2
    switch (command)
 8002aee:	d82a      	bhi.n	8002b46 <MCP_ReceivedPacket+0xa2>
 8002af0:	f1bc 0f38 	cmp.w	ip, #56	; 0x38
 8002af4:	d81e      	bhi.n	8002b34 <MCP_ReceivedPacket+0x90>
 8002af6:	e8df f00c 	tbb	[pc, ip]
 8002afa:	1d63      	.short	0x1d63
 8002afc:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b00:	1d6b1d1d 	.word	0x1d6b1d1d
 8002b04:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b08:	1d701d1d 	.word	0x1d701d1d
 8002b0c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b10:	1d751d1d 	.word	0x1d751d1d
 8002b14:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b18:	1d4c1d1d 	.word	0x1d4c1d1d
 8002b1c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b20:	1d521d1d 	.word	0x1d521d1d
 8002b24:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b28:	1d471d1d 	.word	0x1d471d1d
 8002b2c:	1d1d1d1d 	.word	0x1d1d1d1d
 8002b30:	1d1d      	.short	0x1d1d
 8002b32:	5d          	.byte	0x5d
 8002b33:	00          	.byte	0x00
 8002b34:	2300      	movs	r3, #0
 8002b36:	2002      	movs	r0, #2
      {
        MCPResponse = MCP_CMD_UNKNOWN;
        break;
      }
    }
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002b38:	68a2      	ldr	r2, [r4, #8]
 8002b3a:	54d0      	strb	r0, [r2, r3]
    pHandle->txLength++;
 8002b3c:	89e3      	ldrh	r3, [r4, #14]
 8002b3e:	3301      	adds	r3, #1
 8002b40:	81e3      	strh	r3, [r4, #14]
#ifdef NULL_PTR_CHECK_MCP
  }
#endif
}
 8002b42:	b003      	add	sp, #12
 8002b44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (command)
 8002b46:	f1bc 0f68 	cmp.w	ip, #104	; 0x68
 8002b4a:	d05f      	beq.n	8002c0c <MCP_ReceivedPacket+0x168>
 8002b4c:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
 8002b50:	d06d      	beq.n	8002c2e <MCP_ReceivedPacket+0x18a>
 8002b52:	f1bc 0f48 	cmp.w	ip, #72	; 0x48
 8002b56:	d1ed      	bne.n	8002b34 <MCP_ReceivedPacket+0x90>
        MCI_Clear_Iqdref(pMCI);
 8002b58:	4638      	mov	r0, r7
 8002b5a:	f7ff f9eb 	bl	8001f34 <MCI_Clear_Iqdref>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002b5e:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002b60:	4630      	mov	r0, r6
        break;
 8002b62:	e7e9      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b64:	8980      	ldrh	r0, [r0, #12]
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b66:	6823      	ldr	r3, [r4, #0]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b68:	3802      	subs	r0, #2
      userCommand = ((uint8_t)(command & 0xF8U) >> 3U);
 8002b6a:	f3cc 0cc4 	ubfx	ip, ip, #3, #5
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002b6e:	899a      	ldrh	r2, [r3, #12]
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b70:	b280      	uxth	r0, r0
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002b72:	3502      	adds	r5, #2
    pHandle->txLength = 0U;
 8002b74:	2300      	movs	r3, #0
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002b76:	f1bc 0f01 	cmp.w	ip, #1
    pHandle->rxLength = pHandle->rxLength - MCP_HEADER_SIZE;
 8002b7a:	81a0      	strh	r0, [r4, #12]
    pHandle->rxBuffer = pHandle->rxBuffer + MCP_HEADER_SIZE;
 8002b7c:	6065      	str	r5, [r4, #4]
    pHandle->txLength = 0U;
 8002b7e:	81e3      	strh	r3, [r4, #14]
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002b80:	d935      	bls.n	8002bee <MCP_ReceivedPacket+0x14a>
        MCPResponse = MCP_CMD_OK;
 8002b82:	2300      	movs	r3, #0
          MCPResponse = MCP_ERROR_CALLBACK_NOT_REGISTRED;
 8002b84:	200d      	movs	r0, #13
 8002b86:	e7d7      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        if (IDLE == MCI_GetSTMState(pMCI))
 8002b88:	4638      	mov	r0, r7
 8002b8a:	f7ff f8df 	bl	8001d4c <MCI_GetSTMState>
 8002b8e:	2800      	cmp	r0, #0
 8002b90:	d045      	beq.n	8002c1e <MCP_ReceivedPacket+0x17a>
          (void)MCI_StopMotor(pMCI);
 8002b92:	4638      	mov	r0, r7
 8002b94:	f7ff f910 	bl	8001db8 <MCI_StopMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002b98:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_CMD_OK;
 8002b9a:	2000      	movs	r0, #0
 8002b9c:	e7cc      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        if (RUN == MCI_GetSTMState(pMCI))
 8002b9e:	4638      	mov	r0, r7
 8002ba0:	f7ff f8d4 	bl	8001d4c <MCI_GetSTMState>
 8002ba4:	2806      	cmp	r0, #6
 8002ba6:	d1f7      	bne.n	8002b98 <MCP_ReceivedPacket+0xf4>
          MCI_StopRamp(pMCI);
 8002ba8:	4638      	mov	r0, r7
 8002baa:	f7ff f94b 	bl	8001e44 <MCI_StopRamp>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bae:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002bb0:	2000      	movs	r0, #0
 8002bb2:	e7c1      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        (void)MCI_FaultAcknowledged(pMCI);
 8002bb4:	4638      	mov	r0, r7
 8002bb6:	f7ff f91f 	bl	8001df8 <MCI_FaultAcknowledged>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bba:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002bbc:	2000      	movs	r0, #0
        break;
 8002bbe:	e7bb      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        *pHandle->txBuffer = MCP_VERSION;
 8002bc0:	68a3      	ldr	r3, [r4, #8]
        pHandle->txLength = 4U;
 8002bc2:	2104      	movs	r1, #4
        *pHandle->txBuffer = MCP_VERSION;
 8002bc4:	2201      	movs	r2, #1
        pHandle->txLength = 4U;
 8002bc6:	81e1      	strh	r1, [r4, #14]
        *pHandle->txBuffer = MCP_VERSION;
 8002bc8:	701a      	strb	r2, [r3, #0]
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bca:	89e3      	ldrh	r3, [r4, #14]
        MCPResponse = MCP_CMD_OK;
 8002bcc:	2000      	movs	r0, #0
        break;
 8002bce:	e7b3      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        MCPResponse = RI_SetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002bd0:	4620      	mov	r0, r4
 8002bd2:	f7ff feb7 	bl	8002944 <RI_SetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bd6:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002bd8:	e7ae      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        MCPResponse = RI_GetRegCommandParser(pHandle, (uint16_t)txSyncFreeSpace);
 8002bda:	4620      	mov	r0, r4
 8002bdc:	f7ff ff18 	bl	8002a10 <RI_GetRegCommandParser>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002be0:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002be2:	e7a9      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == false) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002be4:	4638      	mov	r0, r7
 8002be6:	f7ff f8cd 	bl	8001d84 <MCI_StartWithPolarizationMotor>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002bea:	89e3      	ldrh	r3, [r4, #14]
 8002bec:	e7a4      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
    txSyncFreeSpace = (int16_t)pHandle->pTransportLayer->txSyncMaxPayload - 1;
 8002bee:	3a01      	subs	r2, #1
 8002bf0:	b212      	sxth	r2, r2
        if ((userCommand < MCP_USER_CALLBACK_MAX) && (MCP_UserCallBack[userCommand] != NULL))
 8002bf2:	4b11      	ldr	r3, [pc, #68]	; (8002c38 <MCP_ReceivedPacket+0x194>)
 8002bf4:	f853 602c 	ldr.w	r6, [r3, ip, lsl #2]
 8002bf8:	2e00      	cmp	r6, #0
 8002bfa:	d0c2      	beq.n	8002b82 <MCP_ReceivedPacket+0xde>
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 8002bfc:	68a3      	ldr	r3, [r4, #8]
 8002bfe:	9300      	str	r3, [sp, #0]
 8002c00:	4629      	mov	r1, r5
 8002c02:	f104 030e 	add.w	r3, r4, #14
 8002c06:	47b0      	blx	r6
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c08:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = MCP_UserCallBack[userCommand](pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace,
 8002c0a:	e795      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
        MCPResponse = MC_ProfilerCommand(pHandle->rxLength, pHandle->rxBuffer, txSyncFreeSpace, &pHandle->txLength,
 8002c0c:	68a3      	ldr	r3, [r4, #8]
 8002c0e:	9300      	str	r3, [sp, #0]
 8002c10:	4629      	mov	r1, r5
 8002c12:	f104 030e 	add.w	r3, r4, #14
 8002c16:	f7ff f80d 	bl	8001c34 <MC_ProfilerCommand>
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c1a:	89e3      	ldrh	r3, [r4, #14]
        break;
 8002c1c:	e78c      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
          MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002c1e:	4638      	mov	r0, r7
 8002c20:	f7ff f8b0 	bl	8001d84 <MCI_StartWithPolarizationMotor>
 8002c24:	f080 0001 	eor.w	r0, r0, #1
    pHandle->txBuffer[pHandle->txLength] = MCPResponse;
 8002c28:	89e3      	ldrh	r3, [r4, #14]
          MCPResponse = (MCI_StartWithPolarizationMotor(pMCI) == true) ? MCP_CMD_OK : MCP_CMD_NOK;
 8002c2a:	b2c0      	uxtb	r0, r0
 8002c2c:	e784      	b.n	8002b38 <MCP_ReceivedPacket+0x94>
    switch (command)
 8002c2e:	46b4      	mov	ip, r6
 8002c30:	e7df      	b.n	8002bf2 <MCP_ReceivedPacket+0x14e>
 8002c32:	bf00      	nop
 8002c34:	20001a90 	.word	0x20001a90
 8002c38:	20002c18 	.word	0x20002c18

08002c3c <MX_MotorControl_Init>:
 *
 * CubeMX calls this function after all peripherals initializations and
 * before the NVIC is configured
 */
__weak void MX_MotorControl_Init(void)
{
 8002c3c:	b508      	push	{r3, lr}
  /* Reconfigure the SysTick interrupt to fire every 500 us. */
  (void)HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / SYS_TICK_FREQUENCY);
 8002c3e:	f004 fa05 	bl	800704c <HAL_RCC_GetHCLKFreq>
 8002c42:	4b0a      	ldr	r3, [pc, #40]	; (8002c6c <MX_MotorControl_Init+0x30>)
 8002c44:	fba3 3000 	umull	r3, r0, r3, r0
 8002c48:	09c0      	lsrs	r0, r0, #7
 8002c4a:	f003 fbd7 	bl	80063fc <HAL_SYSTICK_Config>
  HAL_NVIC_SetPriority(SysTick_IRQn, uwTickPrio, 0U);
 8002c4e:	4b08      	ldr	r3, [pc, #32]	; (8002c70 <MX_MotorControl_Init+0x34>)
 8002c50:	2200      	movs	r2, #0
 8002c52:	6819      	ldr	r1, [r3, #0]
 8002c54:	f04f 30ff 	mov.w	r0, #4294967295
 8002c58:	f003 fb84 	bl	8006364 <HAL_NVIC_SetPriority>

  /* Initialize the Motor Control Subsystem */
  MCboot(pMCI);
 8002c5c:	4805      	ldr	r0, [pc, #20]	; (8002c74 <MX_MotorControl_Init+0x38>)
 8002c5e:	f7ff fa5f 	bl	8002120 <MCboot>
  mc_lock_pins();
}
 8002c62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  mc_lock_pins();
 8002c66:	f7ff bdf7 	b.w	8002858 <mc_lock_pins>
 8002c6a:	bf00      	nop
 8002c6c:	10624dd3 	.word	0x10624dd3
 8002c70:	200014ac 	.word	0x200014ac
 8002c74:	20002c88 	.word	0x20002c88

08002c78 <ai_network_get_error>:
}

AI_API_ENTRY
ai_error ai_network_get_error(ai_handle network)
{
  return ai_platform_network_get_error(network);
 8002c78:	f008 b818 	b.w	800acac <ai_platform_network_get_error>

08002c7c <ai_network_inputs_get>:
}

AI_API_ENTRY
ai_buffer* ai_network_inputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 8002c7c:	b108      	cbz	r0, 8002c82 <ai_network_inputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_inputs_get(network, n_buffer);
 8002c7e:	f008 b889 	b.w	800ad94 <ai_platform_inputs_get>
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 8002c82:	4802      	ldr	r0, [pc, #8]	; (8002c8c <ai_network_inputs_get+0x10>)
 8002c84:	4b02      	ldr	r3, [pc, #8]	; (8002c90 <ai_network_inputs_get+0x14>)
 8002c86:	6003      	str	r3, [r0, #0]
  return ai_platform_inputs_get(network, n_buffer);
 8002c88:	f008 b884 	b.w	800ad94 <ai_platform_inputs_get>
 8002c8c:	20001198 	.word	0x20001198
 8002c90:	a1c00100 	.word	0xa1c00100

08002c94 <ai_network_outputs_get>:
}

AI_API_ENTRY
ai_buffer* ai_network_outputs_get(ai_handle network, ai_u16 *n_buffer)
{
  if (network == AI_HANDLE_NULL) {
 8002c94:	b108      	cbz	r0, 8002c9a <ai_network_outputs_get+0x6>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
  }
  return ai_platform_outputs_get(network, n_buffer);
 8002c96:	f008 b953 	b.w	800af40 <ai_platform_outputs_get>
    ((ai_network *)network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 8002c9a:	4802      	ldr	r0, [pc, #8]	; (8002ca4 <ai_network_outputs_get+0x10>)
 8002c9c:	4b02      	ldr	r3, [pc, #8]	; (8002ca8 <ai_network_outputs_get+0x14>)
 8002c9e:	6003      	str	r3, [r0, #0]
  return ai_platform_outputs_get(network, n_buffer);
 8002ca0:	f008 b94e 	b.w	800af40 <ai_platform_outputs_get>
 8002ca4:	20001198 	.word	0x20001198
 8002ca8:	a1c00100 	.word	0xa1c00100

08002cac <ai_network_init>:
}

AI_API_ENTRY
ai_bool ai_network_init(
  ai_handle network, const ai_network_params* params)
{
 8002cac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002cb0:	b085      	sub	sp, #20
 8002cb2:	460d      	mov	r5, r1
 8002cb4:	9001      	str	r0, [sp, #4]
  ai_network* net_ctx = ai_platform_network_init(network, params);
 8002cb6:	f008 fae9 	bl	800b28c <ai_platform_network_init>
  if (!net_ctx) return false;
 8002cba:	4604      	mov	r4, r0
 8002cbc:	2800      	cmp	r0, #0
 8002cbe:	f000 80fb 	beq.w	8002eb8 <ai_network_init+0x20c>
  if (ai_platform_get_weights_map(g_network_weights_map, 1, params)) {
 8002cc2:	4e85      	ldr	r6, [pc, #532]	; (8002ed8 <ai_network_init+0x22c>)
 8002cc4:	462a      	mov	r2, r5
 8002cc6:	2101      	movs	r1, #1
 8002cc8:	4630      	mov	r0, r6
 8002cca:	f007 ff25 	bl	800ab18 <ai_platform_get_weights_map>
 8002cce:	9002      	str	r0, [sp, #8]
 8002cd0:	2800      	cmp	r0, #0
 8002cd2:	f000 80f4 	beq.w	8002ebe <ai_network_init+0x212>
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002cd6:	f8df 8254 	ldr.w	r8, [pc, #596]	; 8002f2c <ai_network_init+0x280>
    model__model_a2c_network_sigma_array.data = AI_PTR(g_network_weights_map[0] + 0);
 8002cda:	6833      	ldr	r3, [r6, #0]
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002cdc:	f8d8 2000 	ldr.w	r2, [r8]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002ce0:	4e7e      	ldr	r6, [pc, #504]	; (8002edc <ai_network_init+0x230>)
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002ce2:	487f      	ldr	r0, [pc, #508]	; (8002ee0 <ai_network_init+0x234>)
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002ce4:	497f      	ldr	r1, [pc, #508]	; (8002ee4 <ai_network_init+0x238>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002ce6:	4f80      	ldr	r7, [pc, #512]	; (8002ee8 <ai_network_init+0x23c>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002ce8:	f8df c244 	ldr.w	ip, [pc, #580]	; 8002f30 <ai_network_init+0x284>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002cec:	f8df e244 	ldr.w	lr, [pc, #580]	; 8002f34 <ai_network_init+0x288>
    value_weights_array.format |= AI_FMT_FLAG_CONST;
 8002cf0:	f8df b244 	ldr.w	fp, [pc, #580]	; 8002f38 <ai_network_init+0x28c>
    value_bias_array.format |= AI_FMT_FLAG_CONST;
 8002cf4:	f8df a244 	ldr.w	sl, [pc, #580]	; 8002f3c <ai_network_init+0x290>
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002cf8:	f042 4980 	orr.w	r9, r2, #1073741824	; 0x40000000
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002cfc:	6832      	ldr	r2, [r6, #0]
    model__model_a2c_network_sigma_array.format |= AI_FMT_FLAG_CONST;
 8002cfe:	f8c8 9000 	str.w	r9, [r8]
    model__model_a2c_network_sigma_array.data = AI_PTR(g_network_weights_map[0] + 0);
 8002d02:	e9c8 3302 	strd	r3, r3, [r8, #8]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d06:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d0a:	6802      	ldr	r2, [r0, #0]
    _model_a2c_network_Constant_output_0_array.format |= AI_FMT_FLAG_CONST;
 8002d0c:	f8c6 8000 	str.w	r8, [r6]
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d10:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d14:	680a      	ldr	r2, [r1, #0]
    onnxDiv_43_array.format |= AI_FMT_FLAG_CONST;
 8002d16:	f8c0 8000 	str.w	r8, [r0]
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d1a:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d1e:	683a      	ldr	r2, [r7, #0]
    onnxSub_40_array.format |= AI_FMT_FLAG_CONST;
 8002d20:	f8c1 8000 	str.w	r8, [r1]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d24:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d28:	f8dc 2000 	ldr.w	r2, [ip]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d2c:	f8c7 8000 	str.w	r8, [r7]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d30:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d34:	f8de 2000 	ldr.w	r2, [lr]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d38:	f8cc 8000 	str.w	r8, [ip]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d3c:	f042 4880 	orr.w	r8, r2, #1073741824	; 0x40000000
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d40:	4a6a      	ldr	r2, [pc, #424]	; (8002eec <ai_network_init+0x240>)
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d42:	f8ce 8000 	str.w	r8, [lr]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d46:	6817      	ldr	r7, [r2, #0]
    mu_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d48:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 8002f40 <ai_network_init+0x294>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d4c:	f047 4880 	orr.w	r8, r7, #1073741824	; 0x40000000
 8002d50:	f8c2 8000 	str.w	r8, [r2]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002d54:	f503 470b 	add.w	r7, r3, #35584	; 0x8b00
 8002d58:	4a64      	ldr	r2, [pc, #400]	; (8002eec <ai_network_init+0x240>)
    mu_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d5a:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 8002f44 <ai_network_init+0x298>
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002d5e:	3720      	adds	r7, #32
 8002d60:	6097      	str	r7, [r2, #8]
 8002d62:	9703      	str	r7, [sp, #12]
    _model_a2c_network_Constant_output_0_array.data = AI_PTR(g_network_weights_map[0] + 4);
 8002d64:	1d1f      	adds	r7, r3, #4
 8002d66:	e9c6 7702 	strd	r7, r7, [r6, #8]
    onnxDiv_43_array.data = AI_PTR(g_network_weights_map[0] + 8);
 8002d6a:	f103 0608 	add.w	r6, r3, #8
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 1568);
 8002d6e:	f503 62c4 	add.w	r2, r3, #1568	; 0x620
    onnxDiv_43_array.data = AI_PTR(g_network_weights_map[0] + 8);
 8002d72:	e9c0 6602 	strd	r6, r6, [r0, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002d76:	4f5c      	ldr	r7, [pc, #368]	; (8002ee8 <ai_network_init+0x23c>)
    onnxSub_40_array.data = AI_PTR(g_network_weights_map[0] + 20);
 8002d78:	f103 0014 	add.w	r0, r3, #20
 8002d7c:	e9c1 0002 	strd	r0, r0, [r1, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 1568);
 8002d80:	e9cc 2202 	strd	r2, r2, [ip, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002d84:	f103 0120 	add.w	r1, r3, #32
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 2080);
 8002d88:	f503 6202 	add.w	r2, r3, #2080	; 0x820
    _model_a2c_network_actor_mlp_0_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 32);
 8002d8c:	e9c7 1102 	strd	r1, r1, [r7, #8]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 2080);
 8002d90:	e9ce 2202 	strd	r2, r2, [lr, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d94:	4956      	ldr	r1, [pc, #344]	; (8002ef0 <ai_network_init+0x244>)
    _model_a2c_network_actor_mlp_1_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 35616);
 8002d96:	4a55      	ldr	r2, [pc, #340]	; (8002eec <ai_network_init+0x240>)
 8002d98:	9f03      	ldr	r7, [sp, #12]
 8002d9a:	60d7      	str	r7, [r2, #12]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002d9c:	680a      	ldr	r2, [r1, #0]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002d9e:	4855      	ldr	r0, [pc, #340]	; (8002ef4 <ai_network_init+0x248>)
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.format |= AI_FMT_FLAG_CONST;
 8002da0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002da4:	600a      	str	r2, [r1, #0]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.format |= AI_FMT_FLAG_CONST;
 8002da6:	6802      	ldr	r2, [r0, #0]
 8002da8:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dac:	6002      	str	r2, [r0, #0]
    value_weights_array.format |= AI_FMT_FLAG_CONST;
 8002dae:	f8db 2000 	ldr.w	r2, [fp]
 8002db2:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002db6:	f8cb 2000 	str.w	r2, [fp]
    value_bias_array.format |= AI_FMT_FLAG_CONST;
 8002dba:	f8da 2000 	ldr.w	r2, [sl]
 8002dbe:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dc2:	f8ca 2000 	str.w	r2, [sl]
    mu_weights_array.format |= AI_FMT_FLAG_CONST;
 8002dc6:	f8d9 2000 	ldr.w	r2, [r9]
 8002dca:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dce:	f8c9 2000 	str.w	r2, [r9]
    mu_bias_array.format |= AI_FMT_FLAG_CONST;
 8002dd2:	f8d8 2000 	ldr.w	r2, [r8]
 8002dd6:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8002dda:	f8c8 2000 	str.w	r2, [r8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_weights_array.data = AI_PTR(g_network_weights_map[0] + 35872);
 8002dde:	f503 420c 	add.w	r2, r3, #35840	; 0x8c00
 8002de2:	3220      	adds	r2, #32
 8002de4:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_bias_array.data = AI_PTR(g_network_weights_map[0] + 44448);
 8002de8:	f503 422d 	add.w	r2, r3, #44288	; 0xad00
 8002dec:	32a0      	adds	r2, #160	; 0xa0
 8002dee:	e9c0 2202 	strd	r2, r2, [r0, #8]
    value_weights_array.data = AI_PTR(g_network_weights_map[0] + 44576);
 8002df2:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
 8002df6:	3220      	adds	r2, #32
 8002df8:	e9cb 2202 	strd	r2, r2, [fp, #8]
    value_bias_array.data = AI_PTR(g_network_weights_map[0] + 44704);
 8002dfc:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
 8002e00:	32a0      	adds	r2, #160	; 0xa0
 8002e02:	e9ca 2202 	strd	r2, r2, [sl, #8]
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e06:	f503 422e 	add.w	r2, r3, #44544	; 0xae00
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e0a:	f503 432f 	add.w	r3, r3, #44800	; 0xaf00
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e0e:	32a4      	adds	r2, #164	; 0xa4
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e10:	3324      	adds	r3, #36	; 0x24
    mu_weights_array.data = AI_PTR(g_network_weights_map[0] + 44708);
 8002e12:	e9c9 2202 	strd	r2, r2, [r9, #8]
    mu_bias_array.data = AI_PTR(g_network_weights_map[0] + 44836);
 8002e16:	e9c8 3302 	strd	r3, r3, [r8, #8]
  if (ai_platform_get_activations_map(g_network_activations_map, 1, params)) {
 8002e1a:	4e37      	ldr	r6, [pc, #220]	; (8002ef8 <ai_network_init+0x24c>)
 8002e1c:	462a      	mov	r2, r5
 8002e1e:	2101      	movs	r1, #1
 8002e20:	4630      	mov	r0, r6
 8002e22:	f007 fecd 	bl	800abc0 <ai_platform_get_activations_map>
 8002e26:	4605      	mov	r5, r0
 8002e28:	2800      	cmp	r0, #0
 8002e2a:	d04e      	beq.n	8002eca <ai_network_init+0x21e>
    obs_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e2c:	6833      	ldr	r3, [r6, #0]
 8002e2e:	4a33      	ldr	r2, [pc, #204]	; (8002efc <ai_network_init+0x250>)
    _model_a2c_network_actor_mlp_0_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e30:	4933      	ldr	r1, [pc, #204]	; (8002f00 <ai_network_init+0x254>)
    _model_a2c_network_actor_mlp_Concat_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e32:	f8df 9114 	ldr.w	r9, [pc, #276]	; 8002f48 <ai_network_init+0x29c>
    _model_a2c_network_actor_mlp_Concat_1_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e36:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8002f4c <ai_network_init+0x2a0>
    _model_a2c_network_actor_mlp_activations_1_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 268);
 8002e3a:	f8df e114 	ldr.w	lr, [pc, #276]	; 8002f50 <ai_network_init+0x2a4>
    _model_a2c_network_actor_mlp_activations_2_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 128);
 8002e3e:	f8df c114 	ldr.w	ip, [pc, #276]	; 8002f54 <ai_network_init+0x2a8>
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e42:	4830      	ldr	r0, [pc, #192]	; (8002f04 <ai_network_init+0x258>)
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002e44:	4e30      	ldr	r6, [pc, #192]	; (8002f08 <ai_network_init+0x25c>)
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002e46:	4c31      	ldr	r4, [pc, #196]	; (8002f0c <ai_network_init+0x260>)
    obs_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e48:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Sub_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e4c:	4a30      	ldr	r2, [pc, #192]	; (8002f10 <ai_network_init+0x264>)
 8002e4e:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Div_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e52:	4a30      	ldr	r2, [pc, #192]	; (8002f14 <ai_network_init+0x268>)
 8002e54:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_running_mean_std_Clip_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e58:	4a2f      	ldr	r2, [pc, #188]	; (8002f18 <ai_network_init+0x26c>)
 8002e5a:	e9c2 3302 	strd	r3, r3, [r2, #8]
    _model_a2c_network_actor_mlp_0_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e5e:	f103 020c 	add.w	r2, r3, #12
 8002e62:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_activations_0_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e66:	492d      	ldr	r1, [pc, #180]	; (8002f1c <ai_network_init+0x270>)
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e68:	6082      	str	r2, [r0, #8]
    _model_a2c_network_actor_mlp_activations_0_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e6a:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_1_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002e6e:	492c      	ldr	r1, [pc, #176]	; (8002f20 <ai_network_init+0x274>)
 8002e70:	e9c1 2202 	strd	r2, r2, [r1, #8]
    _model_a2c_network_actor_mlp_2_Gemm_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e74:	492b      	ldr	r1, [pc, #172]	; (8002f24 <ai_network_init+0x278>)
 8002e76:	e9c1 3302 	strd	r3, r3, [r1, #8]
    value_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 8002e7a:	492b      	ldr	r1, [pc, #172]	; (8002f28 <ai_network_init+0x27c>)
 8002e7c:	e9c1 3302 	strd	r3, r3, [r1, #8]
    _model_a2c_network_actor_mlp_Concat_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e80:	f503 7103 	add.w	r1, r3, #524	; 0x20c
 8002e84:	e9c9 1102 	strd	r1, r1, [r9, #8]
    _model_a2c_network_actor_mlp_Concat_1_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 524);
 8002e88:	e9c8 1102 	strd	r1, r1, [r8, #8]
    _model_a2c_network_actor_mlp_activations_1_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 268);
 8002e8c:	f503 7186 	add.w	r1, r3, #268	; 0x10c
 8002e90:	e9ce 1102 	strd	r1, r1, [lr, #8]
    _model_a2c_network_actor_mlp_activations_2_Elu_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 128);
 8002e94:	f103 0180 	add.w	r1, r3, #128	; 0x80
 8002e98:	e9cc 1102 	strd	r1, r1, [ip, #8]
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002e9c:	1d19      	adds	r1, r3, #4
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002e9e:	3308      	adds	r3, #8
    mu_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 8002ea0:	e9c6 1102 	strd	r1, r1, [r6, #8]
    _model_a2c_network_Mul_output_0_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 8002ea4:	e9c4 3302 	strd	r3, r3, [r4, #8]
    log_std_output_array.data = AI_PTR(g_network_activations_map[0] + 12);
 8002ea8:	60c2      	str	r2, [r0, #12]

  ai_bool ok = true;
  ok &= network_configure_weights(net_ctx, params);
  ok &= network_configure_activations(net_ctx, params);

  ok &= ai_platform_network_post_init(network);
 8002eaa:	9801      	ldr	r0, [sp, #4]
 8002eac:	f008 fadc 	bl	800b468 <ai_platform_network_post_init>
 8002eb0:	9b02      	ldr	r3, [sp, #8]
 8002eb2:	4028      	ands	r0, r5
 8002eb4:	4003      	ands	r3, r0
 8002eb6:	b2d8      	uxtb	r0, r3

  return ok;
}
 8002eb8:	b005      	add	sp, #20
 8002eba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_WEIGHTS);
 8002ebe:	2212      	movs	r2, #18
 8002ec0:	2130      	movs	r1, #48	; 0x30
 8002ec2:	4620      	mov	r0, r4
 8002ec4:	f007 ff60 	bl	800ad88 <ai_platform_network_set_error>
  return false;
 8002ec8:	e7a7      	b.n	8002e1a <ai_network_init+0x16e>
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_ACTIVATIONS);
 8002eca:	2213      	movs	r2, #19
 8002ecc:	4620      	mov	r0, r4
 8002ece:	2130      	movs	r1, #48	; 0x30
 8002ed0:	f007 ff5a 	bl	800ad88 <ai_platform_network_set_error>
  return false;
 8002ed4:	e7e9      	b.n	8002eaa <ai_network_init+0x1fe>
 8002ed6:	bf00      	nop
 8002ed8:	20002dc4 	.word	0x20002dc4
 8002edc:	20000cc0 	.word	0x20000cc0
 8002ee0:	20001360 	.word	0x20001360
 8002ee4:	20001390 	.word	0x20001390
 8002ee8:	20000db8 	.word	0x20000db8
 8002eec:	20000de8 	.word	0x20000de8
 8002ef0:	20000f08 	.word	0x20000f08
 8002ef4:	20000e90 	.word	0x20000e90
 8002ef8:	20002dc0 	.word	0x20002dc0
 8002efc:	20001330 	.word	0x20001330
 8002f00:	20000d88 	.word	0x20000d88
 8002f04:	20001228 	.word	0x20001228
 8002f08:	200012d0 	.word	0x200012d0
 8002f0c:	20000d10 	.word	0x20000d10
 8002f10:	20001188 	.word	0x20001188
 8002f14:	20001138 	.word	0x20001138
 8002f18:	200010e8 	.word	0x200010e8
 8002f1c:	20000ff8 	.word	0x20000ff8
 8002f20:	20000e30 	.word	0x20000e30
 8002f24:	20000ed8 	.word	0x20000ed8
 8002f28:	20001408 	.word	0x20001408
 8002f2c:	20001258 	.word	0x20001258
 8002f30:	20000d40 	.word	0x20000d40
 8002f34:	20000e60 	.word	0x20000e60
 8002f38:	20001438 	.word	0x20001438
 8002f3c:	200013c0 	.word	0x200013c0
 8002f40:	20001300 	.word	0x20001300
 8002f44:	20001288 	.word	0x20001288
 8002f48:	20000fa8 	.word	0x20000fa8
 8002f4c:	20000f58 	.word	0x20000f58
 8002f50:	20001048 	.word	0x20001048
 8002f54:	20001098 	.word	0x20001098

08002f58 <ai_network_create_and_init>:
{
 8002f58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002f5c:	b091      	sub	sp, #68	; 0x44
  return ai_platform_network_create(
 8002f5e:	2300      	movs	r3, #0
 8002f60:	2405      	movs	r4, #5
 8002f62:	9400      	str	r4, [sp, #0]
 8002f64:	9301      	str	r3, [sp, #4]
{
 8002f66:	460f      	mov	r7, r1
 8002f68:	4616      	mov	r6, r2
  return ai_platform_network_create(
 8002f6a:	4619      	mov	r1, r3
 8002f6c:	4a26      	ldr	r2, [pc, #152]	; (8003008 <ai_network_create_and_init+0xb0>)
 8002f6e:	2301      	movs	r3, #1
{
 8002f70:	4680      	mov	r8, r0
  return ai_platform_network_create(
 8002f72:	f008 f8b5 	bl	800b0e0 <ai_platform_network_create>
    if (err.type != AI_ERROR_NONE)
 8002f76:	f010 09ff 	ands.w	r9, r0, #255	; 0xff
 8002f7a:	4604      	mov	r4, r0
 8002f7c:	d003      	beq.n	8002f86 <ai_network_create_and_init+0x2e>
}
 8002f7e:	4620      	mov	r0, r4
 8002f80:	b011      	add	sp, #68	; 0x44
 8002f82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (ai_network_data_params_get(&params) != true) {
 8002f86:	a802      	add	r0, sp, #8
 8002f88:	f000 f842 	bl	8003010 <ai_network_data_params_get>
 8002f8c:	b3a8      	cbz	r0, 8002ffa <ai_network_create_and_init+0xa2>
    if (activations) {
 8002f8e:	b17f      	cbz	r7, 8002fb0 <ai_network_create_and_init+0x58>
        for (int idx=0;idx<params.map_activations.size;idx++)
 8002f90:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002f94:	b163      	cbz	r3, 8002fb0 <ai_network_create_and_init+0x58>
 8002f96:	3f04      	subs	r7, #4
 8002f98:	464d      	mov	r5, r9
            AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_activations, idx, activations[idx]);
 8002f9a:	4629      	mov	r1, r5
 8002f9c:	f857 2f04 	ldr.w	r2, [r7, #4]!
 8002fa0:	a805      	add	r0, sp, #20
 8002fa2:	f007 fda5 	bl	800aaf0 <ai_buffer_array_item_set_address>
        for (int idx=0;idx<params.map_activations.size;idx++)
 8002fa6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002faa:	3501      	adds	r5, #1
 8002fac:	42ab      	cmp	r3, r5
 8002fae:	dcf4      	bgt.n	8002f9a <ai_network_create_and_init+0x42>
    if (weights) {
 8002fb0:	b17e      	cbz	r6, 8002fd2 <ai_network_create_and_init+0x7a>
        for (int idx=0;idx<params.map_weights.size;idx++)
 8002fb2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002fb6:	b163      	cbz	r3, 8002fd2 <ai_network_create_and_init+0x7a>
 8002fb8:	3e04      	subs	r6, #4
 8002fba:	2500      	movs	r5, #0
            AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_weights, idx, weights[idx]);
 8002fbc:	4629      	mov	r1, r5
 8002fbe:	f856 2f04 	ldr.w	r2, [r6, #4]!
 8002fc2:	a803      	add	r0, sp, #12
 8002fc4:	f007 fd94 	bl	800aaf0 <ai_buffer_array_item_set_address>
        for (int idx=0;idx<params.map_weights.size;idx++)
 8002fc8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002fcc:	3501      	adds	r5, #1
 8002fce:	42ab      	cmp	r3, r5
 8002fd0:	dcf4      	bgt.n	8002fbc <ai_network_create_and_init+0x64>
    if (ai_network_init(*network, &params) != true) {
 8002fd2:	f8d8 0000 	ldr.w	r0, [r8]
 8002fd6:	a902      	add	r1, sp, #8
 8002fd8:	f7ff fe68 	bl	8002cac <ai_network_init>
 8002fdc:	b128      	cbz	r0, 8002fea <ai_network_create_and_init+0x92>
    return err;
 8002fde:	f369 0407 	bfi	r4, r9, #0, #8
}
 8002fe2:	4620      	mov	r0, r4
 8002fe4:	b011      	add	sp, #68	; 0x44
 8002fe6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  return ai_platform_network_get_error(network);
 8002fea:	f8d8 0000 	ldr.w	r0, [r8]
 8002fee:	f007 fe5d 	bl	800acac <ai_platform_network_get_error>
 8002ff2:	fa5f f980 	uxtb.w	r9, r0
 8002ff6:	4604      	mov	r4, r0
 8002ff8:	e7f1      	b.n	8002fde <ai_network_create_and_init+0x86>
 8002ffa:	f8d8 0000 	ldr.w	r0, [r8]
 8002ffe:	f007 fe55 	bl	800acac <ai_platform_network_get_error>
 8003002:	4604      	mov	r4, r0
        return err;
 8003004:	e7bb      	b.n	8002f7e <ai_network_create_and_init+0x26>
 8003006:	bf00      	nop
 8003008:	20001198 	.word	0x20001198

0800300c <ai_network_run>:

AI_API_ENTRY
ai_i32 ai_network_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
  return ai_platform_network_process(network, input, output);
 800300c:	f008 bab4 	b.w	800b578 <ai_platform_network_process>

08003010 <ai_network_data_params_get>:
 * @return true if a valid configuration is present, false otherwise
 */
AI_API_ENTRY
ai_bool ai_network_data_params_get(ai_network_params* params)
{
  if (!params) return false;
 8003010:	4603      	mov	r3, r0
 8003012:	b198      	cbz	r0, 800303c <ai_network_data_params_get+0x2c>
{
 8003014:	b510      	push	{r4, lr}
  
  const ai_buffer_array map_activations = 
 8003016:	4c0a      	ldr	r4, [pc, #40]	; (8003040 <ai_network_data_params_get+0x30>)
 8003018:	e894 0003 	ldmia.w	r4, {r0, r1}
{
 800301c:	b084      	sub	sp, #16
  const ai_buffer_array map_activations = 
 800301e:	466a      	mov	r2, sp
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_ACTIVATIONS_COUNT, g_network_data_map_activations);
  
  const ai_buffer_array map_weights = 
 8003020:	3408      	adds	r4, #8
  const ai_buffer_array map_activations = 
 8003022:	e882 0003 	stmia.w	r2, {r0, r1}
  const ai_buffer_array map_weights = 
 8003026:	e894 0003 	ldmia.w	r4, {r0, r1}
 800302a:	ac02      	add	r4, sp, #8
 800302c:	e884 0003 	stmia.w	r4, {r0, r1}
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_WEIGHTS_COUNT, g_network_data_map_weights);

  return ai_platform_bind_network_params(params, &map_weights, &map_activations);
 8003030:	4621      	mov	r1, r4
 8003032:	4618      	mov	r0, r3
 8003034:	f007 fe18 	bl	800ac68 <ai_platform_bind_network_params>
}
 8003038:	b004      	add	sp, #16
 800303a:	bd10      	pop	{r4, pc}
 800303c:	4770      	bx	lr
 800303e:	bf00      	nop
 8003040:	0800ee80 	.word	0x0800ee80

08003044 <PWMC_GetPhaseCurrents>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctGetPhaseCurrents(pHandle, Iab);
 8003044:	6803      	ldr	r3, [r0, #0]
 8003046:	4718      	bx	r3

08003048 <PWMC_SetPhaseVoltage>:
  * @param  Valfa_beta: Voltage Components expressed in the @f$(\alpha, \beta)@f$ reference frame.
  * @retval #MC_NO_ERROR if no error occurred or #MC_DURATION if the duty cycles were
  *         set too late for being taken into account in the next PWM cycle.
  */
__weak uint16_t PWMC_SetPhaseVoltage(PWMC_Handle_t *pHandle, alphabeta_t Valfa_beta)
{
 8003048:	b530      	push	{r4, r5, lr}
    int32_t wTimePhA;
    int32_t wTimePhB;
    int32_t wTimePhC;

    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 800304a:	f8b0 e072 	ldrh.w	lr, [r0, #114]	; 0x72
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 800304e:	f8b0 204e 	ldrh.w	r2, [r0, #78]	; 0x4e
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8003052:	ea4f 4c21 	mov.w	ip, r1, asr #16
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 8003056:	b20b      	sxth	r3, r1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 8003058:	fb0e fc0c 	mul.w	ip, lr, ip
 800305c:	ebcc 7ccc 	rsb	ip, ip, ip, lsl #31
    wUAlpha = Valfa_beta.alpha * (int32_t)pHandle->hT_Sqrt3;
 8003060:	fb02 f303 	mul.w	r3, r2, r3
{
 8003064:	b083      	sub	sp, #12

    wX = wUBeta;
    wY = (wUBeta + wUAlpha) / 2;
 8003066:	eb03 024c 	add.w	r2, r3, ip, lsl #1
    wZ = (wUBeta - wUAlpha) / 2;
 800306a:	ebc3 034c 	rsb	r3, r3, ip, lsl #1
{
 800306e:	9101      	str	r1, [sp, #4]
    wZ = (wUBeta - wUAlpha) / 2;
 8003070:	eb03 74d3 	add.w	r4, r3, r3, lsr #31
    wY = (wUBeta + wUAlpha) / 2;
 8003074:	eb02 71d2 	add.w	r1, r2, r2, lsr #31

    /* Sector calculation from wX, wY, wZ */
    if (wY < 0)
 8003078:	1c55      	adds	r5, r2, #1
    wUBeta = -(Valfa_beta.beta * ((int32_t)pHandle->PWMperiod)) * 2;
 800307a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    wY = (wUBeta + wUAlpha) / 2;
 800307e:	ea4f 0161 	mov.w	r1, r1, asr #1
    wZ = (wUBeta - wUAlpha) / 2;
 8003082:	ea4f 0464 	mov.w	r4, r4, asr #1
    if (wY < 0)
 8003086:	f2c0 809c 	blt.w	80031c2 <PWMC_SetPhaseVoltage+0x17a>
        }
        }
    }
    else /* wY > 0 */
    {
      if (wZ >= 0)
 800308a:	1c5d      	adds	r5, r3, #1
 800308c:	db65      	blt.n	800315a <PWMC_SetPhaseVoltage+0x112>
      {
        pHandle->Sector = SECTOR_2;
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 800308e:	1b09      	subs	r1, r1, r4
 8003090:	bf44      	itt	mi
 8003092:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 8003096:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 800309a:	2b00      	cmp	r3, #0
 800309c:	bfbc      	itt	lt
 800309e:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 80030a2:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
        wTimePhC = wTimePhA - (wY / 131072);
 80030a6:	2a00      	cmp	r2, #0
 80030a8:	bfb8      	it	lt
 80030aa:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80030ae:	ea4f 0e9e 	mov.w	lr, lr, lsr #2

        if(true == pHandle->SingleShuntTopology)
 80030b2:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80030b6:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
        pHandle->Sector = SECTOR_2;
 80030ba:	f04f 0c01 	mov.w	ip, #1
        wTimePhC = wTimePhA - (wY / 131072);
 80030be:	bfb8      	it	lt
 80030c0:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
        pHandle->Sector = SECTOR_2;
 80030c4:	f880 c07c 	strb.w	ip, [r0, #124]	; 0x7c
        wTimePhB = wTimePhA + (wZ / 131072);
 80030c8:	eb01 43a3 	add.w	r3, r1, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072);
 80030cc:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 80030d0:	2c00      	cmp	r4, #0
 80030d2:	f040 80a0 	bne.w	8003216 <PWMC_SetPhaseVoltage+0x1ce>
          pHandle->midDuty = 0U;
          pHandle->highDuty = 1U;
        }
        else
        {
        pHandle->lowDuty = (uint16_t)wTimePhB;
 80030d6:	fa1f fe83 	uxth.w	lr, r3
        pHandle->midDuty = (uint16_t)wTimePhA;
 80030da:	fa1f fc81 	uxth.w	ip, r1
        pHandle->highDuty = (uint16_t)wTimePhC;
 80030de:	b294      	uxth	r4, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 80030e0:	f8a0 405c 	strh.w	r4, [r0, #92]	; 0x5c

    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));

    if (1U == pHandle->DTTest)
 80030e4:	f8b0 4070 	ldrh.w	r4, [r0, #112]	; 0x70
          pHandle->lowDuty = (uint16_t)wTimePhC;
 80030e8:	f8a0 e058 	strh.w	lr, [r0, #88]	; 0x58
 80030ec:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 80030f0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80030f4:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 80030f8:	b289      	uxth	r1, r1
 80030fa:	b29b      	uxth	r3, r3
 80030fc:	b292      	uxth	r2, r2
    if (1U == pHandle->DTTest)
 80030fe:	2c01      	cmp	r4, #1
          pHandle->midDuty = (uint16_t)wTimePhB;
 8003100:	f8a0 c05a 	strh.w	ip, [r0, #90]	; 0x5a
    pHandle->CntPhA = (uint16_t)(MAX(wTimePhA, 0));
 8003104:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
    pHandle->CntPhB = (uint16_t)(MAX(wTimePhB, 0));
 8003108:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
    pHandle->CntPhC = (uint16_t)(MAX(wTimePhC, 0));
 800310c:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
    if (1U == pHandle->DTTest)
 8003110:	d11e      	bne.n	8003150 <PWMC_SetPhaseVoltage+0x108>
    {
      /* Dead time compensation */
      if (pHandle->Ia > 0)
 8003112:	f9b0 4062 	ldrsh.w	r4, [r0, #98]	; 0x62
 8003116:	2c00      	cmp	r4, #0
      {
        pHandle->CntPhA += pHandle->DTCompCnt;
 8003118:	f8b0 4074 	ldrh.w	r4, [r0, #116]	; 0x74
 800311c:	bfcc      	ite	gt
 800311e:	1909      	addgt	r1, r1, r4
      }
      else
      {
        pHandle->CntPhA -= pHandle->DTCompCnt;
 8003120:	1b09      	suble	r1, r1, r4
 8003122:	b289      	uxth	r1, r1
 8003124:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
      }

      if (pHandle->Ib > 0)
 8003128:	f9b0 1064 	ldrsh.w	r1, [r0, #100]	; 0x64
 800312c:	2900      	cmp	r1, #0
      else
      {
        pHandle->CntPhB -= pHandle->DTCompCnt;
      }

      if (pHandle->Ic > 0)
 800312e:	f9b0 1066 	ldrsh.w	r1, [r0, #102]	; 0x66
        pHandle->CntPhB += pHandle->DTCompCnt;
 8003132:	bfcc      	ite	gt
 8003134:	191b      	addgt	r3, r3, r4
        pHandle->CntPhB -= pHandle->DTCompCnt;
 8003136:	1b1b      	suble	r3, r3, r4
      if (pHandle->Ic > 0)
 8003138:	2900      	cmp	r1, #0
        pHandle->CntPhB -= pHandle->DTCompCnt;
 800313a:	b29b      	uxth	r3, r3
      {
        pHandle->CntPhC += pHandle->DTCompCnt;
 800313c:	bfcc      	ite	gt
 800313e:	18a4      	addgt	r4, r4, r2
      }
      else
      {
        pHandle->CntPhC -= pHandle->DTCompCnt;
 8003140:	1b12      	suble	r2, r2, r4
 8003142:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
        pHandle->CntPhC += pHandle->DTCompCnt;
 8003146:	bfcc      	ite	gt
 8003148:	f8a0 4054 	strhgt.w	r4, [r0, #84]	; 0x54
        pHandle->CntPhC -= pHandle->DTCompCnt;
 800314c:	f8a0 2054 	strhle.w	r2, [r0, #84]	; 0x54
      }
    }
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 8003150:	6943      	ldr	r3, [r0, #20]
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (returnValue);
}
 8003152:	b003      	add	sp, #12
 8003154:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    returnValue = pHandle->pFctSetADCSampPointSectX(pHandle);
 8003158:	4718      	bx	r3
        if ( wX <= 0 )
 800315a:	f1bc 0f00 	cmp.w	ip, #0
 800315e:	f340 808c 	ble.w	800327a <PWMC_SetPhaseVoltage+0x232>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 8003162:	ebbc 0404 	subs.w	r4, ip, r4
 8003166:	bf44      	itt	mi
 8003168:	f504 347f 	addmi.w	r4, r4, #261120	; 0x3fc00
 800316c:	f204 34ff 	addwmi	r4, r4, #1023	; 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 8003170:	2b00      	cmp	r3, #0
 8003172:	bfbc      	itt	lt
 8003174:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 8003178:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 800317c:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhC = wTimePhB - (wX / 131072);
 8003180:	f1bc 0f00 	cmp.w	ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4)+ ((wX - wZ) / (int32_t)262144);
 8003184:	eb0e 41a4 	add.w	r1, lr, r4, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 8003188:	bfb8      	it	lt
 800318a:	f50c 3cff 	addlt.w	ip, ip, #130560	; 0x1fe00
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 800318e:	f890 407f 	ldrb.w	r4, [r0, #127]	; 0x7f
          pHandle->Sector = SECTOR_1;
 8003192:	f04f 0200 	mov.w	r2, #0
          wTimePhB = wTimePhA + (wZ / 131072);
 8003196:	eb01 43a3 	add.w	r3, r1, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 800319a:	bfb8      	it	lt
 800319c:	f20c 1cff 	addwlt	ip, ip, #511	; 0x1ff
          pHandle->Sector = SECTOR_1;
 80031a0:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
          wTimePhC = wTimePhB - (wX / 131072);
 80031a4:	eba3 426c 	sub.w	r2, r3, ip, asr #17
          if((pHandle->DPWM_Mode == true) || (pHandle->SingleShuntTopology == true))
 80031a8:	2c00      	cmp	r4, #0
 80031aa:	f040 80c6 	bne.w	800333a <PWMC_SetPhaseVoltage+0x2f2>
 80031ae:	f890 5087 	ldrb.w	r5, [r0, #135]	; 0x87
 80031b2:	2d00      	cmp	r5, #0
 80031b4:	f000 80d3 	beq.w	800335e <PWMC_SetPhaseVoltage+0x316>
 80031b8:	f04f 0e02 	mov.w	lr, #2
 80031bc:	f04f 0c01 	mov.w	ip, #1
 80031c0:	e78e      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
      if (wZ < 0)
 80031c2:	1c5d      	adds	r5, r3, #1
 80031c4:	f2c0 8085 	blt.w	80032d2 <PWMC_SetPhaseVoltage+0x28a>
        if (wX <= 0)
 80031c8:	f1bc 0f00 	cmp.w	ip, #0
 80031cc:	dd29      	ble.n	8003222 <PWMC_SetPhaseVoltage+0x1da>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 80031ce:	ebb1 010c 	subs.w	r1, r1, ip
 80031d2:	bf44      	itt	mi
 80031d4:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 80031d8:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 80031dc:	2a00      	cmp	r2, #0
 80031de:	bfb8      	it	lt
 80031e0:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4)+ ((wY - wX) / (int32_t)262144);
 80031e4:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
 80031e8:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
          wTimePhC = wTimePhA - (wY / 131072);
 80031ec:	bfb8      	it	lt
 80031ee:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
          if(true == pHandle->SingleShuntTopology)
 80031f2:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          pHandle->Sector = SECTOR_3;
 80031f6:	2302      	movs	r3, #2
          wTimePhC = wTimePhA - (wY / 131072);
 80031f8:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
          pHandle->Sector = SECTOR_3;
 80031fc:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
          wTimePhB = wTimePhC + (wX / 131072);
 8003200:	eb02 436c 	add.w	r3, r2, ip, asr #17
          if(true == pHandle->SingleShuntTopology)
 8003204:	2c00      	cmp	r4, #0
 8003206:	f040 8092 	bne.w	800332e <PWMC_SetPhaseVoltage+0x2e6>
          pHandle->lowDuty = (uint16_t)wTimePhB;
 800320a:	fa1f fe83 	uxth.w	lr, r3
          pHandle->midDuty = (uint16_t)wTimePhC;
 800320e:	fa1f fc82 	uxth.w	ip, r2
          pHandle->highDuty = (uint16_t)wTimePhA;
 8003212:	b28c      	uxth	r4, r1
 8003214:	e764      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
 8003216:	f04f 0e02 	mov.w	lr, #2
 800321a:	f04f 0c00 	mov.w	ip, #0
 800321e:	2401      	movs	r4, #1
 8003220:	e75e      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8003222:	ebbc 0404 	subs.w	r4, ip, r4
 8003226:	bf44      	itt	mi
 8003228:	f504 347f 	addmi.w	r4, r4, #261120	; 0x3fc00
 800322c:	f204 34ff 	addwmi	r4, r4, #1023	; 0x3ff
          wTimePhB = wTimePhA + (wZ / 131072);
 8003230:	2b00      	cmp	r3, #0
 8003232:	bfb8      	it	lt
 8003234:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
          pHandle->Sector = SECTOR_4;
 8003238:	f04f 0203 	mov.w	r2, #3
          wTimePhB = wTimePhA + (wZ / 131072);
 800323c:	bfb8      	it	lt
 800323e:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
          pHandle->Sector = SECTOR_4;
 8003242:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 8003246:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhC = wTimePhB - (wX / 131072);
 800324a:	f1bc 0200 	subs.w	r2, ip, #0
          wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wX - wZ) / (int32_t)262144);
 800324e:	eb0e 41a4 	add.w	r1, lr, r4, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 8003252:	bfb8      	it	lt
 8003254:	f502 32ff 	addlt.w	r2, r2, #130560	; 0x1fe00
          if(true == pHandle->SingleShuntTopology)
 8003258:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          wTimePhB = wTimePhA + (wZ / 131072);
 800325c:	eb01 43a3 	add.w	r3, r1, r3, asr #18
          wTimePhC = wTimePhB - (wX / 131072);
 8003260:	bfb8      	it	lt
 8003262:	f202 12ff 	addwlt	r2, r2, #511	; 0x1ff
 8003266:	eba3 4262 	sub.w	r2, r3, r2, asr #17
          if(true == pHandle->SingleShuntTopology)
 800326a:	2c00      	cmp	r4, #0
 800326c:	d071      	beq.n	8003352 <PWMC_SetPhaseVoltage+0x30a>
 800326e:	f04f 0e00 	mov.w	lr, #0
 8003272:	f04f 0c01 	mov.w	ip, #1
 8003276:	2402      	movs	r4, #2
 8003278:	e732      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 800327a:	ebb1 010c 	subs.w	r1, r1, ip
 800327e:	bf44      	itt	mi
 8003280:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 8003284:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
          wTimePhC = wTimePhA - (wY / 131072);
 8003288:	2a00      	cmp	r2, #0
 800328a:	bfb8      	it	lt
 800328c:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
          pHandle->Sector = SECTOR_6;
 8003290:	f04f 0305 	mov.w	r3, #5
          wTimePhC = wTimePhA - (wY / 131072);
 8003294:	bfb8      	it	lt
 8003296:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
          pHandle->Sector = SECTOR_6;
 800329a:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 800329e:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
          wTimePhB = wTimePhC + (wX / 131072);
 80032a2:	f1bc 0300 	subs.w	r3, ip, #0
 80032a6:	bfb8      	it	lt
 80032a8:	f503 33ff 	addlt.w	r3, r3, #130560	; 0x1fe00
          wTimePhA = (((int32_t )pHandle->PWMperiod) / 4) + ((wY - wX) / (int32_t)262144);
 80032ac:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
          if(true == pHandle->SingleShuntTopology)
 80032b0:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
          wTimePhC = wTimePhA - (wY / 131072);
 80032b4:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
          wTimePhB = wTimePhC + (wX / 131072);
 80032b8:	bfb8      	it	lt
 80032ba:	f203 13ff 	addwlt	r3, r3, #511	; 0x1ff
 80032be:	eb02 4363 	add.w	r3, r2, r3, asr #17
          if(true == pHandle->SingleShuntTopology)
 80032c2:	2c00      	cmp	r4, #0
 80032c4:	d03f      	beq.n	8003346 <PWMC_SetPhaseVoltage+0x2fe>
 80032c6:	f04f 0e01 	mov.w	lr, #1
 80032ca:	f04f 0c02 	mov.w	ip, #2
 80032ce:	2400      	movs	r4, #0
 80032d0:	e706      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80032d2:	1b09      	subs	r1, r1, r4
 80032d4:	bf44      	itt	mi
 80032d6:	f501 317f 	addmi.w	r1, r1, #261120	; 0x3fc00
 80032da:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
        wTimePhB = wTimePhA + (wZ / 131072);
 80032de:	2b00      	cmp	r3, #0
 80032e0:	bfbc      	itt	lt
 80032e2:	f503 337f 	addlt.w	r3, r3, #261120	; 0x3fc00
 80032e6:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
        wTimePhC = wTimePhA - (wY / 131072) ;
 80032ea:	2a00      	cmp	r2, #0
 80032ec:	bfb8      	it	lt
 80032ee:	f502 327f 	addlt.w	r2, r2, #261120	; 0x3fc00
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80032f2:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
        if(true == pHandle->SingleShuntTopology)
 80032f6:	f890 4087 	ldrb.w	r4, [r0, #135]	; 0x87
        wTimePhA = (((int32_t)pHandle->PWMperiod) / 4) + ((wY - wZ) / (int32_t)262144);
 80032fa:	eb0e 41a1 	add.w	r1, lr, r1, asr #18
        pHandle->Sector = SECTOR_5;
 80032fe:	f04f 0c04 	mov.w	ip, #4
        wTimePhC = wTimePhA - (wY / 131072) ;
 8003302:	bfb8      	it	lt
 8003304:	f202 32ff 	addwlt	r2, r2, #1023	; 0x3ff
        pHandle->Sector = SECTOR_5;
 8003308:	f880 c07c 	strb.w	ip, [r0, #124]	; 0x7c
        wTimePhB = wTimePhA + (wZ / 131072);
 800330c:	eb01 43a3 	add.w	r3, r1, r3, asr #18
        wTimePhC = wTimePhA - (wY / 131072) ;
 8003310:	eba1 42a2 	sub.w	r2, r1, r2, asr #18
        if(true == pHandle->SingleShuntTopology)
 8003314:	b92c      	cbnz	r4, 8003322 <PWMC_SetPhaseVoltage+0x2da>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 8003316:	fa1f fe82 	uxth.w	lr, r2
          pHandle->midDuty = (uint16_t)wTimePhA;
 800331a:	fa1f fc81 	uxth.w	ip, r1
          pHandle->highDuty = (uint16_t)wTimePhB;
 800331e:	b29c      	uxth	r4, r3
 8003320:	e6de      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
 8003322:	f04f 0e01 	mov.w	lr, #1
 8003326:	f04f 0c00 	mov.w	ip, #0
 800332a:	2402      	movs	r4, #2
 800332c:	e6d8      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
 800332e:	f04f 0e00 	mov.w	lr, #0
 8003332:	f04f 0c02 	mov.w	ip, #2
 8003336:	2401      	movs	r4, #1
 8003338:	e6d2      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
 800333a:	f04f 0e02 	mov.w	lr, #2
 800333e:	f04f 0c01 	mov.w	ip, #1
 8003342:	2400      	movs	r4, #0
 8003344:	e6cc      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 8003346:	fa1f fe81 	uxth.w	lr, r1
            pHandle->midDuty = (uint16_t)wTimePhC;
 800334a:	fa1f fc82 	uxth.w	ip, r2
            pHandle->highDuty = (uint16_t)wTimePhB;
 800334e:	b29c      	uxth	r4, r3
 8003350:	e6c6      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
          pHandle->lowDuty = (uint16_t)wTimePhC;
 8003352:	fa1f fe82 	uxth.w	lr, r2
          pHandle->midDuty = (uint16_t)wTimePhB;
 8003356:	fa1f fc83 	uxth.w	ip, r3
          pHandle->highDuty = (uint16_t)wTimePhA;
 800335a:	b28c      	uxth	r4, r1
 800335c:	e6c0      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
            pHandle->lowDuty = (uint16_t)wTimePhA;
 800335e:	fa1f fe81 	uxth.w	lr, r1
            pHandle->midDuty = (uint16_t)wTimePhB;
 8003362:	fa1f fc83 	uxth.w	ip, r3
            pHandle->highDuty = (uint16_t)wTimePhC;
 8003366:	b294      	uxth	r4, r2
 8003368:	e6ba      	b.n	80030e0 <PWMC_SetPhaseVoltage+0x98>
 800336a:	bf00      	nop

0800336c <PWMC_SwitchOffPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOffPwm(pHandle);
 800336c:	6843      	ldr	r3, [r0, #4]
 800336e:	4718      	bx	r3

08003370 <PWMC_SwitchOnPWM>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->pFctSwitchOnPwm(pHandle);
 8003370:	6883      	ldr	r3, [r0, #8]
 8003372:	4718      	bx	r3

08003374 <PWMC_CurrentReadingCalibr>:
  *         #CRC_EXEC to execute the offset calibration.
  * @retval true if the current calibration has been completed, **false** if it is
  *         still ongoing.
  */
__weak bool PWMC_CurrentReadingCalibr(PWMC_Handle_t *pHandle, CRCAction_t action)
{
 8003374:	b510      	push	{r4, lr}
 8003376:	4604      	mov	r4, r0
 8003378:	b082      	sub	sp, #8
    /* Nothing to do */
  }
  else
  {
#endif
    if (CRC_START == action)
 800337a:	b199      	cbz	r1, 80033a4 <PWMC_CurrentReadingCalibr+0x30>
    {
      PWMC_SwitchOffPWM(pHandle);
      pHandle->pFctCurrReadingCalib(pHandle);
      retVal = true;
    }
    else if (CRC_EXEC == action)
 800337c:	2901      	cmp	r1, #1
 800337e:	d002      	beq.n	8003386 <PWMC_CurrentReadingCalibr+0x12>
  bool retVal = false;
 8003380:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (retVal);
}
 8003382:	b002      	add	sp, #8
 8003384:	bd10      	pop	{r4, pc}
      if (pHandle->OffCalibrWaitTimeCounter > 0u)
 8003386:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 800338a:	b19b      	cbz	r3, 80033b4 <PWMC_CurrentReadingCalibr+0x40>
        pHandle->OffCalibrWaitTimeCounter--;
 800338c:	3b01      	subs	r3, #1
 800338e:	b29b      	uxth	r3, r3
 8003390:	9101      	str	r1, [sp, #4]
 8003392:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
        if (0U == pHandle->OffCalibrWaitTimeCounter)
 8003396:	2b00      	cmp	r3, #0
 8003398:	d1f2      	bne.n	8003380 <PWMC_CurrentReadingCalibr+0xc>
          pHandle->pFctCurrReadingCalib(pHandle);
 800339a:	68c3      	ldr	r3, [r0, #12]
 800339c:	4798      	blx	r3
          retVal = true;
 800339e:	9901      	ldr	r1, [sp, #4]
 80033a0:	4608      	mov	r0, r1
 80033a2:	e7ee      	b.n	8003382 <PWMC_CurrentReadingCalibr+0xe>
      PWMC_SwitchOffPWM(pHandle);
 80033a4:	f7ff ffe2 	bl	800336c <PWMC_SwitchOffPWM>
      pHandle->pFctCurrReadingCalib(pHandle);
 80033a8:	4620      	mov	r0, r4
 80033aa:	68e3      	ldr	r3, [r4, #12]
 80033ac:	4798      	blx	r3
      retVal = true;
 80033ae:	2001      	movs	r0, #1
}
 80033b0:	b002      	add	sp, #8
 80033b2:	bd10      	pop	{r4, pc}
        retVal = true;
 80033b4:	4608      	mov	r0, r1
}
 80033b6:	b002      	add	sp, #8
 80033b8:	bd10      	pop	{r4, pc}
 80033ba:	bf00      	nop

080033bc <PWMC_OVP_Handler>:
    tempPointer = MC_NULL;
  }
  else
  {
#endif
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 80033bc:	6c4a      	ldr	r2, [r1, #68]	; 0x44
{
 80033be:	4603      	mov	r3, r0
    pHandle->OverVoltageFlag = true;
 80033c0:	f04f 0c01 	mov.w	ip, #1
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 80033c4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80033c8:	644a      	str	r2, [r1, #68]	; 0x44
    tempPointer = &(pHandle->Motor);
#ifdef NULL_PTR_CHECK_PWR_CUR_FDB
  }
#endif
  return (tempPointer);
}
 80033ca:	307a      	adds	r0, #122	; 0x7a
    pHandle->OverVoltageFlag = true;
 80033cc:	f883 c083 	strb.w	ip, [r3, #131]	; 0x83
    pHandle->BrakeActionLock = true;
 80033d0:	f883 c085 	strb.w	ip, [r3, #133]	; 0x85
}
 80033d4:	4770      	bx	lr
 80033d6:	bf00      	nop

080033d8 <PWMC_IsFaultOccurred>:
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns #MC_OVER_CURR if an overcurrent has been
  *                  detected since last method call, #MC_NO_FAULTS otherwise.
  */
__weak uint16_t PWMC_IsFaultOccurred(PWMC_Handle_t *pHandle)
{
 80033d8:	4603      	mov	r3, r0
  uint16_t retVal = MC_NO_FAULTS;

  if (true == pHandle->OverVoltageFlag)
 80033da:	f890 0083 	ldrb.w	r0, [r0, #131]	; 0x83
 80033de:	b1a8      	cbz	r0, 800340c <PWMC_IsFaultOccurred+0x34>
  {
    retVal = MC_OVER_VOLT;
    pHandle->OverVoltageFlag = false;
 80033e0:	2200      	movs	r2, #0
 80033e2:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
 80033e6:	2142      	movs	r1, #66	; 0x42
    retVal = MC_OVER_VOLT;
 80033e8:	2002      	movs	r0, #2
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->OverCurrentFlag)
 80033ea:	f893 2082 	ldrb.w	r2, [r3, #130]	; 0x82
 80033ee:	b11a      	cbz	r2, 80033f8 <PWMC_IsFaultOccurred+0x20>
  {
    retVal |= MC_OVER_CURR;
    pHandle->OverCurrentFlag = false;
 80033f0:	2200      	movs	r2, #0
 80033f2:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
    retVal |= MC_OVER_CURR;
 80033f6:	4608      	mov	r0, r1
  else
  {
    /* Nothing to do */
  }

  if (true == pHandle->driverProtectionFlag)
 80033f8:	f893 2084 	ldrb.w	r2, [r3, #132]	; 0x84
 80033fc:	b12a      	cbz	r2, 800340a <PWMC_IsFaultOccurred+0x32>
  {
    retVal |= MC_DP_FAULT;
 80033fe:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
    pHandle->driverProtectionFlag = false;
 8003402:	2200      	movs	r2, #0
    retVal |= MC_DP_FAULT;
 8003404:	b280      	uxth	r0, r0
    pHandle->driverProtectionFlag = false;
 8003406:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
  {
    /* Nothing to do */
  }

  return (retVal);
}
 800340a:	4770      	bx	lr
 800340c:	2140      	movs	r1, #64	; 0x40
 800340e:	e7ec      	b.n	80033ea <PWMC_IsFaultOccurred+0x12>

08003410 <RI_SetRegisterGlobal>:
#include "mcp_config.h"
#include "mcpa.h"
#include "mc_configuration_registers.h"

uint8_t RI_SetRegisterGlobal(uint16_t regID, uint8_t typeID, uint8_t *data, uint16_t *size, int16_t dataAvailable)
{
 8003410:	b510      	push	{r4, lr}
  uint8_t retVal = MCP_CMD_OK;
  switch(typeID)
 8003412:	3908      	subs	r1, #8
{
 8003414:	f9bd c008 	ldrsh.w	ip, [sp, #8]
  switch(typeID)
 8003418:	2920      	cmp	r1, #32
 800341a:	d812      	bhi.n	8003442 <RI_SetRegisterGlobal+0x32>
 800341c:	e8df f001 	tbb	[pc, r1]
 8003420:	11111115 	.word	0x11111115
 8003424:	11111111 	.word	0x11111111
 8003428:	1111111d 	.word	0x1111111d
 800342c:	11111111 	.word	0x11111111
 8003430:	1111112d 	.word	0x1111112d
 8003434:	11111111 	.word	0x11111111
 8003438:	11111135 	.word	0x11111135
 800343c:	11111111 	.word	0x11111111
 8003440:	4c          	.byte	0x4c
 8003441:	00          	.byte	0x00
    }

    default:
    {
      retVal = MCP_ERROR_BAD_DATA_TYPE;
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 8003442:	2200      	movs	r2, #0
 8003444:	801a      	strh	r2, [r3, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 8003446:	2007      	movs	r0, #7
      break;
    }
  }
  return (retVal);
}
 8003448:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_UNKNOWN_REG;
 800344a:	2848      	cmp	r0, #72	; 0x48
      *size = 1;
 800344c:	f04f 0201 	mov.w	r2, #1
          retVal = MCP_ERROR_UNKNOWN_REG;
 8003450:	bf0c      	ite	eq
 8003452:	2004      	moveq	r0, #4
 8003454:	2005      	movne	r0, #5
      *size = 1;
 8003456:	801a      	strh	r2, [r3, #0]
}
 8003458:	bd10      	pop	{r4, pc}
      switch (regID)
 800345a:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 800345e:	d04e      	beq.n	80034fe <RI_SetRegisterGlobal+0xee>
 8003460:	d93c      	bls.n	80034dc <RI_SetRegisterGlobal+0xcc>
 8003462:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003466:	d04a      	beq.n	80034fe <RI_SetRegisterGlobal+0xee>
 8003468:	f641 3258 	movw	r2, #7000	; 0x1b58
 800346c:	4290      	cmp	r0, r2
 800346e:	bf14      	ite	ne
 8003470:	2005      	movne	r0, #5
 8003472:	2004      	moveq	r0, #4
      *size = 2;
 8003474:	2202      	movs	r2, #2
 8003476:	801a      	strh	r2, [r3, #0]
}
 8003478:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_UNKNOWN_REG;
 800347a:	2818      	cmp	r0, #24
      *size = 4;
 800347c:	f04f 0204 	mov.w	r2, #4
          retVal = MCP_ERROR_UNKNOWN_REG;
 8003480:	bf0c      	ite	eq
 8003482:	4610      	moveq	r0, r2
 8003484:	2005      	movne	r0, #5
      *size = 4;
 8003486:	801a      	strh	r2, [r3, #0]
}
 8003488:	bd10      	pop	{r4, pc}
uint8_t RI_MovString(const char_t *srcString, char_t *destString, uint16_t *size, int16_t maxSize)
{
  uint8_t retVal = MCP_CMD_OK;
  const char_t *tempsrcString = srcString;
  char_t *tempdestString = destString;
  *size= 1U ; /* /0 is the min String size */
 800348a:	2101      	movs	r1, #1
 800348c:	8019      	strh	r1, [r3, #0]

  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800348e:	f992 0000 	ldrsb.w	r0, [r2]
 8003492:	b358      	cbz	r0, 80034ec <RI_SetRegisterGlobal+0xdc>
 8003494:	fa1f fc8c 	uxth.w	ip, ip
 8003498:	1850      	adds	r0, r2, r1
 800349a:	e004      	b.n	80034a6 <RI_SetRegisterGlobal+0x96>
  {
    *tempdestString = *tempsrcString;
    tempdestString++;
    tempsrcString++;
    *size = *size + 1U;
 800349c:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 800349e:	f992 4000 	ldrsb.w	r4, [r2]
 80034a2:	3001      	adds	r0, #1
 80034a4:	b314      	cbz	r4, 80034ec <RI_SetRegisterGlobal+0xdc>
    *size = *size + 1U;
 80034a6:	f101 0e01 	add.w	lr, r1, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034aa:	4561      	cmp	r1, ip
    tempdestString++;
 80034ac:	4602      	mov	r2, r0
    *size = *size + 1U;
 80034ae:	fa1f f18e 	uxth.w	r1, lr
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80034b2:	d3f3      	bcc.n	800349c <RI_SetRegisterGlobal+0x8c>
      retVal = MCP_ERROR_RO_REG;
 80034b4:	2004      	movs	r0, #4
}
 80034b6:	bd10      	pop	{r4, pc}
      *size = rawSize + 2U;
 80034b8:	8812      	ldrh	r2, [r2, #0]
 80034ba:	3202      	adds	r2, #2
 80034bc:	b292      	uxth	r2, r2
      if (*size > (uint16_t)dataAvailable)
 80034be:	fa1f fc8c 	uxth.w	ip, ip
 80034c2:	4562      	cmp	r2, ip
      *size = rawSize + 2U;
 80034c4:	801a      	strh	r2, [r3, #0]
      if (*size > (uint16_t)dataAvailable)
 80034c6:	d81c      	bhi.n	8003502 <RI_SetRegisterGlobal+0xf2>
        switch (regID)
 80034c8:	28a8      	cmp	r0, #168	; 0xa8
 80034ca:	d0f3      	beq.n	80034b4 <RI_SetRegisterGlobal+0xa4>
 80034cc:	d812      	bhi.n	80034f4 <RI_SetRegisterGlobal+0xe4>
 80034ce:	f020 0040 	bic.w	r0, r0, #64	; 0x40
            retVal = MCP_ERROR_RO_REG;
 80034d2:	2828      	cmp	r0, #40	; 0x28
 80034d4:	bf14      	ite	ne
 80034d6:	2005      	movne	r0, #5
 80034d8:	2004      	moveq	r0, #4
}
 80034da:	bd10      	pop	{r4, pc}
 80034dc:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80034e0:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 80034e4:	bf14      	ite	ne
 80034e6:	2005      	movne	r0, #5
 80034e8:	2004      	moveq	r0, #4
 80034ea:	e7c3      	b.n	8003474 <RI_SetRegisterGlobal+0x64>
  { /* Last string char must be 0 */
    retVal = MCP_ERROR_STRING_FORMAT;
  }
  else
  {
    *tempdestString = (int8_t)0;
 80034ec:	2300      	movs	r3, #0
 80034ee:	7013      	strb	r3, [r2, #0]
      retVal = MCP_ERROR_RO_REG;
 80034f0:	2004      	movs	r0, #4
  return (retVal);
 80034f2:	e7e0      	b.n	80034b6 <RI_SetRegisterGlobal+0xa6>
            retVal = MCP_ERROR_RO_REG;
 80034f4:	28e8      	cmp	r0, #232	; 0xe8
 80034f6:	bf14      	ite	ne
 80034f8:	2005      	movne	r0, #5
 80034fa:	2004      	moveq	r0, #4
}
 80034fc:	bd10      	pop	{r4, pc}
  uint8_t retVal = MCP_CMD_OK;
 80034fe:	2000      	movs	r0, #0
 8003500:	e7b8      	b.n	8003474 <RI_SetRegisterGlobal+0x64>
        *size = 0;
 8003502:	2200      	movs	r2, #0
 8003504:	801a      	strh	r2, [r3, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 8003506:	200a      	movs	r0, #10
}
 8003508:	bd10      	pop	{r4, pc}
 800350a:	bf00      	nop

0800350c <RI_SetRegisterMotor1>:
{
 800350c:	b530      	push	{r4, r5, lr}
 800350e:	b083      	sub	sp, #12
  switch(typeID)
 8003510:	3908      	subs	r1, #8
{
 8003512:	f9bd e018 	ldrsh.w	lr, [sp, #24]
 8003516:	4694      	mov	ip, r2
 8003518:	461c      	mov	r4, r3
  switch(typeID)
 800351a:	2920      	cmp	r1, #32
 800351c:	d812      	bhi.n	8003544 <RI_SetRegisterMotor1+0x38>
 800351e:	e8df f001 	tbb	[pc, r1]
 8003522:	1116      	.short	0x1116
 8003524:	11111111 	.word	0x11111111
 8003528:	11251111 	.word	0x11251111
 800352c:	11111111 	.word	0x11111111
 8003530:	117b1111 	.word	0x117b1111
 8003534:	11111111 	.word	0x11111111
 8003538:	11491111 	.word	0x11491111
 800353c:	11111111 	.word	0x11111111
 8003540:	1111      	.short	0x1111
 8003542:	64          	.byte	0x64
 8003543:	00          	.byte	0x00
      *size =0; /* From this point we are not able anymore to decode the RX buffer */
 8003544:	2300      	movs	r3, #0
 8003546:	8023      	strh	r3, [r4, #0]
      retVal = MCP_ERROR_BAD_DATA_TYPE;
 8003548:	2007      	movs	r0, #7
}
 800354a:	b003      	add	sp, #12
 800354c:	bd30      	pop	{r4, r5, pc}
      switch (regID)
 800354e:	2848      	cmp	r0, #72	; 0x48
 8003550:	f000 81d1 	beq.w	80038f6 <RI_SetRegisterMotor1+0x3ea>
 8003554:	2888      	cmp	r0, #136	; 0x88
 8003556:	f040 81c3 	bne.w	80038e0 <RI_SetRegisterMotor1+0x3d4>
          uint8_t regdata8 = *data;
 800355a:	7813      	ldrb	r3, [r2, #0]
          if ((uint8_t)MCM_TORQUE_MODE == regdata8)
 800355c:	2b04      	cmp	r3, #4
 800355e:	f000 81e9 	beq.w	8003934 <RI_SetRegisterMotor1+0x428>
          if ((uint8_t)MCM_SPEED_MODE == regdata8)
 8003562:	2b03      	cmp	r3, #3
 8003564:	f000 8210 	beq.w	8003988 <RI_SetRegisterMotor1+0x47c>
  uint8_t retVal = MCP_CMD_OK;
 8003568:	2000      	movs	r0, #0
 800356a:	e1ba      	b.n	80038e2 <RI_SetRegisterMotor1+0x3d6>
      uint16_t regdata16 = *(uint16_t *)data; //cstat !MISRAC2012-Rule-11.3
 800356c:	f5b0 6f15 	cmp.w	r0, #2384	; 0x950
 8003570:	8815      	ldrh	r5, [r2, #0]
      switch (regID)
 8003572:	f000 8245 	beq.w	8003a00 <RI_SetRegisterMotor1+0x4f4>
 8003576:	d871      	bhi.n	800365c <RI_SetRegisterMotor1+0x150>
 8003578:	f5b0 7f34 	cmp.w	r0, #720	; 0x2d0
 800357c:	f000 823a 	beq.w	80039f4 <RI_SetRegisterMotor1+0x4e8>
 8003580:	d959      	bls.n	8003636 <RI_SetRegisterMotor1+0x12a>
 8003582:	f5b0 6f8a 	cmp.w	r0, #1104	; 0x450
 8003586:	f000 8229 	beq.w	80039dc <RI_SetRegisterMotor1+0x4d0>
 800358a:	f240 8100 	bls.w	800378e <RI_SetRegisterMotor1+0x282>
 800358e:	f5b0 6fba 	cmp.w	r0, #1488	; 0x5d0
 8003592:	d00a      	beq.n	80035aa <RI_SetRegisterMotor1+0x9e>
 8003594:	f240 811c 	bls.w	80037d0 <RI_SetRegisterMotor1+0x2c4>
 8003598:	f5b0 6f05 	cmp.w	r0, #2128	; 0x850
 800359c:	d005      	beq.n	80035aa <RI_SetRegisterMotor1+0x9e>
 800359e:	f240 810b 	bls.w	80037b8 <RI_SetRegisterMotor1+0x2ac>
 80035a2:	f5b0 6f11 	cmp.w	r0, #2320	; 0x910
 80035a6:	f040 8122 	bne.w	80037ee <RI_SetRegisterMotor1+0x2e2>
 80035aa:	2004      	movs	r0, #4
      *size = 2;
 80035ac:	2302      	movs	r3, #2
 80035ae:	8023      	strh	r3, [r4, #0]
}
 80035b0:	b003      	add	sp, #12
 80035b2:	bd30      	pop	{r4, r5, pc}
  *size= 1U ; /* /0 is the min String size */
 80035b4:	2201      	movs	r2, #1
 80035b6:	8022      	strh	r2, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80035b8:	f99c 3000 	ldrsb.w	r3, [ip]
 80035bc:	2b00      	cmp	r3, #0
 80035be:	f000 816a 	beq.w	8003896 <RI_SetRegisterMotor1+0x38a>
 80035c2:	fa1f f18e 	uxth.w	r1, lr
 80035c6:	eb0c 0302 	add.w	r3, ip, r2
 80035ca:	e006      	b.n	80035da <RI_SetRegisterMotor1+0xce>
    *size = *size + 1U;
 80035cc:	8022      	strh	r2, [r4, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80035ce:	f99c 0000 	ldrsb.w	r0, [ip]
 80035d2:	3301      	adds	r3, #1
 80035d4:	2800      	cmp	r0, #0
 80035d6:	f000 815e 	beq.w	8003896 <RI_SetRegisterMotor1+0x38a>
    *size = *size + 1U;
 80035da:	1c50      	adds	r0, r2, #1
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80035dc:	4291      	cmp	r1, r2
    tempdestString++;
 80035de:	469c      	mov	ip, r3
    *size = *size + 1U;
 80035e0:	b282      	uxth	r2, r0
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80035e2:	d8f3      	bhi.n	80035cc <RI_SetRegisterMotor1+0xc0>
      retVal = MCP_ERROR_RO_REG;
 80035e4:	2004      	movs	r0, #4
}
 80035e6:	b003      	add	sp, #12
 80035e8:	bd30      	pop	{r4, r5, pc}
      *size = rawSize + 2U;
 80035ea:	8813      	ldrh	r3, [r2, #0]
 80035ec:	3302      	adds	r3, #2
 80035ee:	b29b      	uxth	r3, r3
      if (*size > (uint16_t)dataAvailable)
 80035f0:	fa1f f18e 	uxth.w	r1, lr
 80035f4:	428b      	cmp	r3, r1
      *size = rawSize + 2U;
 80035f6:	8023      	strh	r3, [r4, #0]
      if (*size > (uint16_t)dataAvailable)
 80035f8:	f200 8179 	bhi.w	80038ee <RI_SetRegisterMotor1+0x3e2>
        switch (regID)
 80035fc:	f5b0 7ff4 	cmp.w	r0, #488	; 0x1e8
 8003600:	f000 81ba 	beq.w	8003978 <RI_SetRegisterMotor1+0x46c>
 8003604:	f200 8156 	bhi.w	80038b4 <RI_SetRegisterMotor1+0x3a8>
 8003608:	f5b0 7fd4 	cmp.w	r0, #424	; 0x1a8
 800360c:	f000 81a6 	beq.w	800395c <RI_SetRegisterMotor1+0x450>
 8003610:	f240 8146 	bls.w	80038a0 <RI_SetRegisterMotor1+0x394>
 8003614:	2005      	movs	r0, #5
 8003616:	e798      	b.n	800354a <RI_SetRegisterMotor1+0x3e>
      switch (regID)
 8003618:	2898      	cmp	r0, #152	; 0x98
 800361a:	f000 817d 	beq.w	8003918 <RI_SetRegisterMotor1+0x40c>
 800361e:	f200 8129 	bhi.w	8003874 <RI_SetRegisterMotor1+0x368>
 8003622:	f020 0040 	bic.w	r0, r0, #64	; 0x40
          retVal = MCP_ERROR_RO_REG;
 8003626:	2818      	cmp	r0, #24
 8003628:	bf14      	ite	ne
 800362a:	2005      	movne	r0, #5
 800362c:	2004      	moveq	r0, #4
      *size = 4;
 800362e:	2304      	movs	r3, #4
 8003630:	8023      	strh	r3, [r4, #0]
}
 8003632:	b003      	add	sp, #12
 8003634:	bd30      	pop	{r4, r5, pc}
 8003636:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 800363a:	f000 81f3 	beq.w	8003a24 <RI_SetRegisterMotor1+0x518>
 800363e:	f240 809a 	bls.w	8003776 <RI_SetRegisterMotor1+0x26a>
 8003642:	f5b0 7f04 	cmp.w	r0, #528	; 0x210
 8003646:	f000 81bd 	beq.w	80039c4 <RI_SetRegisterMotor1+0x4b8>
 800364a:	f5b0 7f24 	cmp.w	r0, #656	; 0x290
 800364e:	d121      	bne.n	8003694 <RI_SetRegisterMotor1+0x188>
          PID_SetKP(&PIDIdHandle_M1, (int16_t)regdata16);
 8003650:	48aa      	ldr	r0, [pc, #680]	; (80038fc <RI_SetRegisterMotor1+0x3f0>)
 8003652:	b229      	sxth	r1, r5
 8003654:	f005 fd90 	bl	8009178 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8003658:	2000      	movs	r0, #0
          break;
 800365a:	e7a7      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800365c:	f241 5310 	movw	r3, #5392	; 0x1510
 8003660:	4298      	cmp	r0, r3
 8003662:	f000 81eb 	beq.w	8003a3c <RI_SetRegisterMotor1+0x530>
 8003666:	d940      	bls.n	80036ea <RI_SetRegisterMotor1+0x1de>
 8003668:	f241 6310 	movw	r3, #5648	; 0x1610
 800366c:	4298      	cmp	r0, r3
 800366e:	f000 81df 	beq.w	8003a30 <RI_SetRegisterMotor1+0x524>
 8003672:	d92b      	bls.n	80036cc <RI_SetRegisterMotor1+0x1c0>
 8003674:	f641 03d0 	movw	r3, #6352	; 0x18d0
 8003678:	4298      	cmp	r0, r3
 800367a:	f000 81cd 	beq.w	8003a18 <RI_SetRegisterMotor1+0x50c>
 800367e:	d91a      	bls.n	80036b6 <RI_SetRegisterMotor1+0x1aa>
 8003680:	f641 1310 	movw	r3, #6416	; 0x1910
 8003684:	4298      	cmp	r0, r3
 8003686:	d10f      	bne.n	80036a8 <RI_SetRegisterMotor1+0x19c>
          PID_SetKPDivisorPOW2 (&(&STO_PLL_M1)->PIRegulator,regdata16);
 8003688:	489d      	ldr	r0, [pc, #628]	; (8003900 <RI_SetRegisterMotor1+0x3f4>)
 800368a:	4629      	mov	r1, r5
 800368c:	f005 fd84 	bl	8009198 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003690:	2000      	movs	r0, #0
          break;
 8003692:	e78b      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003694:	f5b0 7fe8 	cmp.w	r0, #464	; 0x1d0
 8003698:	f040 80de 	bne.w	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKI(&PIDIqHandle_M1, (int16_t)regdata16);
 800369c:	4899      	ldr	r0, [pc, #612]	; (8003904 <RI_SetRegisterMotor1+0x3f8>)
 800369e:	b229      	sxth	r1, r5
 80036a0:	f005 fd6c 	bl	800917c <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 80036a4:	2000      	movs	r0, #0
          break;
 80036a6:	e781      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80036a8:	f641 3358 	movw	r3, #7000	; 0x1b58
 80036ac:	4298      	cmp	r0, r3
 80036ae:	bf14      	ite	ne
 80036b0:	2005      	movne	r0, #5
 80036b2:	2004      	moveq	r0, #4
 80036b4:	e77a      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80036b6:	f241 6350 	movw	r3, #5712	; 0x1650
 80036ba:	4298      	cmp	r0, r3
 80036bc:	f040 80cc 	bne.w	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKDDivisorPOW2(&PIDIqHandle_M1, regdata16);
 80036c0:	4890      	ldr	r0, [pc, #576]	; (8003904 <RI_SetRegisterMotor1+0x3f8>)
 80036c2:	4629      	mov	r1, r5
 80036c4:	f005 fd90 	bl	80091e8 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80036c8:	2000      	movs	r0, #0
          break;
 80036ca:	e76f      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80036cc:	f241 5390 	movw	r3, #5520	; 0x1590
 80036d0:	4298      	cmp	r0, r3
 80036d2:	f000 8163 	beq.w	800399c <RI_SetRegisterMotor1+0x490>
 80036d6:	f241 53d0 	movw	r3, #5584	; 0x15d0
 80036da:	4298      	cmp	r0, r3
 80036dc:	d11b      	bne.n	8003716 <RI_SetRegisterMotor1+0x20a>
          PID_SetKPDivisorPOW2(&PIDIqHandle_M1, regdata16);
 80036de:	4889      	ldr	r0, [pc, #548]	; (8003904 <RI_SetRegisterMotor1+0x3f8>)
 80036e0:	4629      	mov	r1, r5
 80036e2:	f005 fd59 	bl	8009198 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80036e6:	2000      	movs	r0, #0
          break;
 80036e8:	e760      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80036ea:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 80036ee:	f000 80fc 	beq.w	80038ea <RI_SetRegisterMotor1+0x3de>
 80036f2:	d92a      	bls.n	800374a <RI_SetRegisterMotor1+0x23e>
 80036f4:	f241 4390 	movw	r3, #5264	; 0x1490
 80036f8:	4298      	cmp	r0, r3
 80036fa:	f000 8175 	beq.w	80039e8 <RI_SetRegisterMotor1+0x4dc>
 80036fe:	d915      	bls.n	800372c <RI_SetRegisterMotor1+0x220>
 8003700:	f241 43d0 	movw	r3, #5328	; 0x14d0
 8003704:	4298      	cmp	r0, r3
 8003706:	f040 80a7 	bne.w	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKDDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 800370a:	487f      	ldr	r0, [pc, #508]	; (8003908 <RI_SetRegisterMotor1+0x3fc>)
 800370c:	4629      	mov	r1, r5
 800370e:	f005 fd6b 	bl	80091e8 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003712:	2000      	movs	r0, #0
          break;
 8003714:	e74a      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003716:	f241 5350 	movw	r3, #5456	; 0x1550
 800371a:	4298      	cmp	r0, r3
 800371c:	f040 809c 	bne.w	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKIDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8003720:	4876      	ldr	r0, [pc, #472]	; (80038fc <RI_SetRegisterMotor1+0x3f0>)
 8003722:	4629      	mov	r1, r5
 8003724:	f005 fd44 	bl	80091b0 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003728:	2000      	movs	r0, #0
          break;
 800372a:	e73f      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800372c:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003730:	f000 80db 	beq.w	80038ea <RI_SetRegisterMotor1+0x3de>
 8003734:	f241 4350 	movw	r3, #5200	; 0x1450
 8003738:	4298      	cmp	r0, r3
 800373a:	f040 808d 	bne.w	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKPDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 800373e:	4872      	ldr	r0, [pc, #456]	; (8003908 <RI_SetRegisterMotor1+0x3fc>)
 8003740:	4629      	mov	r1, r5
 8003742:	f005 fd29 	bl	8009198 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003746:	2000      	movs	r0, #0
          break;
 8003748:	e730      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800374a:	f5b0 6f29 	cmp.w	r0, #2704	; 0xa90
 800374e:	f43f af2c 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 8003752:	d967      	bls.n	8003824 <RI_SetRegisterMotor1+0x318>
 8003754:	f5b0 6f3d 	cmp.w	r0, #3024	; 0xbd0
 8003758:	f43f af27 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 800375c:	d957      	bls.n	800380e <RI_SetRegisterMotor1+0x302>
 800375e:	f5b0 6f49 	cmp.w	r0, #3216	; 0xc90
 8003762:	f43f af22 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 8003766:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800376a:	f5b0 6f41 	cmp.w	r0, #3088	; 0xc10
 800376e:	bf14      	ite	ne
 8003770:	2005      	movne	r0, #5
 8003772:	2004      	moveq	r0, #4
 8003774:	e71a      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003776:	28d0      	cmp	r0, #208	; 0xd0
 8003778:	f000 812a 	beq.w	80039d0 <RI_SetRegisterMotor1+0x4c4>
 800377c:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
 8003780:	d13d      	bne.n	80037fe <RI_SetRegisterMotor1+0x2f2>
          PID_SetKD(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8003782:	4861      	ldr	r0, [pc, #388]	; (8003908 <RI_SetRegisterMotor1+0x3fc>)
 8003784:	b229      	sxth	r1, r5
 8003786:	f005 fd27 	bl	80091d8 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 800378a:	2000      	movs	r0, #0
          break;
 800378c:	e70e      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800378e:	f5b0 7f54 	cmp.w	r0, #848	; 0x350
 8003792:	f000 8109 	beq.w	80039a8 <RI_SetRegisterMotor1+0x49c>
 8003796:	f5b0 7f64 	cmp.w	r0, #912	; 0x390
 800379a:	d173      	bne.n	8003884 <RI_SetRegisterMotor1+0x378>
          STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 800379c:	485b      	ldr	r0, [pc, #364]	; (800390c <RI_SetRegisterMotor1+0x400>)
 800379e:	aa01      	add	r2, sp, #4
 80037a0:	f10d 0102 	add.w	r1, sp, #2
 80037a4:	f007 f8f0 	bl	800a988 <STO_PLL_GetObserverGains>
          STO_PLL_SetObserverGains(&STO_PLL_M1, hC1, (int16_t)regdata16);
 80037a8:	4858      	ldr	r0, [pc, #352]	; (800390c <RI_SetRegisterMotor1+0x400>)
 80037aa:	f9bd 1002 	ldrsh.w	r1, [sp, #2]
 80037ae:	b22a      	sxth	r2, r5
 80037b0:	f007 f8f2 	bl	800a998 <STO_PLL_SetObserverGains>
  uint8_t retVal = MCP_CMD_OK;
 80037b4:	2000      	movs	r0, #0
 80037b6:	e6f9      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80037b8:	f5b0 6f01 	cmp.w	r0, #2064	; 0x810
 80037bc:	f43f aef5 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 80037c0:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80037c4:	f5b0 6ff2 	cmp.w	r0, #1936	; 0x790
 80037c8:	bf14      	ite	ne
 80037ca:	2005      	movne	r0, #5
 80037cc:	2004      	moveq	r0, #4
 80037ce:	e6ed      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80037d0:	f5b0 6f92 	cmp.w	r0, #1168	; 0x490
 80037d4:	d105      	bne.n	80037e2 <RI_SetRegisterMotor1+0x2d6>
          PID_SetKP (&(&STO_PLL_M1)->PIRegulator, (int16_t)regdata16);
 80037d6:	484a      	ldr	r0, [pc, #296]	; (8003900 <RI_SetRegisterMotor1+0x3f4>)
 80037d8:	b229      	sxth	r1, r5
 80037da:	f005 fccd 	bl	8009178 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 80037de:	2000      	movs	r0, #0
          break;
 80037e0:	e6e4      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80037e2:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 80037e6:	bf14      	ite	ne
 80037e8:	2005      	movne	r0, #5
 80037ea:	2004      	moveq	r0, #4
 80037ec:	e6de      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80037ee:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80037f2:	f5b0 6f09 	cmp.w	r0, #2192	; 0x890
 80037f6:	bf14      	ite	ne
 80037f8:	2005      	movne	r0, #5
 80037fa:	2004      	moveq	r0, #4
 80037fc:	e6d6      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 80037fe:	2890      	cmp	r0, #144	; 0x90
 8003800:	d12a      	bne.n	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKP(&PIDSpeedHandle_M1, (int16_t)regdata16);
 8003802:	4841      	ldr	r0, [pc, #260]	; (8003908 <RI_SetRegisterMotor1+0x3fc>)
 8003804:	b229      	sxth	r1, r5
 8003806:	f005 fcb7 	bl	8009178 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 800380a:	2000      	movs	r0, #0
          break;
 800380c:	e6ce      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800380e:	f5b0 6f35 	cmp.w	r0, #2896	; 0xb50
 8003812:	f43f aeca 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 8003816:	d914      	bls.n	8003842 <RI_SetRegisterMotor1+0x336>
 8003818:	f5b0 6f39 	cmp.w	r0, #2960	; 0xb90
 800381c:	bf14      	ite	ne
 800381e:	2005      	movne	r0, #5
 8003820:	2004      	moveq	r0, #4
 8003822:	e6c3      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003824:	f5b0 6f19 	cmp.w	r0, #2448	; 0x990
 8003828:	d115      	bne.n	8003856 <RI_SetRegisterMotor1+0x34a>
          currComp = MCI_GetIqdref(pMCIN);
 800382a:	4839      	ldr	r0, [pc, #228]	; (8003910 <RI_SetRegisterMotor1+0x404>)
 800382c:	f7fe fb54 	bl	8001ed8 <MCI_GetIqdref>
 8003830:	9001      	str	r0, [sp, #4]
          currComp.d = (int16_t)regdata16;
 8003832:	f8ad 5006 	strh.w	r5, [sp, #6]
          MCI_SetCurrentReferences(pMCIN,currComp);
 8003836:	4836      	ldr	r0, [pc, #216]	; (8003910 <RI_SetRegisterMotor1+0x404>)
 8003838:	9901      	ldr	r1, [sp, #4]
 800383a:	f7fe fa35 	bl	8001ca8 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 800383e:	2000      	movs	r0, #0
 8003840:	e6b4      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003842:	f5b0 6f2d 	cmp.w	r0, #2768	; 0xad0
 8003846:	f43f aeb0 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 800384a:	f5b0 6f31 	cmp.w	r0, #2832	; 0xb10
 800384e:	bf14      	ite	ne
 8003850:	2005      	movne	r0, #5
 8003852:	2004      	moveq	r0, #4
 8003854:	e6aa      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003856:	d201      	bcs.n	800385c <RI_SetRegisterMotor1+0x350>
          retVal = MCP_ERROR_UNKNOWN_REG;
 8003858:	2005      	movs	r0, #5
 800385a:	e6a7      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 800385c:	f020 0340 	bic.w	r3, r0, #64	; 0x40
 8003860:	f5b3 6f21 	cmp.w	r3, #2576	; 0xa10
 8003864:	f43f aea1 	beq.w	80035aa <RI_SetRegisterMotor1+0x9e>
 8003868:	f5b0 6f1d 	cmp.w	r0, #2512	; 0x9d0
 800386c:	bf14      	ite	ne
 800386e:	2005      	movne	r0, #5
 8003870:	2004      	moveq	r0, #4
 8003872:	e69b      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003874:	28d8      	cmp	r0, #216	; 0xd8
 8003876:	d067      	beq.n	8003948 <RI_SetRegisterMotor1+0x43c>
          retVal = MCP_ERROR_RO_REG;
 8003878:	f5b0 7f8c 	cmp.w	r0, #280	; 0x118
 800387c:	bf14      	ite	ne
 800387e:	2005      	movne	r0, #5
 8003880:	2004      	moveq	r0, #4
 8003882:	e6d4      	b.n	800362e <RI_SetRegisterMotor1+0x122>
 8003884:	f5b0 7f44 	cmp.w	r0, #784	; 0x310
 8003888:	d1e6      	bne.n	8003858 <RI_SetRegisterMotor1+0x34c>
          PID_SetKD(&PIDIdHandle_M1, (int16_t)regdata16);
 800388a:	481c      	ldr	r0, [pc, #112]	; (80038fc <RI_SetRegisterMotor1+0x3f0>)
 800388c:	b229      	sxth	r1, r5
 800388e:	f005 fca3 	bl	80091d8 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 8003892:	2000      	movs	r0, #0
          break;
 8003894:	e68a      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
    *tempdestString = (int8_t)0;
 8003896:	2300      	movs	r3, #0
 8003898:	f88c 3000 	strb.w	r3, [ip]
      retVal = MCP_ERROR_RO_REG;
 800389c:	2004      	movs	r0, #4
  return (retVal);
 800389e:	e6a2      	b.n	80035e6 <RI_SetRegisterMotor1+0xda>
 80038a0:	28a8      	cmp	r0, #168	; 0xa8
 80038a2:	f43f ae9f 	beq.w	80035e4 <RI_SetRegisterMotor1+0xd8>
 80038a6:	d913      	bls.n	80038d0 <RI_SetRegisterMotor1+0x3c4>
            retVal = MCP_ERROR_RO_REG;
 80038a8:	28e8      	cmp	r0, #232	; 0xe8
 80038aa:	bf14      	ite	ne
 80038ac:	2005      	movne	r0, #5
 80038ae:	2004      	moveq	r0, #4
}
 80038b0:	b003      	add	sp, #12
 80038b2:	bd30      	pop	{r4, r5, pc}
 80038b4:	f5b0 7f5a 	cmp.w	r0, #872	; 0x368
 80038b8:	d048      	beq.n	800394c <RI_SetRegisterMotor1+0x440>
 80038ba:	f5b0 6fa5 	cmp.w	r0, #1320	; 0x528
 80038be:	f47f aea9 	bne.w	8003614 <RI_SetRegisterMotor1+0x108>
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 80038c2:	4814      	ldr	r0, [pc, #80]	; (8003914 <RI_SetRegisterMotor1+0x408>)
 80038c4:	1c91      	adds	r1, r2, #2
}
 80038c6:	b003      	add	sp, #12
 80038c8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            retVal =  MCPA_cfgLog (&MCPA_UART_A, rawData);
 80038cc:	f005 bbb4 	b.w	8009038 <MCPA_cfgLog>
 80038d0:	f020 0040 	bic.w	r0, r0, #64	; 0x40
            retVal = MCP_ERROR_RO_REG;
 80038d4:	2828      	cmp	r0, #40	; 0x28
 80038d6:	bf14      	ite	ne
 80038d8:	2005      	movne	r0, #5
 80038da:	2004      	moveq	r0, #4
}
 80038dc:	b003      	add	sp, #12
 80038de:	bd30      	pop	{r4, r5, pc}
 80038e0:	2005      	movs	r0, #5
      *size = 1;
 80038e2:	2301      	movs	r3, #1
 80038e4:	8023      	strh	r3, [r4, #0]
}
 80038e6:	b003      	add	sp, #12
 80038e8:	bd30      	pop	{r4, r5, pc}
  uint8_t retVal = MCP_CMD_OK;
 80038ea:	2000      	movs	r0, #0
 80038ec:	e65e      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
        *size = 0;
 80038ee:	2300      	movs	r3, #0
 80038f0:	8023      	strh	r3, [r4, #0]
        retVal = MCP_ERROR_BAD_RAW_FORMAT; /* This error stop the parsing of the CMD buffer */
 80038f2:	200a      	movs	r0, #10
 80038f4:	e629      	b.n	800354a <RI_SetRegisterMotor1+0x3e>
            retVal = MCP_ERROR_RO_REG;
 80038f6:	2004      	movs	r0, #4
 80038f8:	e7f3      	b.n	80038e2 <RI_SetRegisterMotor1+0x3d6>
 80038fa:	bf00      	nop
 80038fc:	200000c0 	.word	0x200000c0
 8003900:	20000244 	.word	0x20000244
 8003904:	200000ec 	.word	0x200000ec
 8003908:	20000118 	.word	0x20000118
 800390c:	20000210 	.word	0x20000210
 8003910:	20001a90 	.word	0x20001a90
 8003914:	20000400 	.word	0x20000400
          MCI_ExecSpeedRamp(pMCIN,((((int16_t)regdata32) * ((int16_t)SPEED_UNIT)) / (int16_t)U_RPM), 0);
 8003918:	f9b2 3000 	ldrsh.w	r3, [r2]
 800391c:	494a      	ldr	r1, [pc, #296]	; (8003a48 <RI_SetRegisterMotor1+0x53c>)
 800391e:	484b      	ldr	r0, [pc, #300]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003920:	fb81 2103 	smull	r2, r1, r1, r3
 8003924:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8003928:	2200      	movs	r2, #0
 800392a:	b209      	sxth	r1, r1
 800392c:	f7fe f998 	bl	8001c60 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003930:	2000      	movs	r0, #0
          break;
 8003932:	e67c      	b.n	800362e <RI_SetRegisterMotor1+0x122>
            MCI_ExecTorqueRamp(pMCIN, MCI_GetTeref(pMCIN), 0);
 8003934:	4845      	ldr	r0, [pc, #276]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003936:	f7fe faf9 	bl	8001f2c <MCI_GetTeref>
 800393a:	2200      	movs	r2, #0
 800393c:	4601      	mov	r1, r0
 800393e:	4843      	ldr	r0, [pc, #268]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003940:	f7fe f998 	bl	8001c74 <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003944:	2000      	movs	r0, #0
 8003946:	e7cc      	b.n	80038e2 <RI_SetRegisterMotor1+0x3d6>
          retVal = MCP_ERROR_RO_REG;
 8003948:	2004      	movs	r0, #4
 800394a:	e670      	b.n	800362e <RI_SetRegisterMotor1+0x122>
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 800394c:	f8d2 1002 	ldr.w	r1, [r2, #2]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8003950:	483e      	ldr	r0, [pc, #248]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
            currComp.q = *((int16_t *) rawData); //cstat !MISRAC2012-Rule-11.3
 8003952:	9101      	str	r1, [sp, #4]
            MCI_SetCurrentReferences(pMCIN, currComp);
 8003954:	f7fe f9a8 	bl	8001ca8 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 8003958:	2000      	movs	r0, #0
 800395a:	e5f6      	b.n	800354a <RI_SetRegisterMotor1+0x3e>
            MCI_ExecSpeedRamp(pMCIN, (int16_t)((rpm * SPEED_UNIT) / U_RPM), duration);
 800395c:	f8d2 1002 	ldr.w	r1, [r2, #2]
 8003960:	4b39      	ldr	r3, [pc, #228]	; (8003a48 <RI_SetRegisterMotor1+0x53c>)
 8003962:	88d2      	ldrh	r2, [r2, #6]
 8003964:	fb83 0301 	smull	r0, r3, r3, r1
 8003968:	eba3 71e1 	sub.w	r1, r3, r1, asr #31
 800396c:	4837      	ldr	r0, [pc, #220]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 800396e:	b209      	sxth	r1, r1
 8003970:	f7fe f976 	bl	8001c60 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003974:	2000      	movs	r0, #0
            break;
 8003976:	e5e8      	b.n	800354a <RI_SetRegisterMotor1+0x3e>
            MCI_ExecTorqueRamp(pMCIN, (int16_t)torque, duration);
 8003978:	4834      	ldr	r0, [pc, #208]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 800397a:	88d2      	ldrh	r2, [r2, #6]
 800397c:	f9bc 1002 	ldrsh.w	r1, [ip, #2]
 8003980:	f7fe f978 	bl	8001c74 <MCI_ExecTorqueRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003984:	2000      	movs	r0, #0
            break;
 8003986:	e5e0      	b.n	800354a <RI_SetRegisterMotor1+0x3e>
            MCI_ExecSpeedRamp(pMCIN, MCI_GetMecSpeedRefUnit(pMCIN), 0);
 8003988:	4830      	ldr	r0, [pc, #192]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 800398a:	f7fe fa77 	bl	8001e7c <MCI_GetMecSpeedRefUnit>
 800398e:	2200      	movs	r2, #0
 8003990:	4601      	mov	r1, r0
 8003992:	482e      	ldr	r0, [pc, #184]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003994:	f7fe f964 	bl	8001c60 <MCI_ExecSpeedRamp>
  uint8_t retVal = MCP_CMD_OK;
 8003998:	2000      	movs	r0, #0
 800399a:	e7a2      	b.n	80038e2 <RI_SetRegisterMotor1+0x3d6>
          PID_SetKDDivisorPOW2(&PIDIdHandle_M1, regdata16);
 800399c:	482c      	ldr	r0, [pc, #176]	; (8003a50 <RI_SetRegisterMotor1+0x544>)
 800399e:	4629      	mov	r1, r5
 80039a0:	f005 fc22 	bl	80091e8 <PID_SetKDDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80039a4:	2000      	movs	r0, #0
          break;
 80039a6:	e601      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 80039a8:	482a      	ldr	r0, [pc, #168]	; (8003a54 <RI_SetRegisterMotor1+0x548>)
 80039aa:	aa01      	add	r2, sp, #4
 80039ac:	f10d 0102 	add.w	r1, sp, #2
 80039b0:	f006 ffea 	bl	800a988 <STO_PLL_GetObserverGains>
          STO_PLL_SetObserverGains(&STO_PLL_M1, (int16_t)regdata16, hC2);
 80039b4:	4827      	ldr	r0, [pc, #156]	; (8003a54 <RI_SetRegisterMotor1+0x548>)
 80039b6:	f9bd 2004 	ldrsh.w	r2, [sp, #4]
 80039ba:	b229      	sxth	r1, r5
 80039bc:	f006 ffec 	bl	800a998 <STO_PLL_SetObserverGains>
  uint8_t retVal = MCP_CMD_OK;
 80039c0:	2000      	movs	r0, #0
 80039c2:	e5f3      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKD(&PIDIqHandle_M1, (int16_t)regdata16);
 80039c4:	4824      	ldr	r0, [pc, #144]	; (8003a58 <RI_SetRegisterMotor1+0x54c>)
 80039c6:	b229      	sxth	r1, r5
 80039c8:	f005 fc06 	bl	80091d8 <PID_SetKD>
  uint8_t retVal = MCP_CMD_OK;
 80039cc:	2000      	movs	r0, #0
          break;
 80039ce:	e5ed      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKI(&PIDSpeedHandle_M1, (int16_t)regdata16);
 80039d0:	4822      	ldr	r0, [pc, #136]	; (8003a5c <RI_SetRegisterMotor1+0x550>)
 80039d2:	b229      	sxth	r1, r5
 80039d4:	f005 fbd2 	bl	800917c <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 80039d8:	2000      	movs	r0, #0
          break;
 80039da:	e5e7      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKI (&(&STO_PLL_M1)->PIRegulator, (int16_t)regdata16);
 80039dc:	4820      	ldr	r0, [pc, #128]	; (8003a60 <RI_SetRegisterMotor1+0x554>)
 80039de:	b229      	sxth	r1, r5
 80039e0:	f005 fbcc 	bl	800917c <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 80039e4:	2000      	movs	r0, #0
          break;
 80039e6:	e5e1      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2(&PIDSpeedHandle_M1, regdata16);
 80039e8:	481c      	ldr	r0, [pc, #112]	; (8003a5c <RI_SetRegisterMotor1+0x550>)
 80039ea:	4629      	mov	r1, r5
 80039ec:	f005 fbe0 	bl	80091b0 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 80039f0:	2000      	movs	r0, #0
          break;
 80039f2:	e5db      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKI(&PIDIdHandle_M1, (int16_t)regdata16);
 80039f4:	4816      	ldr	r0, [pc, #88]	; (8003a50 <RI_SetRegisterMotor1+0x544>)
 80039f6:	b229      	sxth	r1, r5
 80039f8:	f005 fbc0 	bl	800917c <PID_SetKI>
  uint8_t retVal = MCP_CMD_OK;
 80039fc:	2000      	movs	r0, #0
          break;
 80039fe:	e5d5      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          currComp = MCI_GetIqdref(pMCIN);
 8003a00:	4812      	ldr	r0, [pc, #72]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003a02:	f7fe fa69 	bl	8001ed8 <MCI_GetIqdref>
 8003a06:	9001      	str	r0, [sp, #4]
          currComp.q = (int16_t)regdata16;
 8003a08:	f8ad 5004 	strh.w	r5, [sp, #4]
          MCI_SetCurrentReferences(pMCIN,currComp);
 8003a0c:	480f      	ldr	r0, [pc, #60]	; (8003a4c <RI_SetRegisterMotor1+0x540>)
 8003a0e:	9901      	ldr	r1, [sp, #4]
 8003a10:	f7fe f94a 	bl	8001ca8 <MCI_SetCurrentReferences>
  uint8_t retVal = MCP_CMD_OK;
 8003a14:	2000      	movs	r0, #0
 8003a16:	e5c9      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2 (&(&STO_PLL_M1)->PIRegulator,regdata16);
 8003a18:	4811      	ldr	r0, [pc, #68]	; (8003a60 <RI_SetRegisterMotor1+0x554>)
 8003a1a:	4629      	mov	r1, r5
 8003a1c:	f005 fbc8 	bl	80091b0 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a20:	2000      	movs	r0, #0
          break;
 8003a22:	e5c3      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKP(&PIDIqHandle_M1, (int16_t)regdata16);
 8003a24:	480c      	ldr	r0, [pc, #48]	; (8003a58 <RI_SetRegisterMotor1+0x54c>)
 8003a26:	b229      	sxth	r1, r5
 8003a28:	f005 fba6 	bl	8009178 <PID_SetKP>
  uint8_t retVal = MCP_CMD_OK;
 8003a2c:	2000      	movs	r0, #0
          break;
 8003a2e:	e5bd      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKIDivisorPOW2(&PIDIqHandle_M1, regdata16);
 8003a30:	4809      	ldr	r0, [pc, #36]	; (8003a58 <RI_SetRegisterMotor1+0x54c>)
 8003a32:	4629      	mov	r1, r5
 8003a34:	f005 fbbc 	bl	80091b0 <PID_SetKIDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a38:	2000      	movs	r0, #0
          break;
 8003a3a:	e5b7      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
          PID_SetKPDivisorPOW2(&PIDIdHandle_M1, regdata16);
 8003a3c:	4804      	ldr	r0, [pc, #16]	; (8003a50 <RI_SetRegisterMotor1+0x544>)
 8003a3e:	4629      	mov	r1, r5
 8003a40:	f005 fbaa 	bl	8009198 <PID_SetKPDivisorPOW2>
  uint8_t retVal = MCP_CMD_OK;
 8003a44:	2000      	movs	r0, #0
          break;
 8003a46:	e5b1      	b.n	80035ac <RI_SetRegisterMotor1+0xa0>
 8003a48:	2aaaaaab 	.word	0x2aaaaaab
 8003a4c:	20001a90 	.word	0x20001a90
 8003a50:	200000c0 	.word	0x200000c0
 8003a54:	20000210 	.word	0x20000210
 8003a58:	200000ec 	.word	0x200000ec
 8003a5c:	20000118 	.word	0x20000118
 8003a60:	20000244 	.word	0x20000244

08003a64 <RI_GetRegisterGlobal>:
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8003a64:	b510      	push	{r4, lr}
    switch (typeID)
 8003a66:	f1a1 0c08 	sub.w	ip, r1, #8
uint8_t RI_GetRegisterGlobal(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace){
 8003a6a:	f9bd e008 	ldrsh.w	lr, [sp, #8]
    switch (typeID)
 8003a6e:	f1bc 0f20 	cmp.w	ip, #32
 8003a72:	d812      	bhi.n	8003a9a <RI_GetRegisterGlobal+0x36>
 8003a74:	e8df f00c 	tbb	[pc, ip]
 8003a78:	1111111b 	.word	0x1111111b
 8003a7c:	11111111 	.word	0x11111111
 8003a80:	11111129 	.word	0x11111129
 8003a84:	11111111 	.word	0x11111111
 8003a88:	11111122 	.word	0x11111122
 8003a8c:	11111111 	.word	0x11111111
 8003a90:	11111137 	.word	0x11111137
 8003a94:	11111111 	.word	0x11111111
 8003a98:	13          	.byte	0x13
 8003a99:	00          	.byte	0x00
 8003a9a:	2007      	movs	r0, #7
}
 8003a9c:	bd10      	pop	{r4, pc}
        switch (regID)
 8003a9e:	2828      	cmp	r0, #40	; 0x28
 8003aa0:	d02d      	beq.n	8003afe <RI_GetRegisterGlobal+0x9a>
        *size = (*rawSize) + 2U;
 8003aa2:	8812      	ldrh	r2, [r2, #0]
 8003aa4:	3202      	adds	r2, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003aa6:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 8003aa8:	b292      	uxth	r2, r2
 8003aaa:	801a      	strh	r2, [r3, #0]
}
 8003aac:	bd10      	pop	{r4, pc}
        if (freeSpace > 0)
 8003aae:	f1be 0f00 	cmp.w	lr, #0
 8003ab2:	dd22      	ble.n	8003afa <RI_GetRegisterGlobal+0x96>
          *size = 1;
 8003ab4:	2201      	movs	r2, #1
 8003ab6:	801a      	strh	r2, [r3, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8003ab8:	2005      	movs	r0, #5
}
 8003aba:	bd10      	pop	{r4, pc}
        if (freeSpace >= 4)
 8003abc:	f1be 0f03 	cmp.w	lr, #3
 8003ac0:	dd19      	ble.n	8003af6 <RI_GetRegisterGlobal+0x92>
          *size = 4;
 8003ac2:	2204      	movs	r2, #4
 8003ac4:	801a      	strh	r2, [r3, #0]
              retVal = MCP_ERROR_UNKNOWN_REG;
 8003ac6:	2005      	movs	r0, #5
}
 8003ac8:	bd10      	pop	{r4, pc}
        if (freeSpace >= 2)
 8003aca:	f1be 0f01 	cmp.w	lr, #1
 8003ace:	dd12      	ble.n	8003af6 <RI_GetRegisterGlobal+0x92>
          switch (regID)
 8003ad0:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 8003ad4:	d05b      	beq.n	8003b8e <RI_GetRegisterGlobal+0x12a>
    uint8_t retVal = MCP_CMD_OK;
 8003ad6:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003ada:	bf14      	ite	ne
 8003adc:	2005      	movne	r0, #5
 8003ade:	2000      	moveq	r0, #0
          *size = 2;
 8003ae0:	2202      	movs	r2, #2
 8003ae2:	801a      	strh	r2, [r3, #0]
}
 8003ae4:	bd10      	pop	{r4, pc}
        switch (regID)
 8003ae6:	2820      	cmp	r0, #32
 8003ae8:	d02d      	beq.n	8003b46 <RI_GetRegisterGlobal+0xe2>
 8003aea:	2860      	cmp	r0, #96	; 0x60
 8003aec:	d011      	beq.n	8003b12 <RI_GetRegisterGlobal+0xae>
            *size= 0 ; /* */
 8003aee:	2200      	movs	r2, #0
 8003af0:	801a      	strh	r2, [r3, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003af2:	2005      	movs	r0, #5
}
 8003af4:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003af6:	2008      	movs	r0, #8
}
 8003af8:	bd10      	pop	{r4, pc}
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003afa:	4608      	mov	r0, r1
}
 8003afc:	bd10      	pop	{r4, pc}
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003afe:	fa1f fe8e 	uxth.w	lr, lr
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8003b02:	210a      	movs	r1, #10
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003b04:	f1be 0f0b 	cmp.w	lr, #11
            *rawSize = (uint16_t)sizeof(GlobalConfig_reg_t);
 8003b08:	8011      	strh	r1, [r2, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003b0a:	d834      	bhi.n	8003b76 <RI_GetRegisterGlobal+0x112>
 8003b0c:	220c      	movs	r2, #12
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003b0e:	2008      	movs	r0, #8
 8003b10:	e7cb      	b.n	8003aaa <RI_GetRegisterGlobal+0x46>
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b12:	4c20      	ldr	r4, [pc, #128]	; (8003b94 <RI_GetRegisterGlobal+0x130>)
 8003b14:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8003b18:	2101      	movs	r1, #1
 8003b1a:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b1c:	b180      	cbz	r0, 8003b40 <RI_GetRegisterGlobal+0xdc>
 8003b1e:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8003b22:	46a4      	mov	ip, r4
 8003b24:	e008      	b.n	8003b38 <RI_GetRegisterGlobal+0xd4>
    *tempdestString = *tempsrcString;
 8003b26:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8003b2a:	8819      	ldrh	r1, [r3, #0]
 8003b2c:	3101      	adds	r1, #1
 8003b2e:	b289      	uxth	r1, r1
 8003b30:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b32:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8003b36:	b118      	cbz	r0, 8003b40 <RI_GetRegisterGlobal+0xdc>
 8003b38:	458e      	cmp	lr, r1
 8003b3a:	d8f4      	bhi.n	8003b26 <RI_GetRegisterGlobal+0xc2>
    retVal = MCP_ERROR_STRING_FORMAT;
 8003b3c:	2006      	movs	r0, #6
}
 8003b3e:	bd10      	pop	{r4, pc}
    *tempdestString = (int8_t)0;
 8003b40:	2000      	movs	r0, #0
 8003b42:	7010      	strb	r0, [r2, #0]
}
 8003b44:	bd10      	pop	{r4, pc}
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b46:	4c14      	ldr	r4, [pc, #80]	; (8003b98 <RI_GetRegisterGlobal+0x134>)
 8003b48:	f994 0000 	ldrsb.w	r0, [r4]
  *size= 1U ; /* /0 is the min String size */
 8003b4c:	2101      	movs	r1, #1
 8003b4e:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b50:	2800      	cmp	r0, #0
 8003b52:	d0f5      	beq.n	8003b40 <RI_GetRegisterGlobal+0xdc>
 8003b54:	fa1f fe8e 	uxth.w	lr, lr
  const char_t *tempsrcString = srcString;
 8003b58:	46a4      	mov	ip, r4
 8003b5a:	e009      	b.n	8003b70 <RI_GetRegisterGlobal+0x10c>
    *tempdestString = *tempsrcString;
 8003b5c:	f802 0b01 	strb.w	r0, [r2], #1
    *size = *size + 1U;
 8003b60:	8819      	ldrh	r1, [r3, #0]
 8003b62:	3101      	adds	r1, #1
 8003b64:	b289      	uxth	r1, r1
 8003b66:	8019      	strh	r1, [r3, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 8003b68:	f91c 0f01 	ldrsb.w	r0, [ip, #1]!
 8003b6c:	2800      	cmp	r0, #0
 8003b6e:	d0e7      	beq.n	8003b40 <RI_GetRegisterGlobal+0xdc>
 8003b70:	458e      	cmp	lr, r1
 8003b72:	d8f3      	bhi.n	8003b5c <RI_GetRegisterGlobal+0xf8>
 8003b74:	e7e2      	b.n	8003b3c <RI_GetRegisterGlobal+0xd8>
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8003b76:	4909      	ldr	r1, [pc, #36]	; (8003b9c <RI_GetRegisterGlobal+0x138>)
 8003b78:	6848      	ldr	r0, [r1, #4]
 8003b7a:	680c      	ldr	r4, [r1, #0]
 8003b7c:	8909      	ldrh	r1, [r1, #8]
 8003b7e:	f8c2 0006 	str.w	r0, [r2, #6]
 8003b82:	f8c2 4002 	str.w	r4, [r2, #2]
 8003b86:	8151      	strh	r1, [r2, #10]
    uint8_t retVal = MCP_CMD_OK;
 8003b88:	2000      	movs	r0, #0
              (void)memcpy(rawData, &globalConfig_reg, sizeof(GlobalConfig_reg_t));
 8003b8a:	220c      	movs	r2, #12
 8003b8c:	e78d      	b.n	8003aaa <RI_GetRegisterGlobal+0x46>
    uint8_t retVal = MCP_CMD_OK;
 8003b8e:	2000      	movs	r0, #0
 8003b90:	e7a6      	b.n	8003ae0 <RI_GetRegisterGlobal+0x7c>
 8003b92:	bf00      	nop
 8003b94:	0800f050 	.word	0x0800f050
 8003b98:	0800f060 	.word	0x0800f060
 8003b9c:	0800f0e4 	.word	0x0800f0e4

08003ba0 <RI_GetRegisterMotor1>:
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8003ba0:	b530      	push	{r4, r5, lr}
 8003ba2:	b095      	sub	sp, #84	; 0x54
 8003ba4:	461d      	mov	r5, r3
    switch (typeID)
 8003ba6:	f1a1 0308 	sub.w	r3, r1, #8
  uint8_t RI_GetRegisterMotor1(uint16_t regID,uint8_t typeID,uint8_t * data,uint16_t *size,int16_t freeSpace) {
 8003baa:	f9bd c060 	ldrsh.w	ip, [sp, #96]	; 0x60
 8003bae:	4614      	mov	r4, r2
    switch (typeID)
 8003bb0:	2b20      	cmp	r3, #32
 8003bb2:	d812      	bhi.n	8003bda <RI_GetRegisterMotor1+0x3a>
 8003bb4:	e8df f003 	tbb	[pc, r3]
 8003bb8:	1111112d 	.word	0x1111112d
 8003bbc:	11111111 	.word	0x11111111
 8003bc0:	11111140 	.word	0x11111140
 8003bc4:	11111111 	.word	0x11111111
 8003bc8:	11111167 	.word	0x11111167
 8003bcc:	11111111 	.word	0x11111111
 8003bd0:	11111182 	.word	0x11111182
 8003bd4:	11111111 	.word	0x11111111
 8003bd8:	14          	.byte	0x14
 8003bd9:	00          	.byte	0x00
 8003bda:	2007      	movs	r0, #7
  }
 8003bdc:	b015      	add	sp, #84	; 0x54
 8003bde:	bd30      	pop	{r4, r5, pc}
        rawData++;
 8003be0:	f5b0 7f94 	cmp.w	r0, #296	; 0x128
 8003be4:	f104 0302 	add.w	r3, r4, #2
        switch (regID)
 8003be8:	f000 82cb 	beq.w	8004182 <RI_GetRegisterMotor1+0x5e2>
 8003bec:	d87e      	bhi.n	8003cec <RI_GetRegisterMotor1+0x14c>
 8003bee:	28a8      	cmp	r0, #168	; 0xa8
 8003bf0:	f000 82bd 	beq.w	800416e <RI_GetRegisterMotor1+0x5ce>
 8003bf4:	28e8      	cmp	r0, #232	; 0xe8
 8003bf6:	d16b      	bne.n	8003cd0 <RI_GetRegisterMotor1+0x130>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003bf8:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 8003bfc:	220e      	movs	r2, #14
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003bfe:	f1bc 0f0f 	cmp.w	ip, #15
            *rawSize = (uint16_t)sizeof(FOCFwConfig_reg_t);
 8003c02:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003c04:	f200 8280 	bhi.w	8004108 <RI_GetRegisterMotor1+0x568>
 8003c08:	2310      	movs	r3, #16
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003c0a:	2008      	movs	r0, #8
        *size = (*rawSize) + 2U;
 8003c0c:	802b      	strh	r3, [r5, #0]
  }
 8003c0e:	b015      	add	sp, #84	; 0x54
 8003c10:	bd30      	pop	{r4, r5, pc}
        if (freeSpace > 0)
 8003c12:	f1bc 0f00 	cmp.w	ip, #0
 8003c16:	f340 82a0 	ble.w	800415a <RI_GetRegisterMotor1+0x5ba>
          switch (regID)
 8003c1a:	2848      	cmp	r0, #72	; 0x48
 8003c1c:	f000 829f 	beq.w	800415e <RI_GetRegisterMotor1+0x5be>
 8003c20:	2888      	cmp	r0, #136	; 0x88
 8003c22:	f040 823b 	bne.w	800409c <RI_GetRegisterMotor1+0x4fc>
              *data = (uint8_t)MCI_GetControlMode(pMCIN);
 8003c26:	48b2      	ldr	r0, [pc, #712]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003c28:	f7fe f8fe 	bl	8001e28 <MCI_GetControlMode>
 8003c2c:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003c2e:	2000      	movs	r0, #0
          *size = 1;
 8003c30:	2301      	movs	r3, #1
 8003c32:	802b      	strh	r3, [r5, #0]
  }
 8003c34:	b015      	add	sp, #84	; 0x54
 8003c36:	bd30      	pop	{r4, r5, pc}
        if (freeSpace >= 2)
 8003c38:	f1bc 0f01 	cmp.w	ip, #1
 8003c3c:	f340 822b 	ble.w	8004096 <RI_GetRegisterMotor1+0x4f6>
          switch (regID)
 8003c40:	f5b0 6f1d 	cmp.w	r0, #2512	; 0x9d0
 8003c44:	f000 8315 	beq.w	8004272 <RI_GetRegisterMotor1+0x6d2>
 8003c48:	f200 80a7 	bhi.w	8003d9a <RI_GetRegisterMotor1+0x1fa>
 8003c4c:	f5b0 6f8a 	cmp.w	r0, #1104	; 0x450
 8003c50:	f000 8309 	beq.w	8004266 <RI_GetRegisterMotor1+0x6c6>
 8003c54:	f240 817a 	bls.w	8003f4c <RI_GetRegisterMotor1+0x3ac>
 8003c58:	f5b0 6f05 	cmp.w	r0, #2128	; 0x850
 8003c5c:	f000 82fd 	beq.w	800425a <RI_GetRegisterMotor1+0x6ba>
 8003c60:	f240 808b 	bls.w	8003d7a <RI_GetRegisterMotor1+0x1da>
 8003c64:	f5b0 6f11 	cmp.w	r0, #2320	; 0x910
 8003c68:	f000 82ef 	beq.w	800424a <RI_GetRegisterMotor1+0x6aa>
 8003c6c:	d979      	bls.n	8003d62 <RI_GetRegisterMotor1+0x1c2>
 8003c6e:	f5b0 6f15 	cmp.w	r0, #2384	; 0x950
 8003c72:	d16a      	bne.n	8003d4a <RI_GetRegisterMotor1+0x1aa>
              *regdata16 = MCI_GetIqdref(pMCIN).q;
 8003c74:	489e      	ldr	r0, [pc, #632]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003c76:	f7fe f92f 	bl	8001ed8 <MCI_GetIqdref>
 8003c7a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003c7c:	2000      	movs	r0, #0
          *size = 2;
 8003c7e:	2302      	movs	r3, #2
 8003c80:	802b      	strh	r3, [r5, #0]
  }
 8003c82:	b015      	add	sp, #84	; 0x54
 8003c84:	bd30      	pop	{r4, r5, pc}
        if (freeSpace >= 4)
 8003c86:	f1bc 0f03 	cmp.w	ip, #3
 8003c8a:	f340 8204 	ble.w	8004096 <RI_GetRegisterMotor1+0x4f6>
          switch (regID)
 8003c8e:	28d8      	cmp	r0, #216	; 0xd8
 8003c90:	f000 82bf 	beq.w	8004212 <RI_GetRegisterMotor1+0x672>
 8003c94:	f200 81ed 	bhi.w	8004072 <RI_GetRegisterMotor1+0x4d2>
 8003c98:	2858      	cmp	r0, #88	; 0x58
 8003c9a:	f000 82b1 	beq.w	8004200 <RI_GetRegisterMotor1+0x660>
 8003c9e:	2898      	cmp	r0, #152	; 0x98
 8003ca0:	f040 81de 	bne.w	8004060 <RI_GetRegisterMotor1+0x4c0>
              *regdata32 = (((int32_t)MCI_GetMecSpeedRefUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8003ca4:	4892      	ldr	r0, [pc, #584]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003ca6:	f7fe f8e9 	bl	8001e7c <MCI_GetMecSpeedRefUnit>
 8003caa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003cae:	0040      	lsls	r0, r0, #1
 8003cb0:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003cb2:	2000      	movs	r0, #0
          *size = 4;
 8003cb4:	2304      	movs	r3, #4
 8003cb6:	802b      	strh	r3, [r5, #0]
  }
 8003cb8:	b015      	add	sp, #84	; 0x54
 8003cba:	bd30      	pop	{r4, r5, pc}
        switch (regID)
 8003cbc:	28a0      	cmp	r0, #160	; 0xa0
 8003cbe:	f000 820b 	beq.w	80040d8 <RI_GetRegisterMotor1+0x538>
 8003cc2:	28e0      	cmp	r0, #224	; 0xe0
 8003cc4:	f000 81ec 	beq.w	80040a0 <RI_GetRegisterMotor1+0x500>
            *size= 0 ; /* */
 8003cc8:	2300      	movs	r3, #0
 8003cca:	802b      	strh	r3, [r5, #0]
            retVal = MCP_ERROR_UNKNOWN_REG;
 8003ccc:	2005      	movs	r0, #5
            break;
 8003cce:	e785      	b.n	8003bdc <RI_GetRegisterMotor1+0x3c>
 8003cd0:	2868      	cmp	r0, #104	; 0x68
 8003cd2:	f040 8269 	bne.w	80041a8 <RI_GetRegisterMotor1+0x608>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003cd6:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003cda:	223c      	movs	r2, #60	; 0x3c
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003cdc:	f1bc 0f3d 	cmp.w	ip, #61	; 0x3d
            *rawSize = (uint16_t)sizeof(MotorConfig_reg_t);
 8003ce0:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8003ce2:	f200 821e 	bhi.w	8004122 <RI_GetRegisterMotor1+0x582>
 8003ce6:	233e      	movs	r3, #62	; 0x3e
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8003ce8:	2008      	movs	r0, #8
 8003cea:	e78f      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
 8003cec:	f5b0 7ff4 	cmp.w	r0, #488	; 0x1e8
 8003cf0:	f000 825f 	beq.w	80041b2 <RI_GetRegisterMotor1+0x612>
 8003cf4:	f5b0 7f5a 	cmp.w	r0, #872	; 0x368
 8003cf8:	d112      	bne.n	8003d20 <RI_GetRegisterMotor1+0x180>
            *rawSize = 4;
 8003cfa:	2304      	movs	r3, #4
 8003cfc:	8023      	strh	r3, [r4, #0]
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8003cfe:	487c      	ldr	r0, [pc, #496]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d00:	f7fe f8ea 	bl	8001ed8 <MCI_GetIqdref>
 8003d04:	4603      	mov	r3, r0
 8003d06:	8063      	strh	r3, [r4, #2]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d08:	4879      	ldr	r0, [pc, #484]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
            *iqref = (uint16_t)MCI_GetIqdref(pMCIN).q;
 8003d0a:	9312      	str	r3, [sp, #72]	; 0x48
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d0c:	f7fe f8e4 	bl	8001ed8 <MCI_GetIqdref>
        *size = (*rawSize) + 2U;
 8003d10:	8823      	ldrh	r3, [r4, #0]
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d12:	f3c0 400f 	ubfx	r0, r0, #16, #16
        *size = (*rawSize) + 2U;
 8003d16:	3302      	adds	r3, #2
            *idref = (uint16_t)MCI_GetIqdref(pMCIN).d;
 8003d18:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 8003d1a:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 8003d1c:	2000      	movs	r0, #0
            break;
 8003d1e:	e775      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
 8003d20:	f5b0 7fd4 	cmp.w	r0, #424	; 0x1a8
 8003d24:	f040 8240 	bne.w	80041a8 <RI_GetRegisterMotor1+0x608>
            *rpm = (((int32_t)MCI_GetLastRampFinalSpeed(pMCIN) * U_RPM) / (int32_t)SPEED_UNIT);
 8003d28:	4871      	ldr	r0, [pc, #452]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d2a:	f7fe f881 	bl	8001e30 <MCI_GetLastRampFinalSpeed>
 8003d2e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003d32:	0043      	lsls	r3, r0, #1
 8003d34:	f8c4 3002 	str.w	r3, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003d38:	486d      	ldr	r0, [pc, #436]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d3a:	f7fe f881 	bl	8001e40 <MCI_GetLastRampFinalDuration>
            *rawSize = 6;
 8003d3e:	2306      	movs	r3, #6
            *duration = MCI_GetLastRampFinalDuration(pMCIN);
 8003d40:	80e0      	strh	r0, [r4, #6]
            *rawSize = 6;
 8003d42:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003d44:	2000      	movs	r0, #0
            break;
 8003d46:	2308      	movs	r3, #8
 8003d48:	e760      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
 8003d4a:	f5b0 6f19 	cmp.w	r0, #2448	; 0x990
 8003d4e:	f040 82de 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIqdref(pMCIN).d;
 8003d52:	4867      	ldr	r0, [pc, #412]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d54:	f7fe f8c0 	bl	8001ed8 <MCI_GetIqdref>
 8003d58:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003d5c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003d5e:	2000      	movs	r0, #0
              break;
 8003d60:	e78d      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003d62:	f5b0 6f09 	cmp.w	r0, #2192	; 0x890
 8003d66:	f040 8108 	bne.w	8003f7a <RI_GetRegisterMotor1+0x3da>
              *regdata16 = MCI_GetIalphabeta(pMCIN).beta;
 8003d6a:	4861      	ldr	r0, [pc, #388]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d6c:	f7fe f898 	bl	8001ea0 <MCI_GetIalphabeta>
 8003d70:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003d74:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003d76:	2000      	movs	r0, #0
              break;
 8003d78:	e781      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003d7a:	f5b0 6fba 	cmp.w	r0, #1488	; 0x5d0
 8003d7e:	f000 82a2 	beq.w	80042c6 <RI_GetRegisterMotor1+0x726>
 8003d82:	f240 8151 	bls.w	8004028 <RI_GetRegisterMotor1+0x488>
 8003d86:	f5b0 6ffa 	cmp.w	r0, #2000	; 0x7d0
 8003d8a:	f040 8141 	bne.w	8004010 <RI_GetRegisterMotor1+0x470>
              *regdata16 = MCI_GetIab(pMCIN).a;
 8003d8e:	4858      	ldr	r0, [pc, #352]	; (8003ef0 <RI_GetRegisterMotor1+0x350>)
 8003d90:	f7fe f878 	bl	8001e84 <MCI_GetIab>
 8003d94:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003d96:	2000      	movs	r0, #0
              break;
 8003d98:	e771      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003d9a:	f5b0 6f69 	cmp.w	r0, #3728	; 0xe90
 8003d9e:	d011      	beq.n	8003dc4 <RI_GetRegisterMotor1+0x224>
 8003da0:	d836      	bhi.n	8003e10 <RI_GetRegisterMotor1+0x270>
 8003da2:	f5b0 6f35 	cmp.w	r0, #2896	; 0xb50
 8003da6:	f000 82ac 	beq.w	8004302 <RI_GetRegisterMotor1+0x762>
 8003daa:	d922      	bls.n	8003df2 <RI_GetRegisterMotor1+0x252>
 8003dac:	f5b0 6f41 	cmp.w	r0, #3088	; 0xc10
 8003db0:	f000 829f 	beq.w	80042f2 <RI_GetRegisterMotor1+0x752>
 8003db4:	d914      	bls.n	8003de0 <RI_GetRegisterMotor1+0x240>
 8003db6:	f5b0 6f49 	cmp.w	r0, #3216	; 0xc90
 8003dba:	f000 8292 	beq.w	80042e2 <RI_GetRegisterMotor1+0x742>
 8003dbe:	f5b0 6f65 	cmp.w	r0, #3664	; 0xe50
 8003dc2:	d103      	bne.n	8003dcc <RI_GetRegisterMotor1+0x22c>
          *size = 2;
 8003dc4:	2302      	movs	r3, #2
    uint8_t retVal = MCP_CMD_OK;
 8003dc6:	2000      	movs	r0, #0
          *size = 2;
 8003dc8:	802b      	strh	r3, [r5, #0]
 8003dca:	e75a      	b.n	8003c82 <RI_GetRegisterMotor1+0xe2>
 8003dcc:	f5b0 6f45 	cmp.w	r0, #3152	; 0xc50
 8003dd0:	f040 829d 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = STO_PLL_GetEstimatedBemf(&STO_PLL_M1).alpha;
 8003dd4:	4847      	ldr	r0, [pc, #284]	; (8003ef4 <RI_GetRegisterMotor1+0x354>)
 8003dd6:	f006 fdb7 	bl	800a948 <STO_PLL_GetEstimatedBemf>
 8003dda:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ddc:	2000      	movs	r0, #0
              break;
 8003dde:	e74e      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003de0:	f5b0 6f39 	cmp.w	r0, #2960	; 0xb90
 8003de4:	d12a      	bne.n	8003e3c <RI_GetRegisterMotor1+0x29c>
              *regdata16 = SPD_GetS16Speed((SpeednPosFdbk_Handle_t *)&STO_PLL_M1);
 8003de6:	4843      	ldr	r0, [pc, #268]	; (8003ef4 <RI_GetRegisterMotor1+0x354>)
 8003de8:	f006 fabe 	bl	800a368 <SPD_GetS16Speed>
 8003dec:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003dee:	2000      	movs	r0, #0
              break;
 8003df0:	e745      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003df2:	f5b0 6f29 	cmp.w	r0, #2704	; 0xa90
 8003df6:	f000 826c 	beq.w	80042d2 <RI_GetRegisterMotor1+0x732>
 8003dfa:	f240 8087 	bls.w	8003f0c <RI_GetRegisterMotor1+0x36c>
 8003dfe:	f5b0 6f2d 	cmp.w	r0, #2768	; 0xad0
 8003e02:	d16a      	bne.n	8003eda <RI_GetRegisterMotor1+0x33a>
              *regdata16 = SPD_GetElAngle ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 8003e04:	483c      	ldr	r0, [pc, #240]	; (8003ef8 <RI_GetRegisterMotor1+0x358>)
 8003e06:	f006 fa75 	bl	800a2f4 <SPD_GetElAngle>
 8003e0a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e0c:	2000      	movs	r0, #0
              break;
 8003e0e:	e736      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e10:	f241 5390 	movw	r3, #5520	; 0x1590
 8003e14:	4298      	cmp	r0, r3
 8003e16:	f000 8244 	beq.w	80042a2 <RI_GetRegisterMotor1+0x702>
 8003e1a:	d92e      	bls.n	8003e7a <RI_GetRegisterMotor1+0x2da>
 8003e1c:	f241 6350 	movw	r3, #5712	; 0x1650
 8003e20:	4298      	cmp	r0, r3
 8003e22:	f000 8238 	beq.w	8004296 <RI_GetRegisterMotor1+0x6f6>
 8003e26:	d91e      	bls.n	8003e66 <RI_GetRegisterMotor1+0x2c6>
 8003e28:	f641 03d0 	movw	r3, #6352	; 0x18d0
 8003e2c:	4298      	cmp	r0, r3
 8003e2e:	d10f      	bne.n	8003e50 <RI_GetRegisterMotor1+0x2b0>
              *regdataU16 = PID_GetKIDivisorPOW2(&(&STO_PLL_M1)->PIRegulator);
 8003e30:	4832      	ldr	r0, [pc, #200]	; (8003efc <RI_GetRegisterMotor1+0x35c>)
 8003e32:	f005 f9b7 	bl	80091a4 <PID_GetKIDivisorPOW2>
 8003e36:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e38:	2000      	movs	r0, #0
              break;
 8003e3a:	e720      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e3c:	f5b0 6f3d 	cmp.w	r0, #3024	; 0xbd0
 8003e40:	f040 8265 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = STO_PLL_GetEstimatedCurrent(&STO_PLL_M1).alpha;
 8003e44:	482b      	ldr	r0, [pc, #172]	; (8003ef4 <RI_GetRegisterMotor1+0x354>)
 8003e46:	f006 fd8b 	bl	800a960 <STO_PLL_GetEstimatedCurrent>
 8003e4a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e4c:	2000      	movs	r0, #0
              break;
 8003e4e:	e716      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e50:	f641 1310 	movw	r3, #6416	; 0x1910
 8003e54:	4298      	cmp	r0, r3
 8003e56:	f040 825a 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKPDivisorPOW2(&(&STO_PLL_M1)->PIRegulator);
 8003e5a:	4828      	ldr	r0, [pc, #160]	; (8003efc <RI_GetRegisterMotor1+0x35c>)
 8003e5c:	f005 f99a 	bl	8009194 <PID_GetKPDivisorPOW2>
 8003e60:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e62:	2000      	movs	r0, #0
              break;
 8003e64:	e70b      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e66:	f241 53d0 	movw	r3, #5584	; 0x15d0
 8003e6a:	4298      	cmp	r0, r3
 8003e6c:	d115      	bne.n	8003e9a <RI_GetRegisterMotor1+0x2fa>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIqHandle_M1);
 8003e6e:	4824      	ldr	r0, [pc, #144]	; (8003f00 <RI_GetRegisterMotor1+0x360>)
 8003e70:	f005 f990 	bl	8009194 <PID_GetKPDivisorPOW2>
 8003e74:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e76:	2000      	movs	r0, #0
              break;
 8003e78:	e701      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e7a:	f241 43d0 	movw	r3, #5328	; 0x14d0
 8003e7e:	4298      	cmp	r0, r3
 8003e80:	f000 8203 	beq.w	800428a <RI_GetRegisterMotor1+0x6ea>
 8003e84:	d91f      	bls.n	8003ec6 <RI_GetRegisterMotor1+0x326>
 8003e86:	f241 5310 	movw	r3, #5392	; 0x1510
 8003e8a:	4298      	cmp	r0, r3
 8003e8c:	d110      	bne.n	8003eb0 <RI_GetRegisterMotor1+0x310>
              *regdataU16 = PID_GetKPDivisorPOW2(&PIDIdHandle_M1);
 8003e8e:	481d      	ldr	r0, [pc, #116]	; (8003f04 <RI_GetRegisterMotor1+0x364>)
 8003e90:	f005 f980 	bl	8009194 <PID_GetKPDivisorPOW2>
 8003e94:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003e96:	2000      	movs	r0, #0
              break;
 8003e98:	e6f1      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003e9a:	f241 6310 	movw	r3, #5648	; 0x1610
 8003e9e:	4298      	cmp	r0, r3
 8003ea0:	f040 8235 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIqHandle_M1);
 8003ea4:	4816      	ldr	r0, [pc, #88]	; (8003f00 <RI_GetRegisterMotor1+0x360>)
 8003ea6:	f005 f97d 	bl	80091a4 <PID_GetKIDivisorPOW2>
 8003eaa:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003eac:	2000      	movs	r0, #0
              break;
 8003eae:	e6e6      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003eb0:	f241 5350 	movw	r3, #5456	; 0x1550
 8003eb4:	4298      	cmp	r0, r3
 8003eb6:	f040 822a 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = PID_GetKIDivisorPOW2(&PIDIdHandle_M1);
 8003eba:	4812      	ldr	r0, [pc, #72]	; (8003f04 <RI_GetRegisterMotor1+0x364>)
 8003ebc:	f005 f972 	bl	80091a4 <PID_GetKIDivisorPOW2>
 8003ec0:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ec2:	2000      	movs	r0, #0
              break;
 8003ec4:	e6db      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003ec6:	f241 4350 	movw	r3, #5200	; 0x1450
 8003eca:	4298      	cmp	r0, r3
 8003ecc:	d129      	bne.n	8003f22 <RI_GetRegisterMotor1+0x382>
              *regdataU16 = (uint16_t)PID_GetKPDivisorPOW2(&PIDSpeedHandle_M1);
 8003ece:	480e      	ldr	r0, [pc, #56]	; (8003f08 <RI_GetRegisterMotor1+0x368>)
 8003ed0:	f005 f960 	bl	8009194 <PID_GetKPDivisorPOW2>
 8003ed4:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ed6:	2000      	movs	r0, #0
              break;
 8003ed8:	e6d1      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003eda:	f5b0 6f31 	cmp.w	r0, #2832	; 0xb10
 8003ede:	f040 8216 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = SPD_GetS16Speed ((SpeednPosFdbk_Handle_t*) &ENCODER_M1); //cstat !MISRAC2012-Rule-11.3
 8003ee2:	4805      	ldr	r0, [pc, #20]	; (8003ef8 <RI_GetRegisterMotor1+0x358>)
 8003ee4:	f006 fa40 	bl	800a368 <SPD_GetS16Speed>
 8003ee8:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003eea:	2000      	movs	r0, #0
              break;
 8003eec:	e6c7      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003eee:	bf00      	nop
 8003ef0:	20001a90 	.word	0x20001a90
 8003ef4:	20000210 	.word	0x20000210
 8003ef8:	20000024 	.word	0x20000024
 8003efc:	20000244 	.word	0x20000244
 8003f00:	200000ec 	.word	0x200000ec
 8003f04:	200000c0 	.word	0x200000c0
 8003f08:	20000118 	.word	0x20000118
 8003f0c:	f5b0 6f21 	cmp.w	r0, #2576	; 0xa10
 8003f10:	d112      	bne.n	8003f38 <RI_GetRegisterMotor1+0x398>
              *regdata16 = MCI_GetVqd(pMCIN).d;
 8003f12:	48af      	ldr	r0, [pc, #700]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 8003f14:	f7fd ffee 	bl	8001ef4 <MCI_GetVqd>
 8003f18:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8003f1c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f1e:	2000      	movs	r0, #0
              break;
 8003f20:	e6ad      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003f22:	f241 4390 	movw	r3, #5264	; 0x1490
 8003f26:	4298      	cmp	r0, r3
 8003f28:	f040 81f1 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = (uint16_t)PID_GetKIDivisorPOW2(&PIDSpeedHandle_M1);
 8003f2c:	48a9      	ldr	r0, [pc, #676]	; (80041d4 <RI_GetRegisterMotor1+0x634>)
 8003f2e:	f005 f939 	bl	80091a4 <PID_GetKIDivisorPOW2>
 8003f32:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f34:	2000      	movs	r0, #0
              break;
 8003f36:	e6a2      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003f38:	f5b0 6f25 	cmp.w	r0, #2640	; 0xa50
 8003f3c:	f040 81e7 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetValphabeta(pMCIN).alpha;
 8003f40:	48a3      	ldr	r0, [pc, #652]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 8003f42:	f7fd ffe5 	bl	8001f10 <MCI_GetValphabeta>
 8003f46:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f48:	2000      	movs	r0, #0
              break;
 8003f4a:	e698      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003f4c:	f5b0 7f04 	cmp.w	r0, #528	; 0x210
 8003f50:	f000 8195 	beq.w	800427e <RI_GetRegisterMotor1+0x6de>
 8003f54:	d932      	bls.n	8003fbc <RI_GetRegisterMotor1+0x41c>
 8003f56:	f5b0 7f44 	cmp.w	r0, #784	; 0x310
 8003f5a:	f000 81ae 	beq.w	80042ba <RI_GetRegisterMotor1+0x71a>
 8003f5e:	d924      	bls.n	8003faa <RI_GetRegisterMotor1+0x40a>
 8003f60:	f5b0 7f54 	cmp.w	r0, #848	; 0x350
 8003f64:	d113      	bne.n	8003f8e <RI_GetRegisterMotor1+0x3ee>
              STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 8003f66:	489c      	ldr	r0, [pc, #624]	; (80041d8 <RI_GetRegisterMotor1+0x638>)
 8003f68:	aa13      	add	r2, sp, #76	; 0x4c
 8003f6a:	a912      	add	r1, sp, #72	; 0x48
 8003f6c:	f006 fd0c 	bl	800a988 <STO_PLL_GetObserverGains>
              *regdata16 = hC1;
 8003f70:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8003f74:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f76:	2000      	movs	r0, #0
 8003f78:	e681      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003f7a:	f5b0 6f0d 	cmp.w	r0, #2256	; 0x8d0
 8003f7e:	f040 81c6 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIqd(pMCIN).q;
 8003f82:	4893      	ldr	r0, [pc, #588]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 8003f84:	f7fd ff9a 	bl	8001ebc <MCI_GetIqd>
 8003f88:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003f8a:	2000      	movs	r0, #0
              break;
 8003f8c:	e677      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003f8e:	f5b0 7f64 	cmp.w	r0, #912	; 0x390
 8003f92:	f040 81bc 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              STO_PLL_GetObserverGains(&STO_PLL_M1, &hC1, &hC2);
 8003f96:	4890      	ldr	r0, [pc, #576]	; (80041d8 <RI_GetRegisterMotor1+0x638>)
 8003f98:	aa13      	add	r2, sp, #76	; 0x4c
 8003f9a:	a912      	add	r1, sp, #72	; 0x48
 8003f9c:	f006 fcf4 	bl	800a988 <STO_PLL_GetObserverGains>
              *regdata16 = hC2;
 8003fa0:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
 8003fa4:	8023      	strh	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fa6:	2000      	movs	r0, #0
 8003fa8:	e669      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003faa:	f5b0 7f24 	cmp.w	r0, #656	; 0x290
 8003fae:	d113      	bne.n	8003fd8 <RI_GetRegisterMotor1+0x438>
              *regdata16 = PID_GetKP(&PIDIdHandle_M1);
 8003fb0:	488a      	ldr	r0, [pc, #552]	; (80041dc <RI_GetRegisterMotor1+0x63c>)
 8003fb2:	f005 f8e5 	bl	8009180 <PID_GetKP>
 8003fb6:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fb8:	2000      	movs	r0, #0
              break;
 8003fba:	e660      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003fbc:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
 8003fc0:	f000 8175 	beq.w	80042ae <RI_GetRegisterMotor1+0x70e>
 8003fc4:	d91c      	bls.n	8004000 <RI_GetRegisterMotor1+0x460>
 8003fc6:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 8003fca:	d10f      	bne.n	8003fec <RI_GetRegisterMotor1+0x44c>
              *regdata16 = PID_GetKP(&PIDIqHandle_M1);
 8003fcc:	4884      	ldr	r0, [pc, #528]	; (80041e0 <RI_GetRegisterMotor1+0x640>)
 8003fce:	f005 f8d7 	bl	8009180 <PID_GetKP>
 8003fd2:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fd4:	2000      	movs	r0, #0
              break;
 8003fd6:	e652      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003fd8:	f5b0 7f34 	cmp.w	r0, #720	; 0x2d0
 8003fdc:	f040 8197 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDIdHandle_M1);
 8003fe0:	487e      	ldr	r0, [pc, #504]	; (80041dc <RI_GetRegisterMotor1+0x63c>)
 8003fe2:	f005 f8d1 	bl	8009188 <PID_GetKI>
 8003fe6:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003fe8:	2000      	movs	r0, #0
              break;
 8003fea:	e648      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8003fec:	f5b0 7fe8 	cmp.w	r0, #464	; 0x1d0
 8003ff0:	f040 818d 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDIqHandle_M1);
 8003ff4:	487a      	ldr	r0, [pc, #488]	; (80041e0 <RI_GetRegisterMotor1+0x640>)
 8003ff6:	f005 f8c7 	bl	8009188 <PID_GetKI>
 8003ffa:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8003ffc:	2000      	movs	r0, #0
              break;
 8003ffe:	e63e      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8004000:	2890      	cmp	r0, #144	; 0x90
 8004002:	d11a      	bne.n	800403a <RI_GetRegisterMotor1+0x49a>
              *regdata16 = PID_GetKP(&PIDSpeedHandle_M1);
 8004004:	4873      	ldr	r0, [pc, #460]	; (80041d4 <RI_GetRegisterMotor1+0x634>)
 8004006:	f005 f8bb 	bl	8009180 <PID_GetKP>
 800400a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800400c:	2000      	movs	r0, #0
              break;
 800400e:	e636      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8004010:	f5b0 6f01 	cmp.w	r0, #2064	; 0x810
 8004014:	f040 817b 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = MCI_GetIab(pMCIN).b;
 8004018:	486d      	ldr	r0, [pc, #436]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 800401a:	f7fd ff33 	bl	8001e84 <MCI_GetIab>
 800401e:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8004022:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004024:	2000      	movs	r0, #0
              break;
 8004026:	e62a      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8004028:	f5b0 6f92 	cmp.w	r0, #1168	; 0x490
 800402c:	d10e      	bne.n	800404c <RI_GetRegisterMotor1+0x4ac>
              *regdata16 = PID_GetKP (&(&STO_PLL_M1)->PIRegulator);
 800402e:	486d      	ldr	r0, [pc, #436]	; (80041e4 <RI_GetRegisterMotor1+0x644>)
 8004030:	f005 f8a6 	bl	8009180 <PID_GetKP>
 8004034:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004036:	2000      	movs	r0, #0
              break;
 8004038:	e621      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 800403a:	28d0      	cmp	r0, #208	; 0xd0
 800403c:	f040 8167 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdata16 = PID_GetKI(&PIDSpeedHandle_M1);
 8004040:	4864      	ldr	r0, [pc, #400]	; (80041d4 <RI_GetRegisterMotor1+0x634>)
 8004042:	f005 f8a1 	bl	8009188 <PID_GetKI>
 8004046:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004048:	2000      	movs	r0, #0
              break;
 800404a:	e618      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 800404c:	f5b0 6fb2 	cmp.w	r0, #1424	; 0x590
 8004050:	f040 815d 	bne.w	800430e <RI_GetRegisterMotor1+0x76e>
              *regdataU16 = VBS_GetAvBusVoltage_V(BusVoltageSensor);
 8004054:	4864      	ldr	r0, [pc, #400]	; (80041e8 <RI_GetRegisterMotor1+0x648>)
 8004056:	f004 fd1b 	bl	8008a90 <VBS_GetAvBusVoltage_V>
 800405a:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800405c:	2000      	movs	r0, #0
              break;
 800405e:	e60e      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8004060:	2818      	cmp	r0, #24
 8004062:	f040 8082 	bne.w	800416a <RI_GetRegisterMotor1+0x5ca>
              *regdataU32 = MCI_GetFaultState(pMCIN);
 8004066:	485a      	ldr	r0, [pc, #360]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 8004068:	f7fd fed8 	bl	8001e1c <MCI_GetFaultState>
 800406c:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800406e:	2000      	movs	r0, #0
              break;
 8004070:	e620      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
 8004072:	f5b0 7f8c 	cmp.w	r0, #280	; 0x118
 8004076:	f000 80d2 	beq.w	800421e <RI_GetRegisterMotor1+0x67e>
 800407a:	f641 3358 	movw	r3, #7000	; 0x1b58
 800407e:	4298      	cmp	r0, r3
 8004080:	d173      	bne.n	800416a <RI_GetRegisterMotor1+0x5ca>
              ReadVal.Float_Val = PQD_GetAvrgElMotorPowerW(pMPM[M1]);
 8004082:	4b5a      	ldr	r3, [pc, #360]	; (80041ec <RI_GetRegisterMotor1+0x64c>)
 8004084:	6818      	ldr	r0, [r3, #0]
 8004086:	f005 f919 	bl	80092bc <PQD_GetAvrgElMotorPowerW>
 800408a:	ed8d 0a01 	vstr	s0, [sp, #4]
              *regdataU32 = ReadVal.U32_Val; //cstat !UNION-type-punning
 800408e:	9b01      	ldr	r3, [sp, #4]
 8004090:	6023      	str	r3, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004092:	2000      	movs	r0, #0
 8004094:	e60e      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 8004096:	2008      	movs	r0, #8
  }
 8004098:	b015      	add	sp, #84	; 0x54
 800409a:	bd30      	pop	{r4, r5, pc}
 800409c:	2005      	movs	r0, #5
 800409e:	e5c7      	b.n	8003c30 <RI_GetRegisterMotor1+0x90>
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80040a0:	4b53      	ldr	r3, [pc, #332]	; (80041f0 <RI_GetRegisterMotor1+0x650>)
 80040a2:	681a      	ldr	r2, [r3, #0]
  *size= 1U ; /* /0 is the min String size */
 80040a4:	2301      	movs	r3, #1
 80040a6:	802b      	strh	r3, [r5, #0]
            retVal = RI_MovString (MotorConfig_reg[motorID]->name ,charData, size, freeSpace);
 80040a8:	f102 0124 	add.w	r1, r2, #36	; 0x24
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80040ac:	f992 2024 	ldrsb.w	r2, [r2, #36]	; 0x24
 80040b0:	b17a      	cbz	r2, 80040d2 <RI_GetRegisterMotor1+0x532>
 80040b2:	fa1f fc8c 	uxth.w	ip, ip
 80040b6:	e008      	b.n	80040ca <RI_GetRegisterMotor1+0x52a>
    *tempdestString = *tempsrcString;
 80040b8:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 80040bc:	882b      	ldrh	r3, [r5, #0]
 80040be:	3301      	adds	r3, #1
 80040c0:	b29b      	uxth	r3, r3
 80040c2:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80040c4:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 80040c8:	b11a      	cbz	r2, 80040d2 <RI_GetRegisterMotor1+0x532>
 80040ca:	4563      	cmp	r3, ip
 80040cc:	d3f4      	bcc.n	80040b8 <RI_GetRegisterMotor1+0x518>
    retVal = MCP_ERROR_STRING_FORMAT;
 80040ce:	2006      	movs	r0, #6
 80040d0:	e584      	b.n	8003bdc <RI_GetRegisterMotor1+0x3c>
    *tempdestString = (int8_t)0;
 80040d2:	2000      	movs	r0, #0
 80040d4:	7020      	strb	r0, [r4, #0]
    return (retVal);
 80040d6:	e581      	b.n	8003bdc <RI_GetRegisterMotor1+0x3c>
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 80040d8:	4a46      	ldr	r2, [pc, #280]	; (80041f4 <RI_GetRegisterMotor1+0x654>)
  *size= 1U ; /* /0 is the min String size */
 80040da:	2301      	movs	r3, #1
            retVal = RI_MovString (PWR_BOARD_NAME[motorID], charData, size, freeSpace);
 80040dc:	6811      	ldr	r1, [r2, #0]
  *size= 1U ; /* /0 is the min String size */
 80040de:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80040e0:	f991 2000 	ldrsb.w	r2, [r1]
 80040e4:	2a00      	cmp	r2, #0
 80040e6:	d0f4      	beq.n	80040d2 <RI_GetRegisterMotor1+0x532>
 80040e8:	fa1f fc8c 	uxth.w	ip, ip
 80040ec:	e009      	b.n	8004102 <RI_GetRegisterMotor1+0x562>
    *tempdestString = *tempsrcString;
 80040ee:	f804 2b01 	strb.w	r2, [r4], #1
    *size = *size + 1U;
 80040f2:	882b      	ldrh	r3, [r5, #0]
 80040f4:	3301      	adds	r3, #1
 80040f6:	b29b      	uxth	r3, r3
 80040f8:	802b      	strh	r3, [r5, #0]
  while ((*tempsrcString != (char_t)0) && (*size < (uint16_t)maxSize))
 80040fa:	f911 2f01 	ldrsb.w	r2, [r1, #1]!
 80040fe:	2a00      	cmp	r2, #0
 8004100:	d0e7      	beq.n	80040d2 <RI_GetRegisterMotor1+0x532>
 8004102:	4563      	cmp	r3, ip
 8004104:	d3f3      	bcc.n	80040ee <RI_GetRegisterMotor1+0x54e>
 8004106:	e7e2      	b.n	80040ce <RI_GetRegisterMotor1+0x52e>
              FOCFwConfig_reg_t const *pFOCConfig_reg = FOCConfig_reg[motorID];
 8004108:	4a3b      	ldr	r2, [pc, #236]	; (80041f8 <RI_GetRegisterMotor1+0x658>)
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 800410a:	6812      	ldr	r2, [r2, #0]
 800410c:	6810      	ldr	r0, [r2, #0]
 800410e:	6851      	ldr	r1, [r2, #4]
 8004110:	6894      	ldr	r4, [r2, #8]
 8004112:	609c      	str	r4, [r3, #8]
 8004114:	6018      	str	r0, [r3, #0]
 8004116:	6059      	str	r1, [r3, #4]
 8004118:	8992      	ldrh	r2, [r2, #12]
 800411a:	819a      	strh	r2, [r3, #12]
    uint8_t retVal = MCP_CMD_OK;
 800411c:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pFOCConfig_reg, sizeof(FOCFwConfig_reg_t));
 800411e:	2310      	movs	r3, #16
 8004120:	e574      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
              MotorConfig_reg_t const *pMotorConfig_reg = MotorConfig_reg[motorID];
 8004122:	4a33      	ldr	r2, [pc, #204]	; (80041f0 <RI_GetRegisterMotor1+0x650>)
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 8004124:	6812      	ldr	r2, [r2, #0]
 8004126:	f102 0e30 	add.w	lr, r2, #48	; 0x30
 800412a:	6814      	ldr	r4, [r2, #0]
 800412c:	6850      	ldr	r0, [r2, #4]
 800412e:	6891      	ldr	r1, [r2, #8]
 8004130:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8004134:	f8c3 c00c 	str.w	ip, [r3, #12]
 8004138:	3210      	adds	r2, #16
 800413a:	4572      	cmp	r2, lr
 800413c:	601c      	str	r4, [r3, #0]
 800413e:	6058      	str	r0, [r3, #4]
 8004140:	6099      	str	r1, [r3, #8]
 8004142:	f103 0310 	add.w	r3, r3, #16
 8004146:	d1f0      	bne.n	800412a <RI_GetRegisterMotor1+0x58a>
 8004148:	6810      	ldr	r0, [r2, #0]
 800414a:	6851      	ldr	r1, [r2, #4]
 800414c:	6892      	ldr	r2, [r2, #8]
 800414e:	609a      	str	r2, [r3, #8]
 8004150:	6018      	str	r0, [r3, #0]
 8004152:	6059      	str	r1, [r3, #4]
    uint8_t retVal = MCP_CMD_OK;
 8004154:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pMotorConfig_reg, sizeof(MotorConfig_reg_t));
 8004156:	233e      	movs	r3, #62	; 0x3e
 8004158:	e558      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
          retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800415a:	4608      	mov	r0, r1
 800415c:	e53e      	b.n	8003bdc <RI_GetRegisterMotor1+0x3c>
              *data = (uint8_t)MCI_GetSTMState(pMCIN);
 800415e:	481c      	ldr	r0, [pc, #112]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 8004160:	f7fd fdf4 	bl	8001d4c <MCI_GetSTMState>
 8004164:	7020      	strb	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004166:	2000      	movs	r0, #0
              break;
 8004168:	e562      	b.n	8003c30 <RI_GetRegisterMotor1+0x90>
 800416a:	2005      	movs	r0, #5
 800416c:	e5a2      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 800416e:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8004172:	2210      	movs	r2, #16
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 8004174:	f1bc 0f11 	cmp.w	ip, #17
            *rawSize = (uint16_t)sizeof(ApplicationConfig_reg_t);
 8004178:	8022      	strh	r2, [r4, #0]
            if (((*rawSize) + 2U) > (uint16_t)freeSpace)
 800417a:	d859      	bhi.n	8004230 <RI_GetRegisterMotor1+0x690>
 800417c:	2312      	movs	r3, #18
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800417e:	2008      	movs	r0, #8
 8004180:	e544      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8004182:	fa1f fc8c 	uxth.w	ip, ip
            *rawSize = 12;
 8004186:	220c      	movs	r2, #12
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 8004188:	f1bc 0f0d 	cmp.w	ip, #13
            *rawSize = 12;
 800418c:	8022      	strh	r2, [r4, #0]
            if ((*rawSize) +2U > (uint16_t)freeSpace)
 800418e:	d94c      	bls.n	800422a <RI_GetRegisterMotor1+0x68a>
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 8004190:	4a1a      	ldr	r2, [pc, #104]	; (80041fc <RI_GetRegisterMotor1+0x65c>)
 8004192:	6850      	ldr	r0, [r2, #4]
 8004194:	6814      	ldr	r4, [r2, #0]
 8004196:	6891      	ldr	r1, [r2, #8]
 8004198:	68d2      	ldr	r2, [r2, #12]
 800419a:	60da      	str	r2, [r3, #12]
 800419c:	6058      	str	r0, [r3, #4]
 800419e:	601c      	str	r4, [r3, #0]
 80041a0:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 80041a2:	2000      	movs	r0, #0
              memcpy(rawData, &scaleParams_M1, sizeof(ScaleParams_t) );
 80041a4:	230e      	movs	r3, #14
 80041a6:	e531      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
        *size = (*rawSize) + 2U;
 80041a8:	8823      	ldrh	r3, [r4, #0]
 80041aa:	3302      	adds	r3, #2
            retVal = MCP_ERROR_UNKNOWN_REG;
 80041ac:	2005      	movs	r0, #5
        *size = (*rawSize) + 2U;
 80041ae:	b29b      	uxth	r3, r3
 80041b0:	e52c      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
            *rawSize = 4;
 80041b2:	2304      	movs	r3, #4
 80041b4:	8023      	strh	r3, [r4, #0]
            *torque = MCI_GetLastRampFinalTorque(pMCIN);
 80041b6:	4806      	ldr	r0, [pc, #24]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 80041b8:	f7fd fe3e 	bl	8001e38 <MCI_GetLastRampFinalTorque>
 80041bc:	8060      	strh	r0, [r4, #2]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 80041be:	4804      	ldr	r0, [pc, #16]	; (80041d0 <RI_GetRegisterMotor1+0x630>)
 80041c0:	f7fd fe3e 	bl	8001e40 <MCI_GetLastRampFinalDuration>
        *size = (*rawSize) + 2U;
 80041c4:	8823      	ldrh	r3, [r4, #0]
            *duration = MCI_GetLastRampFinalDuration(pMCIN) ;
 80041c6:	80a0      	strh	r0, [r4, #4]
        *size = (*rawSize) + 2U;
 80041c8:	3302      	adds	r3, #2
 80041ca:	b29b      	uxth	r3, r3
    uint8_t retVal = MCP_CMD_OK;
 80041cc:	2000      	movs	r0, #0
            break;
 80041ce:	e51d      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
 80041d0:	20001a90 	.word	0x20001a90
 80041d4:	20000118 	.word	0x20000118
 80041d8:	20000210 	.word	0x20000210
 80041dc:	200000c0 	.word	0x200000c0
 80041e0:	200000ec 	.word	0x200000ec
 80041e4:	20000244 	.word	0x20000244
 80041e8:	20000004 	.word	0x20000004
 80041ec:	200003d0 	.word	0x200003d0
 80041f0:	200003e8 	.word	0x200003e8
 80041f4:	200003ec 	.word	0x200003ec
 80041f8:	200003e4 	.word	0x200003e4
 80041fc:	200003f0 	.word	0x200003f0
              *regdata32 = (((int32_t)MCI_GetAvrgMecSpeedUnit(pMCIN) * U_RPM) / SPEED_UNIT);
 8004200:	4844      	ldr	r0, [pc, #272]	; (8004314 <RI_GetRegisterMotor1+0x774>)
 8004202:	f7fd fe23 	bl	8001e4c <MCI_GetAvrgMecSpeedUnit>
 8004206:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800420a:	0040      	lsls	r0, r0, #1
 800420c:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800420e:	2000      	movs	r0, #0
              break;
 8004210:	e550      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
              *regdata32 = STO_PLL_GetEstimatedBemfLevel(&STO_PLL_M1);
 8004212:	4841      	ldr	r0, [pc, #260]	; (8004318 <RI_GetRegisterMotor1+0x778>)
 8004214:	f006 fbc4 	bl	800a9a0 <STO_PLL_GetEstimatedBemfLevel>
 8004218:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800421a:	2000      	movs	r0, #0
              break;
 800421c:	e54a      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
              *regdata32 = STO_PLL_GetObservedBemfLevel(&STO_PLL_M1);
 800421e:	483e      	ldr	r0, [pc, #248]	; (8004318 <RI_GetRegisterMotor1+0x778>)
 8004220:	f006 fbc2 	bl	800a9a8 <STO_PLL_GetObservedBemfLevel>
 8004224:	6020      	str	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004226:	2000      	movs	r0, #0
              break;
 8004228:	e544      	b.n	8003cb4 <RI_GetRegisterMotor1+0x114>
 800422a:	230e      	movs	r3, #14
              retVal = MCP_ERROR_NO_TXSYNC_SPACE;
 800422c:	2008      	movs	r0, #8
 800422e:	e4ed      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
              ApplicationConfig_reg_t const *pApplicationConfig_reg = ApplicationConfig_reg[motorID];
 8004230:	4a3a      	ldr	r2, [pc, #232]	; (800431c <RI_GetRegisterMotor1+0x77c>)
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 8004232:	6812      	ldr	r2, [r2, #0]
 8004234:	6850      	ldr	r0, [r2, #4]
 8004236:	6814      	ldr	r4, [r2, #0]
 8004238:	6891      	ldr	r1, [r2, #8]
 800423a:	68d2      	ldr	r2, [r2, #12]
 800423c:	60da      	str	r2, [r3, #12]
 800423e:	6058      	str	r0, [r3, #4]
 8004240:	601c      	str	r4, [r3, #0]
 8004242:	6099      	str	r1, [r3, #8]
    uint8_t retVal = MCP_CMD_OK;
 8004244:	2000      	movs	r0, #0
              (void)memcpy(rawData, (const uint8_t *)pApplicationConfig_reg, sizeof(ApplicationConfig_reg_t));
 8004246:	2312      	movs	r3, #18
 8004248:	e4e0      	b.n	8003c0c <RI_GetRegisterMotor1+0x6c>
              *regdata16 = MCI_GetIqd(pMCIN).d;
 800424a:	4832      	ldr	r0, [pc, #200]	; (8004314 <RI_GetRegisterMotor1+0x774>)
 800424c:	f7fd fe36 	bl	8001ebc <MCI_GetIqd>
 8004250:	f3c0 400f 	ubfx	r0, r0, #16, #16
 8004254:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004256:	2000      	movs	r0, #0
              break;
 8004258:	e511      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetIalphabeta(pMCIN).alpha;
 800425a:	482e      	ldr	r0, [pc, #184]	; (8004314 <RI_GetRegisterMotor1+0x774>)
 800425c:	f7fd fe20 	bl	8001ea0 <MCI_GetIalphabeta>
 8004260:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004262:	2000      	movs	r0, #0
              break;
 8004264:	e50b      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKI (&(&STO_PLL_M1)->PIRegulator);
 8004266:	482e      	ldr	r0, [pc, #184]	; (8004320 <RI_GetRegisterMotor1+0x780>)
 8004268:	f004 ff8e 	bl	8009188 <PID_GetKI>
 800426c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800426e:	2000      	movs	r0, #0
              break;
 8004270:	e505      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetVqd(pMCIN).q;
 8004272:	4828      	ldr	r0, [pc, #160]	; (8004314 <RI_GetRegisterMotor1+0x774>)
 8004274:	f7fd fe3e 	bl	8001ef4 <MCI_GetVqd>
 8004278:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800427a:	2000      	movs	r0, #0
              break;
 800427c:	e4ff      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDIqHandle_M1);
 800427e:	4829      	ldr	r0, [pc, #164]	; (8004324 <RI_GetRegisterMotor1+0x784>)
 8004280:	f004 ffac 	bl	80091dc <PID_GetKD>
 8004284:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004286:	2000      	movs	r0, #0
              break;
 8004288:	e4f9      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDSpeedHandle_M1);
 800428a:	4827      	ldr	r0, [pc, #156]	; (8004328 <RI_GetRegisterMotor1+0x788>)
 800428c:	f004 ffaa 	bl	80091e4 <PID_GetKDDivisorPOW2>
 8004290:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 8004292:	2000      	movs	r0, #0
              break;
 8004294:	e4f3      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIqHandle_M1);
 8004296:	4823      	ldr	r0, [pc, #140]	; (8004324 <RI_GetRegisterMotor1+0x784>)
 8004298:	f004 ffa4 	bl	80091e4 <PID_GetKDDivisorPOW2>
 800429c:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800429e:	2000      	movs	r0, #0
              break;
 80042a0:	e4ed      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdataU16 = PID_GetKDDivisorPOW2(&PIDIdHandle_M1);
 80042a2:	4822      	ldr	r0, [pc, #136]	; (800432c <RI_GetRegisterMotor1+0x78c>)
 80042a4:	f004 ff9e 	bl	80091e4 <PID_GetKDDivisorPOW2>
 80042a8:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042aa:	2000      	movs	r0, #0
              break;
 80042ac:	e4e7      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDSpeedHandle_M1);
 80042ae:	481e      	ldr	r0, [pc, #120]	; (8004328 <RI_GetRegisterMotor1+0x788>)
 80042b0:	f004 ff94 	bl	80091dc <PID_GetKD>
 80042b4:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042b6:	2000      	movs	r0, #0
              break;
 80042b8:	e4e1      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = PID_GetKD(&PIDIdHandle_M1);
 80042ba:	481c      	ldr	r0, [pc, #112]	; (800432c <RI_GetRegisterMotor1+0x78c>)
 80042bc:	f004 ff8e 	bl	80091dc <PID_GetKD>
 80042c0:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042c2:	2000      	movs	r0, #0
              break;
 80042c4:	e4db      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = NTC_GetAvTemp_C(&TempSensor_M1);
 80042c6:	481a      	ldr	r0, [pc, #104]	; (8004330 <RI_GetRegisterMotor1+0x790>)
 80042c8:	f004 ff3c 	bl	8009144 <NTC_GetAvTemp_C>
 80042cc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042ce:	2000      	movs	r0, #0
              break;
 80042d0:	e4d5      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = MCI_GetValphabeta(pMCIN).beta;
 80042d2:	4810      	ldr	r0, [pc, #64]	; (8004314 <RI_GetRegisterMotor1+0x774>)
 80042d4:	f7fd fe1c 	bl	8001f10 <MCI_GetValphabeta>
 80042d8:	f3c0 400f 	ubfx	r0, r0, #16, #16
 80042dc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042de:	2000      	movs	r0, #0
              break;
 80042e0:	e4cd      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = STO_PLL_GetEstimatedBemf(&STO_PLL_M1).beta;
 80042e2:	480d      	ldr	r0, [pc, #52]	; (8004318 <RI_GetRegisterMotor1+0x778>)
 80042e4:	f006 fb30 	bl	800a948 <STO_PLL_GetEstimatedBemf>
 80042e8:	f3c0 400f 	ubfx	r0, r0, #16, #16
 80042ec:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042ee:	2000      	movs	r0, #0
              break;
 80042f0:	e4c5      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = STO_PLL_GetEstimatedCurrent(&STO_PLL_M1).beta;
 80042f2:	4809      	ldr	r0, [pc, #36]	; (8004318 <RI_GetRegisterMotor1+0x778>)
 80042f4:	f006 fb34 	bl	800a960 <STO_PLL_GetEstimatedCurrent>
 80042f8:	f3c0 400f 	ubfx	r0, r0, #16, #16
 80042fc:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 80042fe:	2000      	movs	r0, #0
              break;
 8004300:	e4bd      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
              *regdata16 = SPD_GetElAngle((SpeednPosFdbk_Handle_t *)&STO_PLL_M1);
 8004302:	4805      	ldr	r0, [pc, #20]	; (8004318 <RI_GetRegisterMotor1+0x778>)
 8004304:	f005 fff6 	bl	800a2f4 <SPD_GetElAngle>
 8004308:	8020      	strh	r0, [r4, #0]
    uint8_t retVal = MCP_CMD_OK;
 800430a:	2000      	movs	r0, #0
              break;
 800430c:	e4b7      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 800430e:	2005      	movs	r0, #5
 8004310:	e4b5      	b.n	8003c7e <RI_GetRegisterMotor1+0xde>
 8004312:	bf00      	nop
 8004314:	20001a90 	.word	0x20001a90
 8004318:	20000210 	.word	0x20000210
 800431c:	200003e0 	.word	0x200003e0
 8004320:	20000244 	.word	0x20000244
 8004324:	200000ec 	.word	0x200000ec
 8004328:	20000118 	.word	0x20000118
 800432c:	200000c0 	.word	0x200000c0
 8004330:	2000036c 	.word	0x2000036c

08004334 <RI_GetIDSize>:
  return (retVal);
}

uint8_t RI_GetIDSize(uint16_t dataID)
{
  uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;
 8004334:	f000 0038 	and.w	r0, r0, #56	; 0x38
 8004338:	3808      	subs	r0, #8
 800433a:	b2c0      	uxtb	r0, r0
 800433c:	2810      	cmp	r0, #16
 800433e:	bf9a      	itte	ls
 8004340:	4b01      	ldrls	r3, [pc, #4]	; (8004348 <RI_GetIDSize+0x14>)
 8004342:	5c18      	ldrbls	r0, [r3, r0]
 8004344:	2000      	movhi	r0, #0
      break;
    }
  }

  return (result);
}
 8004346:	4770      	bx	lr
 8004348:	0801a168 	.word	0x0801a168

0800434c <RI_GetPtrReg>:

    MCI_Handle_t *pMCIN = &Mci[0];
    uint16_t regID = dataID & REG_MASK;
    uint8_t typeID = ((uint8_t)dataID) & TYPE_MASK;

    switch (typeID)
 800434c:	f000 0338 	and.w	r3, r0, #56	; 0x38
 8004350:	2b10      	cmp	r3, #16
 8004352:	d003      	beq.n	800435c <RI_GetPtrReg+0x10>
 8004354:	4a4d      	ldr	r2, [pc, #308]	; (800448c <RI_GetPtrReg+0x140>)
          }

          default:
          {
            *dataPtr = &nullData16;
            retVal = MCP_ERROR_UNKNOWN_REG;
 8004356:	2005      	movs	r0, #5
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004358:	600a      	str	r2, [r1, #0]
    }
#ifdef NULL_PTR_CHECK_REG_INT
  }
#endif
  return (retVal);
}
 800435a:	4770      	bx	lr
    uint16_t regID = dataID & REG_MASK;
 800435c:	f020 0007 	bic.w	r0, r0, #7
 8004360:	f5b0 6f21 	cmp.w	r0, #2576	; 0xa10
 8004364:	b283      	uxth	r3, r0
 8004366:	f000 8082 	beq.w	800446e <RI_GetPtrReg+0x122>
 800436a:	d811      	bhi.n	8004390 <RI_GetPtrReg+0x44>
 800436c:	f5b3 6f0d 	cmp.w	r3, #2256	; 0x8d0
 8004370:	f000 8082 	beq.w	8004478 <RI_GetPtrReg+0x12c>
 8004374:	d929      	bls.n	80043ca <RI_GetPtrReg+0x7e>
 8004376:	f5b3 6f19 	cmp.w	r3, #2448	; 0x990
 800437a:	f000 8082 	beq.w	8004482 <RI_GetPtrReg+0x136>
 800437e:	d919      	bls.n	80043b4 <RI_GetPtrReg+0x68>
 8004380:	f5b3 6f1d 	cmp.w	r3, #2512	; 0x9d0
 8004384:	d1e6      	bne.n	8004354 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 8004386:	4b42      	ldr	r3, [pc, #264]	; (8004490 <RI_GetPtrReg+0x144>)
 8004388:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800438a:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.q);
 800438c:	3216      	adds	r2, #22
            break;
 800438e:	e7e3      	b.n	8004358 <RI_GetPtrReg+0xc>
 8004390:	f5b3 6f35 	cmp.w	r3, #2896	; 0xb50
 8004394:	d055      	beq.n	8004442 <RI_GetPtrReg+0xf6>
 8004396:	d82f      	bhi.n	80043f8 <RI_GetPtrReg+0xac>
 8004398:	f5b3 6f2d 	cmp.w	r3, #2768	; 0xad0
 800439c:	d04e      	beq.n	800443c <RI_GetPtrReg+0xf0>
 800439e:	d920      	bls.n	80043e2 <RI_GetPtrReg+0x96>
 80043a0:	483c      	ldr	r0, [pc, #240]	; (8004494 <RI_GetPtrReg+0x148>)
 80043a2:	4a3a      	ldr	r2, [pc, #232]	; (800448c <RI_GetPtrReg+0x140>)
 80043a4:	f5b3 6f31 	cmp.w	r3, #2832	; 0xb10
 80043a8:	bf0a      	itet	eq
 80043aa:	4602      	moveq	r2, r0
 80043ac:	2005      	movne	r0, #5
 80043ae:	2000      	moveq	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 80043b0:	600a      	str	r2, [r1, #0]
}
 80043b2:	4770      	bx	lr
 80043b4:	f5b3 6f11 	cmp.w	r3, #2320	; 0x910
 80043b8:	d04b      	beq.n	8004452 <RI_GetPtrReg+0x106>
 80043ba:	f5b3 6f15 	cmp.w	r3, #2384	; 0x950
 80043be:	d1c9      	bne.n	8004354 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80043c0:	4b33      	ldr	r3, [pc, #204]	; (8004490 <RI_GetPtrReg+0x144>)
 80043c2:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80043c4:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.q);
 80043c6:	3210      	adds	r2, #16
            break;
 80043c8:	e7c6      	b.n	8004358 <RI_GetPtrReg+0xc>
 80043ca:	f5b3 6f05 	cmp.w	r3, #2128	; 0x850
 80043ce:	d03b      	beq.n	8004448 <RI_GetPtrReg+0xfc>
 80043d0:	d91c      	bls.n	800440c <RI_GetPtrReg+0xc0>
 80043d2:	f5b3 6f09 	cmp.w	r3, #2192	; 0x890
 80043d6:	d1bd      	bne.n	8004354 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 80043d8:	4b2d      	ldr	r3, [pc, #180]	; (8004490 <RI_GetPtrReg+0x144>)
 80043da:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80043dc:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.beta);
 80043de:	3206      	adds	r2, #6
            break;
 80043e0:	e7ba      	b.n	8004358 <RI_GetPtrReg+0xc>
 80043e2:	f5b3 6f25 	cmp.w	r3, #2640	; 0xa50
 80043e6:	d039      	beq.n	800445c <RI_GetPtrReg+0x110>
 80043e8:	f5b3 6f29 	cmp.w	r3, #2704	; 0xa90
 80043ec:	d1b2      	bne.n	8004354 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 80043ee:	4b28      	ldr	r3, [pc, #160]	; (8004490 <RI_GetPtrReg+0x144>)
 80043f0:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 80043f2:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.beta);
 80043f4:	321c      	adds	r2, #28
            break;
 80043f6:	e7af      	b.n	8004358 <RI_GetPtrReg+0xc>
 80043f8:	f5b3 6f45 	cmp.w	r3, #3152	; 0xc50
 80043fc:	d01b      	beq.n	8004436 <RI_GetPtrReg+0xea>
 80043fe:	f5b3 6f49 	cmp.w	r3, #3216	; 0xc90
 8004402:	d10e      	bne.n	8004422 <RI_GetPtrReg+0xd6>
 8004404:	4a24      	ldr	r2, [pc, #144]	; (8004498 <RI_GetPtrReg+0x14c>)
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004406:	600a      	str	r2, [r1, #0]
  uint8_t retVal = MCP_CMD_OK;
 8004408:	2000      	movs	r0, #0
}
 800440a:	4770      	bx	lr
 800440c:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8004410:	d029      	beq.n	8004466 <RI_GetPtrReg+0x11a>
 8004412:	f5b3 6f01 	cmp.w	r3, #2064	; 0x810
 8004416:	d19d      	bne.n	8004354 <RI_GetPtrReg+0x8>
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004418:	4b1d      	ldr	r3, [pc, #116]	; (8004490 <RI_GetPtrReg+0x144>)
 800441a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800441c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 800441e:	3202      	adds	r2, #2
            break;
 8004420:	e79a      	b.n	8004358 <RI_GetPtrReg+0xc>
 8004422:	481e      	ldr	r0, [pc, #120]	; (800449c <RI_GetPtrReg+0x150>)
 8004424:	4a19      	ldr	r2, [pc, #100]	; (800448c <RI_GetPtrReg+0x140>)
 8004426:	f5b3 6f39 	cmp.w	r3, #2960	; 0xb90
 800442a:	bf0a      	itet	eq
 800442c:	4602      	moveq	r2, r0
 800442e:	2005      	movne	r0, #5
 8004430:	2000      	moveq	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.b);
 8004432:	600a      	str	r2, [r1, #0]
}
 8004434:	4770      	bx	lr
 8004436:	4a1a      	ldr	r2, [pc, #104]	; (80044a0 <RI_GetPtrReg+0x154>)
  uint8_t retVal = MCP_CMD_OK;
 8004438:	2000      	movs	r0, #0
 800443a:	e78d      	b.n	8004358 <RI_GetPtrReg+0xc>
 800443c:	4a19      	ldr	r2, [pc, #100]	; (80044a4 <RI_GetPtrReg+0x158>)
 800443e:	2000      	movs	r0, #0
 8004440:	e78a      	b.n	8004358 <RI_GetPtrReg+0xc>
 8004442:	4a19      	ldr	r2, [pc, #100]	; (80044a8 <RI_GetPtrReg+0x15c>)
 8004444:	2000      	movs	r0, #0
 8004446:	e787      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 8004448:	4b11      	ldr	r3, [pc, #68]	; (8004490 <RI_GetPtrReg+0x144>)
 800444a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800444c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Ialphabeta.alpha);
 800444e:	3204      	adds	r2, #4
            break;
 8004450:	e782      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 8004452:	4b0f      	ldr	r3, [pc, #60]	; (8004490 <RI_GetPtrReg+0x144>)
 8004454:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004456:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.d);
 8004458:	320e      	adds	r2, #14
            break;
 800445a:	e77d      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 800445c:	4b0c      	ldr	r3, [pc, #48]	; (8004490 <RI_GetPtrReg+0x144>)
 800445e:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004460:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Valphabeta.alpha);
 8004462:	321a      	adds	r2, #26
            break;
 8004464:	e778      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 8004466:	4b0a      	ldr	r3, [pc, #40]	; (8004490 <RI_GetPtrReg+0x144>)
  uint8_t retVal = MCP_CMD_OK;
 8004468:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iab.a);
 800446a:	685a      	ldr	r2, [r3, #4]
             break;
 800446c:	e774      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 800446e:	4b08      	ldr	r3, [pc, #32]	; (8004490 <RI_GetPtrReg+0x144>)
 8004470:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004472:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Vqd.d);
 8004474:	3218      	adds	r2, #24
            break;
 8004476:	e76f      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 8004478:	4b05      	ldr	r3, [pc, #20]	; (8004490 <RI_GetPtrReg+0x144>)
 800447a:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 800447c:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqd.q);
 800447e:	320c      	adds	r2, #12
            break;
 8004480:	e76a      	b.n	8004358 <RI_GetPtrReg+0xc>
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8004482:	4b03      	ldr	r3, [pc, #12]	; (8004490 <RI_GetPtrReg+0x144>)
 8004484:	685a      	ldr	r2, [r3, #4]
  uint8_t retVal = MCP_CMD_OK;
 8004486:	2000      	movs	r0, #0
            *dataPtr = &(pMCIN->pFOCVars->Iqdref.d);
 8004488:	3212      	adds	r2, #18
            break;
 800448a:	e765      	b.n	8004358 <RI_GetPtrReg+0xc>
 800448c:	20002dc8 	.word	0x20002dc8
 8004490:	20001a90 	.word	0x20001a90
 8004494:	20000030 	.word	0x20000030
 8004498:	20000282 	.word	0x20000282
 800449c:	2000021c 	.word	0x2000021c
 80044a0:	20000280 	.word	0x20000280
 80044a4:	20000028 	.word	0x20000028
 80044a8:	20000214 	.word	0x20000214

080044ac <RCM_RegisterRegConv>:

    /* Parse the array to be sure that same
     * conversion does not already exist*/
    while (i < RCM_MAX_CONV)
    {
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044ac:	4980      	ldr	r1, [pc, #512]	; (80046b0 <RCM_RegisterRegConv+0x204>)
 80044ae:	680b      	ldr	r3, [r1, #0]
{
 80044b0:	b570      	push	{r4, r5, r6, lr}
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	f000 8094 	beq.w	80045e0 <RCM_RegisterRegConv+0x134>
        /* Nothing to do */
      }
      /* Ticket 64042 : If RCM_handle_array [i] is null access to data member will cause Memory Fault */
      if (RCM_handle_array [i] != 0)
      {
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80044b8:	f890 c004 	ldrb.w	ip, [r0, #4]
 80044bc:	791a      	ldrb	r2, [r3, #4]
 80044be:	4594      	cmp	ip, r2
 80044c0:	d027      	beq.n	8004512 <RCM_RegisterRegConv+0x66>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044c2:	684a      	ldr	r2, [r1, #4]
 80044c4:	2a00      	cmp	r2, #0
 80044c6:	f000 80a6 	beq.w	8004616 <RCM_RegisterRegConv+0x16a>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80044ca:	7914      	ldrb	r4, [r2, #4]
 80044cc:	4564      	cmp	r4, ip
  uint8_t handle = 255U;
 80044ce:	f04f 03ff 	mov.w	r3, #255	; 0xff
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80044d2:	f000 808e 	beq.w	80045f2 <RCM_RegisterRegConv+0x146>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044d6:	688c      	ldr	r4, [r1, #8]
 80044d8:	2c00      	cmp	r4, #0
 80044da:	f000 80c0 	beq.w	800465e <RCM_RegisterRegConv+0x1b2>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80044de:	7922      	ldrb	r2, [r4, #4]
 80044e0:	4562      	cmp	r2, ip
 80044e2:	f000 808f 	beq.w	8004604 <RCM_RegisterRegConv+0x158>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80044e6:	68ca      	ldr	r2, [r1, #12]
 80044e8:	2a00      	cmp	r2, #0
 80044ea:	f000 80c1 	beq.w	8004670 <RCM_RegisterRegConv+0x1c4>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80044ee:	7914      	ldrb	r4, [r2, #4]
 80044f0:	4564      	cmp	r4, ip
 80044f2:	f000 809c 	beq.w	800462e <RCM_RegisterRegConv+0x182>
    while (i < RCM_MAX_CONV)
 80044f6:	f04f 0200 	mov.w	r2, #0
 80044fa:	f363 0207 	bfi	r2, r3, #0, #8
 80044fe:	f363 220f 	bfi	r2, r3, #8, #8
      {
        /* Nothing to do */
      }
      i++;
    }
    if (handle < RCM_MAX_CONV)
 8004502:	2b03      	cmp	r3, #3
 8004504:	4614      	mov	r4, r2
 8004506:	bf88      	it	hi
 8004508:	23ff      	movhi	r3, #255	; 0xff
 800450a:	f240 80ce 	bls.w	80046aa <RCM_RegisterRegConv+0x1fe>
      /* Nothing to do handle is already set to error value : 255 */
    }
#ifdef NULL_PTR_CHECK_REG_CON_MNG
  }
#endif
  regConv->convHandle = handle;
 800450e:	7303      	strb	r3, [r0, #12]
}
 8004510:	bd70      	pop	{r4, r5, r6, pc}
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 8004512:	6802      	ldr	r2, [r0, #0]
 8004514:	681b      	ldr	r3, [r3, #0]
 8004516:	429a      	cmp	r2, r3
 8004518:	d1d3      	bne.n	80044c2 <RCM_RegisterRegConv+0x16>
    uint8_t i = 0;
 800451a:	2300      	movs	r3, #0
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800451c:	461c      	mov	r4, r3
      RCM_handle_array [handle] = regConv;
 800451e:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
      RCM_CB_array [handle].cb = NULL; /* If a previous callback was attached, it is cleared */
 8004522:	4d64      	ldr	r5, [pc, #400]	; (80046b4 <RCM_RegisterRegConv+0x208>)
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004524:	6891      	ldr	r1, [r2, #8]
 8004526:	2600      	movs	r6, #0
 8004528:	f845 6033 	str.w	r6, [r5, r3, lsl #3]
 800452c:	07ce      	lsls	r6, r1, #31
 800452e:	d422      	bmi.n	8004576 <RCM_RegisterRegConv+0xca>
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_EOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 8004530:	6851      	ldr	r1, [r2, #4]
 8004532:	f021 0104 	bic.w	r1, r1, #4
 8004536:	6051      	str	r1, [r2, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8004538:	2104      	movs	r1, #4
 800453a:	6011      	str	r1, [r2, #0]
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_JEOC(ADC_TypeDef *ADCx)
{
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 800453c:	6851      	ldr	r1, [r2, #4]
 800453e:	f021 0120 	bic.w	r1, r1, #32
 8004542:	6051      	str	r1, [r2, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 8004544:	2120      	movs	r1, #32
 8004546:	6011      	str	r1, [r2, #0]
  MODIFY_REG(ADCx->CR,
 8004548:	6891      	ldr	r1, [r2, #8]
 800454a:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 800454e:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 8004552:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 8004556:	6091      	str	r1, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8004558:	6891      	ldr	r1, [r2, #8]
 800455a:	2900      	cmp	r1, #0
 800455c:	dbfc      	blt.n	8004558 <RCM_RegisterRegConv+0xac>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 800455e:	6811      	ldr	r1, [r2, #0]
 8004560:	07cd      	lsls	r5, r1, #31
 8004562:	d408      	bmi.n	8004576 <RCM_RegisterRegConv+0xca>
  MODIFY_REG(ADCx->CR,
 8004564:	4d54      	ldr	r5, [pc, #336]	; (80046b8 <RCM_RegisterRegConv+0x20c>)
 8004566:	6891      	ldr	r1, [r2, #8]
 8004568:	4029      	ands	r1, r5
 800456a:	f041 0101 	orr.w	r1, r1, #1
 800456e:	6091      	str	r1, [r2, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8004570:	6811      	ldr	r1, [r2, #0]
 8004572:	07c9      	lsls	r1, r1, #31
 8004574:	d5f7      	bpl.n	8004566 <RCM_RegisterRegConv+0xba>
      RCM_NoInj_array[handle].enable = false;
 8004576:	4d51      	ldr	r5, [pc, #324]	; (80046bc <RCM_RegisterRegConv+0x210>)
 8004578:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 800457c:	0049      	lsls	r1, r1, #1
      RCM_NoInj_array[handle].prev = handle;
 800457e:	eb05 0c01 	add.w	ip, r5, r1
      RCM_NoInj_array[handle].enable = false;
 8004582:	f04f 0e00 	mov.w	lr, #0
 8004586:	f805 e001 	strb.w	lr, [r5, r1]
      RCM_NoInj_array[handle].prev = handle;
 800458a:	f8ac 4004 	strh.w	r4, [ip, #4]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 800458e:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004590:	f021 010f 	bic.w	r1, r1, #15
 8004594:	6311      	str	r1, [r2, #48]	; 0x30
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8004596:	f890 c004 	ldrb.w	ip, [r0, #4]
 800459a:	f1bc 0f09 	cmp.w	ip, #9
 800459e:	d84f      	bhi.n	8004640 <RCM_RegisterRegConv+0x194>
 80045a0:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 80045a4:	ea4f 618c 	mov.w	r1, ip, lsl #26
 80045a8:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 80045ac:	2401      	movs	r4, #1
 80045ae:	fa04 f40c 	lsl.w	r4, r4, ip
 80045b2:	4321      	orrs	r1, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80045b4:	0dcc      	lsrs	r4, r1, #23
 80045b6:	f004 0404 	and.w	r4, r4, #4
 80045ba:	f102 0514 	add.w	r5, r2, #20
  MODIFY_REG(*preg,
 80045be:	6886      	ldr	r6, [r0, #8]
 80045c0:	592a      	ldr	r2, [r5, r4]
 80045c2:	f3c1 5104 	ubfx	r1, r1, #20, #5
 80045c6:	f04f 0e07 	mov.w	lr, #7
 80045ca:	fa06 fc01 	lsl.w	ip, r6, r1
 80045ce:	fa0e f101 	lsl.w	r1, lr, r1
 80045d2:	ea22 0101 	bic.w	r1, r2, r1
 80045d6:	ea41 010c 	orr.w	r1, r1, ip
 80045da:	5129      	str	r1, [r5, r4]
  regConv->convHandle = handle;
 80045dc:	7303      	strb	r3, [r0, #12]
}
 80045de:	bd70      	pop	{r4, r5, r6, pc}
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 80045e0:	684a      	ldr	r2, [r1, #4]
 80045e2:	2a00      	cmp	r2, #0
 80045e4:	d04b      	beq.n	800467e <RCM_RegisterRegConv+0x1d2>
 80045e6:	f890 c004 	ldrb.w	ip, [r0, #4]
        if ((RCM_handle_array [i]->channel == regConv->channel)
 80045ea:	7914      	ldrb	r4, [r2, #4]
 80045ec:	4564      	cmp	r4, ip
 80045ee:	f47f af72 	bne.w	80044d6 <RCM_RegisterRegConv+0x2a>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80045f2:	6814      	ldr	r4, [r2, #0]
 80045f4:	6802      	ldr	r2, [r0, #0]
 80045f6:	4294      	cmp	r4, r2
 80045f8:	f47f af6d 	bne.w	80044d6 <RCM_RegisterRegConv+0x2a>
      i++;
 80045fc:	2301      	movs	r3, #1
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 80045fe:	f240 1401 	movw	r4, #257	; 0x101
 8004602:	e78c      	b.n	800451e <RCM_RegisterRegConv+0x72>
 8004604:	6824      	ldr	r4, [r4, #0]
 8004606:	6802      	ldr	r2, [r0, #0]
 8004608:	4294      	cmp	r4, r2
 800460a:	f47f af6c 	bne.w	80044e6 <RCM_RegisterRegConv+0x3a>
      i++;
 800460e:	2302      	movs	r3, #2
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004610:	f240 2402 	movw	r4, #514	; 0x202
 8004614:	e783      	b.n	800451e <RCM_RegisterRegConv+0x72>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8004616:	688c      	ldr	r4, [r1, #8]
      i++;
 8004618:	2301      	movs	r3, #1
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800461a:	2c00      	cmp	r4, #0
 800461c:	f47f af5f 	bne.w	80044de <RCM_RegisterRegConv+0x32>
 8004620:	68ca      	ldr	r2, [r1, #12]
 8004622:	2a00      	cmp	r2, #0
 8004624:	d03b      	beq.n	800469e <RCM_RegisterRegConv+0x1f2>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004626:	7915      	ldrb	r5, [r2, #4]
 8004628:	7904      	ldrb	r4, [r0, #4]
 800462a:	42a5      	cmp	r5, r4
 800462c:	d137      	bne.n	800469e <RCM_RegisterRegConv+0x1f2>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800462e:	6814      	ldr	r4, [r2, #0]
 8004630:	6802      	ldr	r2, [r0, #0]
 8004632:	4294      	cmp	r4, r2
 8004634:	f47f af5f 	bne.w	80044f6 <RCM_RegisterRegConv+0x4a>
      i++;
 8004638:	2303      	movs	r3, #3
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800463a:	f240 3403 	movw	r4, #771	; 0x303
 800463e:	e76e      	b.n	800451e <RCM_RegisterRegConv+0x72>
      LL_ADC_SetChannelSamplingTime(regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel),
 8004640:	f06f 011d 	mvn.w	r1, #29
 8004644:	2403      	movs	r4, #3
 8004646:	fb14 140c 	smlabb	r4, r4, ip, r1
 800464a:	2101      	movs	r1, #1
 800464c:	fa01 f10c 	lsl.w	r1, r1, ip
 8004650:	ea41 5104 	orr.w	r1, r1, r4, lsl #20
 8004654:	ea41 618c 	orr.w	r1, r1, ip, lsl #26
 8004658:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800465c:	e7aa      	b.n	80045b4 <RCM_RegisterRegConv+0x108>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800465e:	2b04      	cmp	r3, #4
 8004660:	d913      	bls.n	800468a <RCM_RegisterRegConv+0x1de>
 8004662:	68cb      	ldr	r3, [r1, #12]
 8004664:	b113      	cbz	r3, 800466c <RCM_RegisterRegConv+0x1c0>
        if ((RCM_handle_array [i]->channel == regConv->channel)
 8004666:	791a      	ldrb	r2, [r3, #4]
 8004668:	4562      	cmp	r2, ip
 800466a:	d010      	beq.n	800468e <RCM_RegisterRegConv+0x1e2>
 800466c:	6802      	ldr	r2, [r0, #0]
 800466e:	e7ce      	b.n	800460e <RCM_RegisterRegConv+0x162>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 8004670:	2b04      	cmp	r3, #4
 8004672:	d914      	bls.n	800469e <RCM_RegisterRegConv+0x1f2>
 8004674:	6802      	ldr	r2, [r0, #0]
      i++;
 8004676:	2303      	movs	r3, #3
 8004678:	f240 3403 	movw	r4, #771	; 0x303
 800467c:	e74f      	b.n	800451e <RCM_RegisterRegConv+0x72>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800467e:	688c      	ldr	r4, [r1, #8]
 8004680:	b11c      	cbz	r4, 800468a <RCM_RegisterRegConv+0x1de>
 8004682:	f890 c004 	ldrb.w	ip, [r0, #4]
    uint8_t i = 0;
 8004686:	4613      	mov	r3, r2
 8004688:	e729      	b.n	80044de <RCM_RegisterRegConv+0x32>
      if ((0 == RCM_handle_array [i]) && (handle > RCM_MAX_CONV))
 800468a:	4623      	mov	r3, r4
 800468c:	e7c8      	b.n	8004620 <RCM_RegisterRegConv+0x174>
         && (RCM_handle_array [i]->regADC == regConv->regADC))
 800468e:	681b      	ldr	r3, [r3, #0]
 8004690:	6802      	ldr	r2, [r0, #0]
 8004692:	4293      	cmp	r3, r2
 8004694:	d0d0      	beq.n	8004638 <RCM_RegisterRegConv+0x18c>
 8004696:	f240 2402 	movw	r4, #514	; 0x202
      i++;
 800469a:	2302      	movs	r3, #2
 800469c:	e73f      	b.n	800451e <RCM_RegisterRegConv+0x72>
    while (i < RCM_MAX_CONV)
 800469e:	f04f 0400 	mov.w	r4, #0
 80046a2:	f363 0407 	bfi	r4, r3, #0, #8
 80046a6:	f363 240f 	bfi	r4, r3, #8, #8
 80046aa:	6802      	ldr	r2, [r0, #0]
    if (handle < RCM_MAX_CONV)
 80046ac:	e737      	b.n	800451e <RCM_RegisterRegConv+0x72>
 80046ae:	bf00      	nop
 80046b0:	20002e10 	.word	0x20002e10
 80046b4:	20002dcc 	.word	0x20002dcc
 80046b8:	7fffffc0 	.word	0x7fffffc0
 80046bc:	20002dec 	.word	0x20002dec

080046c0 <RCM_ExecRegularConv>:
 * Otherwise, the latest stored conversion result will be returned.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
uint16_t RCM_ExecRegularConv (RegConv_t *regConv)
{
 80046c0:	b510      	push	{r4, lr}
  uint16_t retVal;
  uint8_t handle = regConv->convHandle;
 80046c2:	7b03      	ldrb	r3, [r0, #12]
  uint8_t formerNext;
  uint8_t i=0;
  uint8_t LastEnable = RCM_MAX_CONV;

  if (false == RCM_NoInj_array [handle].enable)
 80046c4:	4a5e      	ldr	r2, [pc, #376]	; (8004840 <RCM_ExecRegularConv+0x180>)
 80046c6:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80046ca:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80046ce:	f812 1011 	ldrb.w	r1, [r2, r1, lsl #1]
 80046d2:	2900      	cmp	r1, #0
 80046d4:	d13c      	bne.n	8004750 <RCM_ExecRegularConv+0x90>
  {
    /* Find position in the list */
    while (i < RCM_MAX_CONV)
    {
      if (true == RCM_NoInj_array [i].enable)
 80046d6:	7810      	ldrb	r0, [r2, #0]
 80046d8:	b9a8      	cbnz	r0, 8004706 <RCM_ExecRegularConv+0x46>
  uint8_t LastEnable = RCM_MAX_CONV;
 80046da:	2104      	movs	r1, #4
      if (true == RCM_NoInj_array [i].enable)
 80046dc:	7990      	ldrb	r0, [r2, #6]
 80046de:	2800      	cmp	r0, #0
 80046e0:	d07f      	beq.n	80047e2 <RCM_ExecRegularConv+0x122>
      {
        if (RCM_NoInj_array[i].next > handle)
 80046e2:	7ad0      	ldrb	r0, [r2, #11]
 80046e4:	4283      	cmp	r3, r0
 80046e6:	f0c0 809b 	bcc.w	8004820 <RCM_ExecRegularConv+0x160>
      if (true == RCM_NoInj_array [i].enable)
 80046ea:	7b11      	ldrb	r1, [r2, #12]
 80046ec:	2900      	cmp	r1, #0
 80046ee:	f000 809a 	beq.w	8004826 <RCM_ExecRegularConv+0x166>
        if (RCM_NoInj_array[i].next > handle)
 80046f2:	7c50      	ldrb	r0, [r2, #17]
 80046f4:	4283      	cmp	r3, r0
 80046f6:	f0c0 80a0 	bcc.w	800483a <RCM_ExecRegularConv+0x17a>
      if (true == RCM_NoInj_array [i].enable)
 80046fa:	7c91      	ldrb	r1, [r2, #18]
 80046fc:	2900      	cmp	r1, #0
 80046fe:	f040 8096 	bne.w	800482e <RCM_ExecRegularConv+0x16e>
      }
      else
      {
        /* Nothing to do */
      }
      i++;
 8004702:	2102      	movs	r1, #2
 8004704:	e074      	b.n	80047f0 <RCM_ExecRegularConv+0x130>
        if (RCM_NoInj_array[i].next > handle)
 8004706:	7950      	ldrb	r0, [r2, #5]
 8004708:	4298      	cmp	r0, r3
 800470a:	d9e7      	bls.n	80046dc <RCM_ExecRegularConv+0x1c>
      if (true == RCM_NoInj_array [i].enable)
 800470c:	468e      	mov	lr, r1
          RCM_NoInj_array[handle].next = formerNext;
 800470e:	eb0c 0403 	add.w	r4, ip, r3
 8004712:	eb02 0444 	add.w	r4, r2, r4, lsl #1
          RCM_NoInj_array[i].next = handle;
 8004716:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
          RCM_NoInj_array[handle].prev = i;
 800471a:	7121      	strb	r1, [r4, #4]
          RCM_NoInj_array[handle].next = formerNext;
 800471c:	7160      	strb	r0, [r4, #5]
      }
    }
    /* The handle is now linked with others, we can set the enable flag */
    RCM_NoInj_array[handle].enable = true;
    RCM_NoInj_array[handle].status = notvalid;
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800471e:	4c49      	ldr	r4, [pc, #292]	; (8004844 <RCM_ExecRegularConv+0x184>)
          RCM_NoInj_array[formerNext].prev = handle;
 8004720:	eb00 0040 	add.w	r0, r0, r0, lsl #1
          RCM_NoInj_array[i].next = handle;
 8004724:	eb02 0e4e 	add.w	lr, r2, lr, lsl #1
          RCM_NoInj_array[formerNext].prev = handle;
 8004728:	eb02 0040 	add.w	r0, r2, r0, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800472c:	7821      	ldrb	r1, [r4, #0]
          RCM_NoInj_array[i].next = handle;
 800472e:	f88e 3005 	strb.w	r3, [lr, #5]
          RCM_NoInj_array[formerNext].prev = handle;
 8004732:	7103      	strb	r3, [r0, #4]
    RCM_NoInj_array[handle].enable = true;
 8004734:	eb0c 0003 	add.w	r0, ip, r3
 8004738:	f04f 0e01 	mov.w	lr, #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800473c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    RCM_NoInj_array[handle].enable = true;
 8004740:	f822 e010 	strh.w	lr, [r2, r0, lsl #1]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004744:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8004748:	7849      	ldrb	r1, [r1, #1]
 800474a:	4571      	cmp	r1, lr
    {/* Select the new conversion to be the next scheduled only if a conversion is not ongoing */
      RCM_currentHandle = handle;
 800474c:	bf18      	it	ne
 800474e:	7023      	strbne	r3, [r4, #0]
  }
  else
  {
    /* Nothing to do the current handle is already scheduled */
  }
  if (false == PWM_Handle_M1.ADCRegularLocked)
 8004750:	493d      	ldr	r1, [pc, #244]	; (8004848 <RCM_ExecRegularConv+0x188>)
 8004752:	f891 10a0 	ldrb.w	r1, [r1, #160]	; 0xa0
 8004756:	2900      	cmp	r1, #0
 8004758:	d133      	bne.n	80047c2 <RCM_ExecRegularConv+0x102>
  /* The ADC is free to be used asynchronously */
  {
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 800475a:	493c      	ldr	r1, [pc, #240]	; (800484c <RCM_ExecRegularConv+0x18c>)
 800475c:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 8004760:	790c      	ldrb	r4, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8004762:	6808      	ldr	r0, [r1, #0]
 8004764:	2c09      	cmp	r4, #9
 8004766:	d931      	bls.n	80047cc <RCM_ExecRegularConv+0x10c>
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 8004768:	f06f 011d 	mvn.w	r1, #29
 800476c:	f04f 0e03 	mov.w	lr, #3
 8004770:	fb1e 1e04 	smlabb	lr, lr, r4, r1
 8004774:	2101      	movs	r1, #1
 8004776:	40a1      	lsls	r1, r4
 8004778:	ea41 510e 	orr.w	r1, r1, lr, lsl #20
 800477c:	ea41 6184 	orr.w	r1, r1, r4, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 8004780:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  MODIFY_REG(*preg,
 8004784:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004786:	0d09      	lsrs	r1, r1, #20
 8004788:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
 800478c:	f424 64f8 	bic.w	r4, r4, #1984	; 0x7c0
 8004790:	4321      	orrs	r1, r4
 8004792:	6301      	str	r1, [r0, #48]	; 0x30
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 8004794:	6c01      	ldr	r1, [r0, #64]	; 0x40
  MODIFY_REG(ADCx->CR,
 8004796:	6881      	ldr	r1, [r0, #8]
 8004798:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800479c:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80047a0:	f041 0104 	orr.w	r1, r1, #4
 80047a4:	6081      	str	r1, [r0, #8]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 80047a6:	6801      	ldr	r1, [r0, #0]
 80047a8:	0749      	lsls	r1, r1, #29
 80047aa:	d5fc      	bpl.n	80047a6 <RCM_ExecRegularConv+0xe6>
    {
      /* Nothing to do */
    }

    /* Read the "Regular" conversion (Not related to current sampling) */
    RCM_NoInj_array[handle].value = LL_ADC_REG_ReadConversionData12(RCM_handle_array[handle]->regADC);
 80047ac:	eb0c 0103 	add.w	r1, ip, r3
 80047b0:	eb02 0141 	add.w	r1, r2, r1, lsl #1
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 80047b4:	6c00      	ldr	r0, [r0, #64]	; 0x40
 80047b6:	8048      	strh	r0, [r1, #2]
    RCM_currentHandle = RCM_NoInj_array[handle].next;
 80047b8:	4822      	ldr	r0, [pc, #136]	; (8004844 <RCM_ExecRegularConv+0x184>)
 80047ba:	794c      	ldrb	r4, [r1, #5]
 80047bc:	7004      	strb	r4, [r0, #0]
    RCM_NoInj_array[handle].status = valid;
 80047be:	2002      	movs	r0, #2
 80047c0:	7048      	strb	r0, [r1, #1]
  }
  else
  {
    /* Nothing to do */
  }
  retVal = RCM_NoInj_array[handle].value;
 80047c2:	449c      	add	ip, r3
 80047c4:	eb02 024c 	add.w	r2, r2, ip, lsl #1
  return (retVal);
}
 80047c8:	8850      	ldrh	r0, [r2, #2]
 80047ca:	bd10      	pop	{r4, pc}
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80047cc:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 80047d0:	06a1      	lsls	r1, r4, #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80047d2:	ea41 510e 	orr.w	r1, r1, lr, lsl #20
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[handle]->channel));
 80047d6:	f04f 0e01 	mov.w	lr, #1
 80047da:	fa0e f404 	lsl.w	r4, lr, r4
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[handle]->regADC,
 80047de:	4321      	orrs	r1, r4
 80047e0:	e7d0      	b.n	8004784 <RCM_ExecRegularConv+0xc4>
      if (true == RCM_NoInj_array [i].enable)
 80047e2:	7b10      	ldrb	r0, [r2, #12]
 80047e4:	2800      	cmp	r0, #0
 80047e6:	d184      	bne.n	80046f2 <RCM_ExecRegularConv+0x32>
 80047e8:	7c90      	ldrb	r0, [r2, #18]
 80047ea:	bb00      	cbnz	r0, 800482e <RCM_ExecRegularConv+0x16e>
       if (LastEnable != RCM_MAX_CONV )
 80047ec:	2904      	cmp	r1, #4
 80047ee:	d013      	beq.n	8004818 <RCM_ExecRegularConv+0x158>
         formerNext = RCM_NoInj_array[LastEnable].next;
 80047f0:	eb01 0041 	add.w	r0, r1, r1, lsl #1
         RCM_NoInj_array[handle].next = formerNext;
 80047f4:	eb0c 0403 	add.w	r4, ip, r3
 80047f8:	eb02 0444 	add.w	r4, r2, r4, lsl #1
         formerNext = RCM_NoInj_array[LastEnable].next;
 80047fc:	eb02 0040 	add.w	r0, r2, r0, lsl #1
         RCM_NoInj_array[handle].prev = LastEnable;
 8004800:	7121      	strb	r1, [r4, #4]
         formerNext = RCM_NoInj_array[LastEnable].next;
 8004802:	7941      	ldrb	r1, [r0, #5]
         RCM_NoInj_array[handle].next = formerNext;
 8004804:	7161      	strb	r1, [r4, #5]
         RCM_NoInj_array[formerNext].prev = handle;
 8004806:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800480a:	eb02 0141 	add.w	r1, r2, r1, lsl #1
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 800480e:	4c0d      	ldr	r4, [pc, #52]	; (8004844 <RCM_ExecRegularConv+0x184>)
         RCM_NoInj_array[formerNext].prev = handle;
 8004810:	710b      	strb	r3, [r1, #4]
         RCM_NoInj_array[LastEnable].next = handle;
 8004812:	7143      	strb	r3, [r0, #5]
    if (RCM_NoInj_array[RCM_currentHandle].status != ongoing)
 8004814:	7821      	ldrb	r1, [r4, #0]
 8004816:	e78d      	b.n	8004734 <RCM_ExecRegularConv+0x74>
         RCM_currentHandle = handle;
 8004818:	4c0a      	ldr	r4, [pc, #40]	; (8004844 <RCM_ExecRegularConv+0x184>)
 800481a:	4619      	mov	r1, r3
 800481c:	7023      	strb	r3, [r4, #0]
    while (i < RCM_MAX_CONV)
 800481e:	e789      	b.n	8004734 <RCM_ExecRegularConv+0x74>
      i++;
 8004820:	2101      	movs	r1, #1
      if (true == RCM_NoInj_array [i].enable)
 8004822:	468e      	mov	lr, r1
 8004824:	e773      	b.n	800470e <RCM_ExecRegularConv+0x4e>
 8004826:	7c91      	ldrb	r1, [r2, #18]
 8004828:	b909      	cbnz	r1, 800482e <RCM_ExecRegularConv+0x16e>
      i++;
 800482a:	2101      	movs	r1, #1
 800482c:	e7e0      	b.n	80047f0 <RCM_ExecRegularConv+0x130>
        if (RCM_NoInj_array[i].next > handle)
 800482e:	7dd0      	ldrb	r0, [r2, #23]
 8004830:	4298      	cmp	r0, r3
      i++;
 8004832:	f04f 0103 	mov.w	r1, #3
        if (RCM_NoInj_array[i].next > handle)
 8004836:	d9db      	bls.n	80047f0 <RCM_ExecRegularConv+0x130>
 8004838:	e768      	b.n	800470c <RCM_ExecRegularConv+0x4c>
      i++;
 800483a:	2102      	movs	r1, #2
 800483c:	e766      	b.n	800470c <RCM_ExecRegularConv+0x4c>
 800483e:	bf00      	nop
 8004840:	20002dec 	.word	0x20002dec
 8004844:	20002e0c 	.word	0x20002e0c
 8004848:	20000154 	.word	0x20000154
 800484c:	20002e10 	.word	0x20002e10

08004850 <RCM_ExecUserConv>:
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecUserConv()
{
  uint8_t handle;
  if (RCM_UserConvHandle != NULL)
 8004850:	4b14      	ldr	r3, [pc, #80]	; (80048a4 <RCM_ExecUserConv+0x54>)
{
 8004852:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCM_UserConvHandle != NULL)
 8004856:	681c      	ldr	r4, [r3, #0]
 8004858:	b124      	cbz	r4, 8004864 <RCM_ExecUserConv+0x14>
  {
    handle = RCM_UserConvHandle->convHandle;
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 800485a:	4d13      	ldr	r5, [pc, #76]	; (80048a8 <RCM_ExecUserConv+0x58>)
    handle = RCM_UserConvHandle->convHandle;
 800485c:	7b26      	ldrb	r6, [r4, #12]
    if (RCM_USERCONV_REQUESTED == RCM_UserConvState)
 800485e:	782b      	ldrb	r3, [r5, #0]
 8004860:	2b01      	cmp	r3, #1
 8004862:	d001      	beq.n	8004868 <RCM_ExecUserConv+0x18>
  }
  else
  {
     /* Nothing to do */
  }
}
 8004864:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 8004868:	4620      	mov	r0, r4
 800486a:	f7ff ff29 	bl	80046c0 <RCM_ExecRegularConv>
 800486e:	4b0f      	ldr	r3, [pc, #60]	; (80048ac <RCM_ExecUserConv+0x5c>)
 8004870:	8018      	strh	r0, [r3, #0]
      if (RCM_NoInj_array [handle].status != notvalid)
 8004872:	4b0f      	ldr	r3, [pc, #60]	; (80048b0 <RCM_ExecUserConv+0x60>)
 8004874:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 8004878:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      RCM_UserConvValue = RCM_ExecRegularConv(RCM_UserConvHandle);
 800487c:	4601      	mov	r1, r0
      if (RCM_NoInj_array [handle].status != notvalid)
 800487e:	785b      	ldrb	r3, [r3, #1]
 8004880:	b10b      	cbz	r3, 8004886 <RCM_ExecUserConv+0x36>
        RCM_UserConvState = RCM_USERCONV_EOC;
 8004882:	2302      	movs	r3, #2
 8004884:	702b      	strb	r3, [r5, #0]
      if (RCM_CB_array[handle].cb != NULL)
 8004886:	4b0b      	ldr	r3, [pc, #44]	; (80048b4 <RCM_ExecUserConv+0x64>)
 8004888:	f853 7036 	ldr.w	r7, [r3, r6, lsl #3]
 800488c:	2f00      	cmp	r7, #0
 800488e:	d0e9      	beq.n	8004864 <RCM_ExecUserConv+0x14>
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 8004890:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8004894:	4620      	mov	r0, r4
 8004896:	685a      	ldr	r2, [r3, #4]
        RCM_UserConvState = RCM_USERCONV_IDLE;
 8004898:	2300      	movs	r3, #0
 800489a:	702b      	strb	r3, [r5, #0]
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 800489c:	463b      	mov	r3, r7
}
 800489e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        RCM_CB_array[handle].cb(RCM_UserConvHandle, RCM_UserConvValue,
 80048a2:	4718      	bx	r3
 80048a4:	20002e04 	.word	0x20002e04
 80048a8:	20002e08 	.word	0x20002e08
 80048ac:	20002e0a 	.word	0x20002e0a
 80048b0:	20002dec 	.word	0x20002dec
 80048b4:	20002dcc 	.word	0x20002dcc

080048b8 <RCM_ExecNextConv>:
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ExecNextConv(void)
{
  if (true == RCM_NoInj_array [RCM_currentHandle].enable)
 80048b8:	4b24      	ldr	r3, [pc, #144]	; (800494c <RCM_ExecNextConv+0x94>)
 80048ba:	4825      	ldr	r0, [pc, #148]	; (8004950 <RCM_ExecNextConv+0x98>)
 80048bc:	781a      	ldrb	r2, [r3, #0]
 80048be:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80048c2:	f810 3013 	ldrb.w	r3, [r0, r3, lsl #1]
 80048c6:	b3a3      	cbz	r3, 8004932 <RCM_ExecNextConv+0x7a>
    /* When this function is called, the ADC conversions triggered by External
       event for current reading has been completed.
       ADC is therefore ready to be started because already stopped */

    /* Clear EOC */
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80048c8:	4b22      	ldr	r3, [pc, #136]	; (8004954 <RCM_ExecNextConv+0x9c>)
{
 80048ca:	b510      	push	{r4, lr}
    LL_ADC_ClearFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 80048cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80048d0:	6819      	ldr	r1, [r3, #0]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 80048d2:	2404      	movs	r4, #4
 80048d4:	600c      	str	r4, [r1, #0]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
                                 LL_ADC_REG_RANK_1,
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 80048d6:	f893 c004 	ldrb.w	ip, [r3, #4]
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 80048da:	f1bc 0f09 	cmp.w	ip, #9
 80048de:	ea4f 0e42 	mov.w	lr, r2, lsl #1
 80048e2:	d927      	bls.n	8004934 <RCM_ExecNextConv+0x7c>
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 80048e4:	f06f 031d 	mvn.w	r3, #29
 80048e8:	2403      	movs	r4, #3
 80048ea:	fb14 340c 	smlabb	r4, r4, ip, r3
 80048ee:	2301      	movs	r3, #1
 80048f0:	fa03 f30c 	lsl.w	r3, r3, ip
 80048f4:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
 80048f8:	ea43 638c 	orr.w	r3, r3, ip, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 80048fc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000

    (void)LL_ADC_REG_ReadConversionData12(RCM_handle_array[RCM_currentHandle]->regADC);

    /* Start ADC for regular conversion */
    LL_ADC_REG_StartConversion(RCM_handle_array[RCM_currentHandle]->regADC);
    RCM_NoInj_array[RCM_currentHandle].status = ongoing;
 8004900:	4496      	add	lr, r2
  MODIFY_REG(*preg,
 8004902:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8004904:	0d1b      	lsrs	r3, r3, #20
 8004906:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 800490a:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 800490e:	4313      	orrs	r3, r2
 8004910:	630b      	str	r3, [r1, #48]	; 0x30
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 8004912:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  MODIFY_REG(ADCx->CR,
 8004914:	688b      	ldr	r3, [r1, #8]
 8004916:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800491a:	eb00 004e 	add.w	r0, r0, lr, lsl #1
 800491e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8004922:	f04f 0c01 	mov.w	ip, #1
 8004926:	f043 0304 	orr.w	r3, r3, #4
 800492a:	608b      	str	r3, [r1, #8]
 800492c:	f880 c001 	strb.w	ip, [r0, #1]
  }
  else
  {
    /* Nothing to do, conversion not enabled have already notvalid status */
  }
}
 8004930:	bd10      	pop	{r4, pc}
 8004932:	4770      	bx	lr
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 8004934:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8004938:	ea4f 638c 	mov.w	r3, ip, lsl #26
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 800493c:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
                                 __LL_ADC_DECIMAL_NB_TO_CHANNEL(RCM_handle_array[RCM_currentHandle]->channel));
 8004940:	2401      	movs	r4, #1
 8004942:	fa04 f40c 	lsl.w	r4, r4, ip
    LL_ADC_REG_SetSequencerRanks(RCM_handle_array[RCM_currentHandle]->regADC,
 8004946:	4323      	orrs	r3, r4
 8004948:	e7da      	b.n	8004900 <RCM_ExecNextConv+0x48>
 800494a:	bf00      	nop
 800494c:	20002e0c 	.word	0x20002e0c
 8004950:	20002dec 	.word	0x20002dec
 8004954:	20002e10 	.word	0x20002e10

08004958 <RCM_ReadOngoingConv>:
 * and user conversion.
 *
 * NOTE: This function is not part of the public API and users should not call it.
 */
void RCM_ReadOngoingConv(void)
{
 8004958:	b510      	push	{r4, lr}
  uint32_t result;
  RCM_status_t status;

  status = RCM_NoInj_array[RCM_currentHandle].status;
 800495a:	4814      	ldr	r0, [pc, #80]	; (80049ac <RCM_ReadOngoingConv+0x54>)
  result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 800495c:	4a14      	ldr	r2, [pc, #80]	; (80049b0 <RCM_ReadOngoingConv+0x58>)
  status = RCM_NoInj_array[RCM_currentHandle].status;
 800495e:	7803      	ldrb	r3, [r0, #0]
  result = LL_ADC_IsActiveFlag_EOC(RCM_handle_array[RCM_currentHandle]->regADC);
 8004960:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004964:	6814      	ldr	r4, [r2, #0]
  return ((READ_BIT(ADCx->ISR, ADC_ISR_EOC) == (ADC_ISR_EOC)) ? 1UL : 0UL);
 8004966:	6822      	ldr	r2, [r4, #0]
 8004968:	f012 0f04 	tst.w	r2, #4
  status = RCM_NoInj_array[RCM_currentHandle].status;
 800496c:	ea4f 0143 	mov.w	r1, r3, lsl #1
 8004970:	4a10      	ldr	r2, [pc, #64]	; (80049b4 <RCM_ReadOngoingConv+0x5c>)
 8004972:	d008      	beq.n	8004986 <RCM_ReadOngoingConv+0x2e>
 8004974:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 8004978:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
  if (( valid == status ) || ( notvalid == status ) || ( 0U == result ))
 800497c:	f89c e001 	ldrb.w	lr, [ip, #1]
 8004980:	f01e 0ffd 	tst.w	lr, #253	; 0xfd
 8004984:	d105      	bne.n	8004992 <RCM_ReadOngoingConv+0x3a>
    RCM_NoInj_array[RCM_currentHandle].status = valid;
    /* Restore back DMA configuration */
  }

  /* Prepare next conversion */
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 8004986:	440b      	add	r3, r1
 8004988:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 800498c:	7953      	ldrb	r3, [r2, #5]
 800498e:	7003      	strb	r3, [r0, #0]
}
 8004990:	bd10      	pop	{r4, pc}
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 8004992:	440b      	add	r3, r1
 8004994:	eb02 0243 	add.w	r2, r2, r3, lsl #1
  return (uint16_t)(READ_BIT(ADCx->DR, ADC_DR_RDATA));
 8004998:	6c24      	ldr	r4, [r4, #64]	; 0x40
 800499a:	7953      	ldrb	r3, [r2, #5]
 800499c:	f8ac 4002 	strh.w	r4, [ip, #2]
    RCM_NoInj_array[RCM_currentHandle].status = valid;
 80049a0:	2402      	movs	r4, #2
 80049a2:	f88c 4001 	strb.w	r4, [ip, #1]
  RCM_currentHandle = RCM_NoInj_array [RCM_currentHandle].next;
 80049a6:	7003      	strb	r3, [r0, #0]
}
 80049a8:	bd10      	pop	{r4, pc}
 80049aa:	bf00      	nop
 80049ac:	20002e0c 	.word	0x20002e0c
 80049b0:	20002e10 	.word	0x20002e10
 80049b4:	20002dec 	.word	0x20002dec

080049b8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80049b8:	4b0e      	ldr	r3, [pc, #56]	; (80049f4 <HAL_MspInit+0x3c>)
{
 80049ba:	b500      	push	{lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80049bc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80049be:	f042 0201 	orr.w	r2, r2, #1
 80049c2:	661a      	str	r2, [r3, #96]	; 0x60
 80049c4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 80049c6:	b083      	sub	sp, #12
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80049c8:	f002 0201 	and.w	r2, r2, #1
 80049cc:	9200      	str	r2, [sp, #0]
 80049ce:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80049d0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80049d2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80049d6:	659a      	str	r2, [r3, #88]	; 0x58
 80049d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80049da:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80049de:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 80049e0:	2004      	movs	r0, #4
  __HAL_RCC_PWR_CLK_ENABLE();
 80049e2:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 80049e4:	f001 fcac 	bl	8006340 <HAL_NVIC_SetPriorityGrouping>
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80049e8:	b003      	add	sp, #12
 80049ea:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_PWREx_DisableUCPDDeadBattery();
 80049ee:	f001 bf9d 	b.w	800692c <HAL_PWREx_DisableUCPDDeadBattery>
 80049f2:	bf00      	nop
 80049f4:	40021000 	.word	0x40021000

080049f8 <TIM5_IRQHandler>:
  * @brief This function handles TIM5 global interrupt.
  */
void TIM5_IRQHandler(void)
{
  /* USER CODE BEGIN TIM5_IRQn 0 */
  data_flag=1;
 80049f8:	4b02      	ldr	r3, [pc, #8]	; (8004a04 <TIM5_IRQHandler+0xc>)
  /* USER CODE END TIM5_IRQn 0 */
  HAL_TIM_IRQHandler(&htim5);
 80049fa:	4803      	ldr	r0, [pc, #12]	; (8004a08 <TIM5_IRQHandler+0x10>)
  data_flag=1;
 80049fc:	2201      	movs	r2, #1
 80049fe:	701a      	strb	r2, [r3, #0]
  HAL_TIM_IRQHandler(&htim5);
 8004a00:	f003 b9ca 	b.w	8007d98 <HAL_TIM_IRQHandler>
 8004a04:	20001a6c 	.word	0x20001a6c
 8004a08:	20002f08 	.word	0x20002f08

08004a0c <ADC1_2_IRQHandler>:
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 8004a0c:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8004a10:	2240      	movs	r2, #64	; 0x40
 8004a12:	601a      	str	r2, [r3, #0]
  /* USER CODE END ADC1_2_IRQn 0 */

    /* Clear Flags M1 */
    LL_ADC_ClearFlag_JEOS(ADC1);

  (void)TSK_HighFrequencyTask();
 8004a14:	f7fd bdfe 	b.w	8002614 <TSK_HighFrequencyTask>

08004a18 <TIM1_UP_TIM16_IRQHandler>:
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8004a18:	4b03      	ldr	r3, [pc, #12]	; (8004a28 <TIM1_UP_TIM16_IRQHandler+0x10>)
 /* USER CODE BEGIN TIMx_UP_M1_IRQn 0 */

 /* USER CODE END  TIMx_UP_M1_IRQn 0 */

  LL_TIM_ClearFlag_UPDATE(TIM1);
  (void)R3_1_TIMx_UP_IRQHandler(&PWM_Handle_M1);
 8004a1a:	4804      	ldr	r0, [pc, #16]	; (8004a2c <TIM1_UP_TIM16_IRQHandler+0x14>)
 8004a1c:	f06f 0201 	mvn.w	r2, #1
 8004a20:	611a      	str	r2, [r3, #16]
 8004a22:	f005 ba1f 	b.w	8009e64 <R3_1_TIMx_UP_IRQHandler>
 8004a26:	bf00      	nop
 8004a28:	40012c00 	.word	0x40012c00
 8004a2c:	20000154 	.word	0x20000154

08004a30 <TIM1_BRK_TIM15_IRQHandler>:
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF)) ? 1UL : 0UL);
 8004a30:	490c      	ldr	r1, [pc, #48]	; (8004a64 <TIM1_BRK_TIM15_IRQHandler+0x34>)

 /* USER CODE END  TIMx_UP_M1_IRQn 1 */
}

void TIMx_BRK_M1_IRQHandler(void)
{
 8004a32:	b508      	push	{r3, lr}
 8004a34:	690b      	ldr	r3, [r1, #16]
 8004a36:	061a      	lsls	r2, r3, #24
 8004a38:	d505      	bpl.n	8004a46 <TIM1_BRK_TIM15_IRQHandler+0x16>
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8004a3a:	f06f 0380 	mvn.w	r3, #128	; 0x80
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 8004a3e:	480a      	ldr	r0, [pc, #40]	; (8004a68 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 8004a40:	610b      	str	r3, [r1, #16]
 8004a42:	f7fe fcbb 	bl	80033bc <PWMC_OVP_Handler>
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK2(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8004a46:	4907      	ldr	r1, [pc, #28]	; (8004a64 <TIM1_BRK_TIM15_IRQHandler+0x34>)
 8004a48:	690b      	ldr	r3, [r1, #16]
 8004a4a:	05db      	lsls	r3, r3, #23
 8004a4c:	d505      	bpl.n	8004a5a <TIM1_BRK_TIM15_IRQHandler+0x2a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8004a4e:	f46f 7380 	mvn.w	r3, #256	; 0x100
    /* Nothing to do */
  }
  else
  {
    LL_TIM_ClearFlag_BRK2(TIM1);
    PWMC_OVP_Handler(&PWM_Handle_M1._Super, TIM1);
 8004a52:	4805      	ldr	r0, [pc, #20]	; (8004a68 <TIM1_BRK_TIM15_IRQHandler+0x38>)
 8004a54:	610b      	str	r3, [r1, #16]
 8004a56:	f7fe fcb1 	bl	80033bc <PWMC_OVP_Handler>
  MC_Scheduler();

  /* USER CODE BEGIN TIMx_BRK_M1_IRQn 1 */

  /* USER CODE END TIMx_BRK_M1_IRQn 1 */
}
 8004a5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MC_Scheduler();
 8004a5e:	f7fd bd93 	b.w	8002588 <MC_Scheduler>
 8004a62:	bf00      	nop
 8004a64:	40012c00 	.word	0x40012c00
 8004a68:	20000154 	.word	0x20000154

08004a6c <TIM2_IRQHandler>:
  /* USER CODE BEGIN SPD_TIM_M1_IRQn 0 */

  /* USER CODE END SPD_TIM_M1_IRQn 0 */

 /* Encoder Timer UPDATE IT is dynamicaly enabled/disabled, checking enable state is required */
  if (LL_TIM_IsEnabledIT_UPDATE (ENCODER_M1.TIMx) != 0U)
 8004a6c:	4806      	ldr	r0, [pc, #24]	; (8004a88 <TIM2_IRQHandler+0x1c>)
 8004a6e:	6a03      	ldr	r3, [r0, #32]
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
{
  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
 8004a70:	68da      	ldr	r2, [r3, #12]
 8004a72:	07d1      	lsls	r1, r2, #31
 8004a74:	d507      	bpl.n	8004a86 <TIM2_IRQHandler+0x1a>
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8004a76:	691a      	ldr	r2, [r3, #16]
 8004a78:	07d2      	lsls	r2, r2, #31
 8004a7a:	d504      	bpl.n	8004a86 <TIM2_IRQHandler+0x1a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8004a7c:	f06f 0201 	mvn.w	r2, #1
 8004a80:	611a      	str	r2, [r3, #16]
  {
    if (LL_TIM_IsActiveFlag_UPDATE (ENCODER_M1.TIMx) != 0U)
    {
      LL_TIM_ClearFlag_UPDATE(ENCODER_M1.TIMx);
      (void)ENC_IRQHandler(&ENCODER_M1);
 8004a82:	f004 b9dd 	b.w	8008e40 <ENC_IRQHandler>
    /* No other IT to manage for encoder config */
  }
  /* USER CODE BEGIN SPD_TIM_M1_IRQn 1 */

  /* USER CODE END SPD_TIM_M1_IRQn 1 */
}
 8004a86:	4770      	bx	lr
 8004a88:	20000024 	.word	0x20000024

08004a8c <DMA1_Channel1_IRQHandler>:
}

//cstat !MISRAC2012-Rule-8.13
__STATIC_INLINE uint32_t LL_DMA_IsActiveFlag_TC(DMA_TypeDef *DMAx, uint32_t Channel)
{
  return ((NULL == DMAx) ? 0U : ((READ_BIT(DMAx->ISR,
 8004a8c:	4b04      	ldr	r3, [pc, #16]	; (8004aa0 <DMA1_Channel1_IRQHandler+0x14>)
 8004a8e:	681a      	ldr	r2, [r3, #0]
 8004a90:	0792      	lsls	r2, r2, #30
 8004a92:	d400      	bmi.n	8004a96 <DMA1_Channel1_IRQHandler+0xa>
  }
  /* USER CODE BEGIN DMA1_Channel1_IRQHandler 1 */

  /* USER CODE BEGIN DMA1_Channel1_IRQHandler 1 */

}
 8004a94:	4770      	bx	lr
    WRITE_REG (DMAx->IFCR, DMA_IFCR_CTCIF1 << ((Channel-LL_DMA_CHANNEL_1)<<2));
 8004a96:	2202      	movs	r2, #2
    ASPEP_HWDataReceivedIT (&aspepOverUartA);
 8004a98:	4802      	ldr	r0, [pc, #8]	; (8004aa4 <DMA1_Channel1_IRQHandler+0x18>)
 8004a9a:	605a      	str	r2, [r3, #4]
 8004a9c:	f7fc be64 	b.w	8001768 <ASPEP_HWDataReceivedIT>
 8004aa0:	40020000 	.word	0x40020000
 8004aa4:	20000450 	.word	0x20000450

08004aa8 <USART2_IRQHandler>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC)) ? 1UL : 0UL);
 8004aa8:	4b42      	ldr	r3, [pc, #264]	; (8004bb4 <USART2_IRQHandler+0x10c>)
 8004aaa:	69da      	ldr	r2, [r3, #28]
 8004aac:	0652      	lsls	r2, r2, #25
  * @brief  This function handles USART interrupt request.
  * @param  None
  */
//cstat !MISRAC2012-Rule-8.4
void USART2_IRQHandler(void)
{
 8004aae:	b510      	push	{r4, lr}
 8004ab0:	d509      	bpl.n	8004ac6 <USART2_IRQHandler+0x1e>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_DisableChannel(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8004ab2:	4941      	ldr	r1, [pc, #260]	; (8004bb8 <USART2_IRQHandler+0x110>)
    /* Disable the DMA channel to prepare the next chunck of data */
    LL_DMA_DisableChannel(DMA_TX_A, DMACH_TX_A);
    LL_USART_ClearFlag_TC (USARTA);
    /* Data Sent by UART */
    /* Need to free the buffer, and to check pending transfer */
    ASPEP_HWDataTransmittedIT (&aspepOverUartA);
 8004ab4:	4841      	ldr	r0, [pc, #260]	; (8004bbc <USART2_IRQHandler+0x114>)
 8004ab6:	69ca      	ldr	r2, [r1, #28]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8004ab8:	2440      	movs	r4, #64	; 0x40
 8004aba:	f022 0201 	bic.w	r2, r2, #1
 8004abe:	61ca      	str	r2, [r1, #28]
 8004ac0:	621c      	str	r4, [r3, #32]
 8004ac2:	f7fc fca5 	bl	8001410 <ASPEP_HWDataTransmittedIT>
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8004ac6:	4b3b      	ldr	r3, [pc, #236]	; (8004bb4 <USART2_IRQHandler+0x10c>)
 8004ac8:	69d8      	ldr	r0, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8004aca:	69da      	ldr	r2, [r3, #28]
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8004acc:	69d9      	ldr	r1, [r3, #28]
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_ERROR(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->CR3, USART_CR3_EIE) == (USART_CR3_EIE)) ? 1UL : 0UL);
 8004ace:	689c      	ldr	r4, [r3, #8]
 8004ad0:	07e4      	lsls	r4, r4, #31
 8004ad2:	d526      	bpl.n	8004b22 <USART2_IRQHandler+0x7a>
  return ((READ_BIT(USARTx->ISR, USART_ISR_FE) == (USART_ISR_FE)) ? 1UL : 0UL);
 8004ad4:	f002 0202 	and.w	r2, r2, #2
  return ((READ_BIT(USARTx->ISR, USART_ISR_ORE) == (USART_ISR_ORE)) ? 1UL : 0UL);
 8004ad8:	f000 0008 	and.w	r0, r0, #8
  feFlag = LL_USART_IsActiveFlag_FE(USARTA);
  neFlag = LL_USART_IsActiveFlag_NE(USARTA);
  errorMask = LL_USART_IsEnabledIT_ERROR(USARTA);

  flags = ((oreFlag | feFlag | neFlag) & errorMask);
  if (0U == flags)
 8004adc:	4302      	orrs	r2, r0
  return ((READ_BIT(USARTx->ISR, USART_ISR_NE) == (USART_ISR_NE)) ? 1UL : 0UL);
 8004ade:	f001 0104 	and.w	r1, r1, #4
 8004ae2:	430a      	orrs	r2, r1
 8004ae4:	d01d      	beq.n	8004b22 <USART2_IRQHandler+0x7a>
  {
    /* Nothing to do */
  }
  else
  { /* Stopping the debugger will generate an OverRun error */
    WRITE_REG(USARTA->ICR, USART_ICR_FECF|USART_ICR_ORECF|USART_ICR_NECF);
 8004ae6:	220e      	movs	r2, #14
 8004ae8:	621a      	str	r2, [r3, #32]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004aea:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004aee:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004af2:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8004af6:	f023 0301 	bic.w	r3, r3, #1
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004afa:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004afe:	e840 3100 	strex	r1, r3, [r0]
 8004b02:	2900      	cmp	r1, #0
 8004b04:	d1f3      	bne.n	8004aee <USART2_IRQHandler+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b06:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b0a:	f502 6380 	add.w	r3, r2, #1024	; 0x400
 8004b0e:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004b12:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b16:	f502 6080 	add.w	r0, r2, #1024	; 0x400
 8004b1a:	e840 3100 	strex	r1, r3, [r0]
 8004b1e:	2900      	cmp	r1, #0
 8004b20:	d1f3      	bne.n	8004b0a <USART2_IRQHandler+0x62>
  return ((READ_BIT(USARTx->ISR, USART_ISR_IDLE) == (USART_ISR_IDLE)) ? 1UL : 0UL);
 8004b22:	4b24      	ldr	r3, [pc, #144]	; (8004bb4 <USART2_IRQHandler+0x10c>)
 8004b24:	69da      	ldr	r2, [r3, #28]
 8004b26:	06d2      	lsls	r2, r2, #27
 8004b28:	d541      	bpl.n	8004bae <USART2_IRQHandler+0x106>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8004b2a:	681b      	ldr	r3, [r3, #0]
 8004b2c:	06db      	lsls	r3, r3, #27
 8004b2e:	d53f      	bpl.n	8004bb0 <USART2_IRQHandler+0x108>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b30:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b34:	f502 6380 	add.w	r3, r2, #1024	; 0x400
 8004b38:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8004b3c:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b40:	f502 6080 	add.w	r0, r2, #1024	; 0x400
 8004b44:	e840 3100 	strex	r1, r3, [r0]
 8004b48:	2900      	cmp	r1, #0
 8004b4a:	d1f3      	bne.n	8004b34 <USART2_IRQHandler+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b4c:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b50:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004b54:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8004b58:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b5c:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004b60:	e840 3100 	strex	r1, r3, [r0]
 8004b64:	2900      	cmp	r1, #0
 8004b66:	d1f3      	bne.n	8004b50 <USART2_IRQHandler+0xa8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b68:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b6c:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004b70:	e853 3f00 	ldrex	r3, [r3]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableDMAReq_RX(USART_TypeDef *USARTx)
{
  ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004b74:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b78:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004b7c:	e840 3100 	strex	r1, r3, [r0]
 8004b80:	2900      	cmp	r1, #0
 8004b82:	d1f3      	bne.n	8004b6c <USART2_IRQHandler+0xc4>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 8004b84:	4b0b      	ldr	r3, [pc, #44]	; (8004bb4 <USART2_IRQHandler+0x10c>)
 8004b86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8004b88:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
 8004b8c:	f502 6381 	add.w	r3, r2, #1032	; 0x408
 8004b90:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8004b94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8004b98:	f502 6081 	add.w	r0, r2, #1032	; 0x408
 8004b9c:	e840 3100 	strex	r1, r3, [r0]
 8004ba0:	2900      	cmp	r1, #0
 8004ba2:	d1f3      	bne.n	8004b8c <USART2_IRQHandler+0xe4>
  }

  /* USER CODE BEGIN USART2_IRQHandler 1 */

  /* USER CODE END USART2_IRQHandler 1 */
}
 8004ba4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ASPEP_HWDMAReset (&aspepOverUartA);
 8004ba8:	4804      	ldr	r0, [pc, #16]	; (8004bbc <USART2_IRQHandler+0x114>)
 8004baa:	f7fc be2b 	b.w	8001804 <ASPEP_HWDMAReset>
  return ((READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE)) ? 1UL : 0UL);
 8004bae:	681b      	ldr	r3, [r3, #0]
}
 8004bb0:	bd10      	pop	{r4, pc}
 8004bb2:	bf00      	nop
 8004bb4:	40004400 	.word	0x40004400
 8004bb8:	40020000 	.word	0x40020000
 8004bbc:	20000450 	.word	0x20000450

08004bc0 <HardFault_Handler>:
/**
  * @brief  This function handles Hard Fault exception.
  * @param  None
  */
void HardFault_Handler(void)
{
 8004bc0:	b508      	push	{r3, lr}
 /* USER CODE BEGIN HardFault_IRQn 0 */

 /* USER CODE END HardFault_IRQn 0 */
  TSK_HardwareFaultTask();
 8004bc2:	f7fd fe2d 	bl	8002820 <TSK_HardwareFaultTask>

  /* Go to infinite loop when Hard Fault exception occurs */
  while (true)
 8004bc6:	e7fe      	b.n	8004bc6 <HardFault_Handler+0x6>

08004bc8 <SysTick_Handler>:
 /* USER CODE END HardFault_IRQn 1 */

}

void SysTick_Handler(void)
{
 8004bc8:	b510      	push	{r4, lr}
#ifdef MC_HAL_IS_USED
static uint8_t SystickDividerCounter = SYSTICK_DIVIDER;
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  if (SystickDividerCounter == SYSTICK_DIVIDER)
 8004bca:	4c0a      	ldr	r4, [pc, #40]	; (8004bf4 <SysTick_Handler+0x2c>)
 8004bcc:	7823      	ldrb	r3, [r4, #0]
 8004bce:	2b02      	cmp	r3, #2
 8004bd0:	d006      	beq.n	8004be0 <SysTick_Handler+0x18>
  {
    HAL_IncTick();
    HAL_SYSTICK_IRQHandler();
    SystickDividerCounter = 0;
  }
  SystickDividerCounter ++;
 8004bd2:	3301      	adds	r3, #1
 8004bd4:	b2db      	uxtb	r3, r3
 8004bd6:	7023      	strb	r3, [r4, #0]
  /* USER CODE END SysTick_IRQn 1 */
    MC_RunMotorControlTasks();

  /* USER CODE BEGIN SysTick_IRQn 2 */
  /* USER CODE END SysTick_IRQn 2 */
}
 8004bd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MC_RunMotorControlTasks();
 8004bdc:	f7fd be14 	b.w	8002808 <MC_RunMotorControlTasks>
    HAL_IncTick();
 8004be0:	f000 fc04 	bl	80053ec <HAL_IncTick>
    HAL_SYSTICK_IRQHandler();
 8004be4:	f001 fc26 	bl	8006434 <HAL_SYSTICK_IRQHandler>
 8004be8:	2301      	movs	r3, #1
  SystickDividerCounter ++;
 8004bea:	7023      	strb	r3, [r4, #0]
}
 8004bec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MC_RunMotorControlTasks();
 8004bf0:	f7fd be0a 	b.w	8002808 <MC_RunMotorControlTasks>
 8004bf4:	200014a0 	.word	0x200014a0

08004bf8 <EXTI15_10_IRQHandler>:
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval @note This bit is set when the selected edge event arrives on the interrupt
  */
__STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
{
  return (uint32_t)(READ_BIT(EXTI->PR1, ExtiLine));
 8004bf8:	4b04      	ldr	r3, [pc, #16]	; (8004c0c <EXTI15_10_IRQHandler+0x14>)
 8004bfa:	695a      	ldr	r2, [r3, #20]
  * @brief  This function handles Button IRQ on PIN PC13.
  */
void EXTI15_10_IRQHandler (void)
{
  /* USER CODE BEGIN START_STOP_BTN */
  if (0U == LL_EXTI_ReadFlag_0_31(LL_EXTI_LINE_13))
 8004bfc:	0492      	lsls	r2, r2, #18
 8004bfe:	d400      	bmi.n	8004c02 <EXTI15_10_IRQHandler+0xa>
  {
    LL_EXTI_ClearFlag_0_31 (LL_EXTI_LINE_13);
    (void)UI_HandleStartStopButton_cb ();
  }

}
 8004c00:	4770      	bx	lr
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
  WRITE_REG(EXTI->PR1, ExtiLine);
 8004c02:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8004c06:	615a      	str	r2, [r3, #20]
    (void)UI_HandleStartStopButton_cb ();
 8004c08:	f7fd be1a 	b.w	8002840 <UI_HandleStartStopButton_cb>
 8004c0c:	40010400 	.word	0x40010400

08004c10 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8004c10:	490c      	ldr	r1, [pc, #48]	; (8004c44 <_sbrk+0x34>)
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8004c12:	4a0d      	ldr	r2, [pc, #52]	; (8004c48 <_sbrk+0x38>)
  if (NULL == __sbrk_heap_end)
 8004c14:	680b      	ldr	r3, [r1, #0]
{
 8004c16:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8004c18:	4c0c      	ldr	r4, [pc, #48]	; (8004c4c <_sbrk+0x3c>)
 8004c1a:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8004c1c:	b12b      	cbz	r3, 8004c2a <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8004c1e:	4418      	add	r0, r3
 8004c20:	4290      	cmp	r0, r2
 8004c22:	d807      	bhi.n	8004c34 <_sbrk+0x24>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8004c24:	6008      	str	r0, [r1, #0]

  return (void *)prev_heap_end;
}
 8004c26:	4618      	mov	r0, r3
 8004c28:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8004c2a:	4b09      	ldr	r3, [pc, #36]	; (8004c50 <_sbrk+0x40>)
 8004c2c:	600b      	str	r3, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8004c2e:	4418      	add	r0, r3
 8004c30:	4290      	cmp	r0, r2
 8004c32:	d9f7      	bls.n	8004c24 <_sbrk+0x14>
    errno = ENOMEM;
 8004c34:	f008 fda4 	bl	800d780 <__errno>
 8004c38:	230c      	movs	r3, #12
 8004c3a:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8004c3c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8004c40:	4618      	mov	r0, r3
 8004c42:	bd10      	pop	{r4, pc}
 8004c44:	20002e20 	.word	0x20002e20
 8004c48:	20020000 	.word	0x20020000
 8004c4c:	00000800 	.word	0x00000800
 8004c50:	200031f8 	.word	0x200031f8

08004c54 <MX_TIM2_Init>:
  HAL_TIM_MspPostInit(&htim1);

}
/* TIM2 init function */
void MX_TIM2_Init(void)
{
 8004c54:	b510      	push	{r4, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8004c56:	4819      	ldr	r0, [pc, #100]	; (8004cbc <MX_TIM2_Init+0x68>)
{
 8004c58:	b08c      	sub	sp, #48	; 0x30
  htim2.Instance = TIM2;
 8004c5a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  TIM_Encoder_InitTypeDef sConfig = {0};
 8004c5e:	2300      	movs	r3, #0
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = M1_PULSE_NBR;
 8004c60:	f640 71ff 	movw	r1, #4095	; 0xfff
  htim2.Instance = TIM2;
 8004c64:	6002      	str	r2, [r0, #0]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC1Filter = M1_ENC_IC_FILTER;
 8004c66:	220c      	movs	r2, #12
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8004c68:	2401      	movs	r4, #1
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004c6a:	e9cd 3300 	strd	r3, r3, [sp]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8004c6e:	e9c0 3301 	strd	r3, r3, [r0, #4]
  TIM_Encoder_InitTypeDef sConfig = {0};
 8004c72:	9304      	str	r3, [sp, #16]
 8004c74:	9306      	str	r3, [sp, #24]
 8004c76:	9308      	str	r3, [sp, #32]
 8004c78:	930a      	str	r3, [sp, #40]	; 0x28
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004c7a:	9302      	str	r3, [sp, #8]
  htim2.Init.Period = M1_PULSE_NBR;
 8004c7c:	60c1      	str	r1, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004c7e:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004c80:	6183      	str	r3, [r0, #24]
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
  sConfig.IC2Filter = M1_ENC_IC_FILTER;
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8004c82:	eb0d 0102 	add.w	r1, sp, r2
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8004c86:	2303      	movs	r3, #3
 8004c88:	9303      	str	r3, [sp, #12]
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8004c8a:	9405      	str	r4, [sp, #20]
  sConfig.IC1Filter = M1_ENC_IC_FILTER;
 8004c8c:	9207      	str	r2, [sp, #28]
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8004c8e:	9409      	str	r4, [sp, #36]	; 0x24
  sConfig.IC2Filter = M1_ENC_IC_FILTER;
 8004c90:	920b      	str	r2, [sp, #44]	; 0x2c
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 8004c92:	f002 fe3f 	bl	8007914 <HAL_TIM_Encoder_Init>
 8004c96:	b948      	cbnz	r0, 8004cac <MX_TIM2_Init+0x58>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004c98:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004c9a:	4808      	ldr	r0, [pc, #32]	; (8004cbc <MX_TIM2_Init+0x68>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004c9c:	9300      	str	r3, [sp, #0]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004c9e:	4669      	mov	r1, sp
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004ca0:	9302      	str	r3, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8004ca2:	f003 facf 	bl	8008244 <HAL_TIMEx_MasterConfigSynchronization>
 8004ca6:	b920      	cbnz	r0, 8004cb2 <MX_TIM2_Init+0x5e>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 8004ca8:	b00c      	add	sp, #48	; 0x30
 8004caa:	bd10      	pop	{r4, pc}
    Error_Handler();
 8004cac:	f7fc ffa0 	bl	8001bf0 <Error_Handler>
 8004cb0:	e7f2      	b.n	8004c98 <MX_TIM2_Init+0x44>
    Error_Handler();
 8004cb2:	f7fc ff9d 	bl	8001bf0 <Error_Handler>
}
 8004cb6:	b00c      	add	sp, #48	; 0x30
 8004cb8:	bd10      	pop	{r4, pc}
 8004cba:	bf00      	nop
 8004cbc:	20002e70 	.word	0x20002e70

08004cc0 <MX_TIM3_Init>:
/* TIM3 init function */
void MX_TIM3_Init(void)
{
 8004cc0:	b500      	push	{lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8004cc2:	481b      	ldr	r0, [pc, #108]	; (8004d30 <MX_TIM3_Init+0x70>)
 8004cc4:	4a1b      	ldr	r2, [pc, #108]	; (8004d34 <MX_TIM3_Init+0x74>)
 8004cc6:	6002      	str	r2, [r0, #0]
{
 8004cc8:	b089      	sub	sp, #36	; 0x24
  htim3.Init.Prescaler = 17000;
 8004cca:	f244 2268 	movw	r2, #17000	; 0x4268
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004cce:	2300      	movs	r3, #0
  htim3.Init.Prescaler = 17000;
 8004cd0:	6042      	str	r2, [r0, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8004cd2:	f64f 72ff 	movw	r2, #65535	; 0xffff
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004cd6:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004cda:	e9cd 3306 	strd	r3, r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004cde:	e9cd 3301 	strd	r3, r3, [sp, #4]
  htim3.Init.Period = 65535;
 8004ce2:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004ce6:	9303      	str	r3, [sp, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004ce8:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004cea:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8004cec:	f002 fc4a 	bl	8007584 <HAL_TIM_Base_Init>
 8004cf0:	b990      	cbnz	r0, 8004d18 <MX_TIM3_Init+0x58>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004cf2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8004cf6:	480e      	ldr	r0, [pc, #56]	; (8004d30 <MX_TIM3_Init+0x70>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004cf8:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8004cfa:	a904      	add	r1, sp, #16
 8004cfc:	f002 feba 	bl	8007a74 <HAL_TIM_ConfigClockSource>
 8004d00:	b990      	cbnz	r0, 8004d28 <MX_TIM3_Init+0x68>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d02:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d04:	480a      	ldr	r0, [pc, #40]	; (8004d30 <MX_TIM3_Init+0x70>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d06:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d08:	a901      	add	r1, sp, #4
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004d0a:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8004d0c:	f003 fa9a 	bl	8008244 <HAL_TIMEx_MasterConfigSynchronization>
 8004d10:	b928      	cbnz	r0, 8004d1e <MX_TIM3_Init+0x5e>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8004d12:	b009      	add	sp, #36	; 0x24
 8004d14:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d18:	f7fc ff6a 	bl	8001bf0 <Error_Handler>
 8004d1c:	e7e9      	b.n	8004cf2 <MX_TIM3_Init+0x32>
    Error_Handler();
 8004d1e:	f7fc ff67 	bl	8001bf0 <Error_Handler>
}
 8004d22:	b009      	add	sp, #36	; 0x24
 8004d24:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d28:	f7fc ff62 	bl	8001bf0 <Error_Handler>
 8004d2c:	e7e9      	b.n	8004d02 <MX_TIM3_Init+0x42>
 8004d2e:	bf00      	nop
 8004d30:	20002ebc 	.word	0x20002ebc
 8004d34:	40000400 	.word	0x40000400

08004d38 <MX_TIM5_Init>:
/* TIM5 init function */
void MX_TIM5_Init(void)
{
 8004d38:	b500      	push	{lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
 8004d3a:	481a      	ldr	r0, [pc, #104]	; (8004da4 <MX_TIM5_Init+0x6c>)
 8004d3c:	4a1a      	ldr	r2, [pc, #104]	; (8004da8 <MX_TIM5_Init+0x70>)
 8004d3e:	6002      	str	r2, [r0, #0]
{
 8004d40:	b089      	sub	sp, #36	; 0x24
  htim5.Init.Prescaler = 170;
 8004d42:	22aa      	movs	r2, #170	; 0xaa
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d44:	2300      	movs	r3, #0
  htim5.Init.Prescaler = 170;
 8004d46:	6042      	str	r2, [r0, #4]
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 10000;
 8004d48:	f242 7210 	movw	r2, #10000	; 0x2710
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8004d4c:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004d50:	e9cd 3306 	strd	r3, r3, [sp, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004d54:	e9cd 3301 	strd	r3, r3, [sp, #4]
  htim5.Init.Period = 10000;
 8004d58:	e9c0 3202 	strd	r3, r2, [r0, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004d5c:	9303      	str	r3, [sp, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8004d5e:	6103      	str	r3, [r0, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004d60:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8004d62:	f002 fc0f 	bl	8007584 <HAL_TIM_Base_Init>
 8004d66:	b990      	cbnz	r0, 8004d8e <MX_TIM5_Init+0x56>
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004d68:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8004d6c:	480d      	ldr	r0, [pc, #52]	; (8004da4 <MX_TIM5_Init+0x6c>)
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8004d6e:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8004d70:	a904      	add	r1, sp, #16
 8004d72:	f002 fe7f 	bl	8007a74 <HAL_TIM_ConfigClockSource>
 8004d76:	b990      	cbnz	r0, 8004d9e <MX_TIM5_Init+0x66>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d78:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004d7a:	480a      	ldr	r0, [pc, #40]	; (8004da4 <MX_TIM5_Init+0x6c>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004d7c:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004d7e:	a901      	add	r1, sp, #4
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004d80:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8004d82:	f003 fa5f 	bl	8008244 <HAL_TIMEx_MasterConfigSynchronization>
 8004d86:	b928      	cbnz	r0, 8004d94 <MX_TIM5_Init+0x5c>
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */

}
 8004d88:	b009      	add	sp, #36	; 0x24
 8004d8a:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d8e:	f7fc ff2f 	bl	8001bf0 <Error_Handler>
 8004d92:	e7e9      	b.n	8004d68 <MX_TIM5_Init+0x30>
    Error_Handler();
 8004d94:	f7fc ff2c 	bl	8001bf0 <Error_Handler>
}
 8004d98:	b009      	add	sp, #36	; 0x24
 8004d9a:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8004d9e:	f7fc ff27 	bl	8001bf0 <Error_Handler>
 8004da2:	e7e9      	b.n	8004d78 <MX_TIM5_Init+0x40>
 8004da4:	20002f08 	.word	0x20002f08
 8004da8:	40000c00 	.word	0x40000c00

08004dac <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 8004dac:	b500      	push	{lr}

  if(tim_baseHandle->Instance==TIM1)
 8004dae:	4a1e      	ldr	r2, [pc, #120]	; (8004e28 <HAL_TIM_Base_MspInit+0x7c>)
 8004db0:	6803      	ldr	r3, [r0, #0]
 8004db2:	4293      	cmp	r3, r2
{
 8004db4:	b085      	sub	sp, #20
  if(tim_baseHandle->Instance==TIM1)
 8004db6:	d015      	beq.n	8004de4 <HAL_TIM_Base_MspInit+0x38>
    __HAL_RCC_TIM1_CLK_ENABLE();
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM3)
 8004db8:	4a1c      	ldr	r2, [pc, #112]	; (8004e2c <HAL_TIM_Base_MspInit+0x80>)
 8004dba:	4293      	cmp	r3, r2
 8004dbc:	d005      	beq.n	8004dca <HAL_TIM_Base_MspInit+0x1e>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
 8004dbe:	4a1c      	ldr	r2, [pc, #112]	; (8004e30 <HAL_TIM_Base_MspInit+0x84>)
 8004dc0:	4293      	cmp	r3, r2
 8004dc2:	d01c      	beq.n	8004dfe <HAL_TIM_Base_MspInit+0x52>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}
 8004dc4:	b005      	add	sp, #20
 8004dc6:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM3_CLK_ENABLE();
 8004dca:	4b1a      	ldr	r3, [pc, #104]	; (8004e34 <HAL_TIM_Base_MspInit+0x88>)
 8004dcc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004dce:	f042 0202 	orr.w	r2, r2, #2
 8004dd2:	659a      	str	r2, [r3, #88]	; 0x58
 8004dd4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004dd6:	f003 0302 	and.w	r3, r3, #2
 8004dda:	9302      	str	r3, [sp, #8]
 8004ddc:	9b02      	ldr	r3, [sp, #8]
}
 8004dde:	b005      	add	sp, #20
 8004de0:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM1_CLK_ENABLE();
 8004de4:	4b13      	ldr	r3, [pc, #76]	; (8004e34 <HAL_TIM_Base_MspInit+0x88>)
 8004de6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8004de8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8004dec:	661a      	str	r2, [r3, #96]	; 0x60
 8004dee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004df0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004df4:	9301      	str	r3, [sp, #4]
 8004df6:	9b01      	ldr	r3, [sp, #4]
}
 8004df8:	b005      	add	sp, #20
 8004dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004dfe:	4b0d      	ldr	r3, [pc, #52]	; (8004e34 <HAL_TIM_Base_MspInit+0x88>)
 8004e00:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8004e02:	f041 0108 	orr.w	r1, r1, #8
 8004e06:	6599      	str	r1, [r3, #88]	; 0x58
 8004e08:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e0a:	2200      	movs	r2, #0
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004e0c:	f003 0308 	and.w	r3, r3, #8
 8004e10:	9303      	str	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e12:	2032      	movs	r0, #50	; 0x32
 8004e14:	4611      	mov	r1, r2
    __HAL_RCC_TIM5_CLK_ENABLE();
 8004e16:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
 8004e18:	f001 faa4 	bl	8006364 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8004e1c:	2032      	movs	r0, #50	; 0x32
}
 8004e1e:	b005      	add	sp, #20
 8004e20:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
 8004e24:	f001 badc 	b.w	80063e0 <HAL_NVIC_EnableIRQ>
 8004e28:	40012c00 	.word	0x40012c00
 8004e2c:	40000400 	.word	0x40000400
 8004e30:	40000c00 	.word	0x40000c00
 8004e34:	40021000 	.word	0x40021000

08004e38 <HAL_TIM_Encoder_MspInit>:

void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* tim_encoderHandle)
{
 8004e38:	b530      	push	{r4, r5, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(tim_encoderHandle->Instance==TIM2)
 8004e3a:	6803      	ldr	r3, [r0, #0]
{
 8004e3c:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004e3e:	2400      	movs	r4, #0
  if(tim_encoderHandle->Instance==TIM2)
 8004e40:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004e44:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8004e48:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8004e4c:	9408      	str	r4, [sp, #32]
  if(tim_encoderHandle->Instance==TIM2)
 8004e4e:	d001      	beq.n	8004e54 <HAL_TIM_Encoder_MspInit+0x1c>

  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}
 8004e50:	b00b      	add	sp, #44	; 0x2c
 8004e52:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_TIM2_CLK_ENABLE();
 8004e54:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004e58:	2501      	movs	r5, #1
    __HAL_RCC_TIM2_CLK_ENABLE();
 8004e5a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004e5c:	f042 0201 	orr.w	r2, r2, #1
 8004e60:	659a      	str	r2, [r3, #88]	; 0x58
 8004e62:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004e64:	f002 0201 	and.w	r2, r2, #1
 8004e68:	9201      	str	r2, [sp, #4]
 8004e6a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004e6c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004e6e:	f042 0201 	orr.w	r2, r2, #1
 8004e72:	64da      	str	r2, [r3, #76]	; 0x4c
 8004e74:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004e76:	f002 0201 	and.w	r2, r2, #1
 8004e7a:	9202      	str	r2, [sp, #8]
 8004e7c:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004e7e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004e80:	f042 0202 	orr.w	r2, r2, #2
 8004e84:	64da      	str	r2, [r3, #76]	; 0x4c
 8004e86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004e88:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004e8a:	f003 0302 	and.w	r3, r3, #2
 8004e8e:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004e90:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8004e92:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004e96:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_ENCODER_A_Pin;
 8004e9a:	2302      	movs	r3, #2
 8004e9c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004ea0:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(M1_ENCODER_A_GPIO_Port, &GPIO_InitStruct);
 8004ea2:	f001 fbd3 	bl	800664c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_ENCODER_B_Pin;
 8004ea6:	2208      	movs	r2, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004ea8:	2302      	movs	r3, #2
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004eaa:	4805      	ldr	r0, [pc, #20]	; (8004ec0 <HAL_TIM_Encoder_MspInit+0x88>)
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8004eac:	9508      	str	r5, [sp, #32]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004eae:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004eb0:	e9cd 2304 	strd	r2, r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004eb4:	e9cd 4406 	strd	r4, r4, [sp, #24]
    HAL_GPIO_Init(M1_ENCODER_B_GPIO_Port, &GPIO_InitStruct);
 8004eb8:	f001 fbc8 	bl	800664c <HAL_GPIO_Init>
}
 8004ebc:	b00b      	add	sp, #44	; 0x2c
 8004ebe:	bd30      	pop	{r4, r5, pc}
 8004ec0:	48000400 	.word	0x48000400

08004ec4 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 8004ec4:	b5d0      	push	{r4, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM1)
 8004ec6:	4a20      	ldr	r2, [pc, #128]	; (8004f48 <HAL_TIM_MspPostInit+0x84>)
 8004ec8:	6801      	ldr	r1, [r0, #0]
{
 8004eca:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004ecc:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM1)
 8004ece:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004ed0:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8004ed4:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8004ed8:	9306      	str	r3, [sp, #24]
  if(timHandle->Instance==TIM1)
 8004eda:	d001      	beq.n	8004ee0 <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 8004edc:	b008      	add	sp, #32
 8004ede:	bdd0      	pop	{r4, r6, r7, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004ee0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8004ee4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004ee8:	2406      	movs	r4, #6
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004eea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004eec:	f042 0201 	orr.w	r2, r2, #1
 8004ef0:	64da      	str	r2, [r3, #76]	; 0x4c
 8004ef2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004ef4:	f002 0201 	and.w	r2, r2, #1
 8004ef8:	9200      	str	r2, [sp, #0]
 8004efa:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004efc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004efe:	f042 0202 	orr.w	r2, r2, #2
 8004f02:	64da      	str	r2, [r3, #76]	; 0x4c
 8004f04:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004f06:	9406      	str	r4, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004f08:	f003 0302 	and.w	r3, r3, #2
 8004f0c:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f0e:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin|M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8004f10:	f44f 62f0 	mov.w	r2, #1920	; 0x780
 8004f14:	2602      	movs	r6, #2
 8004f16:	2702      	movs	r7, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f18:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = M1_PWM_UL_Pin|M1_PWM_UH_Pin|M1_PWM_VH_Pin|M1_PWM_WH_Pin;
 8004f1c:	2302      	movs	r3, #2
 8004f1e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8004f22:	e9cd 6704 	strd	r6, r7, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004f26:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f28:	f001 fb90 	bl	800664c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8004f2c:	2203      	movs	r2, #3
 8004f2e:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f30:	4806      	ldr	r0, [pc, #24]	; (8004f4c <HAL_TIM_MspPostInit+0x88>)
    GPIO_InitStruct.Alternate = GPIO_AF6_TIM1;
 8004f32:	9406      	str	r4, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f34:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = M1_PWM_VL_Pin|M1_PWM_WL_Pin;
 8004f36:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8004f3a:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f3e:	f001 fb85 	bl	800664c <HAL_GPIO_Init>
}
 8004f42:	b008      	add	sp, #32
 8004f44:	bdd0      	pop	{r4, r6, r7, pc}
 8004f46:	bf00      	nop
 8004f48:	40012c00 	.word	0x40012c00
 8004f4c:	48000400 	.word	0x48000400

08004f50 <MX_TIM1_Init>:
{
 8004f50:	b510      	push	{r4, lr}
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004f52:	2400      	movs	r4, #0
{
 8004f54:	b09e      	sub	sp, #120	; 0x78
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8004f56:	2234      	movs	r2, #52	; 0x34
 8004f58:	4621      	mov	r1, r4
 8004f5a:	a811      	add	r0, sp, #68	; 0x44
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004f5c:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8004f60:	e9cd 4407 	strd	r4, r4, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004f64:	e9cd 4401 	strd	r4, r4, [sp, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8004f68:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
 8004f6c:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
 8004f70:	e9cd 440f 	strd	r4, r4, [sp, #60]	; 0x3c
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
 8004f74:	9404      	str	r4, [sp, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8004f76:	9400      	str	r4, [sp, #0]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8004f78:	940a      	str	r4, [sp, #40]	; 0x28
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8004f7a:	f008 fba3 	bl	800d6c4 <memset>
  htim1.Instance = TIM1;
 8004f7e:	484f      	ldr	r0, [pc, #316]	; (80050bc <MX_TIM1_Init+0x16c>)
 8004f80:	4a4f      	ldr	r2, [pc, #316]	; (80050c0 <MX_TIM1_Init+0x170>)
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8004f82:	2320      	movs	r3, #32
  htim1.Init.Prescaler = ((TIM_CLOCK_DIVIDER) - 1);
 8004f84:	e9c0 2400 	strd	r2, r4, [r0]
  htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 8004f88:	6083      	str	r3, [r0, #8]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 8004f8a:	f44f 52a6 	mov.w	r2, #5312	; 0x14c0
 8004f8e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004f92:	e9c0 2303 	strd	r2, r3, [r0, #12]
  htim1.Init.RepetitionCounter = (REP_COUNTER);
 8004f96:	2301      	movs	r3, #1
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8004f98:	e9c0 3405 	strd	r3, r4, [r0, #20]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8004f9c:	f002 faf2 	bl	8007584 <HAL_TIM_Base_Init>
 8004fa0:	2800      	cmp	r0, #0
 8004fa2:	d168      	bne.n	8005076 <MX_TIM1_Init+0x126>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8004fa4:	4845      	ldr	r0, [pc, #276]	; (80050bc <MX_TIM1_Init+0x16c>)
 8004fa6:	f002 fc1b 	bl	80077e0 <HAL_TIM_PWM_Init>
 8004faa:	2800      	cmp	r0, #0
 8004fac:	d16a      	bne.n	8005084 <MX_TIM1_Init+0x134>
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;
 8004fae:	2206      	movs	r2, #6
 8004fb0:	2310      	movs	r3, #16
  if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)
 8004fb2:	4842      	ldr	r0, [pc, #264]	; (80050bc <MX_TIM1_Init+0x16c>)
 8004fb4:	a904      	add	r1, sp, #16
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;
 8004fb6:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)
 8004fba:	f002 fe3b 	bl	8007c34 <HAL_TIM_SlaveConfigSynchro>
 8004fbe:	2800      	cmp	r0, #0
 8004fc0:	d179      	bne.n	80050b6 <MX_TIM1_Init+0x166>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 8004fc2:	2300      	movs	r3, #0
 8004fc4:	2270      	movs	r2, #112	; 0x70
 8004fc6:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8004fca:	483c      	ldr	r0, [pc, #240]	; (80050bc <MX_TIM1_Init+0x16c>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004fcc:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8004fce:	4669      	mov	r1, sp
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004fd0:	9302      	str	r3, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8004fd2:	f003 f937 	bl	8008244 <HAL_TIMEx_MasterConfigSynchronization>
 8004fd6:	2800      	cmp	r0, #0
 8004fd8:	d16a      	bne.n	80050b0 <MX_TIM1_Init+0x160>
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8004fda:	2160      	movs	r1, #96	; 0x60
 8004fdc:	f44f 6326 	mov.w	r3, #2656	; 0xa60
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8004fe0:	2000      	movs	r0, #0
  sConfigOC.Pulse = ((PWM_PERIOD_CYCLES) / 4);
 8004fe2:	e9cd 130a 	strd	r1, r3, [sp, #40]	; 0x28
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8004fe6:	2100      	movs	r1, #0
 8004fe8:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8004fec:	2200      	movs	r2, #0
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8004fee:	4833      	ldr	r0, [pc, #204]	; (80050bc <MX_TIM1_Init+0x16c>)
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8004ff0:	9210      	str	r2, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8004ff2:	a90a      	add	r1, sp, #40	; 0x28
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8004ff4:	e9cd 220c 	strd	r2, r2, [sp, #48]	; 0x30
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8004ff8:	f003 f81a 	bl	8008030 <HAL_TIM_PWM_ConfigChannel>
 8004ffc:	2800      	cmp	r0, #0
 8004ffe:	d154      	bne.n	80050aa <MX_TIM1_Init+0x15a>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8005000:	482e      	ldr	r0, [pc, #184]	; (80050bc <MX_TIM1_Init+0x16c>)
 8005002:	2204      	movs	r2, #4
 8005004:	a90a      	add	r1, sp, #40	; 0x28
 8005006:	f003 f813 	bl	8008030 <HAL_TIM_PWM_ConfigChannel>
 800500a:	2800      	cmp	r0, #0
 800500c:	d14a      	bne.n	80050a4 <MX_TIM1_Init+0x154>
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800500e:	482b      	ldr	r0, [pc, #172]	; (80050bc <MX_TIM1_Init+0x16c>)
 8005010:	2208      	movs	r2, #8
 8005012:	a90a      	add	r1, sp, #40	; 0x28
 8005014:	f003 f80c 	bl	8008030 <HAL_TIM_PWM_ConfigChannel>
 8005018:	2800      	cmp	r0, #0
 800501a:	d140      	bne.n	800509e <MX_TIM1_Init+0x14e>
  sConfigOC.OCMode = TIM_OCMODE_PWM2;
 800501c:	2270      	movs	r2, #112	; 0x70
 800501e:	f241 43bf 	movw	r3, #5311	; 0x14bf
 8005022:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8005026:	4825      	ldr	r0, [pc, #148]	; (80050bc <MX_TIM1_Init+0x16c>)
 8005028:	a90a      	add	r1, sp, #40	; 0x28
 800502a:	220c      	movs	r2, #12
 800502c:	f003 f800 	bl	8008030 <HAL_TIM_PWM_ConfigChannel>
 8005030:	bb90      	cbnz	r0, 8005098 <MX_TIM1_Init+0x148>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_ENABLE;
 8005032:	f44f 6400 	mov.w	r4, #2048	; 0x800
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 8005036:	f44f 6280 	mov.w	r2, #1024	; 0x400
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800503a:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_ENABLE;
 800503c:	e9cd 4211 	strd	r4, r2, [sp, #68]	; 0x44
  sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);
 8005040:	2448      	movs	r4, #72	; 0x48
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8005042:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  sBreakDeadTimeConfig.DeadTime = ((DEAD_TIME_COUNTS) / 2);
 8005046:	e9cd 3413 	strd	r3, r4, [sp, #76]	; 0x4c
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 800504a:	e9cd 3215 	strd	r3, r2, [sp, #84]	; 0x54
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 800504e:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
  sBreakDeadTimeConfig.Break2Filter = 3;
 8005052:	2203      	movs	r2, #3
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005054:	4819      	ldr	r0, [pc, #100]	; (80050bc <MX_TIM1_Init+0x16c>)
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8005056:	931d      	str	r3, [sp, #116]	; 0x74
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005058:	a911      	add	r1, sp, #68	; 0x44
  sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
 800505a:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 800505e:	e9cd 3419 	strd	r3, r4, [sp, #100]	; 0x64
  sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
 8005062:	e9cd 231b 	strd	r2, r3, [sp, #108]	; 0x6c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8005066:	f003 f949 	bl	80082fc <HAL_TIMEx_ConfigBreakDeadTime>
 800506a:	b970      	cbnz	r0, 800508a <MX_TIM1_Init+0x13a>
  HAL_TIM_MspPostInit(&htim1);
 800506c:	4813      	ldr	r0, [pc, #76]	; (80050bc <MX_TIM1_Init+0x16c>)
 800506e:	f7ff ff29 	bl	8004ec4 <HAL_TIM_MspPostInit>
}
 8005072:	b01e      	add	sp, #120	; 0x78
 8005074:	bd10      	pop	{r4, pc}
    Error_Handler();
 8005076:	f7fc fdbb 	bl	8001bf0 <Error_Handler>
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 800507a:	4810      	ldr	r0, [pc, #64]	; (80050bc <MX_TIM1_Init+0x16c>)
 800507c:	f002 fbb0 	bl	80077e0 <HAL_TIM_PWM_Init>
 8005080:	2800      	cmp	r0, #0
 8005082:	d094      	beq.n	8004fae <MX_TIM1_Init+0x5e>
    Error_Handler();
 8005084:	f7fc fdb4 	bl	8001bf0 <Error_Handler>
 8005088:	e791      	b.n	8004fae <MX_TIM1_Init+0x5e>
    Error_Handler();
 800508a:	f7fc fdb1 	bl	8001bf0 <Error_Handler>
  HAL_TIM_MspPostInit(&htim1);
 800508e:	480b      	ldr	r0, [pc, #44]	; (80050bc <MX_TIM1_Init+0x16c>)
 8005090:	f7ff ff18 	bl	8004ec4 <HAL_TIM_MspPostInit>
}
 8005094:	b01e      	add	sp, #120	; 0x78
 8005096:	bd10      	pop	{r4, pc}
    Error_Handler();
 8005098:	f7fc fdaa 	bl	8001bf0 <Error_Handler>
 800509c:	e7c9      	b.n	8005032 <MX_TIM1_Init+0xe2>
    Error_Handler();
 800509e:	f7fc fda7 	bl	8001bf0 <Error_Handler>
 80050a2:	e7bb      	b.n	800501c <MX_TIM1_Init+0xcc>
    Error_Handler();
 80050a4:	f7fc fda4 	bl	8001bf0 <Error_Handler>
 80050a8:	e7b1      	b.n	800500e <MX_TIM1_Init+0xbe>
    Error_Handler();
 80050aa:	f7fc fda1 	bl	8001bf0 <Error_Handler>
 80050ae:	e7a7      	b.n	8005000 <MX_TIM1_Init+0xb0>
    Error_Handler();
 80050b0:	f7fc fd9e 	bl	8001bf0 <Error_Handler>
 80050b4:	e791      	b.n	8004fda <MX_TIM1_Init+0x8a>
    Error_Handler();
 80050b6:	f7fc fd9b 	bl	8001bf0 <Error_Handler>
 80050ba:	e782      	b.n	8004fc2 <MX_TIM1_Init+0x72>
 80050bc:	20002e24 	.word	0x20002e24
 80050c0:	40012c00 	.word	0x40012c00

080050c4 <MX_USART2_UART_Init>:
DMA_HandleTypeDef hdma_usart2_tx;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 80050c4:	b510      	push	{r4, lr}
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 80050c6:	481f      	ldr	r0, [pc, #124]	; (8005144 <MX_USART2_UART_Init+0x80>)
 80050c8:	4c1f      	ldr	r4, [pc, #124]	; (8005148 <MX_USART2_UART_Init+0x84>)
  huart2.Init.BaudRate = 1843200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80050ca:	2300      	movs	r3, #0
  huart2.Init.BaudRate = 1843200;
 80050cc:	f44f 11e1 	mov.w	r1, #1843200	; 0x1c2000
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 80050d0:	220c      	movs	r2, #12
  huart2.Init.BaudRate = 1843200;
 80050d2:	e9c0 4100 	strd	r4, r1, [r0]
  huart2.Init.StopBits = UART_STOPBITS_1;
 80050d6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.Mode = UART_MODE_TX_RX;
 80050da:	e9c0 3204 	strd	r3, r2, [r0, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 80050de:	e9c0 3306 	strd	r3, r3, [r0, #24]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 80050e2:	e9c0 3308 	strd	r3, r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80050e6:	6283      	str	r3, [r0, #40]	; 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 80050e8:	f003 fbc2 	bl	8008870 <HAL_UART_Init>
 80050ec:	b970      	cbnz	r0, 800510c <MX_USART2_UART_Init+0x48>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 80050ee:	4815      	ldr	r0, [pc, #84]	; (8005144 <MX_USART2_UART_Init+0x80>)
 80050f0:	2100      	movs	r1, #0
 80050f2:	f003 fc47 	bl	8008984 <HAL_UARTEx_SetTxFifoThreshold>
 80050f6:	b988      	cbnz	r0, 800511c <MX_USART2_UART_Init+0x58>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 80050f8:	4812      	ldr	r0, [pc, #72]	; (8005144 <MX_USART2_UART_Init+0x80>)
 80050fa:	2100      	movs	r1, #0
 80050fc:	f003 fc84 	bl	8008a08 <HAL_UARTEx_SetRxFifoThreshold>
 8005100:	b9a0      	cbnz	r0, 800512c <MX_USART2_UART_Init+0x68>
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 8005102:	4810      	ldr	r0, [pc, #64]	; (8005144 <MX_USART2_UART_Init+0x80>)
 8005104:	f003 fc20 	bl	8008948 <HAL_UARTEx_DisableFifoMode>
 8005108:	b9b8      	cbnz	r0, 800513a <MX_USART2_UART_Init+0x76>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800510a:	bd10      	pop	{r4, pc}
    Error_Handler();
 800510c:	f7fc fd70 	bl	8001bf0 <Error_Handler>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005110:	480c      	ldr	r0, [pc, #48]	; (8005144 <MX_USART2_UART_Init+0x80>)
 8005112:	2100      	movs	r1, #0
 8005114:	f003 fc36 	bl	8008984 <HAL_UARTEx_SetTxFifoThreshold>
 8005118:	2800      	cmp	r0, #0
 800511a:	d0ed      	beq.n	80050f8 <MX_USART2_UART_Init+0x34>
    Error_Handler();
 800511c:	f7fc fd68 	bl	8001bf0 <Error_Handler>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8005120:	4808      	ldr	r0, [pc, #32]	; (8005144 <MX_USART2_UART_Init+0x80>)
 8005122:	2100      	movs	r1, #0
 8005124:	f003 fc70 	bl	8008a08 <HAL_UARTEx_SetRxFifoThreshold>
 8005128:	2800      	cmp	r0, #0
 800512a:	d0ea      	beq.n	8005102 <MX_USART2_UART_Init+0x3e>
    Error_Handler();
 800512c:	f7fc fd60 	bl	8001bf0 <Error_Handler>
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 8005130:	4804      	ldr	r0, [pc, #16]	; (8005144 <MX_USART2_UART_Init+0x80>)
 8005132:	f003 fc09 	bl	8008948 <HAL_UARTEx_DisableFifoMode>
 8005136:	2800      	cmp	r0, #0
 8005138:	d0e7      	beq.n	800510a <MX_USART2_UART_Init+0x46>
}
 800513a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
 800513e:	f7fc bd57 	b.w	8001bf0 <Error_Handler>
 8005142:	bf00      	nop
 8005144:	20003014 	.word	0x20003014
 8005148:	40004400 	.word	0x40004400

0800514c <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800514c:	b570      	push	{r4, r5, r6, lr}
 800514e:	4604      	mov	r4, r0
 8005150:	b09c      	sub	sp, #112	; 0x70

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005152:	2100      	movs	r1, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005154:	2254      	movs	r2, #84	; 0x54
 8005156:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005158:	e9cd 1102 	strd	r1, r1, [sp, #8]
 800515c:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8005160:	9106      	str	r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005162:	f008 faaf 	bl	800d6c4 <memset>
  if(uartHandle->Instance==USART2)
 8005166:	4b31      	ldr	r3, [pc, #196]	; (800522c <HAL_UART_MspInit+0xe0>)
 8005168:	6822      	ldr	r2, [r4, #0]
 800516a:	429a      	cmp	r2, r3
 800516c:	d001      	beq.n	8005172 <HAL_UART_MspInit+0x26>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 800516e:	b01c      	add	sp, #112	; 0x70
 8005170:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8005172:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8005174:	a807      	add	r0, sp, #28
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8005176:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8005178:	f001 ff9a 	bl	80070b0 <HAL_RCCEx_PeriphCLKConfig>
 800517c:	2800      	cmp	r0, #0
 800517e:	d14c      	bne.n	800521a <HAL_UART_MspInit+0xce>
    __HAL_RCC_USART2_CLK_ENABLE();
 8005180:	4b2b      	ldr	r3, [pc, #172]	; (8005230 <HAL_UART_MspInit+0xe4>)
    hdma_usart2_rx.Instance = DMA1_Channel1;
 8005182:	4e2c      	ldr	r6, [pc, #176]	; (8005234 <HAL_UART_MspInit+0xe8>)
    __HAL_RCC_USART2_CLK_ENABLE();
 8005184:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8005186:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800518a:	659a      	str	r2, [r3, #88]	; 0x58
 800518c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800518e:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8005192:	9200      	str	r2, [sp, #0]
 8005194:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005196:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005198:	f042 0201 	orr.w	r2, r2, #1
 800519c:	64da      	str	r2, [r3, #76]	; 0x4c
 800519e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80051a0:	f003 0301 	and.w	r3, r3, #1
 80051a4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 80051a6:	220c      	movs	r2, #12
 80051a8:	2302      	movs	r3, #2
 80051aa:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80051ae:	2200      	movs	r2, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80051b0:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART_TX_Pin|UART_RX_Pin;
 80051b2:	2300      	movs	r3, #0
 80051b4:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051b8:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80051ba:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051bc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80051c0:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051c2:	f001 fa43 	bl	800664c <HAL_GPIO_Init>
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 80051c6:	491c      	ldr	r1, [pc, #112]	; (8005238 <HAL_UART_MspInit+0xec>)
 80051c8:	221a      	movs	r2, #26
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80051ca:	2300      	movs	r3, #0
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 80051cc:	e9c6 1200 	strd	r1, r2, [r6]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 80051d0:	4630      	mov	r0, r6
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
 80051d2:	2280      	movs	r2, #128	; 0x80
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 80051d4:	e9c6 3302 	strd	r3, r3, [r6, #8]
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80051d8:	e9c6 2304 	strd	r2, r3, [r6, #16]
    hdma_usart2_rx.Init.Mode = DMA_NORMAL;
 80051dc:	e9c6 3306 	strd	r3, r3, [r6, #24]
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
 80051e0:	6233      	str	r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 80051e2:	f001 f99d 	bl	8006520 <HAL_DMA_Init>
 80051e6:	b9f0      	cbnz	r0, 8005226 <HAL_UART_MspInit+0xda>
    hdma_usart2_tx.Instance = DMA1_Channel2;
 80051e8:	4d14      	ldr	r5, [pc, #80]	; (800523c <HAL_UART_MspInit+0xf0>)
 80051ea:	4915      	ldr	r1, [pc, #84]	; (8005240 <HAL_UART_MspInit+0xf4>)
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 80051ec:	67e6      	str	r6, [r4, #124]	; 0x7c
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 80051ee:	221b      	movs	r2, #27
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80051f0:	2300      	movs	r3, #0
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 80051f2:	e9c5 1200 	strd	r1, r2, [r5]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 80051f6:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80051f8:	2110      	movs	r1, #16
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 80051fa:	2280      	movs	r2, #128	; 0x80
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80051fc:	e9c5 1302 	strd	r1, r3, [r5, #8]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8005200:	e9c5 3305 	strd	r3, r3, [r5, #20]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8005204:	e9c5 3307 	strd	r3, r3, [r5, #28]
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
 8005208:	62b4      	str	r4, [r6, #40]	; 0x28
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 800520a:	612a      	str	r2, [r5, #16]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 800520c:	f001 f988 	bl	8006520 <HAL_DMA_Init>
 8005210:	b930      	cbnz	r0, 8005220 <HAL_UART_MspInit+0xd4>
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 8005212:	67a5      	str	r5, [r4, #120]	; 0x78
 8005214:	62ac      	str	r4, [r5, #40]	; 0x28
}
 8005216:	b01c      	add	sp, #112	; 0x70
 8005218:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 800521a:	f7fc fce9 	bl	8001bf0 <Error_Handler>
 800521e:	e7af      	b.n	8005180 <HAL_UART_MspInit+0x34>
      Error_Handler();
 8005220:	f7fc fce6 	bl	8001bf0 <Error_Handler>
 8005224:	e7f5      	b.n	8005212 <HAL_UART_MspInit+0xc6>
      Error_Handler();
 8005226:	f7fc fce3 	bl	8001bf0 <Error_Handler>
 800522a:	e7dd      	b.n	80051e8 <HAL_UART_MspInit+0x9c>
 800522c:	40004400 	.word	0x40004400
 8005230:	40021000 	.word	0x40021000
 8005234:	20002f54 	.word	0x20002f54
 8005238:	40020008 	.word	0x40020008
 800523c:	20002fb4 	.word	0x20002fb4
 8005240:	4002001c 	.word	0x4002001c

08005244 <UASPEP_INIT>:
  }
  else
  {
#endif
    /* Enable DMA UART */
    LL_USART_ClearFlag_TC(pHandle->USARTx);
 8005244:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8005246:	2340      	movs	r3, #64	; 0x40
{
 8005248:	b470      	push	{r4, r5, r6}
 800524a:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800524c:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8005250:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005254:	e842 3100 	strex	r1, r3, [r2]
 8005258:	2900      	cmp	r1, #0
 800525a:	d1f7      	bne.n	800524c <UASPEP_INIT+0x8>
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 800525c:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005260:	e851 3f00 	ldrex	r3, [r1]
 8005264:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005268:	e841 3400 	strex	r4, r3, [r1]
 800526c:	2c00      	cmp	r4, #0
 800526e:	d1f7      	bne.n	8005260 <UASPEP_INIT+0x1c>
  * @retval None
  */
__STATIC_INLINE void LL_DMA_SetPeriphAddress(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphAddress)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 8005270:	6901      	ldr	r1, [r0, #16]
 8005272:	4e17      	ldr	r6, [pc, #92]	; (80052d0 <UASPEP_INIT+0x8c>)
 8005274:	6883      	ldr	r3, [r0, #8]
 8005276:	5c74      	ldrb	r4, [r6, r1]
  * @retval None
  */
__STATIC_INLINE void LL_DMA_EnableIT_TC(DMA_TypeDef *DMAx, uint32_t Channel)
{
  uint32_t dma_base_addr = (uint32_t)DMAx;
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_TCIE);
 8005278:	6845      	ldr	r5, [r0, #4]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 800527a:	4423      	add	r3, r4
    LL_USART_EnableDMAReq_TX(pHandle->USARTx);

    /* Write the USART_TDR register address in the DMA control register to configure it as
     * the destination of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)&pHandle->USARTx->TDR);
 800527c:	f102 0128 	add.w	r1, r2, #40	; 0x28
 8005280:	6099      	str	r1, [r3, #8]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_TCIE);
 8005282:	68c3      	ldr	r3, [r0, #12]
 8005284:	5cf1      	ldrb	r1, [r6, r3]
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 8005286:	2340      	movs	r3, #64	; 0x40
 8005288:	6213      	str	r3, [r2, #32]
 800528a:	586b      	ldr	r3, [r5, r1]
 800528c:	f043 0302 	orr.w	r3, r3, #2
 8005290:	506b      	str	r3, [r5, r1]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8005292:	f102 0108 	add.w	r1, r2, #8
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005296:	e851 3f00 	ldrex	r3, [r1]
 800529a:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800529e:	e841 3400 	strex	r4, r3, [r1]
 80052a2:	2c00      	cmp	r4, #0
 80052a4:	d1f7      	bne.n	8005296 <UASPEP_INIT+0x52>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CPAR, PeriphAddress);
 80052a6:	68c3      	ldr	r3, [r0, #12]
 80052a8:	5cf0      	ldrb	r0, [r6, r3]
 80052aa:	4405      	add	r5, r0
    LL_USART_EnableIT_ERROR(pHandle->USARTx);

    /* Write the USART_RDR register address in the DMA control register to configure it as
     * the source of the transfer */
    //cstat !MISRAC2012-Rule-11.4
    LL_DMA_SetPeriphAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)&pHandle->USARTx->RDR);
 80052ac:	f102 0124 	add.w	r1, r2, #36	; 0x24
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80052b0:	2340      	movs	r3, #64	; 0x40
 80052b2:	60a9      	str	r1, [r5, #8]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80052b4:	f102 0108 	add.w	r1, r2, #8
  WRITE_REG(USARTx->ICR, USART_ICR_TCCF);
 80052b8:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80052ba:	e851 3f00 	ldrex	r3, [r1]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 80052be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80052c2:	e841 3200 	strex	r2, r3, [r1]
 80052c6:	2a00      	cmp	r2, #0
 80052c8:	d1f7      	bne.n	80052ba <UASPEP_INIT+0x76>
}
 80052ca:	bc70      	pop	{r4, r5, r6}
 80052cc:	4770      	bx	lr
 80052ce:	bf00      	nop
 80052d0:	0801a17c 	.word	0x0801a17c

080052d4 <UASPEP_SEND_PACKET>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  data Data to be transmitted to controller
  * @param  length Length of the data to be transmitted
  */
bool UASPEP_SEND_PACKET(void *pHWHandle, void *data, uint16_t length)
{
 80052d4:	b430      	push	{r4, r5}
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80052d6:	6903      	ldr	r3, [r0, #16]
 80052d8:	4d0b      	ldr	r5, [pc, #44]	; (8005308 <UASPEP_SEND_PACKET+0x34>)
 80052da:	6884      	ldr	r4, [r0, #8]
 80052dc:	5ceb      	ldrb	r3, [r5, r3]
 80052de:	58e5      	ldr	r5, [r4, r3]
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80052e0:	07ed      	lsls	r5, r5, #31
  return ((READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR,
 80052e2:	eb04 0003 	add.w	r0, r4, r3
                    DMA_CCR_EN) == (DMA_CCR_EN)) ? 1UL : 0UL);
 80052e6:	d40b      	bmi.n	8005300 <UASPEP_SEND_PACKET+0x2c>
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 80052e8:	60c1      	str	r1, [r0, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 80052ea:	6841      	ldr	r1, [r0, #4]
 80052ec:	0c09      	lsrs	r1, r1, #16
 80052ee:	0409      	lsls	r1, r1, #16
 80052f0:	430a      	orrs	r2, r1
 80052f2:	6042      	str	r2, [r0, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 80052f4:	58e2      	ldr	r2, [r4, r3]
  {
    //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
    LL_DMA_SetMemoryAddress(pHandle->txDMA, pHandle->txChannel, (uint32_t)data);
    LL_DMA_SetDataLength(pHandle->txDMA, pHandle->txChannel, length);
    LL_DMA_EnableChannel(pHandle->txDMA, pHandle->txChannel);
    result = true;
 80052f6:	2001      	movs	r0, #1
 80052f8:	4302      	orrs	r2, r0
 80052fa:	50e2      	str	r2, [r4, r3]
  else
  {
    result = false;
  }
  return (result);
}
 80052fc:	bc30      	pop	{r4, r5}
 80052fe:	4770      	bx	lr
    result = false;
 8005300:	2000      	movs	r0, #0
}
 8005302:	bc30      	pop	{r4, r5}
 8005304:	4770      	bx	lr
 8005306:	bf00      	nop
 8005308:	0801a17c 	.word	0x0801a17c

0800530c <UASPEP_RECEIVE_BUFFER>:
  * @param  pHWHandle Hardware components chosen for communication
  * @param  buffer Buffer which will receive the communicated data
  * @param  length Length of the received data
  */
void UASPEP_RECEIVE_BUFFER(void *pHWHandle, void* buffer, uint16_t length)
{
 800530c:	b430      	push	{r4, r5}
  CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 800530e:	68c3      	ldr	r3, [r0, #12]
 8005310:	4d0b      	ldr	r5, [pc, #44]	; (8005340 <UASPEP_RECEIVE_BUFFER+0x34>)
 8005312:	6844      	ldr	r4, [r0, #4]
 8005314:	5ce8      	ldrb	r0, [r5, r3]
 8005316:	5823      	ldr	r3, [r4, r0]
 8005318:	eb04 0c00 	add.w	ip, r4, r0
 800531c:	f023 0301 	bic.w	r3, r3, #1
 8005320:	5023      	str	r3, [r4, r0]
  WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CMAR, MemoryAddress);
 8005322:	f8cc 100c 	str.w	r1, [ip, #12]
  MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CNDTR,
 8005326:	f8dc 3004 	ldr.w	r3, [ip, #4]
 800532a:	0c1b      	lsrs	r3, r3, #16
 800532c:	041b      	lsls	r3, r3, #16
 800532e:	431a      	orrs	r2, r3
 8005330:	f8cc 2004 	str.w	r2, [ip, #4]
  SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)(dma_base_addr + CHANNEL_OFFSET_TAB[Channel])))->CCR, DMA_CCR_EN);
 8005334:	5823      	ldr	r3, [r4, r0]
 8005336:	f043 0301 	orr.w	r3, r3, #1
 800533a:	5023      	str	r3, [r4, r0]
  //cstat !MISRAC2012-Rule-11.4 !MISRAC2012-Rule-11.6
  LL_DMA_SetMemoryAddress(pHandle->rxDMA, pHandle->rxChannel, (uint32_t)buffer);
  LL_DMA_SetDataLength(pHandle->rxDMA, pHandle->rxChannel, length);

  LL_DMA_EnableChannel(pHandle->rxDMA, pHandle->rxChannel);
}
 800533c:	bc30      	pop	{r4, r5}
 800533e:	4770      	bx	lr
 8005340:	0801a17c 	.word	0x0801a17c

08005344 <UASPEP_IDLE_ENABLE>:
  * @param  pHandle Handler of the current instance of the UASPEP component
  */
void UASPEP_IDLE_ENABLE(void *pHWHandle)
{
  UASPEP_Handle_t *pHandle = (UASPEP_Handle_t *)pHWHandle; //cstat !MISRAC2012-Rule-11.5
  LL_USART_ClearFlag_IDLE(pHandle->USARTx);
 8005344:	6802      	ldr	r2, [r0, #0]
  WRITE_REG(USARTx->ICR, USART_ICR_IDLECF);
 8005346:	2310      	movs	r3, #16
 8005348:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800534a:	e852 3f00 	ldrex	r3, [r2]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 800534e:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005352:	e842 3100 	strex	r1, r3, [r2]
 8005356:	2900      	cmp	r1, #0
 8005358:	d1f7      	bne.n	800534a <UASPEP_IDLE_ENABLE+0x6>
  LL_USART_EnableIT_IDLE(pHandle->USARTx);
}
 800535a:	4770      	bx	lr

0800535c <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 800535c:	4a03      	ldr	r2, [pc, #12]	; (800536c <SystemInit+0x10>)
 800535e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8005362:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8005366:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800536a:	4770      	bx	lr
 800536c:	e000ed00 	.word	0xe000ed00

08005370 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8005370:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 8005372:	4b0f      	ldr	r3, [pc, #60]	; (80053b0 <HAL_InitTick+0x40>)
 8005374:	681b      	ldr	r3, [r3, #0]
 8005376:	b90b      	cbnz	r3, 800537c <HAL_InitTick+0xc>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8005378:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 800537a:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 800537c:	490d      	ldr	r1, [pc, #52]	; (80053b4 <HAL_InitTick+0x44>)
 800537e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005382:	4605      	mov	r5, r0
 8005384:	fbb2 f3f3 	udiv	r3, r2, r3
 8005388:	6808      	ldr	r0, [r1, #0]
 800538a:	fbb0 f0f3 	udiv	r0, r0, r3
 800538e:	f001 f835 	bl	80063fc <HAL_SYSTICK_Config>
 8005392:	4604      	mov	r4, r0
 8005394:	2800      	cmp	r0, #0
 8005396:	d1ef      	bne.n	8005378 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8005398:	2d0f      	cmp	r5, #15
 800539a:	d8ed      	bhi.n	8005378 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800539c:	4602      	mov	r2, r0
 800539e:	4629      	mov	r1, r5
 80053a0:	f04f 30ff 	mov.w	r0, #4294967295
 80053a4:	f000 ffde 	bl	8006364 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 80053a8:	4b03      	ldr	r3, [pc, #12]	; (80053b8 <HAL_InitTick+0x48>)
 80053aa:	4620      	mov	r0, r4
 80053ac:	601d      	str	r5, [r3, #0]
}
 80053ae:	bd38      	pop	{r3, r4, r5, pc}
 80053b0:	200014a8 	.word	0x200014a8
 80053b4:	200014a4 	.word	0x200014a4
 80053b8:	200014ac 	.word	0x200014ac

080053bc <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80053bc:	4a0a      	ldr	r2, [pc, #40]	; (80053e8 <HAL_Init+0x2c>)
 80053be:	6813      	ldr	r3, [r2, #0]
 80053c0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
{
 80053c4:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80053c6:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80053c8:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80053ca:	f000 ffb9 	bl	8006340 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80053ce:	2004      	movs	r0, #4
 80053d0:	f7ff ffce 	bl	8005370 <HAL_InitTick>
 80053d4:	b110      	cbz	r0, 80053dc <HAL_Init+0x20>
    status = HAL_ERROR;
 80053d6:	2401      	movs	r4, #1
}
 80053d8:	4620      	mov	r0, r4
 80053da:	bd10      	pop	{r4, pc}
 80053dc:	4604      	mov	r4, r0
    HAL_MspInit();
 80053de:	f7ff faeb 	bl	80049b8 <HAL_MspInit>
}
 80053e2:	4620      	mov	r0, r4
 80053e4:	bd10      	pop	{r4, pc}
 80053e6:	bf00      	nop
 80053e8:	40022000 	.word	0x40022000

080053ec <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80053ec:	4a03      	ldr	r2, [pc, #12]	; (80053fc <HAL_IncTick+0x10>)
 80053ee:	4904      	ldr	r1, [pc, #16]	; (8005400 <HAL_IncTick+0x14>)
 80053f0:	6813      	ldr	r3, [r2, #0]
 80053f2:	6809      	ldr	r1, [r1, #0]
 80053f4:	440b      	add	r3, r1
 80053f6:	6013      	str	r3, [r2, #0]
}
 80053f8:	4770      	bx	lr
 80053fa:	bf00      	nop
 80053fc:	200030a4 	.word	0x200030a4
 8005400:	200014a8 	.word	0x200014a8

08005404 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8005404:	4b01      	ldr	r3, [pc, #4]	; (800540c <HAL_GetTick+0x8>)
 8005406:	6818      	ldr	r0, [r3, #0]
}
 8005408:	4770      	bx	lr
 800540a:	bf00      	nop
 800540c:	200030a4 	.word	0x200030a4

08005410 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8005410:	b530      	push	{r4, r5, lr}
 8005412:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8005414:	2300      	movs	r3, #0
 8005416:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8005418:	2800      	cmp	r0, #0
 800541a:	f000 80d4 	beq.w	80055c6 <HAL_ADC_Init+0x1b6>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 800541e:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 8005420:	4604      	mov	r4, r0
 8005422:	2d00      	cmp	r5, #0
 8005424:	f000 809d 	beq.w	8005562 <HAL_ADC_Init+0x152>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8005428:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 800542a:	6893      	ldr	r3, [r2, #8]
 800542c:	009d      	lsls	r5, r3, #2
 800542e:	d505      	bpl.n	800543c <HAL_ADC_Init+0x2c>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8005430:	6893      	ldr	r3, [r2, #8]
 8005432:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8005436:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800543a:	6093      	str	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800543c:	6893      	ldr	r3, [r2, #8]
 800543e:	00d8      	lsls	r0, r3, #3
 8005440:	d419      	bmi.n	8005476 <HAL_ADC_Init+0x66>
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8005442:	4b7e      	ldr	r3, [pc, #504]	; (800563c <HAL_ADC_Init+0x22c>)
 8005444:	487e      	ldr	r0, [pc, #504]	; (8005640 <HAL_ADC_Init+0x230>)
 8005446:	681b      	ldr	r3, [r3, #0]
  MODIFY_REG(ADCx->CR,
 8005448:	6891      	ldr	r1, [r2, #8]
 800544a:	099b      	lsrs	r3, r3, #6
 800544c:	fba0 0303 	umull	r0, r3, r0, r3
 8005450:	f021 4110 	bic.w	r1, r1, #2415919104	; 0x90000000
 8005454:	099b      	lsrs	r3, r3, #6
 8005456:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 800545a:	3301      	adds	r3, #1
 800545c:	005b      	lsls	r3, r3, #1
 800545e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8005462:	6091      	str	r1, [r2, #8]
 8005464:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8005466:	9b01      	ldr	r3, [sp, #4]
 8005468:	b12b      	cbz	r3, 8005476 <HAL_ADC_Init+0x66>
    {
      wait_loop_index--;
 800546a:	9b01      	ldr	r3, [sp, #4]
 800546c:	3b01      	subs	r3, #1
 800546e:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8005470:	9b01      	ldr	r3, [sp, #4]
 8005472:	2b00      	cmp	r3, #0
 8005474:	d1f9      	bne.n	800546a <HAL_ADC_Init+0x5a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8005476:	6893      	ldr	r3, [r2, #8]
 8005478:	00d9      	lsls	r1, r3, #3
 800547a:	d464      	bmi.n	8005546 <HAL_ADC_Init+0x136>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800547c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800547e:	f043 0310 	orr.w	r3, r3, #16
 8005482:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8005484:	6e23      	ldr	r3, [r4, #96]	; 0x60

    tmp_hal_status = HAL_ERROR;
 8005486:	2001      	movs	r0, #1
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8005488:	4303      	orrs	r3, r0
 800548a:	6623      	str	r3, [r4, #96]	; 0x60
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800548c:	6893      	ldr	r3, [r2, #8]
 800548e:	f013 0f04 	tst.w	r3, #4
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8005492:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8005494:	d15e      	bne.n	8005554 <HAL_ADC_Init+0x144>
 8005496:	06db      	lsls	r3, r3, #27
 8005498:	d45c      	bmi.n	8005554 <HAL_ADC_Init+0x144>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800549a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800549c:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 80054a0:	f043 0302 	orr.w	r3, r3, #2
 80054a4:	65e3      	str	r3, [r4, #92]	; 0x5c
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80054a6:	6893      	ldr	r3, [r2, #8]
 80054a8:	07dd      	lsls	r5, r3, #31
 80054aa:	d419      	bmi.n	80054e0 <HAL_ADC_Init+0xd0>
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80054ac:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80054b0:	4b64      	ldr	r3, [pc, #400]	; (8005644 <HAL_ADC_Init+0x234>)
 80054b2:	f000 80a0 	beq.w	80055f6 <HAL_ADC_Init+0x1e6>
 80054b6:	429a      	cmp	r2, r3
 80054b8:	f000 80a5 	beq.w	8005606 <HAL_ADC_Init+0x1f6>
 80054bc:	4962      	ldr	r1, [pc, #392]	; (8005648 <HAL_ADC_Init+0x238>)
 80054be:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80054c2:	6889      	ldr	r1, [r1, #8]
 80054c4:	689b      	ldr	r3, [r3, #8]
 80054c6:	430b      	orrs	r3, r1
 80054c8:	4960      	ldr	r1, [pc, #384]	; (800564c <HAL_ADC_Init+0x23c>)
 80054ca:	6889      	ldr	r1, [r1, #8]
 80054cc:	430b      	orrs	r3, r1
 80054ce:	07d9      	lsls	r1, r3, #31
 80054d0:	d406      	bmi.n	80054e0 <HAL_ADC_Init+0xd0>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 80054d2:	495f      	ldr	r1, [pc, #380]	; (8005650 <HAL_ADC_Init+0x240>)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 80054d4:	688b      	ldr	r3, [r1, #8]
 80054d6:	6865      	ldr	r5, [r4, #4]
 80054d8:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 80054dc:	432b      	orrs	r3, r5
 80054de:	608b      	str	r3, [r1, #8]
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                                     |
                hadc->Init.DataAlign                                                   |
 80054e0:	68e5      	ldr	r5, [r4, #12]
 80054e2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
                hadc->Init.Resolution                                                  |
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 80054e4:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
                hadc->Init.DataAlign                                                   |
 80054e8:	432b      	orrs	r3, r5
 80054ea:	68a5      	ldr	r5, [r4, #8]
 80054ec:	432b      	orrs	r3, r5
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80054ee:	7f65      	ldrb	r5, [r4, #29]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80054f0:	2901      	cmp	r1, #1
                hadc->Init.DataAlign                                                   |
 80054f2:	ea43 3345 	orr.w	r3, r3, r5, lsl #13
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80054f6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80054fa:	d05f      	beq.n	80055bc <HAL_ADC_Init+0x1ac>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80054fc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80054fe:	b121      	cbz	r1, 800550a <HAL_ADC_Init+0xfa>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 8005500:	6b25      	ldr	r5, [r4, #48]	; 0x30
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8005502:	f401 7178 	and.w	r1, r1, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 8005506:	4329      	orrs	r1, r5
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8005508:	430b      	orrs	r3, r1
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 800550a:	68d5      	ldr	r5, [r2, #12]
 800550c:	4951      	ldr	r1, [pc, #324]	; (8005654 <HAL_ADC_Init+0x244>)
 800550e:	4029      	ands	r1, r5
 8005510:	4319      	orrs	r1, r3
 8005512:	60d1      	str	r1, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
 8005514:	6913      	ldr	r3, [r2, #16]
 8005516:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005518:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 800551c:	430b      	orrs	r3, r1
 800551e:	6113      	str	r3, [r2, #16]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005520:	6893      	ldr	r3, [r2, #8]
 8005522:	075b      	lsls	r3, r3, #29
 8005524:	d523      	bpl.n	800556e <HAL_ADC_Init+0x15e>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005526:	6893      	ldr	r3, [r2, #8]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8005528:	6963      	ldr	r3, [r4, #20]
 800552a:	2b01      	cmp	r3, #1
 800552c:	d04e      	beq.n	80055cc <HAL_ADC_Init+0x1bc>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800552e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8005530:	f023 030f 	bic.w	r3, r3, #15
 8005534:	6313      	str	r3, [r2, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8005536:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8005538:	f023 0303 	bic.w	r3, r3, #3
 800553c:	f043 0301 	orr.w	r3, r3, #1
 8005540:	65e3      	str	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
  }

  /* Return function status */
  return tmp_hal_status;
}
 8005542:	b003      	add	sp, #12
 8005544:	bd30      	pop	{r4, r5, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005546:	6893      	ldr	r3, [r2, #8]
 8005548:	f013 0f04 	tst.w	r3, #4
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800554c:	f04f 0000 	mov.w	r0, #0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8005550:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8005552:	d0a0      	beq.n	8005496 <HAL_ADC_Init+0x86>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8005554:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
 8005556:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8005558:	f043 0310 	orr.w	r3, r3, #16
 800555c:	65e3      	str	r3, [r4, #92]	; 0x5c
}
 800555e:	b003      	add	sp, #12
 8005560:	bd30      	pop	{r4, r5, pc}
    HAL_ADC_MspInit(hadc);
 8005562:	f7fb fd09 	bl	8000f78 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8005566:	6625      	str	r5, [r4, #96]	; 0x60
    hadc->Lock = HAL_UNLOCKED;
 8005568:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 800556c:	e75c      	b.n	8005428 <HAL_ADC_Init+0x18>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800556e:	6893      	ldr	r3, [r2, #8]
 8005570:	071d      	lsls	r5, r3, #28
 8005572:	d4d9      	bmi.n	8005528 <HAL_ADC_Init+0x118>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8005574:	68d1      	ldr	r1, [r2, #12]
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8005576:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 800557a:	7f25      	ldrb	r5, [r4, #28]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 800557c:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8005580:	005b      	lsls	r3, r3, #1
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8005582:	f021 0102 	bic.w	r1, r1, #2
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8005586:	ea43 3385 	orr.w	r3, r3, r5, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 800558a:	430b      	orrs	r3, r1
      if (hadc->Init.GainCompensation != 0UL)
 800558c:	6921      	ldr	r1, [r4, #16]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 800558e:	60d3      	str	r3, [r2, #12]
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8005590:	6913      	ldr	r3, [r2, #16]
      if (hadc->Init.GainCompensation != 0UL)
 8005592:	bb19      	cbnz	r1, 80055dc <HAL_ADC_Init+0x1cc>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 8005594:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005598:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, 0UL);
 800559a:	f8d2 30c0 	ldr.w	r3, [r2, #192]	; 0xc0
 800559e:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 80055a2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80055a6:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
      if (hadc->Init.OversamplingMode == ENABLE)
 80055aa:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80055ae:	2b01      	cmp	r3, #1
 80055b0:	d032      	beq.n	8005618 <HAL_ADC_Init+0x208>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80055b2:	6913      	ldr	r3, [r2, #16]
 80055b4:	f023 0301 	bic.w	r3, r3, #1
 80055b8:	6113      	str	r3, [r2, #16]
 80055ba:	e7b5      	b.n	8005528 <HAL_ADC_Init+0x118>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 80055bc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80055be:	3901      	subs	r1, #1
 80055c0:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 80055c4:	e79a      	b.n	80054fc <HAL_ADC_Init+0xec>
    return HAL_ERROR;
 80055c6:	2001      	movs	r0, #1
}
 80055c8:	b003      	add	sp, #12
 80055ca:	bd30      	pop	{r4, r5, pc}
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 80055cc:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80055ce:	6a23      	ldr	r3, [r4, #32]
 80055d0:	f021 010f 	bic.w	r1, r1, #15
 80055d4:	3b01      	subs	r3, #1
 80055d6:	430b      	orrs	r3, r1
 80055d8:	6313      	str	r3, [r2, #48]	; 0x30
 80055da:	e7ac      	b.n	8005536 <HAL_ADC_Init+0x126>
        SET_BIT(hadc->Instance->CFGR2, ADC_CFGR2_GCOMP);
 80055dc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80055e0:	6113      	str	r3, [r2, #16]
        MODIFY_REG(hadc->Instance->GCOMP, ADC_GCOMP_GCOMPCOEFF, hadc->Init.GainCompensation);
 80055e2:	f8d2 30c0 	ldr.w	r3, [r2, #192]	; 0xc0
 80055e6:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 80055ea:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80055ee:	430b      	orrs	r3, r1
 80055f0:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
 80055f4:	e7d9      	b.n	80055aa <HAL_ADC_Init+0x19a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80055f6:	6891      	ldr	r1, [r2, #8]
 80055f8:	689b      	ldr	r3, [r3, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80055fa:	430b      	orrs	r3, r1
 80055fc:	07db      	lsls	r3, r3, #31
 80055fe:	f53f af6f 	bmi.w	80054e0 <HAL_ADC_Init+0xd0>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8005602:	4915      	ldr	r1, [pc, #84]	; (8005658 <HAL_ADC_Init+0x248>)
 8005604:	e766      	b.n	80054d4 <HAL_ADC_Init+0xc4>
 8005606:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 800560a:	689b      	ldr	r3, [r3, #8]
 800560c:	6891      	ldr	r1, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800560e:	430b      	orrs	r3, r1
 8005610:	07d9      	lsls	r1, r3, #31
 8005612:	f53f af65 	bmi.w	80054e0 <HAL_ADC_Init+0xd0>
 8005616:	e7f4      	b.n	8005602 <HAL_ADC_Init+0x1f2>
        MODIFY_REG(hadc->Instance->CFGR2,
 8005618:	6911      	ldr	r1, [r2, #16]
 800561a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800561c:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 800561e:	f421 61ff 	bic.w	r1, r1, #2040	; 0x7f8
 8005622:	f021 0104 	bic.w	r1, r1, #4
 8005626:	432b      	orrs	r3, r5
 8005628:	430b      	orrs	r3, r1
 800562a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800562c:	430b      	orrs	r3, r1
 800562e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005630:	430b      	orrs	r3, r1
 8005632:	f043 0301 	orr.w	r3, r3, #1
 8005636:	6113      	str	r3, [r2, #16]
 8005638:	e776      	b.n	8005528 <HAL_ADC_Init+0x118>
 800563a:	bf00      	nop
 800563c:	200014a4 	.word	0x200014a4
 8005640:	053e2d63 	.word	0x053e2d63
 8005644:	50000100 	.word	0x50000100
 8005648:	50000400 	.word	0x50000400
 800564c:	50000600 	.word	0x50000600
 8005650:	50000700 	.word	0x50000700
 8005654:	fff04007 	.word	0xfff04007
 8005658:	50000300 	.word	0x50000300

0800565c <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 800565c:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800565e:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
{
 8005662:	b083      	sub	sp, #12
 8005664:	4603      	mov	r3, r0
  __HAL_LOCK(hadc);
 8005666:	2a01      	cmp	r2, #1
  __IO uint32_t wait_loop_index = 0UL;
 8005668:	f04f 0000 	mov.w	r0, #0
 800566c:	9001      	str	r0, [sp, #4]
  __HAL_LOCK(hadc);
 800566e:	f000 8174 	beq.w	800595a <HAL_ADC_ConfigChannel+0x2fe>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8005672:	681a      	ldr	r2, [r3, #0]
  __HAL_LOCK(hadc);
 8005674:	2001      	movs	r0, #1
 8005676:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800567a:	6894      	ldr	r4, [r2, #8]
 800567c:	0766      	lsls	r6, r4, #29
 800567e:	d45e      	bmi.n	800573e <HAL_ADC_ConfigChannel+0xe2>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8005680:	6848      	ldr	r0, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8005682:	ea4f 1e90 	mov.w	lr, r0, lsr #6
  MODIFY_REG(*preg,
 8005686:	f000 0c1f 	and.w	ip, r0, #31
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800568a:	f00e 0e0c 	and.w	lr, lr, #12
  MODIFY_REG(*preg,
 800568e:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8005690:	f102 0430 	add.w	r4, r2, #48	; 0x30
  MODIFY_REG(*preg,
 8005694:	f3c0 6084 	ubfx	r0, r0, #26, #5
 8005698:	f854 500e 	ldr.w	r5, [r4, lr]
 800569c:	261f      	movs	r6, #31
 800569e:	fa00 f00c 	lsl.w	r0, r0, ip
 80056a2:	fa06 fc0c 	lsl.w	ip, r6, ip
 80056a6:	ea25 0c0c 	bic.w	ip, r5, ip
 80056aa:	ea40 000c 	orr.w	r0, r0, ip
 80056ae:	f844 000e 	str.w	r0, [r4, lr]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80056b2:	6890      	ldr	r0, [r2, #8]
 80056b4:	0745      	lsls	r5, r0, #29
 80056b6:	d572      	bpl.n	800579e <HAL_ADC_ConfigChannel+0x142>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80056b8:	6890      	ldr	r0, [r2, #8]
 80056ba:	6808      	ldr	r0, [r1, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80056bc:	6894      	ldr	r4, [r2, #8]
 80056be:	f014 0f01 	tst.w	r4, #1
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 80056c2:	4604      	mov	r4, r0
 80056c4:	d10c      	bne.n	80056e0 <HAL_ADC_ConfigChannel+0x84>
  if (SingleDiff == LL_ADC_DIFFERENTIAL_ENDED)
 80056c6:	4dbd      	ldr	r5, [pc, #756]	; (80059bc <HAL_ADC_ConfigChannel+0x360>)
 80056c8:	68ce      	ldr	r6, [r1, #12]
 80056ca:	42ae      	cmp	r6, r5
 80056cc:	f000 80eb 	beq.w	80058a6 <HAL_ADC_ConfigChannel+0x24a>
    CLEAR_BIT(ADCx->DIFSEL,
 80056d0:	f8d2 10b0 	ldr.w	r1, [r2, #176]	; 0xb0
 80056d4:	f3c0 0012 	ubfx	r0, r0, #0, #19
 80056d8:	ea21 0100 	bic.w	r1, r1, r0
 80056dc:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80056e0:	49b7      	ldr	r1, [pc, #732]	; (80059c0 <HAL_ADC_ConfigChannel+0x364>)
 80056e2:	420c      	tst	r4, r1
 80056e4:	d059      	beq.n	800579a <HAL_ADC_ConfigChannel+0x13e>
    {
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80056e6:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80056ea:	f000 8134 	beq.w	8005956 <HAL_ADC_ConfigChannel+0x2fa>
 80056ee:	4db5      	ldr	r5, [pc, #724]	; (80059c4 <HAL_ADC_ConfigChannel+0x368>)
 80056f0:	49b5      	ldr	r1, [pc, #724]	; (80059c8 <HAL_ADC_ConfigChannel+0x36c>)
 80056f2:	48b6      	ldr	r0, [pc, #728]	; (80059cc <HAL_ADC_ConfigChannel+0x370>)
 80056f4:	42aa      	cmp	r2, r5
 80056f6:	bf18      	it	ne
 80056f8:	4601      	movne	r1, r0
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 80056fa:	6888      	ldr	r0, [r1, #8]

      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if (((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC1) || (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 80056fc:	49b4      	ldr	r1, [pc, #720]	; (80059d0 <HAL_ADC_ConfigChannel+0x374>)
 80056fe:	428c      	cmp	r4, r1
 8005700:	f000 75e0 	and.w	r5, r0, #29360128	; 0x1c00000
 8005704:	d024      	beq.n	8005750 <HAL_ADC_ConfigChannel+0xf4>
 8005706:	49b3      	ldr	r1, [pc, #716]	; (80059d4 <HAL_ADC_ConfigChannel+0x378>)
 8005708:	428c      	cmp	r4, r1
 800570a:	d021      	beq.n	8005750 <HAL_ADC_ConfigChannel+0xf4>
          {
            wait_loop_index--;
          }
        }
      }
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800570c:	49b2      	ldr	r1, [pc, #712]	; (80059d8 <HAL_ADC_ConfigChannel+0x37c>)
 800570e:	428c      	cmp	r4, r1
 8005710:	f040 8139 	bne.w	8005986 <HAL_ADC_ConfigChannel+0x32a>
 8005714:	01c4      	lsls	r4, r0, #7
 8005716:	d440      	bmi.n	800579a <HAL_ADC_ConfigChannel+0x13e>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005718:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 800571c:	f000 8215 	beq.w	8005b4a <HAL_ADC_ConfigChannel+0x4ee>
 8005720:	4ca8      	ldr	r4, [pc, #672]	; (80059c4 <HAL_ADC_ConfigChannel+0x368>)
 8005722:	49a9      	ldr	r1, [pc, #676]	; (80059c8 <HAL_ADC_ConfigChannel+0x36c>)
 8005724:	48a9      	ldr	r0, [pc, #676]	; (80059cc <HAL_ADC_ConfigChannel+0x370>)
 8005726:	42a2      	cmp	r2, r4
 8005728:	bf18      	it	ne
 800572a:	4601      	movne	r1, r0
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 800572c:	688a      	ldr	r2, [r1, #8]
 800572e:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 8005732:	432a      	orrs	r2, r5
 8005734:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005738:	2000      	movs	r0, #0
 800573a:	608a      	str	r2, [r1, #8]
}
 800573c:	e003      	b.n	8005746 <HAL_ADC_ConfigChannel+0xea>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800573e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8005740:	f042 0220 	orr.w	r2, r2, #32
 8005744:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8005746:	2200      	movs	r2, #0
 8005748:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
}
 800574c:	b003      	add	sp, #12
 800574e:	bdf0      	pop	{r4, r5, r6, r7, pc}
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8005750:	0201      	lsls	r1, r0, #8
 8005752:	d422      	bmi.n	800579a <HAL_ADC_ConfigChannel+0x13e>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8005754:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8005758:	f000 8113 	beq.w	8005982 <HAL_ADC_ConfigChannel+0x326>
 800575c:	499f      	ldr	r1, [pc, #636]	; (80059dc <HAL_ADC_ConfigChannel+0x380>)
 800575e:	428a      	cmp	r2, r1
 8005760:	d11b      	bne.n	800579a <HAL_ADC_ConfigChannel+0x13e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005762:	489a      	ldr	r0, [pc, #616]	; (80059cc <HAL_ADC_ConfigChannel+0x370>)
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8005764:	4a9e      	ldr	r2, [pc, #632]	; (80059e0 <HAL_ADC_ConfigChannel+0x384>)
 8005766:	4c9f      	ldr	r4, [pc, #636]	; (80059e4 <HAL_ADC_ConfigChannel+0x388>)
 8005768:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 800576a:	6881      	ldr	r1, [r0, #8]
 800576c:	0992      	lsrs	r2, r2, #6
 800576e:	fba4 4202 	umull	r4, r2, r4, r2
 8005772:	0992      	lsrs	r2, r2, #6
 8005774:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8005778:	3201      	adds	r2, #1
 800577a:	4329      	orrs	r1, r5
 800577c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8005780:	0092      	lsls	r2, r2, #2
 8005782:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8005786:	6081      	str	r1, [r0, #8]
 8005788:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 800578a:	9a01      	ldr	r2, [sp, #4]
 800578c:	b12a      	cbz	r2, 800579a <HAL_ADC_ConfigChannel+0x13e>
            wait_loop_index--;
 800578e:	9a01      	ldr	r2, [sp, #4]
 8005790:	3a01      	subs	r2, #1
 8005792:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8005794:	9a01      	ldr	r2, [sp, #4]
 8005796:	2a00      	cmp	r2, #0
 8005798:	d1f9      	bne.n	800578e <HAL_ADC_ConfigChannel+0x132>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800579a:	2000      	movs	r0, #0
 800579c:	e7d3      	b.n	8005746 <HAL_ADC_ConfigChannel+0xea>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800579e:	6890      	ldr	r0, [r2, #8]
 80057a0:	0700      	lsls	r0, r0, #28
 80057a2:	d47e      	bmi.n	80058a2 <HAL_ADC_ConfigChannel+0x246>
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80057a4:	6888      	ldr	r0, [r1, #8]
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80057a6:	680d      	ldr	r5, [r1, #0]
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80057a8:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 80057ac:	f000 8120 	beq.w	80059f0 <HAL_ADC_ConfigChannel+0x394>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80057b0:	0dee      	lsrs	r6, r5, #23
 80057b2:	f102 0c14 	add.w	ip, r2, #20
 80057b6:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
 80057ba:	f3c5 5504 	ubfx	r5, r5, #20, #5
 80057be:	f85c 4006 	ldr.w	r4, [ip, r6]
 80057c2:	2707      	movs	r7, #7
 80057c4:	40a8      	lsls	r0, r5
 80057c6:	fa07 f505 	lsl.w	r5, r7, r5
 80057ca:	ea24 0405 	bic.w	r4, r4, r5
 80057ce:	4320      	orrs	r0, r4
 80057d0:	f84c 0006 	str.w	r0, [ip, r6]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80057d4:	6950      	ldr	r0, [r2, #20]
 80057d6:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80057da:	6150      	str	r0, [r2, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80057dc:	e9d1 5604 	ldrd	r5, r6, [r1, #16]
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80057e0:	2d04      	cmp	r5, #4
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80057e2:	68d0      	ldr	r0, [r2, #12]
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80057e4:	d02d      	beq.n	8005842 <HAL_ADC_ConfigChannel+0x1e6>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80057e6:	f102 0460 	add.w	r4, r2, #96	; 0x60
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80057ea:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 80057ee:	0040      	lsls	r0, r0, #1
  MODIFY_REG(*preg,
 80057f0:	f854 c025 	ldr.w	ip, [r4, r5, lsl #2]
 80057f4:	4f7c      	ldr	r7, [pc, #496]	; (80059e8 <HAL_ADC_ConfigChannel+0x38c>)
 80057f6:	4086      	lsls	r6, r0
 80057f8:	6808      	ldr	r0, [r1, #0]
 80057fa:	ea0c 0707 	and.w	r7, ip, r7
 80057fe:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 8005802:	4338      	orrs	r0, r7
 8005804:	4330      	orrs	r0, r6
 8005806:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 800580a:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800580e:	690d      	ldr	r5, [r1, #16]
  MODIFY_REG(*preg,
 8005810:	698e      	ldr	r6, [r1, #24]
 8005812:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
 8005816:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 800581a:	4330      	orrs	r0, r6
 800581c:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005820:	690e      	ldr	r6, [r1, #16]
        LL_ADC_SetOffsetSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSaturation == ENABLE) ? LL_ADC_OFFSET_SATURATION_ENABLE : LL_ADC_OFFSET_SATURATION_DISABLE);
 8005822:	7f0d      	ldrb	r5, [r1, #28]
  MODIFY_REG(*preg,
 8005824:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 8005828:	f1a5 0501 	sub.w	r5, r5, #1
 800582c:	fab5 f585 	clz	r5, r5
 8005830:	096d      	lsrs	r5, r5, #5
 8005832:	f020 7000 	bic.w	r0, r0, #33554432	; 0x2000000
 8005836:	ea40 6045 	orr.w	r0, r0, r5, lsl #25
 800583a:	f844 0026 	str.w	r0, [r4, r6, lsl #2]
 800583e:	6808      	ldr	r0, [r1, #0]
}
 8005840:	e73c      	b.n	80056bc <HAL_ADC_ConfigChannel+0x60>
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005842:	6808      	ldr	r0, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005844:	6e14      	ldr	r4, [r2, #96]	; 0x60
 8005846:	6e14      	ldr	r4, [r2, #96]	; 0x60
 8005848:	f3c0 0512 	ubfx	r5, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800584c:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005850:	2d00      	cmp	r5, #0
 8005852:	f040 80df 	bne.w	8005a14 <HAL_ADC_ConfigChannel+0x3b8>
 8005856:	f3c0 6584 	ubfx	r5, r0, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800585a:	42ac      	cmp	r4, r5
 800585c:	f000 813d 	beq.w	8005ada <HAL_ADC_ConfigChannel+0x47e>
 8005860:	6e54      	ldr	r4, [r2, #100]	; 0x64
 8005862:	6e56      	ldr	r6, [r2, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005864:	f102 0460 	add.w	r4, r2, #96	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005868:	f3c6 6684 	ubfx	r6, r6, #26, #5
 800586c:	f102 0764 	add.w	r7, r2, #100	; 0x64
 8005870:	42ae      	cmp	r6, r5
 8005872:	f000 8158 	beq.w	8005b26 <HAL_ADC_ConfigChannel+0x4ca>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005876:	68a6      	ldr	r6, [r4, #8]
 8005878:	68a6      	ldr	r6, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800587a:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800587e:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8005882:	42ae      	cmp	r6, r5
 8005884:	f000 813d 	beq.w	8005b02 <HAL_ADC_ConfigChannel+0x4a6>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005888:	68e6      	ldr	r6, [r4, #12]
 800588a:	68e6      	ldr	r6, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800588c:	f104 070c 	add.w	r7, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005890:	f3c6 6484 	ubfx	r4, r6, #26, #5
 8005894:	42a5      	cmp	r5, r4
 8005896:	f47f af11 	bne.w	80056bc <HAL_ADC_ConfigChannel+0x60>
  MODIFY_REG(*preg,
 800589a:	6838      	ldr	r0, [r7, #0]
 800589c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80058a0:	6038      	str	r0, [r7, #0]
 80058a2:	6808      	ldr	r0, [r1, #0]
}
 80058a4:	e70a      	b.n	80056bc <HAL_ADC_ConfigChannel+0x60>
    SET_BIT(ADCx->DIFSEL,
 80058a6:	f8d2 40b0 	ldr.w	r4, [r2, #176]	; 0xb0
 80058aa:	f3c0 0512 	ubfx	r5, r0, #0, #19
 80058ae:	432c      	orrs	r4, r5
 80058b0:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80058b4:	2d00      	cmp	r5, #0
 80058b6:	d053      	beq.n	8005960 <HAL_ADC_ConfigChannel+0x304>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80058b8:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 80058bc:	2c00      	cmp	r4, #0
 80058be:	f000 80e8 	beq.w	8005a92 <HAL_ADC_ConfigChannel+0x436>
  return __builtin_clz(value);
 80058c2:	fab4 f484 	clz	r4, r4
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80058c6:	3401      	adds	r4, #1
 80058c8:	f004 041f 	and.w	r4, r4, #31
 80058cc:	2c09      	cmp	r4, #9
 80058ce:	f240 80e0 	bls.w	8005a92 <HAL_ADC_ConfigChannel+0x436>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80058d2:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 80058d6:	2c00      	cmp	r4, #0
 80058d8:	f000 813d 	beq.w	8005b56 <HAL_ADC_ConfigChannel+0x4fa>
  return __builtin_clz(value);
 80058dc:	fab4 f484 	clz	r4, r4
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80058e0:	3401      	adds	r4, #1
 80058e2:	06a4      	lsls	r4, r4, #26
 80058e4:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80058e8:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 80058ec:	2d00      	cmp	r5, #0
 80058ee:	f000 8130 	beq.w	8005b52 <HAL_ADC_ConfigChannel+0x4f6>
  return __builtin_clz(value);
 80058f2:	fab5 f585 	clz	r5, r5
 80058f6:	3501      	adds	r5, #1
 80058f8:	f005 051f 	and.w	r5, r5, #31
 80058fc:	2601      	movs	r6, #1
 80058fe:	fa06 f505 	lsl.w	r5, r6, r5
 8005902:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005904:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 8005908:	2800      	cmp	r0, #0
 800590a:	f000 8120 	beq.w	8005b4e <HAL_ADC_ConfigChannel+0x4f2>
  return __builtin_clz(value);
 800590e:	fab0 f080 	clz	r0, r0
 8005912:	1c45      	adds	r5, r0, #1
 8005914:	f005 051f 	and.w	r5, r5, #31
 8005918:	2003      	movs	r0, #3
 800591a:	f06f 061d 	mvn.w	r6, #29
 800591e:	fb10 6005 	smlabb	r0, r0, r5, r6
 8005922:	0500      	lsls	r0, r0, #20
 8005924:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005928:	4320      	orrs	r0, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800592a:	0dc5      	lsrs	r5, r0, #23
  MODIFY_REG(*preg,
 800592c:	688c      	ldr	r4, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800592e:	f005 0504 	and.w	r5, r5, #4
 8005932:	f102 0614 	add.w	r6, r2, #20
  MODIFY_REG(*preg,
 8005936:	f3c0 5004 	ubfx	r0, r0, #20, #5
 800593a:	fa04 fc00 	lsl.w	ip, r4, r0
 800593e:	f04f 0e07 	mov.w	lr, #7
 8005942:	5974      	ldr	r4, [r6, r5]
 8005944:	fa0e f000 	lsl.w	r0, lr, r0
 8005948:	ea24 0000 	bic.w	r0, r4, r0
 800594c:	ea40 000c 	orr.w	r0, r0, ip
 8005950:	5170      	str	r0, [r6, r5]
    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8005952:	680c      	ldr	r4, [r1, #0]
}
 8005954:	e6c4      	b.n	80056e0 <HAL_ADC_ConfigChannel+0x84>
      tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8005956:	491c      	ldr	r1, [pc, #112]	; (80059c8 <HAL_ADC_ConfigChannel+0x36c>)
 8005958:	e6cf      	b.n	80056fa <HAL_ADC_ConfigChannel+0x9e>
  __HAL_LOCK(hadc);
 800595a:	2002      	movs	r0, #2
}
 800595c:	b003      	add	sp, #12
 800595e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8005960:	0e80      	lsrs	r0, r0, #26
 8005962:	3001      	adds	r0, #1
 8005964:	f000 051f 	and.w	r5, r0, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005968:	2d09      	cmp	r5, #9
 800596a:	f200 8084 	bhi.w	8005a76 <HAL_ADC_ConfigChannel+0x41a>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800596e:	0684      	lsls	r4, r0, #26
 8005970:	2001      	movs	r0, #1
 8005972:	40a8      	lsls	r0, r5
 8005974:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 8005978:	4304      	orrs	r4, r0
 800597a:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 800597e:	0500      	lsls	r0, r0, #20
 8005980:	e7d2      	b.n	8005928 <HAL_ADC_ConfigChannel+0x2cc>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005982:	4811      	ldr	r0, [pc, #68]	; (80059c8 <HAL_ADC_ConfigChannel+0x36c>)
 8005984:	e6ee      	b.n	8005764 <HAL_ADC_ConfigChannel+0x108>
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 8005986:	4919      	ldr	r1, [pc, #100]	; (80059ec <HAL_ADC_ConfigChannel+0x390>)
 8005988:	428c      	cmp	r4, r1
 800598a:	f47f af06 	bne.w	800579a <HAL_ADC_ConfigChannel+0x13e>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800598e:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
 8005992:	f47f af02 	bne.w	800579a <HAL_ADC_ConfigChannel+0x13e>
        if (ADC_VREFINT_INSTANCE(hadc))
 8005996:	490b      	ldr	r1, [pc, #44]	; (80059c4 <HAL_ADC_ConfigChannel+0x368>)
 8005998:	428a      	cmp	r2, r1
 800599a:	f43f aefe 	beq.w	800579a <HAL_ADC_ConfigChannel+0x13e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800599e:	4c0b      	ldr	r4, [pc, #44]	; (80059cc <HAL_ADC_ConfigChannel+0x370>)
 80059a0:	f501 7100 	add.w	r1, r1, #512	; 0x200
 80059a4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 80059a8:	bf18      	it	ne
 80059aa:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 80059ac:	688a      	ldr	r2, [r1, #8]
 80059ae:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 80059b2:	432a      	orrs	r2, r5
 80059b4:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80059b8:	608a      	str	r2, [r1, #8]
}
 80059ba:	e6c4      	b.n	8005746 <HAL_ADC_ConfigChannel+0xea>
 80059bc:	407f0000 	.word	0x407f0000
 80059c0:	80080000 	.word	0x80080000
 80059c4:	50000100 	.word	0x50000100
 80059c8:	50000300 	.word	0x50000300
 80059cc:	50000700 	.word	0x50000700
 80059d0:	c3210000 	.word	0xc3210000
 80059d4:	90c00010 	.word	0x90c00010
 80059d8:	c7520000 	.word	0xc7520000
 80059dc:	50000600 	.word	0x50000600
 80059e0:	200014a4 	.word	0x200014a4
 80059e4:	053e2d63 	.word	0x053e2d63
 80059e8:	03fff000 	.word	0x03fff000
 80059ec:	cb840000 	.word	0xcb840000
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80059f0:	0de8      	lsrs	r0, r5, #23
 80059f2:	f000 0004 	and.w	r0, r0, #4
 80059f6:	f102 0414 	add.w	r4, r2, #20
  MODIFY_REG(*preg,
 80059fa:	f3c5 5504 	ubfx	r5, r5, #20, #5
 80059fe:	2607      	movs	r6, #7
 8005a00:	40ae      	lsls	r6, r5
 8005a02:	5825      	ldr	r5, [r4, r0]
 8005a04:	ea25 0506 	bic.w	r5, r5, r6
 8005a08:	5025      	str	r5, [r4, r0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005a0a:	6950      	ldr	r0, [r2, #20]
 8005a0c:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 8005a10:	6150      	str	r0, [r2, #20]
}
 8005a12:	e6e3      	b.n	80057dc <HAL_ADC_ConfigChannel+0x180>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a14:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a18:	b11d      	cbz	r5, 8005a22 <HAL_ADC_ConfigChannel+0x3c6>
  return __builtin_clz(value);
 8005a1a:	fab5 f585 	clz	r5, r5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005a1e:	42ac      	cmp	r4, r5
 8005a20:	d05b      	beq.n	8005ada <HAL_ADC_ConfigChannel+0x47e>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005a22:	6e54      	ldr	r4, [r2, #100]	; 0x64
 8005a24:	6e56      	ldr	r6, [r2, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005a26:	f102 0460 	add.w	r4, r2, #96	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005a2a:	f3c6 6684 	ubfx	r6, r6, #26, #5
 8005a2e:	f102 0764 	add.w	r7, r2, #100	; 0x64
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a32:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a36:	b11d      	cbz	r5, 8005a40 <HAL_ADC_ConfigChannel+0x3e4>
  return __builtin_clz(value);
 8005a38:	fab5 f585 	clz	r5, r5
 8005a3c:	42ae      	cmp	r6, r5
 8005a3e:	d072      	beq.n	8005b26 <HAL_ADC_ConfigChannel+0x4ca>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005a40:	68a5      	ldr	r5, [r4, #8]
 8005a42:	68a6      	ldr	r6, [r4, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005a44:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005a48:	f3c6 6684 	ubfx	r6, r6, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a4c:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a50:	b11d      	cbz	r5, 8005a5a <HAL_ADC_ConfigChannel+0x3fe>
  return __builtin_clz(value);
 8005a52:	fab5 f585 	clz	r5, r5
 8005a56:	42ae      	cmp	r6, r5
 8005a58:	d053      	beq.n	8005b02 <HAL_ADC_ConfigChannel+0x4a6>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005a5a:	68e5      	ldr	r5, [r4, #12]
 8005a5c:	68e5      	ldr	r5, [r4, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005a5e:	f104 070c 	add.w	r7, r4, #12
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005a62:	f3c5 6484 	ubfx	r4, r5, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a66:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005a6a:	2d00      	cmp	r5, #0
 8005a6c:	f43f ae26 	beq.w	80056bc <HAL_ADC_ConfigChannel+0x60>
  return __builtin_clz(value);
 8005a70:	fab5 f585 	clz	r5, r5
 8005a74:	e70e      	b.n	8005894 <HAL_ADC_ConfigChannel+0x238>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8005a76:	0684      	lsls	r4, r0, #26
 8005a78:	eb05 0045 	add.w	r0, r5, r5, lsl #1
 8005a7c:	381e      	subs	r0, #30
 8005a7e:	2601      	movs	r6, #1
 8005a80:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 8005a84:	0500      	lsls	r0, r0, #20
 8005a86:	fa06 f505 	lsl.w	r5, r6, r5
 8005a8a:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
 8005a8e:	432c      	orrs	r4, r5
 8005a90:	e74a      	b.n	8005928 <HAL_ADC_ConfigChannel+0x2cc>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005a92:	fa90 f4a0 	rbit	r4, r0
  if (value == 0U)
 8005a96:	2c00      	cmp	r4, #0
 8005a98:	d065      	beq.n	8005b66 <HAL_ADC_ConfigChannel+0x50a>
  return __builtin_clz(value);
 8005a9a:	fab4 f484 	clz	r4, r4
 8005a9e:	3401      	adds	r4, #1
 8005aa0:	06a4      	lsls	r4, r4, #26
 8005aa2:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005aa6:	fa90 f5a0 	rbit	r5, r0
  if (value == 0U)
 8005aaa:	2d00      	cmp	r5, #0
 8005aac:	d059      	beq.n	8005b62 <HAL_ADC_ConfigChannel+0x506>
  return __builtin_clz(value);
 8005aae:	fab5 f585 	clz	r5, r5
 8005ab2:	3501      	adds	r5, #1
 8005ab4:	f005 051f 	and.w	r5, r5, #31
 8005ab8:	2601      	movs	r6, #1
 8005aba:	fa06 f505 	lsl.w	r5, r6, r5
 8005abe:	432c      	orrs	r4, r5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005ac0:	fa90 f0a0 	rbit	r0, r0
  if (value == 0U)
 8005ac4:	2800      	cmp	r0, #0
 8005ac6:	d049      	beq.n	8005b5c <HAL_ADC_ConfigChannel+0x500>
  return __builtin_clz(value);
 8005ac8:	fab0 f080 	clz	r0, r0
 8005acc:	3001      	adds	r0, #1
 8005ace:	f000 001f 	and.w	r0, r0, #31
 8005ad2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8005ad6:	0500      	lsls	r0, r0, #20
 8005ad8:	e726      	b.n	8005928 <HAL_ADC_ConfigChannel+0x2cc>
  MODIFY_REG(*preg,
 8005ada:	6e10      	ldr	r0, [r2, #96]	; 0x60
 8005adc:	4614      	mov	r4, r2
 8005ade:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005ae2:	f844 0f60 	str.w	r0, [r4, #96]!
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005ae6:	6e50      	ldr	r0, [r2, #100]	; 0x64
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005ae8:	6808      	ldr	r0, [r1, #0]
 8005aea:	6e56      	ldr	r6, [r2, #100]	; 0x64
 8005aec:	f3c0 0512 	ubfx	r5, r0, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005af0:	f102 0764 	add.w	r7, r2, #100	; 0x64
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005af4:	f3c6 6684 	ubfx	r6, r6, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005af8:	2d00      	cmp	r5, #0
 8005afa:	d19a      	bne.n	8005a32 <HAL_ADC_ConfigChannel+0x3d6>
 8005afc:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b00:	e6b6      	b.n	8005870 <HAL_ADC_ConfigChannel+0x214>
  MODIFY_REG(*preg,
 8005b02:	6838      	ldr	r0, [r7, #0]
 8005b04:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005b08:	6038      	str	r0, [r7, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b0a:	68e0      	ldr	r0, [r4, #12]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b0c:	6808      	ldr	r0, [r1, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005b0e:	f104 070c 	add.w	r7, r4, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b12:	68e4      	ldr	r4, [r4, #12]
 8005b14:	f3c0 0512 	ubfx	r5, r0, #0, #19
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005b18:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b1c:	2d00      	cmp	r5, #0
 8005b1e:	d1a2      	bne.n	8005a66 <HAL_ADC_ConfigChannel+0x40a>
 8005b20:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b24:	e6b6      	b.n	8005894 <HAL_ADC_ConfigChannel+0x238>
  MODIFY_REG(*preg,
 8005b26:	6838      	ldr	r0, [r7, #0]
 8005b28:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8005b2c:	6038      	str	r0, [r7, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005b2e:	68a0      	ldr	r0, [r4, #8]
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b30:	6808      	ldr	r0, [r1, #0]
 8005b32:	68a6      	ldr	r6, [r4, #8]
 8005b34:	f3c0 0512 	ubfx	r5, r0, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005b38:	f104 0708 	add.w	r7, r4, #8
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005b3c:	f3c6 6684 	ubfx	r6, r6, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8005b40:	2d00      	cmp	r5, #0
 8005b42:	d183      	bne.n	8005a4c <HAL_ADC_ConfigChannel+0x3f0>
 8005b44:	f3c0 6584 	ubfx	r5, r0, #26, #5
 8005b48:	e69b      	b.n	8005882 <HAL_ADC_ConfigChannel+0x226>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005b4a:	4908      	ldr	r1, [pc, #32]	; (8005b6c <HAL_ADC_ConfigChannel+0x510>)
 8005b4c:	e5ee      	b.n	800572c <HAL_ADC_ConfigChannel+0xd0>
 8005b4e:	4808      	ldr	r0, [pc, #32]	; (8005b70 <HAL_ADC_ConfigChannel+0x514>)
 8005b50:	e6ea      	b.n	8005928 <HAL_ADC_ConfigChannel+0x2cc>
 8005b52:	2502      	movs	r5, #2
 8005b54:	e6d5      	b.n	8005902 <HAL_ADC_ConfigChannel+0x2a6>
 8005b56:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 8005b5a:	e6c5      	b.n	80058e8 <HAL_ADC_ConfigChannel+0x28c>
 8005b5c:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 8005b60:	e6e2      	b.n	8005928 <HAL_ADC_ConfigChannel+0x2cc>
 8005b62:	2502      	movs	r5, #2
 8005b64:	e7ab      	b.n	8005abe <HAL_ADC_ConfigChannel+0x462>
 8005b66:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 8005b6a:	e79c      	b.n	8005aa6 <HAL_ADC_ConfigChannel+0x44a>
 8005b6c:	50000300 	.word	0x50000300
 8005b70:	fe500000 	.word	0xfe500000

08005b74 <HAL_ADCEx_InjectedConfigChannel>:
  * @param sConfigInjected Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
{
 8005b74:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8005b76:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
{
 8005b7a:	4602      	mov	r2, r0
 8005b7c:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0;
 8005b7e:	2000      	movs	r0, #0
  __HAL_LOCK(hadc);
 8005b80:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0;
 8005b82:	9001      	str	r0, [sp, #4]
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8005b84:	6950      	ldr	r0, [r2, #20]
  __HAL_LOCK(hadc);
 8005b86:	f000 8178 	beq.w	8005e7a <HAL_ADCEx_InjectedConfigChannel+0x306>
 8005b8a:	2301      	movs	r3, #1
 8005b8c:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58
  /*      injected channel rank. It is entered into queue only when all       */
  /*      injected ranks have been set.                                       */
  /*   Note: Scan mode is not present by hardware on this device, but used    */
  /*   by software for alignment over all STM32 devices.                      */

  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8005b90:	b1e8      	cbz	r0, 8005bce <HAL_ADCEx_InjectedConfigChannel+0x5a>
      (sConfigInjected->InjectedNbrOfConversion == 1U))
 8005b92:	6a0b      	ldr	r3, [r1, #32]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8005b94:	2b01      	cmp	r3, #1
 8005b96:	d01a      	beq.n	8005bce <HAL_ADCEx_InjectedConfigChannel+0x5a>
    /* 1. Start new context and set parameters related to all injected        */
    /*    channels: injected sequence length and trigger.                     */

    /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
    /*   call of the context under setting                                    */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005b98:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8005b9a:	2800      	cmp	r0, #0
 8005b9c:	f040 8129 	bne.w	8005df2 <HAL_ADCEx_InjectedConfigChannel+0x27e>
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005ba0:	6a88      	ldr	r0, [r1, #40]	; 0x28
 8005ba2:	2800      	cmp	r0, #0
 8005ba4:	f000 823f 	beq.w	8006026 <HAL_ADCEx_InjectedConfigChannel+0x4b2>
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005ba8:	1e5e      	subs	r6, r3, #1
 8005baa:	6acc      	ldr	r4, [r1, #44]	; 0x2c
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8005bac:	f000 007c 	and.w	r0, r0, #124	; 0x7c
 8005bb0:	4330      	orrs	r0, r6
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005bb2:	ea40 0304 	orr.w	r3, r0, r4
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005bb6:	e9d1 4500 	ldrd	r4, r5, [r1]
 8005bba:	f005 051f 	and.w	r5, r5, #31
 8005bbe:	f3c4 6084 	ubfx	r0, r4, #26, #5
 8005bc2:	40a8      	lsls	r0, r5
    hadc->InjectionConfig.ChannelCount--;

    /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
          call, aggregate the setting to those already built during the previous
          HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005bc4:	4318      	orrs	r0, r3
    hadc->InjectionConfig.ChannelCount--;
 8005bc6:	6696      	str	r6, [r2, #104]	; 0x68

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005bc8:	6813      	ldr	r3, [r2, #0]
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005bca:	6650      	str	r0, [r2, #100]	; 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005bcc:	e005      	b.n	8005bda <HAL_ADCEx_InjectedConfigChannel+0x66>
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 8005bce:	684b      	ldr	r3, [r1, #4]
 8005bd0:	2b09      	cmp	r3, #9
 8005bd2:	f000 80fa 	beq.w	8005dca <HAL_ADCEx_InjectedConfigChannel+0x256>
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005bd6:	680c      	ldr	r4, [r1, #0]
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005bd8:	6813      	ldr	r3, [r2, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005bda:	6898      	ldr	r0, [r3, #8]
 8005bdc:	0707      	lsls	r7, r0, #28
 8005bde:	d410      	bmi.n	8005c02 <HAL_ADCEx_InjectedConfigChannel+0x8e>
  /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
  /*    mode is disabled.                                                     */
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (sConfigInjected->AutoInjectedConv == DISABLE)
 8005be0:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005be4:	2800      	cmp	r0, #0
 8005be6:	f040 80e7 	bne.w	8005db8 <HAL_ADCEx_InjectedConfigChannel+0x244>
    {
      MODIFY_REG(hadc->Instance->CFGR,
 8005bea:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
 8005bee:	68dd      	ldr	r5, [r3, #12]
 8005bf0:	f891 6026 	ldrb.w	r6, [r1, #38]	; 0x26
 8005bf4:	0500      	lsls	r0, r0, #20
 8005bf6:	f425 1540 	bic.w	r5, r5, #3145728	; 0x300000
 8005bfa:	ea40 5046 	orr.w	r0, r0, r6, lsl #21
 8005bfe:	4328      	orrs	r0, r5
 8005c00:	60d8      	str	r0, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8005c02:	6898      	ldr	r0, [r3, #8]
 8005c04:	f010 0004 	ands.w	r0, r0, #4
 8005c08:	d06a      	beq.n	8005ce0 <HAL_ADCEx_InjectedConfigChannel+0x16c>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005c0a:	6898      	ldr	r0, [r3, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005c0c:	2000      	movs	r0, #0
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8005c0e:	689d      	ldr	r5, [r3, #8]
 8005c10:	07ee      	lsls	r6, r5, #31
 8005c12:	d40c      	bmi.n	8005c2e <HAL_ADCEx_InjectedConfigChannel+0xba>
  if (SingleDiff == LL_ADC_DIFFERENTIAL_ENDED)
 8005c14:	4da9      	ldr	r5, [pc, #676]	; (8005ebc <HAL_ADCEx_InjectedConfigChannel+0x348>)
 8005c16:	68ce      	ldr	r6, [r1, #12]
 8005c18:	42ae      	cmp	r6, r5
 8005c1a:	f000 810f 	beq.w	8005e3c <HAL_ADCEx_InjectedConfigChannel+0x2c8>
    CLEAR_BIT(ADCx->DIFSEL,
 8005c1e:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
 8005c22:	f3c4 0512 	ubfx	r5, r4, #0, #19
 8005c26:	ea21 0105 	bic.w	r1, r1, r5
 8005c2a:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0
  /* internal measurement paths enable: If internal channel selected,       */
  /* enable dedicated internal buffers and path.                            */
  /* Note: these internal measurement paths can be disabled using           */
  /* HAL_ADC_DeInit().                                                      */

  if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 8005c2e:	49a4      	ldr	r1, [pc, #656]	; (8005ec0 <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 8005c30:	420c      	tst	r4, r1
 8005c32:	d029      	beq.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
  {
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8005c34:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005c38:	f000 811d 	beq.w	8005e76 <HAL_ADCEx_InjectedConfigChannel+0x302>
 8005c3c:	4ea1      	ldr	r6, [pc, #644]	; (8005ec4 <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005c3e:	49a2      	ldr	r1, [pc, #648]	; (8005ec8 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005c40:	4da2      	ldr	r5, [pc, #648]	; (8005ecc <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005c42:	42b3      	cmp	r3, r6
 8005c44:	bf18      	it	ne
 8005c46:	4629      	movne	r1, r5

    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if (((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC1)
 8005c48:	4da1      	ldr	r5, [pc, #644]	; (8005ed0 <HAL_ADCEx_InjectedConfigChannel+0x35c>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL));
 8005c4a:	6889      	ldr	r1, [r1, #8]
 8005c4c:	42ac      	cmp	r4, r5
 8005c4e:	f001 76e0 	and.w	r6, r1, #29360128	; 0x1c00000
 8005c52:	d01e      	beq.n	8005c92 <HAL_ADCEx_InjectedConfigChannel+0x11e>
         || (sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR_ADC5))
 8005c54:	4d9f      	ldr	r5, [pc, #636]	; (8005ed4 <HAL_ADCEx_InjectedConfigChannel+0x360>)
 8005c56:	42ac      	cmp	r4, r5
 8005c58:	d01b      	beq.n	8005c92 <HAL_ADCEx_InjectedConfigChannel+0x11e>
        {
          wait_loop_index--;
        }
      }
    }
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
 8005c5a:	4d9f      	ldr	r5, [pc, #636]	; (8005ed8 <HAL_ADCEx_InjectedConfigChannel+0x364>)
 8005c5c:	42ac      	cmp	r4, r5
 8005c5e:	f040 8113 	bne.w	8005e88 <HAL_ADCEx_InjectedConfigChannel+0x314>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8005c62:	01cd      	lsls	r5, r1, #7
 8005c64:	d410      	bmi.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
    {
      if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
      {
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005c66:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005c6a:	f000 8249 	beq.w	8006100 <HAL_ADCEx_InjectedConfigChannel+0x58c>
 8005c6e:	4d95      	ldr	r5, [pc, #596]	; (8005ec4 <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005c70:	4995      	ldr	r1, [pc, #596]	; (8005ec8 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005c72:	4c96      	ldr	r4, [pc, #600]	; (8005ecc <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005c74:	42ab      	cmp	r3, r5
 8005c76:	bf18      	it	ne
 8005c78:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005c7a:	688b      	ldr	r3, [r1, #8]
 8005c7c:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005c80:	4333      	orrs	r3, r6
 8005c82:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005c86:	608b      	str	r3, [r1, #8]
      /* nothing to do */
    }
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8005c88:	2300      	movs	r3, #0
 8005c8a:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58

  /* Return function status */
  return tmp_hal_status;
}
 8005c8e:	b003      	add	sp, #12
 8005c90:	bdf0      	pop	{r4, r5, r6, r7, pc}
        && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8005c92:	0209      	lsls	r1, r1, #8
 8005c94:	d4f8      	bmi.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
      if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8005c96:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005c9a:	f000 8233 	beq.w	8006104 <HAL_ADCEx_InjectedConfigChannel+0x590>
 8005c9e:	498f      	ldr	r1, [pc, #572]	; (8005edc <HAL_ADCEx_InjectedConfigChannel+0x368>)
 8005ca0:	428b      	cmp	r3, r1
 8005ca2:	d1f1      	bne.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005ca4:	4c89      	ldr	r4, [pc, #548]	; (8005ecc <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005ca6:	68a1      	ldr	r1, [r4, #8]
        wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (((SystemCoreClock / (100000UL * 2UL)) + 1UL) + 1UL));
 8005ca8:	4b8d      	ldr	r3, [pc, #564]	; (8005ee0 <HAL_ADCEx_InjectedConfigChannel+0x36c>)
 8005caa:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8005cae:	4331      	orrs	r1, r6
 8005cb0:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8005cb4:	681b      	ldr	r3, [r3, #0]
 8005cb6:	60a1      	str	r1, [r4, #8]
 8005cb8:	498a      	ldr	r1, [pc, #552]	; (8005ee4 <HAL_ADCEx_InjectedConfigChannel+0x370>)
 8005cba:	099b      	lsrs	r3, r3, #6
 8005cbc:	fba1 1303 	umull	r1, r3, r1, r3
 8005cc0:	099b      	lsrs	r3, r3, #6
 8005cc2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8005cc6:	009b      	lsls	r3, r3, #2
 8005cc8:	3318      	adds	r3, #24
 8005cca:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8005ccc:	9b01      	ldr	r3, [sp, #4]
 8005cce:	2b00      	cmp	r3, #0
 8005cd0:	d0da      	beq.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
          wait_loop_index--;
 8005cd2:	9b01      	ldr	r3, [sp, #4]
 8005cd4:	3b01      	subs	r3, #1
 8005cd6:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 8005cd8:	9b01      	ldr	r3, [sp, #4]
 8005cda:	2b00      	cmp	r3, #0
 8005cdc:	d1f9      	bne.n	8005cd2 <HAL_ADCEx_InjectedConfigChannel+0x15e>
 8005cde:	e7d3      	b.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005ce0:	689d      	ldr	r5, [r3, #8]
 8005ce2:	f015 0508 	ands.w	r5, r5, #8
 8005ce6:	d192      	bne.n	8005c0e <HAL_ADCEx_InjectedConfigChannel+0x9a>
    if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8005ce8:	6a88      	ldr	r0, [r1, #40]	; 0x28
 8005cea:	2800      	cmp	r0, #0
 8005cec:	f040 8097 	bne.w	8005e1e <HAL_ADCEx_InjectedConfigChannel+0x2aa>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005cf0:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005cf4:	2801      	cmp	r0, #1
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005cf6:	68d8      	ldr	r0, [r3, #12]
 8005cf8:	bf0c      	ite	eq
 8005cfa:	f040 7000 	orreq.w	r0, r0, #33554432	; 0x2000000
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005cfe:	f020 7000 	bicne.w	r0, r0, #33554432	; 0x2000000
 8005d02:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005d04:	2000      	movs	r0, #0
    if (sConfigInjected->InjecOversamplingMode == ENABLE)
 8005d06:	f891 5030 	ldrb.w	r5, [r1, #48]	; 0x30
 8005d0a:	2d01      	cmp	r5, #1
 8005d0c:	f000 8149 	beq.w	8005fa2 <HAL_ADCEx_InjectedConfigChannel+0x42e>
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 8005d10:	691d      	ldr	r5, [r3, #16]
 8005d12:	f025 0502 	bic.w	r5, r5, #2
 8005d16:	611d      	str	r5, [r3, #16]
    if (sConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8005d18:	688d      	ldr	r5, [r1, #8]
 8005d1a:	f1b5 4f00 	cmp.w	r5, #2147483648	; 0x80000000
 8005d1e:	f000 812e 	beq.w	8005f7e <HAL_ADCEx_InjectedConfigChannel+0x40a>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005d22:	0de6      	lsrs	r6, r4, #23
 8005d24:	f006 0604 	and.w	r6, r6, #4
 8005d28:	f103 0c14 	add.w	ip, r3, #20
  MODIFY_REG(*preg,
 8005d2c:	f3c4 5404 	ubfx	r4, r4, #20, #5
 8005d30:	2707      	movs	r7, #7
 8005d32:	40a5      	lsls	r5, r4
 8005d34:	40a7      	lsls	r7, r4
 8005d36:	f85c 4006 	ldr.w	r4, [ip, r6]
 8005d3a:	ea24 0407 	bic.w	r4, r4, r7
 8005d3e:	432c      	orrs	r4, r5
 8005d40:	f84c 4006 	str.w	r4, [ip, r6]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005d44:	695c      	ldr	r4, [r3, #20]
 8005d46:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8005d4a:	615c      	str	r4, [r3, #20]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8005d4c:	e9d1 6504 	ldrd	r6, r5, [r1, #16]
 8005d50:	2e04      	cmp	r6, #4
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 8005d52:	68dc      	ldr	r4, [r3, #12]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 8005d54:	f000 80ce 	beq.w	8005ef4 <HAL_ADCEx_InjectedConfigChannel+0x380>
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 8005d58:	f3c4 04c1 	ubfx	r4, r4, #3, #2
 8005d5c:	0064      	lsls	r4, r4, #1
 8005d5e:	fa05 fc04 	lsl.w	ip, r5, r4
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005d62:	f103 0560 	add.w	r5, r3, #96	; 0x60
  MODIFY_REG(*preg,
 8005d66:	680c      	ldr	r4, [r1, #0]
 8005d68:	f855 e026 	ldr.w	lr, [r5, r6, lsl #2]
 8005d6c:	4f5e      	ldr	r7, [pc, #376]	; (8005ee8 <HAL_ADCEx_InjectedConfigChannel+0x374>)
 8005d6e:	f004 44f8 	and.w	r4, r4, #2080374784	; 0x7c000000
 8005d72:	ea0e 0707 	and.w	r7, lr, r7
 8005d76:	433c      	orrs	r4, r7
 8005d78:	ea44 040c 	orr.w	r4, r4, ip
 8005d7c:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8005d80:	f845 4026 	str.w	r4, [r5, r6, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005d84:	690f      	ldr	r7, [r1, #16]
  MODIFY_REG(*preg,
 8005d86:	698e      	ldr	r6, [r1, #24]
 8005d88:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8005d8c:	f024 7480 	bic.w	r4, r4, #16777216	; 0x1000000
 8005d90:	4334      	orrs	r4, r6
 8005d92:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005d96:	690f      	ldr	r7, [r1, #16]
      LL_ADC_SetOffsetSaturation(hadc->Instance, sConfigInjected->InjectedOffsetNumber,
 8005d98:	7f0e      	ldrb	r6, [r1, #28]
  MODIFY_REG(*preg,
 8005d9a:	f855 4027 	ldr.w	r4, [r5, r7, lsl #2]
 8005d9e:	f1a6 0601 	sub.w	r6, r6, #1
 8005da2:	fab6 f686 	clz	r6, r6
 8005da6:	0976      	lsrs	r6, r6, #5
 8005da8:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
 8005dac:	ea44 6446 	orr.w	r4, r4, r6, lsl #25
 8005db0:	f845 4027 	str.w	r4, [r5, r7, lsl #2]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 8005db4:	680c      	ldr	r4, [r1, #0]
}
 8005db6:	e72a      	b.n	8005c0e <HAL_ADCEx_InjectedConfigChannel+0x9a>
      MODIFY_REG(hadc->Instance->CFGR,
 8005db8:	68d8      	ldr	r0, [r3, #12]
 8005dba:	f891 5026 	ldrb.w	r5, [r1, #38]	; 0x26
 8005dbe:	f420 1040 	bic.w	r0, r0, #3145728	; 0x300000
 8005dc2:	ea40 5045 	orr.w	r0, r0, r5, lsl #21
 8005dc6:	60d8      	str	r0, [r3, #12]
 8005dc8:	e71b      	b.n	8005c02 <HAL_ADCEx_InjectedConfigChannel+0x8e>
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005dca:	6a8b      	ldr	r3, [r1, #40]	; 0x28
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005dcc:	680c      	ldr	r4, [r1, #0]
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 8005dce:	2b00      	cmp	r3, #0
 8005dd0:	d056      	beq.n	8005e80 <HAL_ADCEx_InjectedConfigChannel+0x30c>
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005dd2:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8005dd4:	f003 037c 	and.w	r3, r3, #124	; 0x7c
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 8005dd8:	0c65      	lsrs	r5, r4, #17
 8005dda:	f405 5578 	and.w	r5, r5, #15872	; 0x3e00
 8005dde:	4303      	orrs	r3, r0
 8005de0:	431d      	orrs	r5, r3
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
 8005de2:	6813      	ldr	r3, [r2, #0]
 8005de4:	4e41      	ldr	r6, [pc, #260]	; (8005eec <HAL_ADCEx_InjectedConfigChannel+0x378>)
 8005de6:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 8005de8:	4030      	ands	r0, r6
 8005dea:	4328      	orrs	r0, r5
 8005dec:	64d8      	str	r0, [r3, #76]	; 0x4c
      hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
 8005dee:	6655      	str	r5, [r2, #100]	; 0x64
 8005df0:	e6f3      	b.n	8005bda <HAL_ADCEx_InjectedConfigChannel+0x66>
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005df2:	680c      	ldr	r4, [r1, #0]
 8005df4:	684b      	ldr	r3, [r1, #4]
 8005df6:	f3c4 6584 	ubfx	r5, r4, #26, #5
 8005dfa:	f003 031f 	and.w	r3, r3, #31
 8005dfe:	409d      	lsls	r5, r3
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e00:	6e53      	ldr	r3, [r2, #100]	; 0x64
    hadc->InjectionConfig.ChannelCount--;
 8005e02:	3801      	subs	r0, #1
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e04:	431d      	orrs	r5, r3
    hadc->InjectionConfig.ChannelCount--;
 8005e06:	6690      	str	r0, [r2, #104]	; 0x68
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005e08:	6813      	ldr	r3, [r2, #0]
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005e0a:	6655      	str	r5, [r2, #100]	; 0x64
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005e0c:	2800      	cmp	r0, #0
 8005e0e:	f47f aee4 	bne.w	8005bda <HAL_ADCEx_InjectedConfigChannel+0x66>
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005e12:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 8005e14:	4e35      	ldr	r6, [pc, #212]	; (8005eec <HAL_ADCEx_InjectedConfigChannel+0x378>)
 8005e16:	4030      	ands	r0, r6
 8005e18:	4328      	orrs	r0, r5
 8005e1a:	64d8      	str	r0, [r3, #76]	; 0x4c
 8005e1c:	e6dd      	b.n	8005bda <HAL_ADCEx_InjectedConfigChannel+0x66>
        || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 8005e1e:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 8005e20:	2800      	cmp	r0, #0
 8005e22:	f43f af65 	beq.w	8005cf0 <HAL_ADCEx_InjectedConfigChannel+0x17c>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005e26:	f891 0025 	ldrb.w	r0, [r1, #37]	; 0x25
 8005e2a:	2801      	cmp	r0, #1
 8005e2c:	f000 8163 	beq.w	80060f6 <HAL_ADCEx_InjectedConfigChannel+0x582>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005e30:	4628      	mov	r0, r5
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005e32:	68dd      	ldr	r5, [r3, #12]
 8005e34:	f025 7500 	bic.w	r5, r5, #33554432	; 0x2000000
 8005e38:	60dd      	str	r5, [r3, #12]
 8005e3a:	e764      	b.n	8005d06 <HAL_ADCEx_InjectedConfigChannel+0x192>
    SET_BIT(ADCx->DIFSEL,
 8005e3c:	f8d3 50b0 	ldr.w	r5, [r3, #176]	; 0xb0
 8005e40:	f3c4 0612 	ubfx	r6, r4, #0, #19
 8005e44:	4335      	orrs	r5, r6
 8005e46:	f8c3 50b0 	str.w	r5, [r3, #176]	; 0xb0
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8005e4a:	2e00      	cmp	r6, #0
 8005e4c:	f040 80b4 	bne.w	8005fb8 <HAL_ADCEx_InjectedConfigChannel+0x444>
 8005e50:	0ea4      	lsrs	r4, r4, #26
 8005e52:	3401      	adds	r4, #1
 8005e54:	f004 0c1f 	and.w	ip, r4, #31
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005e58:	f1bc 0f09 	cmp.w	ip, #9
 8005e5c:	f200 80e6 	bhi.w	800602c <HAL_ADCEx_InjectedConfigChannel+0x4b8>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8005e60:	06a5      	lsls	r5, r4, #26
 8005e62:	2401      	movs	r4, #1
 8005e64:	fa04 f40c 	lsl.w	r4, r4, ip
 8005e68:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 8005e6c:	4325      	orrs	r5, r4
 8005e6e:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8005e72:	0524      	lsls	r4, r4, #20
 8005e74:	e0e7      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8005e76:	4914      	ldr	r1, [pc, #80]	; (8005ec8 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 8005e78:	e6e6      	b.n	8005c48 <HAL_ADCEx_InjectedConfigChannel+0xd4>
  __HAL_LOCK(hadc);
 8005e7a:	2002      	movs	r0, #2
}
 8005e7c:	b003      	add	sp, #12
 8005e7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
 8005e80:	0c65      	lsrs	r5, r4, #17
 8005e82:	f405 5578 	and.w	r5, r5, #15872	; 0x3e00
 8005e86:	e7ac      	b.n	8005de2 <HAL_ADCEx_InjectedConfigChannel+0x26e>
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
 8005e88:	4d19      	ldr	r5, [pc, #100]	; (8005ef0 <HAL_ADCEx_InjectedConfigChannel+0x37c>)
 8005e8a:	42ac      	cmp	r4, r5
 8005e8c:	f47f aefc 	bne.w	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8005e90:	024c      	lsls	r4, r1, #9
 8005e92:	f53f aef9 	bmi.w	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
      if (ADC_VREFINT_INSTANCE(hadc))
 8005e96:	490b      	ldr	r1, [pc, #44]	; (8005ec4 <HAL_ADCEx_InjectedConfigChannel+0x350>)
 8005e98:	428b      	cmp	r3, r1
 8005e9a:	f43f aef5 	beq.w	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8005e9e:	4c0b      	ldr	r4, [pc, #44]	; (8005ecc <HAL_ADCEx_InjectedConfigChannel+0x358>)
 8005ea0:	f501 7100 	add.w	r1, r1, #512	; 0x200
 8005ea4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005ea8:	bf18      	it	ne
 8005eaa:	4621      	movne	r1, r4
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VSENSESEL | ADC_CCR_VBATSEL, PathInternal);
 8005eac:	688b      	ldr	r3, [r1, #8]
 8005eae:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005eb2:	4333      	orrs	r3, r6
 8005eb4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8005eb8:	608b      	str	r3, [r1, #8]
}
 8005eba:	e6e5      	b.n	8005c88 <HAL_ADCEx_InjectedConfigChannel+0x114>
 8005ebc:	407f0000 	.word	0x407f0000
 8005ec0:	80080000 	.word	0x80080000
 8005ec4:	50000100 	.word	0x50000100
 8005ec8:	50000300 	.word	0x50000300
 8005ecc:	50000700 	.word	0x50000700
 8005ed0:	c3210000 	.word	0xc3210000
 8005ed4:	90c00010 	.word	0x90c00010
 8005ed8:	c7520000 	.word	0xc7520000
 8005edc:	50000600 	.word	0x50000600
 8005ee0:	200014a4 	.word	0x200014a4
 8005ee4:	053e2d63 	.word	0x053e2d63
 8005ee8:	03fff000 	.word	0x03fff000
 8005eec:	04104000 	.word	0x04104000
 8005ef0:	cb840000 	.word	0xcb840000
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005ef4:	6e1c      	ldr	r4, [r3, #96]	; 0x60
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005ef6:	680c      	ldr	r4, [r1, #0]
 8005ef8:	6e1d      	ldr	r5, [r3, #96]	; 0x60
 8005efa:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005efe:	f3c5 6584 	ubfx	r5, r5, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005f02:	2e00      	cmp	r6, #0
 8005f04:	f000 80b7 	beq.w	8006076 <HAL_ADCEx_InjectedConfigChannel+0x502>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f08:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f0c:	b126      	cbz	r6, 8005f18 <HAL_ADCEx_InjectedConfigChannel+0x3a4>
  return __builtin_clz(value);
 8005f0e:	fab6 f686 	clz	r6, r6
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 8005f12:	42b5      	cmp	r5, r6
 8005f14:	f000 80f8 	beq.w	8006108 <HAL_ADCEx_InjectedConfigChannel+0x594>
 8005f18:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 8005f1a:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f1c:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8005f20:	f3c7 6784 	ubfx	r7, r7, #26, #5
 8005f24:	f103 0c64 	add.w	ip, r3, #100	; 0x64
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f28:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f2c:	b126      	cbz	r6, 8005f38 <HAL_ADCEx_InjectedConfigChannel+0x3c4>
  return __builtin_clz(value);
 8005f2e:	fab6 f686 	clz	r6, r6
 8005f32:	42b7      	cmp	r7, r6
 8005f34:	f000 80fd 	beq.w	8006132 <HAL_ADCEx_InjectedConfigChannel+0x5be>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005f38:	68ae      	ldr	r6, [r5, #8]
 8005f3a:	68af      	ldr	r7, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f3c:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8005f40:	f3c7 6784 	ubfx	r7, r7, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f44:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f48:	b126      	cbz	r6, 8005f54 <HAL_ADCEx_InjectedConfigChannel+0x3e0>
  return __builtin_clz(value);
 8005f4a:	fab6 f686 	clz	r6, r6
 8005f4e:	42b7      	cmp	r7, r6
 8005f50:	f000 8104 	beq.w	800615c <HAL_ADCEx_InjectedConfigChannel+0x5e8>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005f54:	68ee      	ldr	r6, [r5, #12]
 8005f56:	68ef      	ldr	r7, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005f58:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8005f5a:	f3c7 6784 	ubfx	r7, r7, #26, #5
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005f5e:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005f62:	2e00      	cmp	r6, #0
 8005f64:	f43f ae53 	beq.w	8005c0e <HAL_ADCEx_InjectedConfigChannel+0x9a>
  return __builtin_clz(value);
 8005f68:	fab6 f686 	clz	r6, r6
 8005f6c:	42be      	cmp	r6, r7
 8005f6e:	f47f ae4e 	bne.w	8005c0e <HAL_ADCEx_InjectedConfigChannel+0x9a>
  MODIFY_REG(*preg,
 8005f72:	682c      	ldr	r4, [r5, #0]
 8005f74:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8005f78:	602c      	str	r4, [r5, #0]
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 8005f7a:	680c      	ldr	r4, [r1, #0]
}
 8005f7c:	e647      	b.n	8005c0e <HAL_ADCEx_InjectedConfigChannel+0x9a>
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005f7e:	0de5      	lsrs	r5, r4, #23
  MODIFY_REG(*preg,
 8005f80:	f3c4 5604 	ubfx	r6, r4, #20, #5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005f84:	f005 0504 	and.w	r5, r5, #4
 8005f88:	f103 0414 	add.w	r4, r3, #20
  MODIFY_REG(*preg,
 8005f8c:	2707      	movs	r7, #7
 8005f8e:	40b7      	lsls	r7, r6
 8005f90:	5966      	ldr	r6, [r4, r5]
 8005f92:	ea26 0607 	bic.w	r6, r6, r7
 8005f96:	5166      	str	r6, [r4, r5]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005f98:	695c      	ldr	r4, [r3, #20]
 8005f9a:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8005f9e:	615c      	str	r4, [r3, #20]
}
 8005fa0:	e6d4      	b.n	8005d4c <HAL_ADCEx_InjectedConfigChannel+0x1d8>
      MODIFY_REG(hadc->Instance->CFGR2,
 8005fa2:	e9d1 570d 	ldrd	r5, r7, [r1, #52]	; 0x34
 8005fa6:	691e      	ldr	r6, [r3, #16]
 8005fa8:	433d      	orrs	r5, r7
 8005faa:	f426 76ff 	bic.w	r6, r6, #510	; 0x1fe
 8005fae:	4335      	orrs	r5, r6
 8005fb0:	f045 0502 	orr.w	r5, r5, #2
 8005fb4:	611d      	str	r5, [r3, #16]
 8005fb6:	e6af      	b.n	8005d18 <HAL_ADCEx_InjectedConfigChannel+0x1a4>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005fb8:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8005fbc:	2d00      	cmp	r5, #0
 8005fbe:	d076      	beq.n	80060ae <HAL_ADCEx_InjectedConfigChannel+0x53a>
  return __builtin_clz(value);
 8005fc0:	fab5 f585 	clz	r5, r5
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8005fc4:	3501      	adds	r5, #1
 8005fc6:	f005 051f 	and.w	r5, r5, #31
 8005fca:	2d09      	cmp	r5, #9
 8005fcc:	d96f      	bls.n	80060ae <HAL_ADCEx_InjectedConfigChannel+0x53a>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005fce:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 8005fd2:	2d00      	cmp	r5, #0
 8005fd4:	f000 80e2 	beq.w	800619c <HAL_ADCEx_InjectedConfigChannel+0x628>
  return __builtin_clz(value);
 8005fd8:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 8005fdc:	3501      	adds	r5, #1
 8005fde:	06ad      	lsls	r5, r5, #26
 8005fe0:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005fe4:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 8005fe8:	2e00      	cmp	r6, #0
 8005fea:	f000 80d5 	beq.w	8006198 <HAL_ADCEx_InjectedConfigChannel+0x624>
  return __builtin_clz(value);
 8005fee:	fab6 f686 	clz	r6, r6
 8005ff2:	3601      	adds	r6, #1
 8005ff4:	f006 061f 	and.w	r6, r6, #31
 8005ff8:	2701      	movs	r7, #1
 8005ffa:	fa07 f606 	lsl.w	r6, r7, r6
 8005ffe:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006000:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 8006004:	2c00      	cmp	r4, #0
 8006006:	f000 80c5 	beq.w	8006194 <HAL_ADCEx_InjectedConfigChannel+0x620>
  return __builtin_clz(value);
 800600a:	fab4 f484 	clz	r4, r4
 800600e:	1c66      	adds	r6, r4, #1
 8006010:	f006 061f 	and.w	r6, r6, #31
 8006014:	2403      	movs	r4, #3
 8006016:	f06f 071d 	mvn.w	r7, #29
 800601a:	fb14 7406 	smlabb	r4, r4, r6, r7
 800601e:	0524      	lsls	r4, r4, #20
 8006020:	f044 7400 	orr.w	r4, r4, #33554432	; 0x2000000
 8006024:	e00f      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
 8006026:	3b01      	subs	r3, #1
 8006028:	461e      	mov	r6, r3
 800602a:	e5c4      	b.n	8005bb6 <HAL_ADCEx_InjectedConfigChannel+0x42>
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 800602c:	06a5      	lsls	r5, r4, #26
 800602e:	eb0c 044c 	add.w	r4, ip, ip, lsl #1
 8006032:	3c1e      	subs	r4, #30
 8006034:	2601      	movs	r6, #1
 8006036:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 800603a:	0524      	lsls	r4, r4, #20
 800603c:	fa06 f60c 	lsl.w	r6, r6, ip
 8006040:	f044 7400 	orr.w	r4, r4, #33554432	; 0x2000000
 8006044:	4335      	orrs	r5, r6
      LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8006046:	432c      	orrs	r4, r5
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8006048:	ea4f 5cd4 	mov.w	ip, r4, lsr #23
  MODIFY_REG(*preg,
 800604c:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800604e:	f00c 0c04 	and.w	ip, ip, #4
 8006052:	f103 0e14 	add.w	lr, r3, #20
  MODIFY_REG(*preg,
 8006056:	f3c4 5404 	ubfx	r4, r4, #20, #5
 800605a:	fa05 f604 	lsl.w	r6, r5, r4
 800605e:	2707      	movs	r7, #7
 8006060:	f85e 500c 	ldr.w	r5, [lr, ip]
 8006064:	fa07 f404 	lsl.w	r4, r7, r4
 8006068:	ea25 0404 	bic.w	r4, r5, r4
 800606c:	4334      	orrs	r4, r6
 800606e:	f84e 400c 	str.w	r4, [lr, ip]
  if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 8006072:	680c      	ldr	r4, [r1, #0]
}
 8006074:	e5db      	b.n	8005c2e <HAL_ADCEx_InjectedConfigChannel+0xba>
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006076:	f3c4 6684 	ubfx	r6, r4, #26, #5
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800607a:	42b5      	cmp	r5, r6
 800607c:	d044      	beq.n	8006108 <HAL_ADCEx_InjectedConfigChannel+0x594>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800607e:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 8006080:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8006082:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8006086:	f3c7 6784 	ubfx	r7, r7, #26, #5
 800608a:	f103 0c64 	add.w	ip, r3, #100	; 0x64
 800608e:	42b7      	cmp	r7, r6
 8006090:	d04f      	beq.n	8006132 <HAL_ADCEx_InjectedConfigChannel+0x5be>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8006092:	68af      	ldr	r7, [r5, #8]
 8006094:	68af      	ldr	r7, [r5, #8]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8006096:	f105 0c08 	add.w	ip, r5, #8
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800609a:	f3c7 6784 	ubfx	r7, r7, #26, #5
 800609e:	42b7      	cmp	r7, r6
 80060a0:	d05c      	beq.n	800615c <HAL_ADCEx_InjectedConfigChannel+0x5e8>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80060a2:	68ef      	ldr	r7, [r5, #12]
 80060a4:	68ef      	ldr	r7, [r5, #12]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80060a6:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80060a8:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80060ac:	e75e      	b.n	8005f6c <HAL_ADCEx_InjectedConfigChannel+0x3f8>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80060ae:	fa94 f5a4 	rbit	r5, r4
  if (value == 0U)
 80060b2:	2d00      	cmp	r5, #0
 80060b4:	d068      	beq.n	8006188 <HAL_ADCEx_InjectedConfigChannel+0x614>
  return __builtin_clz(value);
 80060b6:	fab5 f585 	clz	r5, r5
                                    (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel)
 80060ba:	3501      	adds	r5, #1
 80060bc:	06ad      	lsls	r5, r5, #26
 80060be:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80060c2:	fa94 f6a4 	rbit	r6, r4
  if (value == 0U)
 80060c6:	2e00      	cmp	r6, #0
 80060c8:	d05c      	beq.n	8006184 <HAL_ADCEx_InjectedConfigChannel+0x610>
  return __builtin_clz(value);
 80060ca:	fab6 f686 	clz	r6, r6
 80060ce:	3601      	adds	r6, #1
 80060d0:	f006 061f 	and.w	r6, r6, #31
 80060d4:	2701      	movs	r7, #1
 80060d6:	fa07 f606 	lsl.w	r6, r7, r6
 80060da:	4335      	orrs	r5, r6
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80060dc:	fa94 f4a4 	rbit	r4, r4
  if (value == 0U)
 80060e0:	2c00      	cmp	r4, #0
 80060e2:	d054      	beq.n	800618e <HAL_ADCEx_InjectedConfigChannel+0x61a>
  return __builtin_clz(value);
 80060e4:	fab4 f484 	clz	r4, r4
 80060e8:	3401      	adds	r4, #1
 80060ea:	f004 041f 	and.w	r4, r4, #31
 80060ee:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80060f2:	0524      	lsls	r4, r4, #20
 80060f4:	e7a7      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80060f6:	6dd5      	ldr	r5, [r2, #92]	; 0x5c
 80060f8:	f045 0520 	orr.w	r5, r5, #32
 80060fc:	65d5      	str	r5, [r2, #92]	; 0x5c
        tmp_hal_status = HAL_ERROR;
 80060fe:	e602      	b.n	8005d06 <HAL_ADCEx_InjectedConfigChannel+0x192>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8006100:	4928      	ldr	r1, [pc, #160]	; (80061a4 <HAL_ADCEx_InjectedConfigChannel+0x630>)
 8006102:	e5ba      	b.n	8005c7a <HAL_ADCEx_InjectedConfigChannel+0x106>
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8006104:	4c27      	ldr	r4, [pc, #156]	; (80061a4 <HAL_ADCEx_InjectedConfigChannel+0x630>)
 8006106:	e5ce      	b.n	8005ca6 <HAL_ADCEx_InjectedConfigChannel+0x132>
  MODIFY_REG(*preg,
 8006108:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 800610a:	461d      	mov	r5, r3
 800610c:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8006110:	f845 4f60 	str.w	r4, [r5, #96]!
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8006114:	6e5c      	ldr	r4, [r3, #100]	; 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006116:	680c      	ldr	r4, [r1, #0]
 8006118:	6e5f      	ldr	r7, [r3, #100]	; 0x64
 800611a:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 800611e:	f3c7 6784 	ubfx	r7, r7, #26, #5
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8006122:	f103 0c64 	add.w	ip, r3, #100	; 0x64
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006126:	2e00      	cmp	r6, #0
 8006128:	f47f aefe 	bne.w	8005f28 <HAL_ADCEx_InjectedConfigChannel+0x3b4>
 800612c:	f3c4 6684 	ubfx	r6, r4, #26, #5
 8006130:	e7ad      	b.n	800608e <HAL_ADCEx_InjectedConfigChannel+0x51a>
  MODIFY_REG(*preg,
 8006132:	f8dc 4000 	ldr.w	r4, [ip]
 8006136:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 800613a:	f8cc 4000 	str.w	r4, [ip]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800613e:	68ac      	ldr	r4, [r5, #8]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006140:	680c      	ldr	r4, [r1, #0]
 8006142:	68af      	ldr	r7, [r5, #8]
 8006144:	f3c4 0612 	ubfx	r6, r4, #0, #19
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 8006148:	f3c7 6784 	ubfx	r7, r7, #26, #5
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800614c:	f105 0c08 	add.w	ip, r5, #8
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006150:	2e00      	cmp	r6, #0
 8006152:	f47f aef7 	bne.w	8005f44 <HAL_ADCEx_InjectedConfigChannel+0x3d0>
 8006156:	f3c4 6684 	ubfx	r6, r4, #26, #5
 800615a:	e7a0      	b.n	800609e <HAL_ADCEx_InjectedConfigChannel+0x52a>
  MODIFY_REG(*preg,
 800615c:	f8dc 4000 	ldr.w	r4, [ip]
 8006160:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 8006164:	f8cc 4000 	str.w	r4, [ip]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8006168:	68ec      	ldr	r4, [r5, #12]
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800616a:	680c      	ldr	r4, [r1, #0]
 800616c:	68ef      	ldr	r7, [r5, #12]
 800616e:	f3c4 0612 	ubfx	r6, r4, #0, #19
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8006172:	350c      	adds	r5, #12
      if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 8006174:	f3c7 6784 	ubfx	r7, r7, #26, #5
          == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8006178:	2e00      	cmp	r6, #0
 800617a:	f47f aef0 	bne.w	8005f5e <HAL_ADCEx_InjectedConfigChannel+0x3ea>
 800617e:	f3c4 6684 	ubfx	r6, r4, #26, #5
 8006182:	e6f3      	b.n	8005f6c <HAL_ADCEx_InjectedConfigChannel+0x3f8>
 8006184:	2602      	movs	r6, #2
 8006186:	e7a8      	b.n	80060da <HAL_ADCEx_InjectedConfigChannel+0x566>
 8006188:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 800618c:	e799      	b.n	80060c2 <HAL_ADCEx_InjectedConfigChannel+0x54e>
 800618e:	f44f 1440 	mov.w	r4, #3145728	; 0x300000
 8006192:	e758      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
 8006194:	4c04      	ldr	r4, [pc, #16]	; (80061a8 <HAL_ADCEx_InjectedConfigChannel+0x634>)
 8006196:	e756      	b.n	8006046 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
 8006198:	2602      	movs	r6, #2
 800619a:	e730      	b.n	8005ffe <HAL_ADCEx_InjectedConfigChannel+0x48a>
 800619c:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 80061a0:	e720      	b.n	8005fe4 <HAL_ADCEx_InjectedConfigChannel+0x470>
 80061a2:	bf00      	nop
 80061a4:	50000300 	.word	0x50000300
 80061a8:	fe500000 	.word	0xfe500000

080061ac <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 80061ac:	b470      	push	{r4, r5, r6}
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(multimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80061ae:	f890 2058 	ldrb.w	r2, [r0, #88]	; 0x58
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80061b2:	680e      	ldr	r6, [r1, #0]
  __HAL_LOCK(hadc);
 80061b4:	2a01      	cmp	r2, #1
{
 80061b6:	b09d      	sub	sp, #116	; 0x74
  __HAL_LOCK(hadc);
 80061b8:	d056      	beq.n	8006268 <HAL_ADCEx_MultiModeConfigChannel+0xbc>

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80061ba:	6802      	ldr	r2, [r0, #0]
 80061bc:	4603      	mov	r3, r0
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
 80061be:	2400      	movs	r4, #0
  __HAL_LOCK(hadc);
 80061c0:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80061c2:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
 80061c6:	9418      	str	r4, [sp, #96]	; 0x60
  __HAL_LOCK(hadc);
 80061c8:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);
 80061cc:	9419      	str	r4, [sp, #100]	; 0x64
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 80061ce:	d00b      	beq.n	80061e8 <HAL_ADCEx_MultiModeConfigChannel+0x3c>
 80061d0:	4d48      	ldr	r5, [pc, #288]	; (80062f4 <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 80061d2:	42aa      	cmp	r2, r5
 80061d4:	d046      	beq.n	8006264 <HAL_ADCEx_MultiModeConfigChannel+0xb8>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80061d6:	6dda      	ldr	r2, [r3, #92]	; 0x5c

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 80061d8:	f883 4058 	strb.w	r4, [r3, #88]	; 0x58
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80061dc:	f042 0220 	orr.w	r2, r2, #32
 80061e0:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 80061e2:	b01d      	add	sp, #116	; 0x74
 80061e4:	bc70      	pop	{r4, r5, r6}
 80061e6:	4770      	bx	lr
 80061e8:	4843      	ldr	r0, [pc, #268]	; (80062f8 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80061ea:	6880      	ldr	r0, [r0, #8]
 80061ec:	0740      	lsls	r0, r0, #29
 80061ee:	d50b      	bpl.n	8006208 <HAL_ADCEx_MultiModeConfigChannel+0x5c>
 80061f0:	6892      	ldr	r2, [r2, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80061f2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80061f4:	f042 0220 	orr.w	r2, r2, #32
    tmp_hal_status = HAL_ERROR;
 80061f8:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80061fa:	65da      	str	r2, [r3, #92]	; 0x5c
  __HAL_UNLOCK(hadc);
 80061fc:	2200      	movs	r2, #0
 80061fe:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
}
 8006202:	b01d      	add	sp, #116	; 0x74
 8006204:	bc70      	pop	{r4, r5, r6}
 8006206:	4770      	bx	lr
 8006208:	6890      	ldr	r0, [r2, #8]
 800620a:	0744      	lsls	r4, r0, #29
 800620c:	d4f1      	bmi.n	80061f2 <HAL_ADCEx_MultiModeConfigChannel+0x46>
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 800620e:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 8006212:	d02d      	beq.n	8006270 <HAL_ADCEx_MultiModeConfigChannel+0xc4>
 8006214:	4838      	ldr	r0, [pc, #224]	; (80062f8 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 8006216:	4282      	cmp	r2, r0
 8006218:	d02a      	beq.n	8006270 <HAL_ADCEx_MultiModeConfigChannel+0xc4>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 800621a:	2e00      	cmp	r6, #0
 800621c:	d058      	beq.n	80062d0 <HAL_ADCEx_MultiModeConfigChannel+0x124>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 800621e:	4837      	ldr	r0, [pc, #220]	; (80062fc <HAL_ADCEx_MultiModeConfigChannel+0x150>)
 8006220:	684c      	ldr	r4, [r1, #4]
 8006222:	6882      	ldr	r2, [r0, #8]
 8006224:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8006228:	4322      	orrs	r2, r4
 800622a:	f893 4038 	ldrb.w	r4, [r3, #56]	; 0x38
 800622e:	ea42 3244 	orr.w	r2, r2, r4, lsl #13
 8006232:	6082      	str	r2, [r0, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8006234:	4a2f      	ldr	r2, [pc, #188]	; (80062f4 <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 8006236:	6894      	ldr	r4, [r2, #8]
 8006238:	f502 7280 	add.w	r2, r2, #256	; 0x100
 800623c:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800623e:	4322      	orrs	r2, r4
 8006240:	4c2f      	ldr	r4, [pc, #188]	; (8006300 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
 8006242:	68a4      	ldr	r4, [r4, #8]
 8006244:	4322      	orrs	r2, r4
 8006246:	43d2      	mvns	r2, r2
 8006248:	f002 0201 	and.w	r2, r2, #1
 800624c:	b142      	cbz	r2, 8006260 <HAL_ADCEx_MultiModeConfigChannel+0xb4>
        MODIFY_REG(tmpADC_Common->CCR,
 800624e:	6884      	ldr	r4, [r0, #8]
 8006250:	688a      	ldr	r2, [r1, #8]
 8006252:	f424 6171 	bic.w	r1, r4, #3856	; 0xf10
 8006256:	4332      	orrs	r2, r6
 8006258:	f021 010f 	bic.w	r1, r1, #15
 800625c:	430a      	orrs	r2, r1
 800625e:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8006260:	2000      	movs	r0, #0
 8006262:	e7cb      	b.n	80061fc <HAL_ADCEx_MultiModeConfigChannel+0x50>
 8006264:	4827      	ldr	r0, [pc, #156]	; (8006304 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
 8006266:	e7c0      	b.n	80061ea <HAL_ADCEx_MultiModeConfigChannel+0x3e>
  __HAL_LOCK(hadc);
 8006268:	2002      	movs	r0, #2
}
 800626a:	b01d      	add	sp, #116	; 0x74
 800626c:	bc70      	pop	{r4, r5, r6}
 800626e:	4770      	bx	lr
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8006270:	b1ae      	cbz	r6, 800629e <HAL_ADCEx_MultiModeConfigChannel+0xf2>
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 8006272:	4825      	ldr	r0, [pc, #148]	; (8006308 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 8006274:	684c      	ldr	r4, [r1, #4]
 8006276:	6882      	ldr	r2, [r0, #8]
 8006278:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 800627c:	4322      	orrs	r2, r4
 800627e:	f893 4038 	ldrb.w	r4, [r3, #56]	; 0x38
 8006282:	ea42 3244 	orr.w	r2, r2, r4, lsl #13
 8006286:	6082      	str	r2, [r0, #8]
 8006288:	4a1b      	ldr	r2, [pc, #108]	; (80062f8 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 800628a:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 800628e:	6880      	ldr	r0, [r0, #8]
 8006290:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8006292:	4302      	orrs	r2, r0
 8006294:	43d2      	mvns	r2, r2
 8006296:	481c      	ldr	r0, [pc, #112]	; (8006308 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 8006298:	f002 0201 	and.w	r2, r2, #1
 800629c:	e7d6      	b.n	800624c <HAL_ADCEx_MultiModeConfigChannel+0xa0>
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 800629e:	491a      	ldr	r1, [pc, #104]	; (8006308 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062a0:	688a      	ldr	r2, [r1, #8]
 80062a2:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80062a6:	608a      	str	r2, [r1, #8]
 80062a8:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 80062ac:	4a12      	ldr	r2, [pc, #72]	; (80062f8 <HAL_ADCEx_MultiModeConfigChannel+0x14c>)
 80062ae:	6880      	ldr	r0, [r0, #8]
 80062b0:	6892      	ldr	r2, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80062b2:	4915      	ldr	r1, [pc, #84]	; (8006308 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
 80062b4:	4302      	orrs	r2, r0
 80062b6:	43d2      	mvns	r2, r2
 80062b8:	f002 0201 	and.w	r2, r2, #1
 80062bc:	2a00      	cmp	r2, #0
 80062be:	d0cf      	beq.n	8006260 <HAL_ADCEx_MultiModeConfigChannel+0xb4>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 80062c0:	688a      	ldr	r2, [r1, #8]
 80062c2:	f422 6271 	bic.w	r2, r2, #3856	; 0xf10
 80062c6:	f022 020f 	bic.w	r2, r2, #15
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80062ca:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 80062cc:	608a      	str	r2, [r1, #8]
 80062ce:	e795      	b.n	80061fc <HAL_ADCEx_MultiModeConfigChannel+0x50>
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 80062d0:	490a      	ldr	r1, [pc, #40]	; (80062fc <HAL_ADCEx_MultiModeConfigChannel+0x150>)
 80062d2:	4808      	ldr	r0, [pc, #32]	; (80062f4 <HAL_ADCEx_MultiModeConfigChannel+0x148>)
 80062d4:	688a      	ldr	r2, [r1, #8]
 80062d6:	4c0b      	ldr	r4, [pc, #44]	; (8006304 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
 80062d8:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80062dc:	608a      	str	r2, [r1, #8]
 80062de:	6880      	ldr	r0, [r0, #8]
 80062e0:	68a2      	ldr	r2, [r4, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80062e2:	4302      	orrs	r2, r0
 80062e4:	4806      	ldr	r0, [pc, #24]	; (8006300 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
 80062e6:	6880      	ldr	r0, [r0, #8]
 80062e8:	4302      	orrs	r2, r0
 80062ea:	43d2      	mvns	r2, r2
 80062ec:	f002 0201 	and.w	r2, r2, #1
 80062f0:	e7e4      	b.n	80062bc <HAL_ADCEx_MultiModeConfigChannel+0x110>
 80062f2:	bf00      	nop
 80062f4:	50000400 	.word	0x50000400
 80062f8:	50000100 	.word	0x50000100
 80062fc:	50000700 	.word	0x50000700
 8006300:	50000600 	.word	0x50000600
 8006304:	50000500 	.word	0x50000500
 8006308:	50000300 	.word	0x50000300

0800630c <HAL_CORDIC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CORDIC_Init(CORDIC_HandleTypeDef *hcordic)
{
  /* Check the CORDIC handle allocation */
  if (hcordic == NULL)
 800630c:	b1b0      	cbz	r0, 800633c <HAL_CORDIC_Init+0x30>
{
 800630e:	b510      	push	{r4, lr}

    /* Initialize the low level hardware */
    hcordic->MspInitCallback(hcordic);
  }
#else
  if (hcordic->State == HAL_CORDIC_STATE_RESET)
 8006310:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8006314:	4604      	mov	r4, r0
 8006316:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800631a:	b153      	cbz	r3, 8006332 <HAL_CORDIC_Init+0x26>
    HAL_CORDIC_MspInit(hcordic);
  }
#endif /* (USE_HAL_CORDIC_REGISTER_CALLBACKS) */

  /* Set CORDIC error code to none */
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 800631c:	2000      	movs	r0, #0

  /* Reset DMADirection */
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;

  /* Change CORDIC peripheral state */
  hcordic->State = HAL_CORDIC_STATE_READY;
 800631e:	2301      	movs	r3, #1
  hcordic->ErrorCode = HAL_CORDIC_ERROR_NONE;
 8006320:	6260      	str	r0, [r4, #36]	; 0x24
  hcordic->State = HAL_CORDIC_STATE_READY;
 8006322:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  hcordic->pOutBuff = NULL;
 8006326:	e9c4 0001 	strd	r0, r0, [r4, #4]
  hcordic->NbCalcToGet = 0U;
 800632a:	e9c4 0003 	strd	r0, r0, [r4, #12]
  hcordic->DMADirection = CORDIC_DMA_DIR_NONE;
 800632e:	6160      	str	r0, [r4, #20]

  /* Return function status */
  return HAL_OK;
}
 8006330:	bd10      	pop	{r4, pc}
    hcordic->Lock = HAL_UNLOCKED;
 8006332:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_CORDIC_MspInit(hcordic);
 8006336:	f7fb fa7f 	bl	8001838 <HAL_CORDIC_MspInit>
 800633a:	e7ef      	b.n	800631c <HAL_CORDIC_Init+0x10>
    return HAL_ERROR;
 800633c:	2001      	movs	r0, #1
}
 800633e:	4770      	bx	lr

08006340 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006340:	4907      	ldr	r1, [pc, #28]	; (8006360 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8006342:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8006344:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006346:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800634a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800634e:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8006350:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8006352:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8006356:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 800635a:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800635c:	4770      	bx	lr
 800635e:	bf00      	nop
 8006360:	e000ed00 	.word	0xe000ed00

08006364 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8006364:	4b1c      	ldr	r3, [pc, #112]	; (80063d8 <HAL_NVIC_SetPriority+0x74>)
 8006366:	68db      	ldr	r3, [r3, #12]
 8006368:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800636c:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800636e:	f1c3 0e07 	rsb	lr, r3, #7
 8006372:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8006376:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800637a:	bf28      	it	cs
 800637c:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8006380:	f1bc 0f06 	cmp.w	ip, #6
 8006384:	d91b      	bls.n	80063be <HAL_NVIC_SetPriority+0x5a>
 8006386:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8006388:	f04f 3cff 	mov.w	ip, #4294967295
 800638c:	fa0c fc03 	lsl.w	ip, ip, r3
 8006390:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8006394:	f04f 3cff 	mov.w	ip, #4294967295
 8006398:	fa0c fc0e 	lsl.w	ip, ip, lr
 800639c:	ea21 010c 	bic.w	r1, r1, ip
 80063a0:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 80063a2:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80063a4:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 80063a8:	db0c      	blt.n	80063c4 <HAL_NVIC_SetPriority+0x60>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80063aa:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80063ae:	0109      	lsls	r1, r1, #4
 80063b0:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80063b4:	b2c9      	uxtb	r1, r1
 80063b6:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80063ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80063be:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80063c0:	4613      	mov	r3, r2
 80063c2:	e7e7      	b.n	8006394 <HAL_NVIC_SetPriority+0x30>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80063c4:	4b05      	ldr	r3, [pc, #20]	; (80063dc <HAL_NVIC_SetPriority+0x78>)
 80063c6:	f000 000f 	and.w	r0, r0, #15
 80063ca:	0109      	lsls	r1, r1, #4
 80063cc:	4403      	add	r3, r0
 80063ce:	b2c9      	uxtb	r1, r1
 80063d0:	7619      	strb	r1, [r3, #24]
 80063d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063d6:	bf00      	nop
 80063d8:	e000ed00 	.word	0xe000ed00
 80063dc:	e000ecfc 	.word	0xe000ecfc

080063e0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80063e0:	2800      	cmp	r0, #0
 80063e2:	db07      	blt.n	80063f4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80063e4:	4a04      	ldr	r2, [pc, #16]	; (80063f8 <HAL_NVIC_EnableIRQ+0x18>)
 80063e6:	0941      	lsrs	r1, r0, #5
 80063e8:	2301      	movs	r3, #1
 80063ea:	f000 001f 	and.w	r0, r0, #31
 80063ee:	4083      	lsls	r3, r0
 80063f0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80063f4:	4770      	bx	lr
 80063f6:	bf00      	nop
 80063f8:	e000e100 	.word	0xe000e100

080063fc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80063fc:	3801      	subs	r0, #1
 80063fe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8006402:	d210      	bcs.n	8006426 <HAL_SYSTICK_Config+0x2a>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8006404:	b410      	push	{r4}
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8006406:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800640a:	4c08      	ldr	r4, [pc, #32]	; (800642c <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800640c:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800640e:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
 8006412:	f884 c023 	strb.w	ip, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8006416:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8006418:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800641a:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800641c:	619a      	str	r2, [r3, #24]
   return SysTick_Config(TicksNumb);
}
 800641e:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8006422:	6119      	str	r1, [r3, #16]
 8006424:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8006426:	2001      	movs	r0, #1
 8006428:	4770      	bx	lr
 800642a:	bf00      	nop
 800642c:	e000ed00 	.word	0xe000ed00

08006430 <HAL_SYSTICK_Callback>:
__weak void HAL_SYSTICK_Callback(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8006430:	4770      	bx	lr
 8006432:	bf00      	nop

08006434 <HAL_SYSTICK_IRQHandler>:
{
 8006434:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8006436:	f7ff fffb 	bl	8006430 <HAL_SYSTICK_Callback>
}
 800643a:	bd08      	pop	{r3, pc}

0800643c <HAL_CRC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800643c:	2800      	cmp	r0, #0
 800643e:	d036      	beq.n	80064ae <HAL_CRC_Init+0x72>
{
 8006440:	b510      	push	{r4, lr}
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8006442:	7f43      	ldrb	r3, [r0, #29]
 8006444:	4604      	mov	r4, r0
 8006446:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800644a:	b363      	cbz	r3, 80064a6 <HAL_CRC_Init+0x6a>
  hcrc->State = HAL_CRC_STATE_BUSY;

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800644c:	7923      	ldrb	r3, [r4, #4]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800644e:	2202      	movs	r2, #2
 8006450:	7762      	strb	r2, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8006452:	b9f3      	cbnz	r3, 8006492 <HAL_CRC_Init+0x56>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 8006454:	6823      	ldr	r3, [r4, #0]
 8006456:	4a17      	ldr	r2, [pc, #92]	; (80064b4 <HAL_CRC_Init+0x78>)
 8006458:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800645a:	689a      	ldr	r2, [r3, #8]
 800645c:	f022 0218 	bic.w	r2, r2, #24
 8006460:	609a      	str	r2, [r3, #8]
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8006462:	7962      	ldrb	r2, [r4, #5]
 8006464:	b18a      	cbz	r2, 800648a <HAL_CRC_Init+0x4e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8006466:	6922      	ldr	r2, [r4, #16]
 8006468:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800646a:	689a      	ldr	r2, [r3, #8]
 800646c:	6961      	ldr	r1, [r4, #20]
 800646e:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8006472:	430a      	orrs	r2, r1
 8006474:	609a      	str	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 8006476:	689a      	ldr	r2, [r3, #8]
 8006478:	69a1      	ldr	r1, [r4, #24]
 800647a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800647e:	430a      	orrs	r2, r1
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8006480:	2101      	movs	r1, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 8006482:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8006484:	7761      	strb	r1, [r4, #29]

  /* Return function status */
  return HAL_OK;
 8006486:	2000      	movs	r0, #0
}
 8006488:	bd10      	pop	{r4, pc}
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800648a:	f04f 32ff 	mov.w	r2, #4294967295
 800648e:	611a      	str	r2, [r3, #16]
 8006490:	e7eb      	b.n	800646a <HAL_CRC_Init+0x2e>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8006492:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8006496:	4620      	mov	r0, r4
 8006498:	f000 f80e 	bl	80064b8 <HAL_CRCEx_Polynomial_Set>
 800649c:	b908      	cbnz	r0, 80064a2 <HAL_CRC_Init+0x66>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800649e:	6823      	ldr	r3, [r4, #0]
 80064a0:	e7df      	b.n	8006462 <HAL_CRC_Init+0x26>
    return HAL_ERROR;
 80064a2:	2001      	movs	r0, #1
}
 80064a4:	bd10      	pop	{r4, pc}
    hcrc->Lock = HAL_UNLOCKED;
 80064a6:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 80064a8:	f7fb f9f4 	bl	8001894 <HAL_CRC_MspInit>
 80064ac:	e7ce      	b.n	800644c <HAL_CRC_Init+0x10>
    return HAL_ERROR;
 80064ae:	2001      	movs	r0, #1
}
 80064b0:	4770      	bx	lr
 80064b2:	bf00      	nop
 80064b4:	04c11db7 	.word	0x04c11db7

080064b8 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80064b8:	b410      	push	{r4}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 80064ba:	231e      	movs	r3, #30
 80064bc:	e001      	b.n	80064c2 <HAL_CRCEx_Polynomial_Set+0xa>
 80064be:	3b01      	subs	r3, #1
 80064c0:	d315      	bcc.n	80064ee <HAL_CRCEx_Polynomial_Set+0x36>
 80064c2:	fa21 fc03 	lsr.w	ip, r1, r3
 80064c6:	f01c 0f01 	tst.w	ip, #1
 80064ca:	d0f8      	beq.n	80064be <HAL_CRCEx_Polynomial_Set+0x6>
  {
  }

  switch (PolyLength)
 80064cc:	2a18      	cmp	r2, #24
 80064ce:	d80f      	bhi.n	80064f0 <HAL_CRCEx_Polynomial_Set+0x38>
 80064d0:	e8df f002 	tbb	[pc, r2]
 80064d4:	0e0e0e14 	.word	0x0e0e0e14
 80064d8:	0e0e0e0e 	.word	0x0e0e0e0e
 80064dc:	0e0e0e1f 	.word	0x0e0e0e1f
 80064e0:	0e0e0e0e 	.word	0x0e0e0e0e
 80064e4:	0e0e0e22 	.word	0x0e0e0e22
 80064e8:	0e0e0e0e 	.word	0x0e0e0e0e
 80064ec:	12          	.byte	0x12
 80064ed:	00          	.byte	0x00
 80064ee:	b12a      	cbz	r2, 80064fc <HAL_CRCEx_Polynomial_Set+0x44>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 80064f0:	2001      	movs	r0, #1
    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
}
 80064f2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80064f6:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_7B)
 80064f8:	2b06      	cmp	r3, #6
 80064fa:	d8f9      	bhi.n	80064f0 <HAL_CRCEx_Polynomial_Set+0x38>
    WRITE_REG(hcrc->Instance->POL, Pol);
 80064fc:	6804      	ldr	r4, [r0, #0]
 80064fe:	6161      	str	r1, [r4, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 8006500:	68a3      	ldr	r3, [r4, #8]
 8006502:	f023 0318 	bic.w	r3, r3, #24
 8006506:	4313      	orrs	r3, r2
 8006508:	2000      	movs	r0, #0
 800650a:	60a3      	str	r3, [r4, #8]
}
 800650c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006510:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_16B)
 8006512:	2b0f      	cmp	r3, #15
 8006514:	d9f2      	bls.n	80064fc <HAL_CRCEx_Polynomial_Set+0x44>
 8006516:	e7eb      	b.n	80064f0 <HAL_CRCEx_Polynomial_Set+0x38>
      if (msb >= HAL_CRC_LENGTH_8B)
 8006518:	2b07      	cmp	r3, #7
 800651a:	d9ef      	bls.n	80064fc <HAL_CRCEx_Polynomial_Set+0x44>
 800651c:	e7e8      	b.n	80064f0 <HAL_CRCEx_Polynomial_Set+0x38>
 800651e:	bf00      	nop

08006520 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8006520:	2800      	cmp	r0, #0
 8006522:	d078      	beq.n	8006616 <HAL_DMA_Init+0xf6>
{
 8006524:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8006526:	4b3d      	ldr	r3, [pc, #244]	; (800661c <HAL_DMA_Init+0xfc>)
 8006528:	6804      	ldr	r4, [r0, #0]
 800652a:	429c      	cmp	r4, r3
 800652c:	d95f      	bls.n	80065ee <HAL_DMA_Init+0xce>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 800652e:	4a3c      	ldr	r2, [pc, #240]	; (8006620 <HAL_DMA_Init+0x100>)
 8006530:	4b3c      	ldr	r3, [pc, #240]	; (8006624 <HAL_DMA_Init+0x104>)
    hdma->DmaBaseAddress = DMA2;
 8006532:	493d      	ldr	r1, [pc, #244]	; (8006628 <HAL_DMA_Init+0x108>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
 8006534:	4422      	add	r2, r4
 8006536:	fba3 3202 	umull	r3, r2, r3, r2
 800653a:	0912      	lsrs	r2, r2, #4
 800653c:	0092      	lsls	r2, r2, #2
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800653e:	2302      	movs	r3, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8006540:	6885      	ldr	r5, [r0, #8]
  hdma->State = HAL_DMA_STATE_BUSY;
 8006542:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  tmp |=  hdma->Init.Direction        |
 8006546:	68c3      	ldr	r3, [r0, #12]
#else
    DMAMUX1_ChannelBase = DMAMUX1_Channel7;
#endif /* STM32G4x1xx) */
  }
  dmamux_base_addr = (uint32_t)DMAMUX1_ChannelBase;
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8006548:	4e36      	ldr	r6, [pc, #216]	; (8006624 <HAL_DMA_Init+0x104>)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 800654a:	4f34      	ldr	r7, [pc, #208]	; (800661c <HAL_DMA_Init+0xfc>)
 800654c:	e9c0 1210 	strd	r1, r2, [r0, #64]	; 0x40
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8006550:	6901      	ldr	r1, [r0, #16]
  tmp |=  hdma->Init.Direction        |
 8006552:	432b      	orrs	r3, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8006554:	430b      	orrs	r3, r1
 8006556:	6941      	ldr	r1, [r0, #20]
 8006558:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800655a:	6981      	ldr	r1, [r0, #24]
 800655c:	430b      	orrs	r3, r1
  tmp = hdma->Instance->CCR;
 800655e:	6821      	ldr	r1, [r4, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8006560:	f421 4cff 	bic.w	ip, r1, #32640	; 0x7f80
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8006564:	69c1      	ldr	r1, [r0, #28]
 8006566:	430b      	orrs	r3, r1
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8006568:	b2e1      	uxtb	r1, r4
 800656a:	3908      	subs	r1, #8
 800656c:	fba6 6101 	umull	r6, r1, r6, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8006570:	6a06      	ldr	r6, [r0, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 8006572:	f02c 0c70 	bic.w	ip, ip, #112	; 0x70
          hdma->Init.Mode                | hdma->Init.Priority;
 8006576:	4333      	orrs	r3, r6
  tmp |=  hdma->Init.Direction        |
 8006578:	ea43 030c 	orr.w	r3, r3, ip
  hdma->Instance->CCR = tmp;
 800657c:	6023      	str	r3, [r4, #0]
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 800657e:	4e2b      	ldr	r6, [pc, #172]	; (800662c <HAL_DMA_Init+0x10c>)
 8006580:	4b2b      	ldr	r3, [pc, #172]	; (8006630 <HAL_DMA_Init+0x110>)
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8006582:	f3c1 1104 	ubfx	r1, r1, #4, #5
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8006586:	42bc      	cmp	r4, r7
 8006588:	bf98      	it	ls
 800658a:	4633      	movls	r3, r6
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800658c:	f04f 0c01 	mov.w	ip, #1
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8006590:	4c28      	ldr	r4, [pc, #160]	; (8006634 <HAL_DMA_Init+0x114>)
 8006592:	64c4      	str	r4, [r0, #76]	; 0x4c
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8006594:	fa0c f101 	lsl.w	r1, ip, r1
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 8006598:	18d4      	adds	r4, r2, r3
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800659a:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800659e:	6501      	str	r1, [r0, #80]	; 0x50
  hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)(uint32_t)(dmamux_base_addr + ((hdma->ChannelIndex >> 2U) * ((uint32_t)DMAMUX1_Channel1 - (uint32_t)DMAMUX1_Channel0)));
 80065a0:	6484      	str	r4, [r0, #72]	; 0x48
 80065a2:	ea4f 0292 	mov.w	r2, r2, lsr #2
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80065a6:	d02b      	beq.n	8006600 <HAL_DMA_Init+0xe0>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80065a8:	6845      	ldr	r5, [r0, #4]
 80065aa:	b2ec      	uxtb	r4, r5
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80065ac:	3d01      	subs	r5, #1
 80065ae:	2d03      	cmp	r5, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80065b0:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80065b4:	f8c6 1084 	str.w	r1, [r6, #132]	; 0x84
  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 80065b8:	d828      	bhi.n	800660c <HAL_DMA_Init+0xec>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80065ba:	4b1f      	ldr	r3, [pc, #124]	; (8006638 <HAL_DMA_Init+0x118>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80065bc:	4d1f      	ldr	r5, [pc, #124]	; (800663c <HAL_DMA_Init+0x11c>)
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80065be:	4a20      	ldr	r2, [pc, #128]	; (8006640 <HAL_DMA_Init+0x120>)
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80065c0:	4423      	add	r3, r4

  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80065c2:	3c01      	subs	r4, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80065c4:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80065c6:	f004 041f 	and.w	r4, r4, #31
 80065ca:	fa0c f404 	lsl.w	r4, ip, r4
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80065ce:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80065d0:	e9c0 3515 	strd	r3, r5, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x1FU);
 80065d4:	65c4      	str	r4, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 80065d6:	6019      	str	r1, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80065d8:	6454      	str	r4, [r2, #68]	; 0x44
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80065da:	2300      	movs	r3, #0
  hdma->State  = HAL_DMA_STATE_READY;
 80065dc:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80065de:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->Lock = HAL_UNLOCKED;
 80065e0:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State  = HAL_DMA_STATE_READY;
 80065e4:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
}
 80065e8:	bcf0      	pop	{r4, r5, r6, r7}
  return HAL_OK;
 80065ea:	4618      	mov	r0, r3
}
 80065ec:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80065ee:	4a15      	ldr	r2, [pc, #84]	; (8006644 <HAL_DMA_Init+0x124>)
 80065f0:	4b0c      	ldr	r3, [pc, #48]	; (8006624 <HAL_DMA_Init+0x104>)
    hdma->DmaBaseAddress = DMA1;
 80065f2:	4915      	ldr	r1, [pc, #84]	; (8006648 <HAL_DMA_Init+0x128>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 80065f4:	4422      	add	r2, r4
 80065f6:	fba3 3202 	umull	r3, r2, r3, r2
 80065fa:	0912      	lsrs	r2, r2, #4
 80065fc:	0092      	lsls	r2, r2, #2
    hdma->DmaBaseAddress = DMA1;
 80065fe:	e79e      	b.n	800653e <HAL_DMA_Init+0x1e>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8006600:	2400      	movs	r4, #0
 8006602:	6044      	str	r4, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8006604:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8006608:	f8c6 1084 	str.w	r1, [r6, #132]	; 0x84
    hdma->DMAmuxRequestGen = 0U;
 800660c:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 800660e:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 8006612:	65c3      	str	r3, [r0, #92]	; 0x5c
 8006614:	e7e1      	b.n	80065da <HAL_DMA_Init+0xba>
    return HAL_ERROR;
 8006616:	2001      	movs	r0, #1
}
 8006618:	4770      	bx	lr
 800661a:	bf00      	nop
 800661c:	40020407 	.word	0x40020407
 8006620:	bffdfbf8 	.word	0xbffdfbf8
 8006624:	cccccccd 	.word	0xcccccccd
 8006628:	40020400 	.word	0x40020400
 800662c:	40020800 	.word	0x40020800
 8006630:	40020820 	.word	0x40020820
 8006634:	40020880 	.word	0x40020880
 8006638:	1000823f 	.word	0x1000823f
 800663c:	40020940 	.word	0x40020940
 8006640:	40020900 	.word	0x40020900
 8006644:	bffdfff8 	.word	0xbffdfff8
 8006648:	40020000 	.word	0x40020000

0800664c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800664c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 8006650:	680c      	ldr	r4, [r1, #0]
{
 8006652:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0U)
 8006654:	2c00      	cmp	r4, #0
 8006656:	d07d      	beq.n	8006754 <HAL_GPIO_Init+0x108>
 8006658:	f04f 0c00 	mov.w	ip, #0
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800665c:	4e71      	ldr	r6, [pc, #452]	; (8006824 <HAL_GPIO_Init+0x1d8>)
  uint32_t position = 0x00U;
 800665e:	4663      	mov	r3, ip
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8006660:	f04f 0b01 	mov.w	fp, #1
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006664:	468e      	mov	lr, r1
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8006666:	fa0b f703 	lsl.w	r7, fp, r3
    if (iocurrent != 0x00u)
 800666a:	ea17 0a04 	ands.w	sl, r7, r4
 800666e:	d06b      	beq.n	8006748 <HAL_GPIO_Init+0xfc>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8006670:	f8de 1004 	ldr.w	r1, [lr, #4]
 8006674:	f001 0203 	and.w	r2, r1, #3
 8006678:	1e55      	subs	r5, r2, #1
 800667a:	2d01      	cmp	r5, #1
 800667c:	d96d      	bls.n	800675a <HAL_GPIO_Init+0x10e>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800667e:	2a03      	cmp	r2, #3
 8006680:	f040 80b1 	bne.w	80067e6 <HAL_GPIO_Init+0x19a>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8006684:	fa02 f20c 	lsl.w	r2, r2, ip
 8006688:	43d5      	mvns	r5, r2
      temp = GPIOx->MODER;
 800668a:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800668c:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800668e:	432a      	orrs	r2, r5
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8006690:	f411 3f40 	tst.w	r1, #196608	; 0x30000
      GPIOx->MODER = temp;
 8006694:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8006696:	d057      	beq.n	8006748 <HAL_GPIO_Init+0xfc>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006698:	4d63      	ldr	r5, [pc, #396]	; (8006828 <HAL_GPIO_Init+0x1dc>)
 800669a:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 800669c:	f042 0201 	orr.w	r2, r2, #1
 80066a0:	662a      	str	r2, [r5, #96]	; 0x60
 80066a2:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 80066a4:	f002 0201 	and.w	r2, r2, #1
 80066a8:	9203      	str	r2, [sp, #12]
 80066aa:	9a03      	ldr	r2, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2U];
 80066ac:	f023 0203 	bic.w	r2, r3, #3
 80066b0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80066b4:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80066b8:	f003 0703 	and.w	r7, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 80066bc:	6895      	ldr	r5, [r2, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80066be:	00bf      	lsls	r7, r7, #2
 80066c0:	f04f 080f 	mov.w	r8, #15
 80066c4:	fa08 f807 	lsl.w	r8, r8, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80066c8:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80066cc:	ea25 0908 	bic.w	r9, r5, r8
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80066d0:	d01a      	beq.n	8006708 <HAL_GPIO_Init+0xbc>
 80066d2:	4d56      	ldr	r5, [pc, #344]	; (800682c <HAL_GPIO_Init+0x1e0>)
 80066d4:	42a8      	cmp	r0, r5
 80066d6:	f000 8092 	beq.w	80067fe <HAL_GPIO_Init+0x1b2>
 80066da:	4d55      	ldr	r5, [pc, #340]	; (8006830 <HAL_GPIO_Init+0x1e4>)
 80066dc:	42a8      	cmp	r0, r5
 80066de:	f000 8093 	beq.w	8006808 <HAL_GPIO_Init+0x1bc>
 80066e2:	4d54      	ldr	r5, [pc, #336]	; (8006834 <HAL_GPIO_Init+0x1e8>)
 80066e4:	42a8      	cmp	r0, r5
 80066e6:	f000 8083 	beq.w	80067f0 <HAL_GPIO_Init+0x1a4>
 80066ea:	4d53      	ldr	r5, [pc, #332]	; (8006838 <HAL_GPIO_Init+0x1ec>)
 80066ec:	42a8      	cmp	r0, r5
 80066ee:	f000 8092 	beq.w	8006816 <HAL_GPIO_Init+0x1ca>
 80066f2:	4d52      	ldr	r5, [pc, #328]	; (800683c <HAL_GPIO_Init+0x1f0>)
 80066f4:	42a8      	cmp	r0, r5
 80066f6:	bf0c      	ite	eq
 80066f8:	f04f 0805 	moveq.w	r8, #5
 80066fc:	f04f 0806 	movne.w	r8, #6
 8006700:	fa08 f707 	lsl.w	r7, r8, r7
 8006704:	ea49 0907 	orr.w	r9, r9, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8006708:	f8c2 9008 	str.w	r9, [r2, #8]
        temp = EXTI->RTSR1;
 800670c:	68b2      	ldr	r2, [r6, #8]
        temp &= ~(iocurrent);
 800670e:	ea6f 050a 	mvn.w	r5, sl
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8006712:	02cf      	lsls	r7, r1, #11
        temp &= ~(iocurrent);
 8006714:	bf54      	ite	pl
 8006716:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 8006718:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->RTSR1 = temp;
 800671c:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR1;
 800671e:	68f2      	ldr	r2, [r6, #12]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8006720:	028f      	lsls	r7, r1, #10
        temp &= ~(iocurrent);
 8006722:	bf54      	ite	pl
 8006724:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 8006726:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->FTSR1 = temp;
 800672a:	60f2      	str	r2, [r6, #12]

        temp = EXTI->EMR1;
 800672c:	6872      	ldr	r2, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800672e:	038f      	lsls	r7, r1, #14
        temp &= ~(iocurrent);
 8006730:	bf54      	ite	pl
 8006732:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 8006734:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->EMR1 = temp;
 8006738:	6072      	str	r2, [r6, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800673a:	6832      	ldr	r2, [r6, #0]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800673c:	03c9      	lsls	r1, r1, #15
        temp &= ~(iocurrent);
 800673e:	bf54      	ite	pl
 8006740:	402a      	andpl	r2, r5
        {
          temp |= iocurrent;
 8006742:	ea4a 0202 	orrmi.w	r2, sl, r2
        }
        EXTI->IMR1 = temp;
 8006746:	6032      	str	r2, [r6, #0]
      }
    }

    position++;
 8006748:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 800674a:	fa34 f203 	lsrs.w	r2, r4, r3
 800674e:	f10c 0c02 	add.w	ip, ip, #2
 8006752:	d188      	bne.n	8006666 <HAL_GPIO_Init+0x1a>
  }
}
 8006754:	b005      	add	sp, #20
 8006756:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 800675a:	f8d0 9008 	ldr.w	r9, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800675e:	f8de 500c 	ldr.w	r5, [lr, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8006762:	f04f 0803 	mov.w	r8, #3
 8006766:	fa08 f80c 	lsl.w	r8, r8, ip
 800676a:	ea29 0908 	bic.w	r9, r9, r8
        temp |= (GPIO_Init->Speed << (position * 2U));
 800676e:	fa05 f50c 	lsl.w	r5, r5, ip
 8006772:	ea45 0509 	orr.w	r5, r5, r9
        GPIOx->OSPEEDR = temp;
 8006776:	6085      	str	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8006778:	ea6f 0508 	mvn.w	r5, r8
        temp = GPIOx->OTYPER;
 800677c:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8006780:	ea28 0807 	bic.w	r8, r8, r7
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8006784:	f3c1 1700 	ubfx	r7, r1, #4, #1
 8006788:	409f      	lsls	r7, r3
 800678a:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 800678e:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 8006790:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8006792:	ea07 0805 	and.w	r8, r7, r5
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8006796:	f8de 7008 	ldr.w	r7, [lr, #8]
 800679a:	fa07 f70c 	lsl.w	r7, r7, ip
 800679e:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80067a2:	2a02      	cmp	r2, #2
        GPIOx->PUPDR = temp;
 80067a4:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80067a6:	fa02 f20c 	lsl.w	r2, r2, ip
 80067aa:	f47f af6e 	bne.w	800668a <HAL_GPIO_Init+0x3e>
        temp = GPIOx->AFR[position >> 3U];
 80067ae:	ea4f 09d3 	mov.w	r9, r3, lsr #3
 80067b2:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80067b6:	f003 0807 	and.w	r8, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 80067ba:	f8d9 7020 	ldr.w	r7, [r9, #32]
 80067be:	9700      	str	r7, [sp, #0]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80067c0:	f8de 7010 	ldr.w	r7, [lr, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80067c4:	ea4f 0888 	mov.w	r8, r8, lsl #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80067c8:	fa07 f708 	lsl.w	r7, r7, r8
 80067cc:	9701      	str	r7, [sp, #4]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80067ce:	270f      	movs	r7, #15
 80067d0:	fa07 f808 	lsl.w	r8, r7, r8
 80067d4:	9f00      	ldr	r7, [sp, #0]
 80067d6:	ea27 0808 	bic.w	r8, r7, r8
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80067da:	9f01      	ldr	r7, [sp, #4]
 80067dc:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->AFR[position >> 3U] = temp;
 80067e0:	f8c9 7020 	str.w	r7, [r9, #32]
 80067e4:	e751      	b.n	800668a <HAL_GPIO_Init+0x3e>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80067e6:	2503      	movs	r5, #3
 80067e8:	fa05 f50c 	lsl.w	r5, r5, ip
 80067ec:	43ed      	mvns	r5, r5
 80067ee:	e7cf      	b.n	8006790 <HAL_GPIO_Init+0x144>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80067f0:	f04f 0803 	mov.w	r8, #3
 80067f4:	fa08 f707 	lsl.w	r7, r8, r7
 80067f8:	ea49 0907 	orr.w	r9, r9, r7
 80067fc:	e784      	b.n	8006708 <HAL_GPIO_Init+0xbc>
 80067fe:	fa0b f707 	lsl.w	r7, fp, r7
 8006802:	ea49 0907 	orr.w	r9, r9, r7
 8006806:	e77f      	b.n	8006708 <HAL_GPIO_Init+0xbc>
 8006808:	f04f 0802 	mov.w	r8, #2
 800680c:	fa08 f707 	lsl.w	r7, r8, r7
 8006810:	ea49 0907 	orr.w	r9, r9, r7
 8006814:	e778      	b.n	8006708 <HAL_GPIO_Init+0xbc>
 8006816:	f04f 0804 	mov.w	r8, #4
 800681a:	fa08 f707 	lsl.w	r7, r8, r7
 800681e:	ea49 0907 	orr.w	r9, r9, r7
 8006822:	e771      	b.n	8006708 <HAL_GPIO_Init+0xbc>
 8006824:	40010400 	.word	0x40010400
 8006828:	40021000 	.word	0x40021000
 800682c:	48000400 	.word	0x48000400
 8006830:	48000800 	.word	0x48000800
 8006834:	48000c00 	.word	0x48000c00
 8006838:	48001000 	.word	0x48001000
 800683c:	48001400 	.word	0x48001400

08006840 <HAL_PWREx_ControlVoltageScaling>:
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006840:	4a37      	ldr	r2, [pc, #220]	; (8006920 <HAL_PWREx_ControlVoltageScaling+0xe0>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8006842:	b960      	cbnz	r0, 800685e <HAL_PWREx_ControlVoltageScaling+0x1e>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006844:	6813      	ldr	r3, [r2, #0]
 8006846:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 800684a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800684e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006852:	d01d      	beq.n	8006890 <HAL_PWREx_ControlVoltageScaling+0x50>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006854:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006858:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 800685c:	4770      	bx	lr
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 800685e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8006862:	d007      	beq.n	8006874 <HAL_PWREx_ControlVoltageScaling+0x34>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8006864:	6813      	ldr	r3, [r2, #0]
 8006866:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 800686a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 800686e:	2000      	movs	r0, #0
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8006870:	6013      	str	r3, [r2, #0]
}
 8006872:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006874:	6813      	ldr	r3, [r2, #0]
 8006876:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 800687a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800687e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006882:	d02b      	beq.n	80068dc <HAL_PWREx_ControlVoltageScaling+0x9c>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006884:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  return HAL_OK;
 8006888:	2000      	movs	r0, #0
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800688a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 800688e:	4770      	bx	lr
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006890:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006894:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8006898:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800689a:	4822      	ldr	r0, [pc, #136]	; (8006924 <HAL_PWREx_ControlVoltageScaling+0xe4>)
 800689c:	4922      	ldr	r1, [pc, #136]	; (8006928 <HAL_PWREx_ControlVoltageScaling+0xe8>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800689e:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80068a2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80068a6:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068a8:	6803      	ldr	r3, [r0, #0]
 80068aa:	2032      	movs	r0, #50	; 0x32
 80068ac:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068b0:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068b2:	fba1 1303 	umull	r1, r3, r1, r3
 80068b6:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068b8:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068ba:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068be:	d506      	bpl.n	80068ce <HAL_PWREx_ControlVoltageScaling+0x8e>
 80068c0:	e000      	b.n	80068c4 <HAL_PWREx_ControlVoltageScaling+0x84>
 80068c2:	b123      	cbz	r3, 80068ce <HAL_PWREx_ControlVoltageScaling+0x8e>
 80068c4:	6951      	ldr	r1, [r2, #20]
 80068c6:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 80068c8:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068cc:	d4f9      	bmi.n	80068c2 <HAL_PWREx_ControlVoltageScaling+0x82>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80068ce:	4b14      	ldr	r3, [pc, #80]	; (8006920 <HAL_PWREx_ControlVoltageScaling+0xe0>)
 80068d0:	695b      	ldr	r3, [r3, #20]
 80068d2:	055b      	lsls	r3, r3, #21
  return HAL_OK;
 80068d4:	bf54      	ite	pl
 80068d6:	2000      	movpl	r0, #0
        return HAL_TIMEOUT;
 80068d8:	2003      	movmi	r0, #3
 80068da:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 80068dc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80068e0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80068e4:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068e6:	480f      	ldr	r0, [pc, #60]	; (8006924 <HAL_PWREx_ControlVoltageScaling+0xe4>)
 80068e8:	490f      	ldr	r1, [pc, #60]	; (8006928 <HAL_PWREx_ControlVoltageScaling+0xe8>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80068ea:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80068ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80068f2:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068f4:	6803      	ldr	r3, [r0, #0]
 80068f6:	2032      	movs	r0, #50	; 0x32
 80068f8:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80068fc:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 80068fe:	fba1 1303 	umull	r1, r3, r1, r3
 8006902:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006904:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8006906:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800690a:	d5e0      	bpl.n	80068ce <HAL_PWREx_ControlVoltageScaling+0x8e>
 800690c:	e001      	b.n	8006912 <HAL_PWREx_ControlVoltageScaling+0xd2>
 800690e:	2b00      	cmp	r3, #0
 8006910:	d0dd      	beq.n	80068ce <HAL_PWREx_ControlVoltageScaling+0x8e>
 8006912:	6951      	ldr	r1, [r2, #20]
 8006914:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8006916:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800691a:	d5d8      	bpl.n	80068ce <HAL_PWREx_ControlVoltageScaling+0x8e>
 800691c:	e7f7      	b.n	800690e <HAL_PWREx_ControlVoltageScaling+0xce>
 800691e:	bf00      	nop
 8006920:	40007000 	.word	0x40007000
 8006924:	200014a4 	.word	0x200014a4
 8006928:	431bde83 	.word	0x431bde83

0800692c <HAL_PWREx_DisableUCPDDeadBattery>:
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 800692c:	4a02      	ldr	r2, [pc, #8]	; (8006938 <HAL_PWREx_DisableUCPDDeadBattery+0xc>)
 800692e:	6893      	ldr	r3, [r2, #8]
 8006930:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006934:	6093      	str	r3, [r2, #8]
}
 8006936:	4770      	bx	lr
 8006938:	40007000 	.word	0x40007000

0800693c <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800693c:	2800      	cmp	r0, #0
 800693e:	f000 81c3 	beq.w	8006cc8 <HAL_RCC_OscConfig+0x38c>
{
 8006942:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8006946:	6803      	ldr	r3, [r0, #0]
 8006948:	07d9      	lsls	r1, r3, #31
{
 800694a:	b082      	sub	sp, #8
 800694c:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800694e:	d52d      	bpl.n	80069ac <HAL_RCC_OscConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006950:	49a6      	ldr	r1, [pc, #664]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006952:	688a      	ldr	r2, [r1, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006954:	68c9      	ldr	r1, [r1, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006956:	f002 020c 	and.w	r2, r2, #12

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 800695a:	2a0c      	cmp	r2, #12
 800695c:	f000 810a 	beq.w	8006b74 <HAL_RCC_OscConfig+0x238>
 8006960:	2a08      	cmp	r2, #8
 8006962:	f000 810c 	beq.w	8006b7e <HAL_RCC_OscConfig+0x242>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006966:	6863      	ldr	r3, [r4, #4]
 8006968:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800696c:	f000 8133 	beq.w	8006bd6 <HAL_RCC_OscConfig+0x29a>
 8006970:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8006974:	f000 819b 	beq.w	8006cae <HAL_RCC_OscConfig+0x372>
 8006978:	4d9c      	ldr	r5, [pc, #624]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 800697a:	682a      	ldr	r2, [r5, #0]
 800697c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006980:	602a      	str	r2, [r5, #0]
 8006982:	682a      	ldr	r2, [r5, #0]
 8006984:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006988:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800698a:	2b00      	cmp	r3, #0
 800698c:	f040 8128 	bne.w	8006be0 <HAL_RCC_OscConfig+0x2a4>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006990:	f7fe fd38 	bl	8005404 <HAL_GetTick>
 8006994:	4606      	mov	r6, r0

        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8006996:	e005      	b.n	80069a4 <HAL_RCC_OscConfig+0x68>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006998:	f7fe fd34 	bl	8005404 <HAL_GetTick>
 800699c:	1b80      	subs	r0, r0, r6
 800699e:	2864      	cmp	r0, #100	; 0x64
 80069a0:	f200 8142 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80069a4:	682b      	ldr	r3, [r5, #0]
 80069a6:	039f      	lsls	r7, r3, #14
 80069a8:	d4f6      	bmi.n	8006998 <HAL_RCC_OscConfig+0x5c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80069aa:	6823      	ldr	r3, [r4, #0]
 80069ac:	079e      	lsls	r6, r3, #30
 80069ae:	d528      	bpl.n	8006a02 <HAL_RCC_OscConfig+0xc6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80069b0:	4a8e      	ldr	r2, [pc, #568]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 80069b2:	6893      	ldr	r3, [r2, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 80069b4:	68d2      	ldr	r2, [r2, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80069b6:	f003 030c 	and.w	r3, r3, #12
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 80069ba:	2b0c      	cmp	r3, #12
 80069bc:	f000 80ec 	beq.w	8006b98 <HAL_RCC_OscConfig+0x25c>
 80069c0:	2b04      	cmp	r3, #4
 80069c2:	f000 80ee 	beq.w	8006ba2 <HAL_RCC_OscConfig+0x266>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80069c6:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80069c8:	4d88      	ldr	r5, [pc, #544]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80069ca:	2b00      	cmp	r3, #0
 80069cc:	f000 811d 	beq.w	8006c0a <HAL_RCC_OscConfig+0x2ce>
        __HAL_RCC_HSI_ENABLE();
 80069d0:	682b      	ldr	r3, [r5, #0]
 80069d2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80069d6:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80069d8:	f7fe fd14 	bl	8005404 <HAL_GetTick>
 80069dc:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80069de:	e005      	b.n	80069ec <HAL_RCC_OscConfig+0xb0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80069e0:	f7fe fd10 	bl	8005404 <HAL_GetTick>
 80069e4:	1b80      	subs	r0, r0, r6
 80069e6:	2802      	cmp	r0, #2
 80069e8:	f200 811e 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80069ec:	682b      	ldr	r3, [r5, #0]
 80069ee:	0558      	lsls	r0, r3, #21
 80069f0:	d5f6      	bpl.n	80069e0 <HAL_RCC_OscConfig+0xa4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80069f2:	686b      	ldr	r3, [r5, #4]
 80069f4:	6922      	ldr	r2, [r4, #16]
 80069f6:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80069fa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80069fe:	606b      	str	r3, [r5, #4]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006a00:	6823      	ldr	r3, [r4, #0]
 8006a02:	071a      	lsls	r2, r3, #28
 8006a04:	d519      	bpl.n	8006a3a <HAL_RCC_OscConfig+0xfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006a06:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8006a08:	4d78      	ldr	r5, [pc, #480]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8006a0a:	2b00      	cmp	r3, #0
 8006a0c:	f000 809e 	beq.w	8006b4c <HAL_RCC_OscConfig+0x210>
      __HAL_RCC_LSI_ENABLE();
 8006a10:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006a14:	f043 0301 	orr.w	r3, r3, #1
 8006a18:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006a1c:	f7fe fcf2 	bl	8005404 <HAL_GetTick>
 8006a20:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8006a22:	e005      	b.n	8006a30 <HAL_RCC_OscConfig+0xf4>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8006a24:	f7fe fcee 	bl	8005404 <HAL_GetTick>
 8006a28:	1b80      	subs	r0, r0, r6
 8006a2a:	2802      	cmp	r0, #2
 8006a2c:	f200 80fc 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8006a30:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006a34:	079f      	lsls	r7, r3, #30
 8006a36:	d5f5      	bpl.n	8006a24 <HAL_RCC_OscConfig+0xe8>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8006a38:	6823      	ldr	r3, [r4, #0]
 8006a3a:	0759      	lsls	r1, r3, #29
 8006a3c:	d541      	bpl.n	8006ac2 <HAL_RCC_OscConfig+0x186>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8006a3e:	4b6b      	ldr	r3, [pc, #428]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006a40:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006a42:	00d2      	lsls	r2, r2, #3
 8006a44:	f100 80f4 	bmi.w	8006c30 <HAL_RCC_OscConfig+0x2f4>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8006a48:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8006a4a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8006a4e:	659a      	str	r2, [r3, #88]	; 0x58
 8006a50:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006a52:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006a56:	9301      	str	r3, [sp, #4]
 8006a58:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8006a5a:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8006a5c:	4e64      	ldr	r6, [pc, #400]	; (8006bf0 <HAL_RCC_OscConfig+0x2b4>)
 8006a5e:	6833      	ldr	r3, [r6, #0]
 8006a60:	05df      	lsls	r7, r3, #23
 8006a62:	f140 8113 	bpl.w	8006c8c <HAL_RCC_OscConfig+0x350>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006a66:	68a3      	ldr	r3, [r4, #8]
 8006a68:	2b01      	cmp	r3, #1
 8006a6a:	f000 80e3 	beq.w	8006c34 <HAL_RCC_OscConfig+0x2f8>
 8006a6e:	2b05      	cmp	r3, #5
 8006a70:	f000 8169 	beq.w	8006d46 <HAL_RCC_OscConfig+0x40a>
 8006a74:	4e5d      	ldr	r6, [pc, #372]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006a76:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8006a7a:	f022 0201 	bic.w	r2, r2, #1
 8006a7e:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
 8006a82:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 8006a86:	f022 0204 	bic.w	r2, r2, #4
 8006a8a:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8006a8e:	2b00      	cmp	r3, #0
 8006a90:	f040 80d7 	bne.w	8006c42 <HAL_RCC_OscConfig+0x306>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006a94:	f7fe fcb6 	bl	8005404 <HAL_GetTick>

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006a98:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8006a9c:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8006a9e:	e005      	b.n	8006aac <HAL_RCC_OscConfig+0x170>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006aa0:	f7fe fcb0 	bl	8005404 <HAL_GetTick>
 8006aa4:	1bc0      	subs	r0, r0, r7
 8006aa6:	4540      	cmp	r0, r8
 8006aa8:	f200 80be 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8006aac:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8006ab0:	079a      	lsls	r2, r3, #30
 8006ab2:	d4f5      	bmi.n	8006aa0 <HAL_RCC_OscConfig+0x164>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8006ab4:	b125      	cbz	r5, 8006ac0 <HAL_RCC_OscConfig+0x184>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8006ab6:	4a4d      	ldr	r2, [pc, #308]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006ab8:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8006aba:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006abe:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8006ac0:	6823      	ldr	r3, [r4, #0]
 8006ac2:	069b      	lsls	r3, r3, #26
 8006ac4:	d518      	bpl.n	8006af8 <HAL_RCC_OscConfig+0x1bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8006ac6:	69a3      	ldr	r3, [r4, #24]
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8006ac8:	4d48      	ldr	r5, [pc, #288]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8006aca:	2b00      	cmp	r3, #0
 8006acc:	f000 80ca 	beq.w	8006c64 <HAL_RCC_OscConfig+0x328>
      __HAL_RCC_HSI48_ENABLE();
 8006ad0:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006ad4:	f043 0301 	orr.w	r3, r3, #1
 8006ad8:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8006adc:	f7fe fc92 	bl	8005404 <HAL_GetTick>
 8006ae0:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8006ae2:	e005      	b.n	8006af0 <HAL_RCC_OscConfig+0x1b4>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8006ae4:	f7fe fc8e 	bl	8005404 <HAL_GetTick>
 8006ae8:	1b80      	subs	r0, r0, r6
 8006aea:	2802      	cmp	r0, #2
 8006aec:	f200 809c 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8006af0:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006af4:	079f      	lsls	r7, r3, #30
 8006af6:	d5f5      	bpl.n	8006ae4 <HAL_RCC_OscConfig+0x1a8>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8006af8:	69e0      	ldr	r0, [r4, #28]
 8006afa:	b318      	cbz	r0, 8006b44 <HAL_RCC_OscConfig+0x208>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8006afc:	4d3b      	ldr	r5, [pc, #236]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006afe:	68ab      	ldr	r3, [r5, #8]
 8006b00:	f003 030c 	and.w	r3, r3, #12
 8006b04:	2b0c      	cmp	r3, #12
 8006b06:	f000 812c 	beq.w	8006d62 <HAL_RCC_OscConfig+0x426>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8006b0a:	682b      	ldr	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8006b0c:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8006b0e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8006b12:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8006b14:	f000 80da 	beq.w	8006ccc <HAL_RCC_OscConfig+0x390>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8006b18:	68eb      	ldr	r3, [r5, #12]
 8006b1a:	f023 0303 	bic.w	r3, r3, #3
 8006b1e:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 8006b20:	68eb      	ldr	r3, [r5, #12]
 8006b22:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8006b26:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8006b2a:	60eb      	str	r3, [r5, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8006b2c:	f7fe fc6a 	bl	8005404 <HAL_GetTick>
 8006b30:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006b32:	e004      	b.n	8006b3e <HAL_RCC_OscConfig+0x202>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006b34:	f7fe fc66 	bl	8005404 <HAL_GetTick>
 8006b38:	1b00      	subs	r0, r0, r4
 8006b3a:	2802      	cmp	r0, #2
 8006b3c:	d874      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006b3e:	682b      	ldr	r3, [r5, #0]
 8006b40:	019b      	lsls	r3, r3, #6
 8006b42:	d4f7      	bmi.n	8006b34 <HAL_RCC_OscConfig+0x1f8>
      }
    }
  }
  }

  return HAL_OK;
 8006b44:	2000      	movs	r0, #0
}
 8006b46:	b002      	add	sp, #8
 8006b48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8006b4c:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006b50:	f023 0301 	bic.w	r3, r3, #1
 8006b54:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 8006b58:	f7fe fc54 	bl	8005404 <HAL_GetTick>
 8006b5c:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8006b5e:	e004      	b.n	8006b6a <HAL_RCC_OscConfig+0x22e>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8006b60:	f7fe fc50 	bl	8005404 <HAL_GetTick>
 8006b64:	1b80      	subs	r0, r0, r6
 8006b66:	2802      	cmp	r0, #2
 8006b68:	d85e      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8006b6a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8006b6e:	0798      	lsls	r0, r3, #30
 8006b70:	d4f6      	bmi.n	8006b60 <HAL_RCC_OscConfig+0x224>
 8006b72:	e761      	b.n	8006a38 <HAL_RCC_OscConfig+0xfc>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006b74:	f001 0103 	and.w	r1, r1, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8006b78:	2903      	cmp	r1, #3
 8006b7a:	f47f aef4 	bne.w	8006966 <HAL_RCC_OscConfig+0x2a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8006b7e:	4a1b      	ldr	r2, [pc, #108]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006b80:	6812      	ldr	r2, [r2, #0]
 8006b82:	0392      	lsls	r2, r2, #14
 8006b84:	f57f af12 	bpl.w	80069ac <HAL_RCC_OscConfig+0x70>
 8006b88:	6862      	ldr	r2, [r4, #4]
 8006b8a:	2a00      	cmp	r2, #0
 8006b8c:	f47f af0e 	bne.w	80069ac <HAL_RCC_OscConfig+0x70>
        return HAL_ERROR;
 8006b90:	2001      	movs	r0, #1
}
 8006b92:	b002      	add	sp, #8
 8006b94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006b98:	f002 0203 	and.w	r2, r2, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8006b9c:	2a02      	cmp	r2, #2
 8006b9e:	f47f af12 	bne.w	80069c6 <HAL_RCC_OscConfig+0x8a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8006ba2:	4b12      	ldr	r3, [pc, #72]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006ba4:	681b      	ldr	r3, [r3, #0]
 8006ba6:	055d      	lsls	r5, r3, #21
 8006ba8:	d502      	bpl.n	8006bb0 <HAL_RCC_OscConfig+0x274>
 8006baa:	68e3      	ldr	r3, [r4, #12]
 8006bac:	2b00      	cmp	r3, #0
 8006bae:	d0ef      	beq.n	8006b90 <HAL_RCC_OscConfig+0x254>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006bb0:	4a0e      	ldr	r2, [pc, #56]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006bb2:	6920      	ldr	r0, [r4, #16]
 8006bb4:	6853      	ldr	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8006bb6:	490f      	ldr	r1, [pc, #60]	; (8006bf4 <HAL_RCC_OscConfig+0x2b8>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8006bb8:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8006bbc:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8006bc0:	6053      	str	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8006bc2:	6808      	ldr	r0, [r1, #0]
 8006bc4:	f7fe fbd4 	bl	8005370 <HAL_InitTick>
 8006bc8:	2800      	cmp	r0, #0
 8006bca:	d1e1      	bne.n	8006b90 <HAL_RCC_OscConfig+0x254>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8006bcc:	6823      	ldr	r3, [r4, #0]
 8006bce:	071a      	lsls	r2, r3, #28
 8006bd0:	f57f af33 	bpl.w	8006a3a <HAL_RCC_OscConfig+0xfe>
 8006bd4:	e717      	b.n	8006a06 <HAL_RCC_OscConfig+0xca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006bd6:	4a05      	ldr	r2, [pc, #20]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
 8006bd8:	6813      	ldr	r3, [r2, #0]
 8006bda:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006bde:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8006be0:	f7fe fc10 	bl	8005404 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006be4:	4e01      	ldr	r6, [pc, #4]	; (8006bec <HAL_RCC_OscConfig+0x2b0>)
        tickstart = HAL_GetTick();
 8006be6:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006be8:	e00b      	b.n	8006c02 <HAL_RCC_OscConfig+0x2c6>
 8006bea:	bf00      	nop
 8006bec:	40021000 	.word	0x40021000
 8006bf0:	40007000 	.word	0x40007000
 8006bf4:	200014ac 	.word	0x200014ac
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8006bf8:	f7fe fc04 	bl	8005404 <HAL_GetTick>
 8006bfc:	1b40      	subs	r0, r0, r5
 8006bfe:	2864      	cmp	r0, #100	; 0x64
 8006c00:	d812      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006c02:	6833      	ldr	r3, [r6, #0]
 8006c04:	039b      	lsls	r3, r3, #14
 8006c06:	d5f7      	bpl.n	8006bf8 <HAL_RCC_OscConfig+0x2bc>
 8006c08:	e6cf      	b.n	80069aa <HAL_RCC_OscConfig+0x6e>
        __HAL_RCC_HSI_DISABLE();
 8006c0a:	682b      	ldr	r3, [r5, #0]
 8006c0c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006c10:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8006c12:	f7fe fbf7 	bl	8005404 <HAL_GetTick>
 8006c16:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8006c18:	682b      	ldr	r3, [r5, #0]
 8006c1a:	0559      	lsls	r1, r3, #21
 8006c1c:	d5d6      	bpl.n	8006bcc <HAL_RCC_OscConfig+0x290>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8006c1e:	f7fe fbf1 	bl	8005404 <HAL_GetTick>
 8006c22:	1b80      	subs	r0, r0, r6
 8006c24:	2802      	cmp	r0, #2
 8006c26:	d9f7      	bls.n	8006c18 <HAL_RCC_OscConfig+0x2dc>
            return HAL_TIMEOUT;
 8006c28:	2003      	movs	r0, #3
}
 8006c2a:	b002      	add	sp, #8
 8006c2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FlagStatus       pwrclkchanged = RESET;
 8006c30:	2500      	movs	r5, #0
 8006c32:	e713      	b.n	8006a5c <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006c34:	4a65      	ldr	r2, [pc, #404]	; (8006dcc <HAL_RCC_OscConfig+0x490>)
 8006c36:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8006c3a:	f043 0301 	orr.w	r3, r3, #1
 8006c3e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      tickstart = HAL_GetTick();
 8006c42:	f7fe fbdf 	bl	8005404 <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006c46:	4f61      	ldr	r7, [pc, #388]	; (8006dcc <HAL_RCC_OscConfig+0x490>)
      tickstart = HAL_GetTick();
 8006c48:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006c4a:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006c4e:	e004      	b.n	8006c5a <HAL_RCC_OscConfig+0x31e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8006c50:	f7fe fbd8 	bl	8005404 <HAL_GetTick>
 8006c54:	1b80      	subs	r0, r0, r6
 8006c56:	4540      	cmp	r0, r8
 8006c58:	d8e6      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8006c5a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006c5e:	0799      	lsls	r1, r3, #30
 8006c60:	d5f6      	bpl.n	8006c50 <HAL_RCC_OscConfig+0x314>
 8006c62:	e727      	b.n	8006ab4 <HAL_RCC_OscConfig+0x178>
      __HAL_RCC_HSI48_DISABLE();
 8006c64:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006c68:	f023 0301 	bic.w	r3, r3, #1
 8006c6c:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 8006c70:	f7fe fbc8 	bl	8005404 <HAL_GetTick>
 8006c74:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8006c76:	e004      	b.n	8006c82 <HAL_RCC_OscConfig+0x346>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8006c78:	f7fe fbc4 	bl	8005404 <HAL_GetTick>
 8006c7c:	1b80      	subs	r0, r0, r6
 8006c7e:	2802      	cmp	r0, #2
 8006c80:	d8d2      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8006c82:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8006c86:	0798      	lsls	r0, r3, #30
 8006c88:	d4f6      	bmi.n	8006c78 <HAL_RCC_OscConfig+0x33c>
 8006c8a:	e735      	b.n	8006af8 <HAL_RCC_OscConfig+0x1bc>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8006c8c:	6833      	ldr	r3, [r6, #0]
 8006c8e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006c92:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8006c94:	f7fe fbb6 	bl	8005404 <HAL_GetTick>
 8006c98:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8006c9a:	6833      	ldr	r3, [r6, #0]
 8006c9c:	05d8      	lsls	r0, r3, #23
 8006c9e:	f53f aee2 	bmi.w	8006a66 <HAL_RCC_OscConfig+0x12a>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8006ca2:	f7fe fbaf 	bl	8005404 <HAL_GetTick>
 8006ca6:	1bc0      	subs	r0, r0, r7
 8006ca8:	2802      	cmp	r0, #2
 8006caa:	d9f6      	bls.n	8006c9a <HAL_RCC_OscConfig+0x35e>
 8006cac:	e7bc      	b.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8006cae:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8006cb2:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8006cb6:	681a      	ldr	r2, [r3, #0]
 8006cb8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8006cbc:	601a      	str	r2, [r3, #0]
 8006cbe:	681a      	ldr	r2, [r3, #0]
 8006cc0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006cc4:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8006cc6:	e78b      	b.n	8006be0 <HAL_RCC_OscConfig+0x2a4>
    return HAL_ERROR;
 8006cc8:	2001      	movs	r0, #1
}
 8006cca:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8006ccc:	f7fe fb9a 	bl	8005404 <HAL_GetTick>
 8006cd0:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006cd2:	e004      	b.n	8006cde <HAL_RCC_OscConfig+0x3a2>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006cd4:	f7fe fb96 	bl	8005404 <HAL_GetTick>
 8006cd8:	1b80      	subs	r0, r0, r6
 8006cda:	2802      	cmp	r0, #2
 8006cdc:	d8a4      	bhi.n	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8006cde:	682b      	ldr	r3, [r5, #0]
 8006ce0:	0199      	lsls	r1, r3, #6
 8006ce2:	d4f7      	bmi.n	8006cd4 <HAL_RCC_OscConfig+0x398>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8006ce4:	68e9      	ldr	r1, [r5, #12]
 8006ce6:	4b3a      	ldr	r3, [pc, #232]	; (8006dd0 <HAL_RCC_OscConfig+0x494>)
 8006ce8:	6a22      	ldr	r2, [r4, #32]
 8006cea:	6a60      	ldr	r0, [r4, #36]	; 0x24
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006cec:	4e37      	ldr	r6, [pc, #220]	; (8006dcc <HAL_RCC_OscConfig+0x490>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8006cee:	400b      	ands	r3, r1
 8006cf0:	4313      	orrs	r3, r2
 8006cf2:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
 8006cf6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8006cfa:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 8006cfe:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	; 0x30
 8006d02:	3801      	subs	r0, #1
 8006d04:	0849      	lsrs	r1, r1, #1
 8006d06:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8006d0a:	3901      	subs	r1, #1
 8006d0c:	0852      	lsrs	r2, r2, #1
 8006d0e:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8006d12:	3a01      	subs	r2, #1
 8006d14:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8006d18:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8006d1a:	682b      	ldr	r3, [r5, #0]
 8006d1c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006d20:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8006d22:	68eb      	ldr	r3, [r5, #12]
 8006d24:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006d28:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8006d2a:	f7fe fb6b 	bl	8005404 <HAL_GetTick>
 8006d2e:	4604      	mov	r4, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006d30:	e005      	b.n	8006d3e <HAL_RCC_OscConfig+0x402>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8006d32:	f7fe fb67 	bl	8005404 <HAL_GetTick>
 8006d36:	1b00      	subs	r0, r0, r4
 8006d38:	2802      	cmp	r0, #2
 8006d3a:	f63f af75 	bhi.w	8006c28 <HAL_RCC_OscConfig+0x2ec>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006d3e:	6833      	ldr	r3, [r6, #0]
 8006d40:	019a      	lsls	r2, r3, #6
 8006d42:	d5f6      	bpl.n	8006d32 <HAL_RCC_OscConfig+0x3f6>
 8006d44:	e6fe      	b.n	8006b44 <HAL_RCC_OscConfig+0x208>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8006d46:	4b21      	ldr	r3, [pc, #132]	; (8006dcc <HAL_RCC_OscConfig+0x490>)
 8006d48:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8006d4c:	f042 0204 	orr.w	r2, r2, #4
 8006d50:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8006d54:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8006d58:	f042 0201 	orr.w	r2, r2, #1
 8006d5c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8006d60:	e76f      	b.n	8006c42 <HAL_RCC_OscConfig+0x306>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8006d62:	2801      	cmp	r0, #1
 8006d64:	f43f aeef 	beq.w	8006b46 <HAL_RCC_OscConfig+0x20a>
      temp_pllckcfg = RCC->PLLCFGR;
 8006d68:	68eb      	ldr	r3, [r5, #12]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8006d6a:	6a22      	ldr	r2, [r4, #32]
 8006d6c:	f003 0103 	and.w	r1, r3, #3
 8006d70:	4291      	cmp	r1, r2
 8006d72:	f47f af0d 	bne.w	8006b90 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8006d76:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006d78:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8006d7c:	3901      	subs	r1, #1
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8006d7e:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8006d82:	f47f af05 	bne.w	8006b90 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8006d86:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006d88:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8006d8c:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8006d90:	f47f aefe 	bne.w	8006b90 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8006d94:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8006d96:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 8006d9a:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8006d9e:	f47f aef7 	bne.w	8006b90 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8006da2:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8006da4:	0852      	lsrs	r2, r2, #1
 8006da6:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8006daa:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8006dac:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8006db0:	f47f aeee 	bne.w	8006b90 <HAL_RCC_OscConfig+0x254>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8006db4:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8006db6:	0852      	lsrs	r2, r2, #1
 8006db8:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8006dbc:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8006dbe:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
    return HAL_ERROR;
 8006dc2:	bf14      	ite	ne
 8006dc4:	2001      	movne	r0, #1
 8006dc6:	2000      	moveq	r0, #0
 8006dc8:	e6bd      	b.n	8006b46 <HAL_RCC_OscConfig+0x20a>
 8006dca:	bf00      	nop
 8006dcc:	40021000 	.word	0x40021000
 8006dd0:	019f800c 	.word	0x019f800c

08006dd4 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8006dd4:	4b18      	ldr	r3, [pc, #96]	; (8006e38 <HAL_RCC_GetSysClockFreq+0x64>)
 8006dd6:	689a      	ldr	r2, [r3, #8]
 8006dd8:	f002 020c 	and.w	r2, r2, #12
 8006ddc:	2a04      	cmp	r2, #4
 8006dde:	d026      	beq.n	8006e2e <HAL_RCC_GetSysClockFreq+0x5a>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8006de0:	689a      	ldr	r2, [r3, #8]
 8006de2:	f002 020c 	and.w	r2, r2, #12
 8006de6:	2a08      	cmp	r2, #8
 8006de8:	d023      	beq.n	8006e32 <HAL_RCC_GetSysClockFreq+0x5e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8006dea:	689a      	ldr	r2, [r3, #8]
 8006dec:	f002 020c 	and.w	r2, r2, #12
 8006df0:	2a0c      	cmp	r2, #12
 8006df2:	d001      	beq.n	8006df8 <HAL_RCC_GetSysClockFreq+0x24>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }
  else
  {
    sysclockfreq = 0U;
 8006df4:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 8006df6:	4770      	bx	lr
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006df8:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006dfa:	68da      	ldr	r2, [r3, #12]
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006dfc:	68d8      	ldr	r0, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006dfe:	f001 0103 	and.w	r1, r1, #3
    switch (pllsource)
 8006e02:	2903      	cmp	r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006e04:	f3c2 1203 	ubfx	r2, r2, #4, #4
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e08:	f3c0 2006 	ubfx	r0, r0, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e0c:	bf0c      	ite	eq
 8006e0e:	4b0b      	ldreq	r3, [pc, #44]	; (8006e3c <HAL_RCC_GetSysClockFreq+0x68>)
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e10:	4b0b      	ldrne	r3, [pc, #44]	; (8006e40 <HAL_RCC_GetSysClockFreq+0x6c>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006e12:	3201      	adds	r2, #1
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006e14:	fbb3 f3f2 	udiv	r3, r3, r2
 8006e18:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006e1c:	4b06      	ldr	r3, [pc, #24]	; (8006e38 <HAL_RCC_GetSysClockFreq+0x64>)
 8006e1e:	68db      	ldr	r3, [r3, #12]
 8006e20:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8006e24:	3301      	adds	r3, #1
 8006e26:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8006e28:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8006e2c:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 8006e2e:	4804      	ldr	r0, [pc, #16]	; (8006e40 <HAL_RCC_GetSysClockFreq+0x6c>)
 8006e30:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 8006e32:	4802      	ldr	r0, [pc, #8]	; (8006e3c <HAL_RCC_GetSysClockFreq+0x68>)
 8006e34:	4770      	bx	lr
 8006e36:	bf00      	nop
 8006e38:	40021000 	.word	0x40021000
 8006e3c:	016e3600 	.word	0x016e3600
 8006e40:	00f42400 	.word	0x00f42400

08006e44 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8006e44:	2800      	cmp	r0, #0
 8006e46:	f000 80ee 	beq.w	8007026 <HAL_RCC_ClockConfig+0x1e2>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8006e4a:	4a78      	ldr	r2, [pc, #480]	; (800702c <HAL_RCC_ClockConfig+0x1e8>)
{
 8006e4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8006e50:	6813      	ldr	r3, [r2, #0]
 8006e52:	f003 030f 	and.w	r3, r3, #15
 8006e56:	428b      	cmp	r3, r1
 8006e58:	460d      	mov	r5, r1
 8006e5a:	4604      	mov	r4, r0
 8006e5c:	d20c      	bcs.n	8006e78 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006e5e:	6813      	ldr	r3, [r2, #0]
 8006e60:	f023 030f 	bic.w	r3, r3, #15
 8006e64:	430b      	orrs	r3, r1
 8006e66:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8006e68:	6813      	ldr	r3, [r2, #0]
 8006e6a:	f003 030f 	and.w	r3, r3, #15
 8006e6e:	428b      	cmp	r3, r1
 8006e70:	d002      	beq.n	8006e78 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8006e72:	2001      	movs	r0, #1
}
 8006e74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8006e78:	6823      	ldr	r3, [r4, #0]
 8006e7a:	07df      	lsls	r7, r3, #31
 8006e7c:	d569      	bpl.n	8006f52 <HAL_RCC_ClockConfig+0x10e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8006e7e:	6867      	ldr	r7, [r4, #4]
 8006e80:	2f03      	cmp	r7, #3
 8006e82:	f000 80a0 	beq.w	8006fc6 <HAL_RCC_ClockConfig+0x182>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006e86:	4b6a      	ldr	r3, [pc, #424]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006e88:	2f02      	cmp	r7, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006e8a:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8006e8c:	f000 8097 	beq.w	8006fbe <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8006e90:	055b      	lsls	r3, r3, #21
 8006e92:	d5ee      	bpl.n	8006e72 <HAL_RCC_ClockConfig+0x2e>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8006e94:	f7ff ff9e 	bl	8006dd4 <HAL_RCC_GetSysClockFreq>
      if(pllfreq > 80000000U)
 8006e98:	4b66      	ldr	r3, [pc, #408]	; (8007034 <HAL_RCC_ClockConfig+0x1f0>)
 8006e9a:	4298      	cmp	r0, r3
 8006e9c:	f240 80c0 	bls.w	8007020 <HAL_RCC_ClockConfig+0x1dc>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8006ea0:	4a63      	ldr	r2, [pc, #396]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006ea2:	6893      	ldr	r3, [r2, #8]
 8006ea4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006ea8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006eac:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 8006eae:	f04f 0980 	mov.w	r9, #128	; 0x80
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8006eb2:	4e5f      	ldr	r6, [pc, #380]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006eb4:	68b3      	ldr	r3, [r6, #8]
 8006eb6:	f023 0303 	bic.w	r3, r3, #3
 8006eba:	433b      	orrs	r3, r7
 8006ebc:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8006ebe:	f7fe faa1 	bl	8005404 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006ec2:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8006ec6:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8006ec8:	e004      	b.n	8006ed4 <HAL_RCC_ClockConfig+0x90>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006eca:	f7fe fa9b 	bl	8005404 <HAL_GetTick>
 8006ece:	1bc0      	subs	r0, r0, r7
 8006ed0:	4540      	cmp	r0, r8
 8006ed2:	d871      	bhi.n	8006fb8 <HAL_RCC_ClockConfig+0x174>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8006ed4:	68b3      	ldr	r3, [r6, #8]
 8006ed6:	6862      	ldr	r2, [r4, #4]
 8006ed8:	f003 030c 	and.w	r3, r3, #12
 8006edc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8006ee0:	d1f3      	bne.n	8006eca <HAL_RCC_ClockConfig+0x86>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006ee2:	6823      	ldr	r3, [r4, #0]
 8006ee4:	079f      	lsls	r7, r3, #30
 8006ee6:	d436      	bmi.n	8006f56 <HAL_RCC_ClockConfig+0x112>
    if(hpre == RCC_SYSCLK_DIV2)
 8006ee8:	f1b9 0f00 	cmp.w	r9, #0
 8006eec:	d003      	beq.n	8006ef6 <HAL_RCC_ClockConfig+0xb2>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8006eee:	68b3      	ldr	r3, [r6, #8]
 8006ef0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006ef4:	60b3      	str	r3, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006ef6:	4e4d      	ldr	r6, [pc, #308]	; (800702c <HAL_RCC_ClockConfig+0x1e8>)
 8006ef8:	6833      	ldr	r3, [r6, #0]
 8006efa:	f003 030f 	and.w	r3, r3, #15
 8006efe:	42ab      	cmp	r3, r5
 8006f00:	d846      	bhi.n	8006f90 <HAL_RCC_ClockConfig+0x14c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006f02:	6823      	ldr	r3, [r4, #0]
 8006f04:	075a      	lsls	r2, r3, #29
 8006f06:	d506      	bpl.n	8006f16 <HAL_RCC_ClockConfig+0xd2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8006f08:	4949      	ldr	r1, [pc, #292]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f0a:	68e0      	ldr	r0, [r4, #12]
 8006f0c:	688a      	ldr	r2, [r1, #8]
 8006f0e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8006f12:	4302      	orrs	r2, r0
 8006f14:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006f16:	071b      	lsls	r3, r3, #28
 8006f18:	d507      	bpl.n	8006f2a <HAL_RCC_ClockConfig+0xe6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8006f1a:	4a45      	ldr	r2, [pc, #276]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f1c:	6921      	ldr	r1, [r4, #16]
 8006f1e:	6893      	ldr	r3, [r2, #8]
 8006f20:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8006f24:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8006f28:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8006f2a:	f7ff ff53 	bl	8006dd4 <HAL_RCC_GetSysClockFreq>
 8006f2e:	4a40      	ldr	r2, [pc, #256]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f30:	4c41      	ldr	r4, [pc, #260]	; (8007038 <HAL_RCC_ClockConfig+0x1f4>)
 8006f32:	6892      	ldr	r2, [r2, #8]
 8006f34:	4941      	ldr	r1, [pc, #260]	; (800703c <HAL_RCC_ClockConfig+0x1f8>)
 8006f36:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8006f3a:	4603      	mov	r3, r0
 8006f3c:	5ca2      	ldrb	r2, [r4, r2]
  return HAL_InitTick(uwTickPrio);
 8006f3e:	4840      	ldr	r0, [pc, #256]	; (8007040 <HAL_RCC_ClockConfig+0x1fc>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8006f40:	f002 021f 	and.w	r2, r2, #31
 8006f44:	40d3      	lsrs	r3, r2
 8006f46:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8006f48:	6800      	ldr	r0, [r0, #0]
}
 8006f4a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 8006f4e:	f7fe ba0f 	b.w	8005370 <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8006f52:	079e      	lsls	r6, r3, #30
 8006f54:	d5cf      	bpl.n	8006ef6 <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8006f56:	0758      	lsls	r0, r3, #29
 8006f58:	d504      	bpl.n	8006f64 <HAL_RCC_ClockConfig+0x120>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8006f5a:	4935      	ldr	r1, [pc, #212]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f5c:	688a      	ldr	r2, [r1, #8]
 8006f5e:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 8006f62:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8006f64:	0719      	lsls	r1, r3, #28
 8006f66:	d506      	bpl.n	8006f76 <HAL_RCC_ClockConfig+0x132>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 8006f68:	4a31      	ldr	r2, [pc, #196]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f6a:	6893      	ldr	r3, [r2, #8]
 8006f6c:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8006f70:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 8006f74:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006f76:	4a2e      	ldr	r2, [pc, #184]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006f78:	68a1      	ldr	r1, [r4, #8]
 8006f7a:	6893      	ldr	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006f7c:	4e2b      	ldr	r6, [pc, #172]	; (800702c <HAL_RCC_ClockConfig+0x1e8>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8006f7e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006f82:	430b      	orrs	r3, r1
 8006f84:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8006f86:	6833      	ldr	r3, [r6, #0]
 8006f88:	f003 030f 	and.w	r3, r3, #15
 8006f8c:	42ab      	cmp	r3, r5
 8006f8e:	d9b8      	bls.n	8006f02 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8006f90:	6833      	ldr	r3, [r6, #0]
 8006f92:	f023 030f 	bic.w	r3, r3, #15
 8006f96:	432b      	orrs	r3, r5
 8006f98:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 8006f9a:	f7fe fa33 	bl	8005404 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006f9e:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8006fa2:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8006fa4:	6833      	ldr	r3, [r6, #0]
 8006fa6:	f003 030f 	and.w	r3, r3, #15
 8006faa:	42ab      	cmp	r3, r5
 8006fac:	d0a9      	beq.n	8006f02 <HAL_RCC_ClockConfig+0xbe>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8006fae:	f7fe fa29 	bl	8005404 <HAL_GetTick>
 8006fb2:	1bc0      	subs	r0, r0, r7
 8006fb4:	4540      	cmp	r0, r8
 8006fb6:	d9f5      	bls.n	8006fa4 <HAL_RCC_ClockConfig+0x160>
        return HAL_TIMEOUT;
 8006fb8:	2003      	movs	r0, #3
}
 8006fba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8006fbe:	039a      	lsls	r2, r3, #14
 8006fc0:	f53f af68 	bmi.w	8006e94 <HAL_RCC_ClockConfig+0x50>
 8006fc4:	e755      	b.n	8006e72 <HAL_RCC_ClockConfig+0x2e>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8006fc6:	4a1a      	ldr	r2, [pc, #104]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
 8006fc8:	6811      	ldr	r1, [r2, #0]
 8006fca:	0188      	lsls	r0, r1, #6
 8006fcc:	f57f af51 	bpl.w	8006e72 <HAL_RCC_ClockConfig+0x2e>
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006fd0:	68d0      	ldr	r0, [r2, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006fd2:	68d1      	ldr	r1, [r2, #12]
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006fd4:	68d2      	ldr	r2, [r2, #12]
      if(pllfreq > 80000000U)
 8006fd6:	4e17      	ldr	r6, [pc, #92]	; (8007034 <HAL_RCC_ClockConfig+0x1f0>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006fd8:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 8006fdc:	2803      	cmp	r0, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006fde:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006fe2:	bf0c      	ite	eq
 8006fe4:	4817      	ldreq	r0, [pc, #92]	; (8007044 <HAL_RCC_ClockConfig+0x200>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006fe6:	4818      	ldrne	r0, [pc, #96]	; (8007048 <HAL_RCC_ClockConfig+0x204>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006fe8:	3101      	adds	r1, #1
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006fea:	fbb0 f1f1 	udiv	r1, r0, r1
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006fee:	4810      	ldr	r0, [pc, #64]	; (8007030 <HAL_RCC_ClockConfig+0x1ec>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8006ff0:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8006ff4:	fb01 f202 	mul.w	r2, r1, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006ff8:	68c1      	ldr	r1, [r0, #12]
 8006ffa:	f3c1 6141 	ubfx	r1, r1, #25, #2
 8006ffe:	3101      	adds	r1, #1
 8007000:	0049      	lsls	r1, r1, #1
  sysclockfreq = pllvco/pllr;
 8007002:	fbb2 f2f1 	udiv	r2, r2, r1
      if(pllfreq > 80000000U)
 8007006:	42b2      	cmp	r2, r6
 8007008:	d90a      	bls.n	8007020 <HAL_RCC_ClockConfig+0x1dc>
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 800700a:	6882      	ldr	r2, [r0, #8]
 800700c:	f012 0ff0 	tst.w	r2, #240	; 0xf0
 8007010:	f43f af46 	beq.w	8006ea0 <HAL_RCC_ClockConfig+0x5c>
 8007014:	0799      	lsls	r1, r3, #30
 8007016:	d503      	bpl.n	8007020 <HAL_RCC_ClockConfig+0x1dc>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 8007018:	68a3      	ldr	r3, [r4, #8]
 800701a:	2b00      	cmp	r3, #0
 800701c:	f43f af40 	beq.w	8006ea0 <HAL_RCC_ClockConfig+0x5c>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8007020:	f04f 0900 	mov.w	r9, #0
 8007024:	e745      	b.n	8006eb2 <HAL_RCC_ClockConfig+0x6e>
    return HAL_ERROR;
 8007026:	2001      	movs	r0, #1
}
 8007028:	4770      	bx	lr
 800702a:	bf00      	nop
 800702c:	40022000 	.word	0x40022000
 8007030:	40021000 	.word	0x40021000
 8007034:	04c4b400 	.word	0x04c4b400
 8007038:	0801a184 	.word	0x0801a184
 800703c:	200014a4 	.word	0x200014a4
 8007040:	200014ac 	.word	0x200014ac
 8007044:	016e3600 	.word	0x016e3600
 8007048:	00f42400 	.word	0x00f42400

0800704c <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 800704c:	4b01      	ldr	r3, [pc, #4]	; (8007054 <HAL_RCC_GetHCLKFreq+0x8>)
}
 800704e:	6818      	ldr	r0, [r3, #0]
 8007050:	4770      	bx	lr
 8007052:	bf00      	nop
 8007054:	200014a4 	.word	0x200014a4

08007058 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8007058:	4b05      	ldr	r3, [pc, #20]	; (8007070 <HAL_RCC_GetPCLK1Freq+0x18>)
 800705a:	4a06      	ldr	r2, [pc, #24]	; (8007074 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800705c:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800705e:	4906      	ldr	r1, [pc, #24]	; (8007078 <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8007060:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8007064:	6808      	ldr	r0, [r1, #0]
 8007066:	5cd3      	ldrb	r3, [r2, r3]
 8007068:	f003 031f 	and.w	r3, r3, #31
}
 800706c:	40d8      	lsrs	r0, r3
 800706e:	4770      	bx	lr
 8007070:	40021000 	.word	0x40021000
 8007074:	0801a194 	.word	0x0801a194
 8007078:	200014a4 	.word	0x200014a4

0800707c <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 800707c:	4b05      	ldr	r3, [pc, #20]	; (8007094 <HAL_RCC_GetPCLK2Freq+0x18>)
 800707e:	4a06      	ldr	r2, [pc, #24]	; (8007098 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8007080:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8007082:	4906      	ldr	r1, [pc, #24]	; (800709c <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8007084:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8007088:	6808      	ldr	r0, [r1, #0]
 800708a:	5cd3      	ldrb	r3, [r2, r3]
 800708c:	f003 031f 	and.w	r3, r3, #31
}
 8007090:	40d8      	lsrs	r0, r3
 8007092:	4770      	bx	lr
 8007094:	40021000 	.word	0x40021000
 8007098:	0801a194 	.word	0x0801a194
 800709c:	200014a4 	.word	0x200014a4

080070a0 <HAL_RCC_EnableCSS>:
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 80070a0:	4a02      	ldr	r2, [pc, #8]	; (80070ac <HAL_RCC_EnableCSS+0xc>)
 80070a2:	6813      	ldr	r3, [r2, #0]
 80070a4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80070a8:	6013      	str	r3, [r2, #0]
}
 80070aa:	4770      	bx	lr
 80070ac:	40021000 	.word	0x40021000

080070b0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80070b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80070b4:	6803      	ldr	r3, [r0, #0]
{
 80070b6:	4604      	mov	r4, r0
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80070b8:	f413 2000 	ands.w	r0, r3, #524288	; 0x80000
{
 80070bc:	b082      	sub	sp, #8
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80070be:	d056      	beq.n	800716e <HAL_RCCEx_PeriphCLKConfig+0xbe>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80070c0:	4bac      	ldr	r3, [pc, #688]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80070c2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80070c4:	00d5      	lsls	r5, r2, #3
 80070c6:	f140 813e 	bpl.w	8007346 <HAL_RCCEx_PeriphCLKConfig+0x296>
    FlagStatus       pwrclkchanged = RESET;
 80070ca:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80070cc:	4daa      	ldr	r5, [pc, #680]	; (8007378 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80070ce:	682b      	ldr	r3, [r5, #0]
 80070d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80070d4:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80070d6:	f7fe f995 	bl	8005404 <HAL_GetTick>
 80070da:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80070dc:	e005      	b.n	80070ea <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80070de:	f7fe f991 	bl	8005404 <HAL_GetTick>
 80070e2:	1b83      	subs	r3, r0, r6
 80070e4:	2b02      	cmp	r3, #2
 80070e6:	f200 8139 	bhi.w	800735c <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80070ea:	682b      	ldr	r3, [r5, #0]
 80070ec:	05d8      	lsls	r0, r3, #23
 80070ee:	d5f6      	bpl.n	80070de <HAL_RCCEx_PeriphCLKConfig+0x2e>
    }

    if(ret == HAL_OK)
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80070f0:	4da0      	ldr	r5, [pc, #640]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80070f2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80070f6:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80070fa:	d027      	beq.n	800714c <HAL_RCCEx_PeriphCLKConfig+0x9c>
 80070fc:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80070fe:	429a      	cmp	r2, r3
 8007100:	d025      	beq.n	800714e <HAL_RCCEx_PeriphCLKConfig+0x9e>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8007102:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8007106:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800710a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800710e:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8007112:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8007116:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800711a:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800711e:	f421 7340 	bic.w	r3, r1, #768	; 0x300
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8007122:	07c9      	lsls	r1, r1, #31
        RCC->BDCR = tmpregister;
 8007124:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8007128:	f140 8148 	bpl.w	80073bc <HAL_RCCEx_PeriphCLKConfig+0x30c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800712c:	f7fe f96a 	bl	8005404 <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007130:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8007134:	4606      	mov	r6, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8007136:	e005      	b.n	8007144 <HAL_RCCEx_PeriphCLKConfig+0x94>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007138:	f7fe f964 	bl	8005404 <HAL_GetTick>
 800713c:	1b80      	subs	r0, r0, r6
 800713e:	4540      	cmp	r0, r8
 8007140:	f200 810c 	bhi.w	800735c <HAL_RCCEx_PeriphCLKConfig+0x2ac>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8007144:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8007148:	079b      	lsls	r3, r3, #30
 800714a:	d5f5      	bpl.n	8007138 <HAL_RCCEx_PeriphCLKConfig+0x88>
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 800714c:	6d23      	ldr	r3, [r4, #80]	; 0x50
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800714e:	4989      	ldr	r1, [pc, #548]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007150:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8007154:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8007158:	4313      	orrs	r3, r2
 800715a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 800715e:	2000      	movs	r0, #0
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8007160:	b127      	cbz	r7, 800716c <HAL_RCCEx_PeriphCLKConfig+0xbc>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8007162:	4a84      	ldr	r2, [pc, #528]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007164:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8007166:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800716a:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800716c:	6823      	ldr	r3, [r4, #0]
 800716e:	07dd      	lsls	r5, r3, #31
 8007170:	d508      	bpl.n	8007184 <HAL_RCCEx_PeriphCLKConfig+0xd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8007172:	4980      	ldr	r1, [pc, #512]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007174:	6865      	ldr	r5, [r4, #4]
 8007176:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800717a:	f022 0203 	bic.w	r2, r2, #3
 800717e:	432a      	orrs	r2, r5
 8007180:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8007184:	0799      	lsls	r1, r3, #30
 8007186:	d508      	bpl.n	800719a <HAL_RCCEx_PeriphCLKConfig+0xea>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8007188:	497a      	ldr	r1, [pc, #488]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800718a:	68a5      	ldr	r5, [r4, #8]
 800718c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007190:	f022 020c 	bic.w	r2, r2, #12
 8007194:	432a      	orrs	r2, r5
 8007196:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800719a:	075a      	lsls	r2, r3, #29
 800719c:	d508      	bpl.n	80071b0 <HAL_RCCEx_PeriphCLKConfig+0x100>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800719e:	4975      	ldr	r1, [pc, #468]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071a0:	68e5      	ldr	r5, [r4, #12]
 80071a2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071a6:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 80071aa:	432a      	orrs	r2, r5
 80071ac:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80071b0:	071f      	lsls	r7, r3, #28
 80071b2:	d508      	bpl.n	80071c6 <HAL_RCCEx_PeriphCLKConfig+0x116>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80071b4:	496f      	ldr	r1, [pc, #444]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071b6:	6925      	ldr	r5, [r4, #16]
 80071b8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071bc:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 80071c0:	432a      	orrs	r2, r5
 80071c2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80071c6:	06de      	lsls	r6, r3, #27
 80071c8:	d508      	bpl.n	80071dc <HAL_RCCEx_PeriphCLKConfig+0x12c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80071ca:	496a      	ldr	r1, [pc, #424]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071cc:	6965      	ldr	r5, [r4, #20]
 80071ce:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071d2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80071d6:	432a      	orrs	r2, r5
 80071d8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80071dc:	069d      	lsls	r5, r3, #26
 80071de:	d508      	bpl.n	80071f2 <HAL_RCCEx_PeriphCLKConfig+0x142>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80071e0:	4964      	ldr	r1, [pc, #400]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071e2:	69a5      	ldr	r5, [r4, #24]
 80071e4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071e8:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 80071ec:	432a      	orrs	r2, r5
 80071ee:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80071f2:	0659      	lsls	r1, r3, #25
 80071f4:	d508      	bpl.n	8007208 <HAL_RCCEx_PeriphCLKConfig+0x158>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80071f6:	495f      	ldr	r1, [pc, #380]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80071f8:	69e5      	ldr	r5, [r4, #28]
 80071fa:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80071fe:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8007202:	432a      	orrs	r2, r5
 8007204:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8007208:	061a      	lsls	r2, r3, #24
 800720a:	d508      	bpl.n	800721e <HAL_RCCEx_PeriphCLKConfig+0x16e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800720c:	4959      	ldr	r1, [pc, #356]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800720e:	6a25      	ldr	r5, [r4, #32]
 8007210:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007214:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8007218:	432a      	orrs	r2, r5
 800721a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800721e:	05df      	lsls	r7, r3, #23
 8007220:	d508      	bpl.n	8007234 <HAL_RCCEx_PeriphCLKConfig+0x184>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8007222:	4954      	ldr	r1, [pc, #336]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007224:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8007226:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800722a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800722e:	432a      	orrs	r2, r5
 8007230:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

#if defined(I2C4)  

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8007234:	039e      	lsls	r6, r3, #14
 8007236:	d508      	bpl.n	800724a <HAL_RCCEx_PeriphCLKConfig+0x19a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8007238:	494e      	ldr	r1, [pc, #312]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800723a:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800723c:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007240:	f022 0203 	bic.w	r2, r2, #3
 8007244:	432a      	orrs	r2, r5
 8007246:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800724a:	059d      	lsls	r5, r3, #22
 800724c:	d508      	bpl.n	8007260 <HAL_RCCEx_PeriphCLKConfig+0x1b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800724e:	4949      	ldr	r1, [pc, #292]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007250:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8007252:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007256:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 800725a:	432a      	orrs	r2, r5
 800725c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8007260:	0559      	lsls	r1, r3, #21
 8007262:	d50b      	bpl.n	800727c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8007264:	4943      	ldr	r1, [pc, #268]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007266:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8007268:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800726c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8007270:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 8007272:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8007276:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 800727a:	d071      	beq.n	8007360 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 800727c:	051a      	lsls	r2, r3, #20
 800727e:	d50b      	bpl.n	8007298 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8007280:	493c      	ldr	r1, [pc, #240]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8007282:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8007284:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007288:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800728c:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 800728e:	f5b5 0f80 	cmp.w	r5, #4194304	; 0x400000
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8007292:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 8007296:	d068      	beq.n	800736a <HAL_RCCEx_PeriphCLKConfig+0x2ba>
    }
  }

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8007298:	04df      	lsls	r7, r3, #19
 800729a:	d50b      	bpl.n	80072b4 <HAL_RCCEx_PeriphCLKConfig+0x204>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800729c:	4935      	ldr	r1, [pc, #212]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800729e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80072a0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072a4:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80072a8:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 80072aa:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 80072ae:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 80072b2:	d063      	beq.n	800737c <HAL_RCCEx_PeriphCLKConfig+0x2cc>
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 80072b4:	049e      	lsls	r6, r3, #18
 80072b6:	d50b      	bpl.n	80072d0 <HAL_RCCEx_PeriphCLKConfig+0x220>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80072b8:	492e      	ldr	r1, [pc, #184]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072ba:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 80072bc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072c0:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80072c4:	432a      	orrs	r2, r5

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80072c6:	f1b5 6f00 	cmp.w	r5, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80072ca:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80072ce:	d05a      	beq.n	8007386 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80072d0:	045d      	lsls	r5, r3, #17
 80072d2:	d50b      	bpl.n	80072ec <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80072d4:	4927      	ldr	r1, [pc, #156]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072d6:	6c25      	ldr	r5, [r4, #64]	; 0x40
 80072d8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072dc:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80072e0:	432a      	orrs	r2, r5

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80072e2:	f1b5 6f00 	cmp.w	r5, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80072e6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80072ea:	d051      	beq.n	8007390 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 80072ec:	0419      	lsls	r1, r3, #16
 80072ee:	d50b      	bpl.n	8007308 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 80072f0:	4920      	ldr	r1, [pc, #128]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80072f2:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80072f4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80072f8:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80072fc:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 80072fe:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8007302:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 8007306:	d048      	beq.n	800739a <HAL_RCCEx_PeriphCLKConfig+0x2ea>
    }
  }
  
#if defined(ADC345_COMMON)
  /*-------------------------- ADC345 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345)
 8007308:	03da      	lsls	r2, r3, #15
 800730a:	d50b      	bpl.n	8007324 <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC345CLKSOURCE(PeriphClkInit->Adc345ClockSelection));

    /* Configure the ADC345 interface clock source */
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 800730c:	4919      	ldr	r1, [pc, #100]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800730e:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8007310:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007314:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 8007318:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 800731a:	f1b5 4f80 	cmp.w	r5, #1073741824	; 0x40000000
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 800731e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 8007322:	d03f      	beq.n	80073a4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
#endif /* ADC345_COMMON */

#if defined(QUADSPI)

  /*-------------------------- QuadSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 8007324:	035b      	lsls	r3, r3, #13
 8007326:	d50b      	bpl.n	8007340 <HAL_RCCEx_PeriphCLKConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    /* Configure the QuadSPI clock source */
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8007328:	4a12      	ldr	r2, [pc, #72]	; (8007374 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800732a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800732c:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8007330:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007334:	430b      	orrs	r3, r1

    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 8007336:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 800733a:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 800733e:	d036      	beq.n	80073ae <HAL_RCCEx_PeriphCLKConfig+0x2fe>
  }

#endif /* QUADSPI */

  return status;
}
 8007340:	b002      	add	sp, #8
 8007342:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 8007346:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007348:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800734c:	659a      	str	r2, [r3, #88]	; 0x58
 800734e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007350:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8007354:	9301      	str	r3, [sp, #4]
 8007356:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8007358:	2701      	movs	r7, #1
 800735a:	e6b7      	b.n	80070cc <HAL_RCCEx_PeriphCLKConfig+0x1c>
      status = ret;
 800735c:	2003      	movs	r0, #3
 800735e:	e6ff      	b.n	8007160 <HAL_RCCEx_PeriphCLKConfig+0xb0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007360:	68ca      	ldr	r2, [r1, #12]
 8007362:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007366:	60ca      	str	r2, [r1, #12]
 8007368:	e788      	b.n	800727c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800736a:	68ca      	ldr	r2, [r1, #12]
 800736c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007370:	60ca      	str	r2, [r1, #12]
 8007372:	e791      	b.n	8007298 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 8007374:	40021000 	.word	0x40021000
 8007378:	40007000 	.word	0x40007000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800737c:	68ca      	ldr	r2, [r1, #12]
 800737e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007382:	60ca      	str	r2, [r1, #12]
 8007384:	e796      	b.n	80072b4 <HAL_RCCEx_PeriphCLKConfig+0x204>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007386:	68ca      	ldr	r2, [r1, #12]
 8007388:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800738c:	60ca      	str	r2, [r1, #12]
 800738e:	e79f      	b.n	80072d0 <HAL_RCCEx_PeriphCLKConfig+0x220>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007390:	68ca      	ldr	r2, [r1, #12]
 8007392:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007396:	60ca      	str	r2, [r1, #12]
 8007398:	e7a8      	b.n	80072ec <HAL_RCCEx_PeriphCLKConfig+0x23c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 800739a:	68ca      	ldr	r2, [r1, #12]
 800739c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80073a0:	60ca      	str	r2, [r1, #12]
 80073a2:	e7b1      	b.n	8007308 <HAL_RCCEx_PeriphCLKConfig+0x258>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80073a4:	68ca      	ldr	r2, [r1, #12]
 80073a6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80073aa:	60ca      	str	r2, [r1, #12]
 80073ac:	e7ba      	b.n	8007324 <HAL_RCCEx_PeriphCLKConfig+0x274>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80073ae:	68d3      	ldr	r3, [r2, #12]
 80073b0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80073b4:	60d3      	str	r3, [r2, #12]
}
 80073b6:	b002      	add	sp, #8
 80073b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80073bc:	4613      	mov	r3, r2
 80073be:	e6c6      	b.n	800714e <HAL_RCCEx_PeriphCLKConfig+0x9e>

080073c0 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80073c0:	6a03      	ldr	r3, [r0, #32]
 80073c2:	f023 0301 	bic.w	r3, r3, #1
 80073c6:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80073c8:	6a03      	ldr	r3, [r0, #32]
{
 80073ca:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80073cc:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80073ce:	6982      	ldr	r2, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80073d0:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80073d2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80073d6:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 80073da:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80073dc:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC1P;
 80073de:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= OC_Config->OCPolarity;
 80073e2:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80073e4:	4d15      	ldr	r5, [pc, #84]	; (800743c <TIM_OC1_SetConfig+0x7c>)
 80073e6:	42a8      	cmp	r0, r5
 80073e8:	d013      	beq.n	8007412 <TIM_OC1_SetConfig+0x52>
 80073ea:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 80073ee:	42a8      	cmp	r0, r5
 80073f0:	d00f      	beq.n	8007412 <TIM_OC1_SetConfig+0x52>
 80073f2:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 80073f6:	42a8      	cmp	r0, r5
 80073f8:	d00b      	beq.n	8007412 <TIM_OC1_SetConfig+0x52>
 80073fa:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80073fe:	42a8      	cmp	r0, r5
 8007400:	d007      	beq.n	8007412 <TIM_OC1_SetConfig+0x52>
 8007402:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007406:	42a8      	cmp	r0, r5
 8007408:	d003      	beq.n	8007412 <TIM_OC1_SetConfig+0x52>
 800740a:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800740e:	42a8      	cmp	r0, r5
 8007410:	d10d      	bne.n	800742e <TIM_OC1_SetConfig+0x6e>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8007412:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
 8007414:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
 8007418:	432b      	orrs	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800741a:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800741e:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    tmpcr2 |= OC_Config->OCNIdleState;
 8007422:	ea46 0c05 	orr.w	ip, r6, r5
    tmpccer &= ~TIM_CCER_CC1NE;
 8007426:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 800742a:	ea4c 0404 	orr.w	r4, ip, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800742e:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8007430:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8007432:	6182      	str	r2, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8007434:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR1 = OC_Config->Pulse;
 8007436:	6341      	str	r1, [r0, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8007438:	6203      	str	r3, [r0, #32]
}
 800743a:	4770      	bx	lr
 800743c:	40012c00 	.word	0x40012c00

08007440 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8007440:	6a03      	ldr	r3, [r0, #32]
 8007442:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007446:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007448:	6a03      	ldr	r3, [r0, #32]
{
 800744a:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800744c:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800744e:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8007450:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8007452:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8007456:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800745a:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800745c:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC3P;
 800745e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8007462:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8007466:	4d1c      	ldr	r5, [pc, #112]	; (80074d8 <TIM_OC3_SetConfig+0x98>)
 8007468:	42a8      	cmp	r0, r5
 800746a:	d017      	beq.n	800749c <TIM_OC3_SetConfig+0x5c>
 800746c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007470:	42a8      	cmp	r0, r5
 8007472:	d013      	beq.n	800749c <TIM_OC3_SetConfig+0x5c>
 8007474:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 8007478:	42a8      	cmp	r0, r5
 800747a:	d025      	beq.n	80074c8 <TIM_OC3_SetConfig+0x88>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800747c:	4d17      	ldr	r5, [pc, #92]	; (80074dc <TIM_OC3_SetConfig+0x9c>)
 800747e:	42a8      	cmp	r0, r5
 8007480:	d013      	beq.n	80074aa <TIM_OC3_SetConfig+0x6a>
 8007482:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007486:	42a8      	cmp	r0, r5
 8007488:	d00f      	beq.n	80074aa <TIM_OC3_SetConfig+0x6a>
 800748a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800748e:	42a8      	cmp	r0, r5
 8007490:	d00b      	beq.n	80074aa <TIM_OC3_SetConfig+0x6a>
 8007492:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007496:	42a8      	cmp	r0, r5
 8007498:	d10f      	bne.n	80074ba <TIM_OC3_SetConfig+0x7a>
 800749a:	e006      	b.n	80074aa <TIM_OC3_SetConfig+0x6a>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800749c:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 800749e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80074a2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80074a6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80074aa:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80074ae:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80074b2:	ea46 0c05 	orr.w	ip, r6, r5
 80074b6:	ea44 140c 	orr.w	r4, r4, ip, lsl #4

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 80074ba:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80074bc:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 80074be:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80074c0:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR3 = OC_Config->Pulse;
 80074c2:	63c1      	str	r1, [r0, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 80074c4:	6203      	str	r3, [r0, #32]
}
 80074c6:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80074c8:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
 80074ca:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80074ce:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80074d2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80074d6:	e7d1      	b.n	800747c <TIM_OC3_SetConfig+0x3c>
 80074d8:	40012c00 	.word	0x40012c00
 80074dc:	40014000 	.word	0x40014000

080074e0 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80074e0:	6a03      	ldr	r3, [r0, #32]
 80074e2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80074e6:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80074e8:	6a03      	ldr	r3, [r0, #32]
{
 80074ea:	b470      	push	{r4, r5, r6}
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80074ec:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80074ee:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80074f0:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80074f2:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80074f6:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80074fa:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80074fe:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC4P;
 8007500:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8007504:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_4))
 8007508:	4d1c      	ldr	r5, [pc, #112]	; (800757c <TIM_OC4_SetConfig+0x9c>)
 800750a:	42a8      	cmp	r0, r5
 800750c:	d017      	beq.n	800753e <TIM_OC4_SetConfig+0x5e>
 800750e:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007512:	42a8      	cmp	r0, r5
 8007514:	d013      	beq.n	800753e <TIM_OC4_SetConfig+0x5e>
 8007516:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 800751a:	42a8      	cmp	r0, r5
 800751c:	d025      	beq.n	800756a <TIM_OC4_SetConfig+0x8a>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC4NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800751e:	4d18      	ldr	r5, [pc, #96]	; (8007580 <TIM_OC4_SetConfig+0xa0>)
 8007520:	42a8      	cmp	r0, r5
 8007522:	d013      	beq.n	800754c <TIM_OC4_SetConfig+0x6c>
 8007524:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007528:	42a8      	cmp	r0, r5
 800752a:	d00f      	beq.n	800754c <TIM_OC4_SetConfig+0x6c>
 800752c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007530:	42a8      	cmp	r0, r5
 8007532:	d00b      	beq.n	800754c <TIM_OC4_SetConfig+0x6c>
 8007534:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007538:	42a8      	cmp	r0, r5
 800753a:	d10f      	bne.n	800755c <TIM_OC4_SetConfig+0x7c>
 800753c:	e006      	b.n	800754c <TIM_OC4_SetConfig+0x6c>
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 800753e:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 8007540:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 8007544:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 8007548:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    tmpcr2 &= ~TIM_CR2_OIS4N;

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 800754c:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4N;
 8007550:	f424 4440 	bic.w	r4, r4, #49152	; 0xc000
    tmpcr2 |= (OC_Config->OCNIdleState << 6U);
 8007554:	ea46 0c05 	orr.w	ip, r6, r5
 8007558:	ea44 148c 	orr.w	r4, r4, ip, lsl #6

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800755c:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800755e:	6044      	str	r4, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 8007560:	61c2      	str	r2, [r0, #28]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8007562:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR4 = OC_Config->Pulse;
 8007564:	6401      	str	r1, [r0, #64]	; 0x40
  TIMx->CCER = tmpccer;
 8007566:	6203      	str	r3, [r0, #32]
}
 8007568:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 800756a:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC4NP;
 800756c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    tmpccer |= (OC_Config->OCNPolarity << 12U);
 8007570:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
    tmpccer &= ~TIM_CCER_CC4NE;
 8007574:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007578:	e7d1      	b.n	800751e <TIM_OC4_SetConfig+0x3e>
 800757a:	bf00      	nop
 800757c:	40012c00 	.word	0x40012c00
 8007580:	40014000 	.word	0x40014000

08007584 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8007584:	2800      	cmp	r0, #0
 8007586:	f000 808c 	beq.w	80076a2 <HAL_TIM_Base_Init+0x11e>
{
 800758a:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800758c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8007590:	4604      	mov	r4, r0
 8007592:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8007596:	2b00      	cmp	r3, #0
 8007598:	d078      	beq.n	800768c <HAL_TIM_Base_Init+0x108>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800759a:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800759c:	4944      	ldr	r1, [pc, #272]	; (80076b0 <HAL_TIM_Base_Init+0x12c>)
  htim->State = HAL_TIM_STATE_BUSY;
 800759e:	2302      	movs	r3, #2
 80075a0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80075a4:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 80075a6:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80075a8:	d05c      	beq.n	8007664 <HAL_TIM_Base_Init+0xe0>
 80075aa:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80075ae:	d02c      	beq.n	800760a <HAL_TIM_Base_Init+0x86>
 80075b0:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 80075b4:	428a      	cmp	r2, r1
 80075b6:	d028      	beq.n	800760a <HAL_TIM_Base_Init+0x86>
 80075b8:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80075bc:	428a      	cmp	r2, r1
 80075be:	d024      	beq.n	800760a <HAL_TIM_Base_Init+0x86>
 80075c0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80075c4:	428a      	cmp	r2, r1
 80075c6:	d020      	beq.n	800760a <HAL_TIM_Base_Init+0x86>
 80075c8:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 80075cc:	428a      	cmp	r2, r1
 80075ce:	d049      	beq.n	8007664 <HAL_TIM_Base_Init+0xe0>
 80075d0:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 80075d4:	428a      	cmp	r2, r1
 80075d6:	d066      	beq.n	80076a6 <HAL_TIM_Base_Init+0x122>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80075d8:	4936      	ldr	r1, [pc, #216]	; (80076b4 <HAL_TIM_Base_Init+0x130>)
 80075da:	428a      	cmp	r2, r1
 80075dc:	d05b      	beq.n	8007696 <HAL_TIM_Base_Init+0x112>
 80075de:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80075e2:	428a      	cmp	r2, r1
 80075e4:	d057      	beq.n	8007696 <HAL_TIM_Base_Init+0x112>
 80075e6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80075ea:	428a      	cmp	r2, r1
 80075ec:	d053      	beq.n	8007696 <HAL_TIM_Base_Init+0x112>
 80075ee:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80075f2:	428a      	cmp	r2, r1
 80075f4:	d04f      	beq.n	8007696 <HAL_TIM_Base_Init+0x112>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80075f6:	69a0      	ldr	r0, [r4, #24]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80075f8:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80075fa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80075fe:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 8007600:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 8007602:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007604:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007606:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8007608:	e010      	b.n	800762c <HAL_TIM_Base_Init+0xa8>
    tmpcr1 |= Structure->CounterMode;
 800760a:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800760c:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800760e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007612:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8007614:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007618:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800761a:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800761c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007620:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007622:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8007624:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8007626:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007628:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800762a:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 800762c:	2301      	movs	r3, #1
 800762e:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8007630:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8007634:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8007638:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800763c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8007640:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8007644:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8007648:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800764c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8007650:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8007654:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8007658:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 800765c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8007660:	2000      	movs	r0, #0
}
 8007662:	bd10      	pop	{r4, pc}
    tmpcr1 |= Structure->CounterMode;
 8007664:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007666:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007668:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800766c:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 800766e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007672:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007674:	69a1      	ldr	r1, [r4, #24]
 8007676:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800767a:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 800767c:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800767e:	68e3      	ldr	r3, [r4, #12]
 8007680:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007682:	6863      	ldr	r3, [r4, #4]
 8007684:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8007686:	6963      	ldr	r3, [r4, #20]
 8007688:	6313      	str	r3, [r2, #48]	; 0x30
 800768a:	e7cf      	b.n	800762c <HAL_TIM_Base_Init+0xa8>
    htim->Lock = HAL_UNLOCKED;
 800768c:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8007690:	f7fd fb8c 	bl	8004dac <HAL_TIM_Base_MspInit>
 8007694:	e781      	b.n	800759a <HAL_TIM_Base_Init+0x16>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007696:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007698:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 800769a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800769e:	4303      	orrs	r3, r0
 80076a0:	e7e9      	b.n	8007676 <HAL_TIM_Base_Init+0xf2>
    return HAL_ERROR;
 80076a2:	2001      	movs	r0, #1
}
 80076a4:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 80076a6:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80076a8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80076ac:	430b      	orrs	r3, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80076ae:	e793      	b.n	80075d8 <HAL_TIM_Base_Init+0x54>
 80076b0:	40012c00 	.word	0x40012c00
 80076b4:	40014000 	.word	0x40014000

080076b8 <HAL_TIM_Base_Start>:
  if (htim->State != HAL_TIM_STATE_READY)
 80076b8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80076bc:	2b01      	cmp	r3, #1
 80076be:	d12f      	bne.n	8007720 <HAL_TIM_Base_Start+0x68>
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80076c0:	6803      	ldr	r3, [r0, #0]
 80076c2:	4a19      	ldr	r2, [pc, #100]	; (8007728 <HAL_TIM_Base_Start+0x70>)
  htim->State = HAL_TIM_STATE_BUSY;
 80076c4:	2102      	movs	r1, #2
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80076c6:	4293      	cmp	r3, r2
  htim->State = HAL_TIM_STATE_BUSY;
 80076c8:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80076cc:	d01a      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076ce:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80076d2:	d017      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076d4:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80076d8:	4293      	cmp	r3, r2
 80076da:	d013      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076dc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80076e0:	4293      	cmp	r3, r2
 80076e2:	d00f      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076e4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80076e8:	4293      	cmp	r3, r2
 80076ea:	d00b      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076ec:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 80076f0:	4293      	cmp	r3, r2
 80076f2:	d007      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076f4:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 80076f8:	4293      	cmp	r3, r2
 80076fa:	d003      	beq.n	8007704 <HAL_TIM_Base_Start+0x4c>
 80076fc:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8007700:	4293      	cmp	r3, r2
 8007702:	d107      	bne.n	8007714 <HAL_TIM_Base_Start+0x5c>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8007704:	6899      	ldr	r1, [r3, #8]
 8007706:	4a09      	ldr	r2, [pc, #36]	; (800772c <HAL_TIM_Base_Start+0x74>)
 8007708:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800770a:	2a06      	cmp	r2, #6
 800770c:	d00a      	beq.n	8007724 <HAL_TIM_Base_Start+0x6c>
 800770e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007712:	d007      	beq.n	8007724 <HAL_TIM_Base_Start+0x6c>
    __HAL_TIM_ENABLE(htim);
 8007714:	681a      	ldr	r2, [r3, #0]
 8007716:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 800771a:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 800771c:	601a      	str	r2, [r3, #0]
 800771e:	4770      	bx	lr
    return HAL_ERROR;
 8007720:	2001      	movs	r0, #1
 8007722:	4770      	bx	lr
  return HAL_OK;
 8007724:	2000      	movs	r0, #0
}
 8007726:	4770      	bx	lr
 8007728:	40012c00 	.word	0x40012c00
 800772c:	00010007 	.word	0x00010007

08007730 <HAL_TIM_Base_Stop>:
  __HAL_TIM_DISABLE(htim);
 8007730:	6803      	ldr	r3, [r0, #0]
 8007732:	6a19      	ldr	r1, [r3, #32]
 8007734:	f241 1211 	movw	r2, #4369	; 0x1111
 8007738:	4211      	tst	r1, r2
 800773a:	d108      	bne.n	800774e <HAL_TIM_Base_Stop+0x1e>
 800773c:	6a19      	ldr	r1, [r3, #32]
 800773e:	f244 4244 	movw	r2, #17476	; 0x4444
 8007742:	4211      	tst	r1, r2
 8007744:	d103      	bne.n	800774e <HAL_TIM_Base_Stop+0x1e>
 8007746:	681a      	ldr	r2, [r3, #0]
 8007748:	f022 0201 	bic.w	r2, r2, #1
 800774c:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 800774e:	2301      	movs	r3, #1
 8007750:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8007754:	2000      	movs	r0, #0
 8007756:	4770      	bx	lr

08007758 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8007758:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800775c:	2b01      	cmp	r3, #1
 800775e:	d132      	bne.n	80077c6 <HAL_TIM_Base_Start_IT+0x6e>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8007760:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007762:	491b      	ldr	r1, [pc, #108]	; (80077d0 <HAL_TIM_Base_Start_IT+0x78>)
  htim->State = HAL_TIM_STATE_BUSY;
 8007764:	2202      	movs	r2, #2
 8007766:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800776a:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800776c:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800776e:	f042 0201 	orr.w	r2, r2, #1
 8007772:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007774:	d019      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 8007776:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800777a:	d016      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 800777c:	4a15      	ldr	r2, [pc, #84]	; (80077d4 <HAL_TIM_Base_Start_IT+0x7c>)
 800777e:	4293      	cmp	r3, r2
 8007780:	d013      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 8007782:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8007786:	4293      	cmp	r3, r2
 8007788:	d00f      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 800778a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800778e:	4293      	cmp	r3, r2
 8007790:	d00b      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 8007792:	f502 3294 	add.w	r2, r2, #75776	; 0x12800
 8007796:	4293      	cmp	r3, r2
 8007798:	d007      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 800779a:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
 800779e:	4293      	cmp	r3, r2
 80077a0:	d003      	beq.n	80077aa <HAL_TIM_Base_Start_IT+0x52>
 80077a2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80077a6:	4293      	cmp	r3, r2
 80077a8:	d107      	bne.n	80077ba <HAL_TIM_Base_Start_IT+0x62>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80077aa:	6899      	ldr	r1, [r3, #8]
 80077ac:	4a0a      	ldr	r2, [pc, #40]	; (80077d8 <HAL_TIM_Base_Start_IT+0x80>)
 80077ae:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80077b0:	2a06      	cmp	r2, #6
 80077b2:	d00a      	beq.n	80077ca <HAL_TIM_Base_Start_IT+0x72>
 80077b4:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80077b8:	d007      	beq.n	80077ca <HAL_TIM_Base_Start_IT+0x72>
    __HAL_TIM_ENABLE(htim);
 80077ba:	681a      	ldr	r2, [r3, #0]
 80077bc:	f042 0201 	orr.w	r2, r2, #1
  return HAL_OK;
 80077c0:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 80077c2:	601a      	str	r2, [r3, #0]
 80077c4:	4770      	bx	lr
    return HAL_ERROR;
 80077c6:	2001      	movs	r0, #1
 80077c8:	4770      	bx	lr
  return HAL_OK;
 80077ca:	2000      	movs	r0, #0
}
 80077cc:	4770      	bx	lr
 80077ce:	bf00      	nop
 80077d0:	40012c00 	.word	0x40012c00
 80077d4:	40000400 	.word	0x40000400
 80077d8:	00010007 	.word	0x00010007

080077dc <HAL_TIM_PWM_MspInit>:
 80077dc:	4770      	bx	lr
 80077de:	bf00      	nop

080077e0 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 80077e0:	2800      	cmp	r0, #0
 80077e2:	f000 808c 	beq.w	80078fe <HAL_TIM_PWM_Init+0x11e>
{
 80077e6:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 80077e8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80077ec:	4604      	mov	r4, r0
 80077ee:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80077f2:	2b00      	cmp	r3, #0
 80077f4:	d078      	beq.n	80078e8 <HAL_TIM_PWM_Init+0x108>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80077f6:	6822      	ldr	r2, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80077f8:	4944      	ldr	r1, [pc, #272]	; (800790c <HAL_TIM_PWM_Init+0x12c>)
  htim->State = HAL_TIM_STATE_BUSY;
 80077fa:	2302      	movs	r3, #2
 80077fc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007800:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8007802:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007804:	d05c      	beq.n	80078c0 <HAL_TIM_PWM_Init+0xe0>
 8007806:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800780a:	d02c      	beq.n	8007866 <HAL_TIM_PWM_Init+0x86>
 800780c:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 8007810:	428a      	cmp	r2, r1
 8007812:	d028      	beq.n	8007866 <HAL_TIM_PWM_Init+0x86>
 8007814:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007818:	428a      	cmp	r2, r1
 800781a:	d024      	beq.n	8007866 <HAL_TIM_PWM_Init+0x86>
 800781c:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007820:	428a      	cmp	r2, r1
 8007822:	d020      	beq.n	8007866 <HAL_TIM_PWM_Init+0x86>
 8007824:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 8007828:	428a      	cmp	r2, r1
 800782a:	d049      	beq.n	80078c0 <HAL_TIM_PWM_Init+0xe0>
 800782c:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 8007830:	428a      	cmp	r2, r1
 8007832:	d066      	beq.n	8007902 <HAL_TIM_PWM_Init+0x122>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007834:	4936      	ldr	r1, [pc, #216]	; (8007910 <HAL_TIM_PWM_Init+0x130>)
 8007836:	428a      	cmp	r2, r1
 8007838:	d05b      	beq.n	80078f2 <HAL_TIM_PWM_Init+0x112>
 800783a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800783e:	428a      	cmp	r2, r1
 8007840:	d057      	beq.n	80078f2 <HAL_TIM_PWM_Init+0x112>
 8007842:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007846:	428a      	cmp	r2, r1
 8007848:	d053      	beq.n	80078f2 <HAL_TIM_PWM_Init+0x112>
 800784a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800784e:	428a      	cmp	r2, r1
 8007850:	d04f      	beq.n	80078f2 <HAL_TIM_PWM_Init+0x112>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007852:	69a0      	ldr	r0, [r4, #24]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007854:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007856:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800785a:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800785c:	6013      	str	r3, [r2, #0]
  TIMx->PSC = Structure->Prescaler;
 800785e:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007860:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007862:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8007864:	e010      	b.n	8007888 <HAL_TIM_PWM_Init+0xa8>
    tmpcr1 |= Structure->CounterMode;
 8007866:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007868:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800786a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800786e:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8007870:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007874:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007876:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007878:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 800787c:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800787e:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8007880:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8007882:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007884:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007886:	6291      	str	r1, [r2, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 8007888:	2301      	movs	r3, #1
 800788a:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800788c:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8007890:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8007894:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8007898:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800789c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80078a0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80078a4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80078a8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80078ac:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80078b0:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 80078b4:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 80078b8:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80078bc:	2000      	movs	r0, #0
}
 80078be:	bd10      	pop	{r4, pc}
    tmpcr1 |= Structure->CounterMode;
 80078c0:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078c2:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80078c4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80078c8:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 80078ca:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078ce:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80078d0:	69a1      	ldr	r1, [r4, #24]
 80078d2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80078d6:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 80078d8:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80078da:	68e3      	ldr	r3, [r4, #12]
 80078dc:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80078de:	6863      	ldr	r3, [r4, #4]
 80078e0:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 80078e2:	6963      	ldr	r3, [r4, #20]
 80078e4:	6313      	str	r3, [r2, #48]	; 0x30
 80078e6:	e7cf      	b.n	8007888 <HAL_TIM_PWM_Init+0xa8>
    htim->Lock = HAL_UNLOCKED;
 80078e8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 80078ec:	f7ff ff76 	bl	80077dc <HAL_TIM_PWM_MspInit>
 80078f0:	e781      	b.n	80077f6 <HAL_TIM_PWM_Init+0x16>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078f2:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80078f4:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 80078f6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80078fa:	4303      	orrs	r3, r0
 80078fc:	e7e9      	b.n	80078d2 <HAL_TIM_PWM_Init+0xf2>
    return HAL_ERROR;
 80078fe:	2001      	movs	r0, #1
}
 8007900:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8007902:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007904:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007908:	430b      	orrs	r3, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800790a:	e793      	b.n	8007834 <HAL_TIM_PWM_Init+0x54>
 800790c:	40012c00 	.word	0x40012c00
 8007910:	40014000 	.word	0x40014000

08007914 <HAL_TIM_Encoder_Init>:
  if (htim == NULL)
 8007914:	2800      	cmp	r0, #0
 8007916:	f000 80a1 	beq.w	8007a5c <HAL_TIM_Encoder_Init+0x148>
{
 800791a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800791c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8007920:	460d      	mov	r5, r1
 8007922:	4604      	mov	r4, r0
 8007924:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8007928:	2b00      	cmp	r3, #0
 800792a:	f000 8092 	beq.w	8007a52 <HAL_TIM_Encoder_Init+0x13e>
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 800792e:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007930:	494e      	ldr	r1, [pc, #312]	; (8007a6c <HAL_TIM_Encoder_Init+0x158>)
  htim->State = HAL_TIM_STATE_BUSY;
 8007932:	2202      	movs	r2, #2
 8007934:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
 8007938:	689a      	ldr	r2, [r3, #8]
 800793a:	f422 32a0 	bic.w	r2, r2, #81920	; 0x14000
 800793e:	f022 0207 	bic.w	r2, r2, #7
 8007942:	609a      	str	r2, [r3, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007944:	428b      	cmp	r3, r1
  tmpcr1 = TIMx->CR1;
 8007946:	681a      	ldr	r2, [r3, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007948:	d06f      	beq.n	8007a2a <HAL_TIM_Encoder_Init+0x116>
 800794a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800794e:	d023      	beq.n	8007998 <HAL_TIM_Encoder_Init+0x84>
 8007950:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 8007954:	428b      	cmp	r3, r1
 8007956:	d01f      	beq.n	8007998 <HAL_TIM_Encoder_Init+0x84>
 8007958:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800795c:	428b      	cmp	r3, r1
 800795e:	d01b      	beq.n	8007998 <HAL_TIM_Encoder_Init+0x84>
 8007960:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007964:	428b      	cmp	r3, r1
 8007966:	d017      	beq.n	8007998 <HAL_TIM_Encoder_Init+0x84>
 8007968:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 800796c:	428b      	cmp	r3, r1
 800796e:	d05c      	beq.n	8007a2a <HAL_TIM_Encoder_Init+0x116>
 8007970:	f501 51e0 	add.w	r1, r1, #7168	; 0x1c00
 8007974:	428b      	cmp	r3, r1
 8007976:	d073      	beq.n	8007a60 <HAL_TIM_Encoder_Init+0x14c>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007978:	493d      	ldr	r1, [pc, #244]	; (8007a70 <HAL_TIM_Encoder_Init+0x15c>)
 800797a:	428b      	cmp	r3, r1
 800797c:	d059      	beq.n	8007a32 <HAL_TIM_Encoder_Init+0x11e>
 800797e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8007982:	428b      	cmp	r3, r1
 8007984:	d055      	beq.n	8007a32 <HAL_TIM_Encoder_Init+0x11e>
 8007986:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800798a:	428b      	cmp	r3, r1
 800798c:	d051      	beq.n	8007a32 <HAL_TIM_Encoder_Init+0x11e>
 800798e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8007992:	428b      	cmp	r3, r1
 8007994:	d108      	bne.n	80079a8 <HAL_TIM_Encoder_Init+0x94>
 8007996:	e04c      	b.n	8007a32 <HAL_TIM_Encoder_Init+0x11e>
    tmpcr1 |= Structure->CounterMode;
 8007998:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800799a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800799e:	430a      	orrs	r2, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80079a0:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80079a2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80079a6:	430a      	orrs	r2, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80079a8:	69a1      	ldr	r1, [r4, #24]
 80079aa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80079ae:	430a      	orrs	r2, r1
  TIMx->ARR = (uint32_t)Structure->Period ;
 80079b0:	68e1      	ldr	r1, [r4, #12]
  TIMx->CR1 = tmpcr1;
 80079b2:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80079b4:	62d9      	str	r1, [r3, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80079b6:	6862      	ldr	r2, [r4, #4]
 80079b8:	629a      	str	r2, [r3, #40]	; 0x28
  TIMx->EGR = TIM_EGR_UG;
 80079ba:	2601      	movs	r6, #1
 80079bc:	615e      	str	r6, [r3, #20]
  tmpsmcr = htim->Instance->SMCR;
 80079be:	6898      	ldr	r0, [r3, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 80079c0:	699a      	ldr	r2, [r3, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 80079c2:	69af      	ldr	r7, [r5, #24]
 80079c4:	68a9      	ldr	r1, [r5, #8]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 80079c6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80079ca:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 80079ce:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
 80079d2:	4311      	orrs	r1, r2
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80079d4:	692a      	ldr	r2, [r5, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 80079d6:	69ef      	ldr	r7, [r5, #28]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80079d8:	0112      	lsls	r2, r2, #4
 80079da:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80079de:	68ef      	ldr	r7, [r5, #12]
 80079e0:	433a      	orrs	r2, r7
  tmpccer = htim->Instance->CCER;
 80079e2:	6a1f      	ldr	r7, [r3, #32]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 80079e4:	f027 0caa 	bic.w	ip, r7, #170	; 0xaa
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80079e8:	6a2f      	ldr	r7, [r5, #32]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 80079ea:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
 80079ee:	f021 01fc 	bic.w	r1, r1, #252	; 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 80079f2:	ea42 3207 	orr.w	r2, r2, r7, lsl #12
 80079f6:	430a      	orrs	r2, r1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80079f8:	696f      	ldr	r7, [r5, #20]
 80079fa:	6869      	ldr	r1, [r5, #4]
  tmpsmcr |= sConfig->EncoderMode;
 80079fc:	682d      	ldr	r5, [r5, #0]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 80079fe:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  tmpsmcr |= sConfig->EncoderMode;
 8007a02:	4328      	orrs	r0, r5
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8007a04:	ea41 010c 	orr.w	r1, r1, ip
  htim->Instance->SMCR = tmpsmcr;
 8007a08:	6098      	str	r0, [r3, #8]
  htim->Instance->CCMR1 = tmpccmr1;
 8007a0a:	619a      	str	r2, [r3, #24]
  htim->Instance->CCER = tmpccer;
 8007a0c:	6219      	str	r1, [r3, #32]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8007a0e:	f884 6048 	strb.w	r6, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a12:	f884 603e 	strb.w	r6, [r4, #62]	; 0x3e
  TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a16:	f884 603f 	strb.w	r6, [r4, #63]	; 0x3f
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
 8007a1a:	f884 6044 	strb.w	r6, [r4, #68]	; 0x44
  TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
 8007a1e:	f884 6045 	strb.w	r6, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8007a22:	f884 603d 	strb.w	r6, [r4, #61]	; 0x3d
  return HAL_OK;
 8007a26:	2000      	movs	r0, #0
}
 8007a28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpcr1 |= Structure->CounterMode;
 8007a2a:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007a2c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007a30:	430a      	orrs	r2, r1
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007a32:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 8007a34:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007a38:	430a      	orrs	r2, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007a3a:	69a1      	ldr	r1, [r4, #24]
 8007a3c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8007a40:	430a      	orrs	r2, r1
  TIMx->CR1 = tmpcr1;
 8007a42:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007a44:	68e2      	ldr	r2, [r4, #12]
 8007a46:	62da      	str	r2, [r3, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8007a48:	6862      	ldr	r2, [r4, #4]
 8007a4a:	629a      	str	r2, [r3, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8007a4c:	6962      	ldr	r2, [r4, #20]
 8007a4e:	631a      	str	r2, [r3, #48]	; 0x30
 8007a50:	e7b3      	b.n	80079ba <HAL_TIM_Encoder_Init+0xa6>
    htim->Lock = HAL_UNLOCKED;
 8007a52:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Encoder_MspInit(htim);
 8007a56:	f7fd f9ef 	bl	8004e38 <HAL_TIM_Encoder_MspInit>
 8007a5a:	e768      	b.n	800792e <HAL_TIM_Encoder_Init+0x1a>
    return HAL_ERROR;
 8007a5c:	2001      	movs	r0, #1
}
 8007a5e:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8007a60:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007a62:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8007a66:	430a      	orrs	r2, r1
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007a68:	e786      	b.n	8007978 <HAL_TIM_Encoder_Init+0x64>
 8007a6a:	bf00      	nop
 8007a6c:	40012c00 	.word	0x40012c00
 8007a70:	40014000 	.word	0x40014000

08007a74 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8007a74:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8007a78:	2b01      	cmp	r3, #1
 8007a7a:	f000 8094 	beq.w	8007ba6 <HAL_TIM_ConfigClockSource+0x132>
 8007a7e:	4602      	mov	r2, r0
{
 8007a80:	b430      	push	{r4, r5}
  htim->State = HAL_TIM_STATE_BUSY;
 8007a82:	2302      	movs	r3, #2
  tmpsmcr = htim->Instance->SMCR;
 8007a84:	6804      	ldr	r4, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8007a86:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
  __HAL_LOCK(htim);
 8007a8a:	2001      	movs	r0, #1
 8007a8c:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  tmpsmcr = htim->Instance->SMCR;
 8007a90:	68a5      	ldr	r5, [r4, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007a92:	4b64      	ldr	r3, [pc, #400]	; (8007c24 <HAL_TIM_ConfigClockSource+0x1b0>)
 8007a94:	402b      	ands	r3, r5
  htim->Instance->SMCR = tmpsmcr;
 8007a96:	60a3      	str	r3, [r4, #8]
  switch (sClockSourceConfig->ClockSource)
 8007a98:	680b      	ldr	r3, [r1, #0]
 8007a9a:	2b70      	cmp	r3, #112	; 0x70
 8007a9c:	f000 80b1 	beq.w	8007c02 <HAL_TIM_ConfigClockSource+0x18e>
 8007aa0:	d828      	bhi.n	8007af4 <HAL_TIM_ConfigClockSource+0x80>
 8007aa2:	2b50      	cmp	r3, #80	; 0x50
 8007aa4:	f000 8081 	beq.w	8007baa <HAL_TIM_ConfigClockSource+0x136>
 8007aa8:	d93f      	bls.n	8007b2a <HAL_TIM_ConfigClockSource+0xb6>
 8007aaa:	2b60      	cmp	r3, #96	; 0x60
 8007aac:	d11a      	bne.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007aae:	6a23      	ldr	r3, [r4, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8007ab0:	6848      	ldr	r0, [r1, #4]
 8007ab2:	68cd      	ldr	r5, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007ab4:	f023 0310 	bic.w	r3, r3, #16
 8007ab8:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007aba:	69a1      	ldr	r1, [r4, #24]
  tmpccer = TIMx->CCER;
 8007abc:	6a23      	ldr	r3, [r4, #32]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8007abe:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8007ac2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4U);
 8007ac6:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8007aca:	ea41 3105 	orr.w	r1, r1, r5, lsl #12

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8007ace:	61a1      	str	r1, [r4, #24]
  TIMx->CCER = tmpccer;
 8007ad0:	6223      	str	r3, [r4, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007ad2:	68a3      	ldr	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8007ad4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007ad8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007adc:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  HAL_StatusTypeDef status = HAL_OK;
 8007ae0:	2000      	movs	r0, #0
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007ae2:	60a3      	str	r3, [r4, #8]
  htim->State = HAL_TIM_STATE_READY;
 8007ae4:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8007ae6:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8007ae8:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8007aec:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8007af0:	bc30      	pop	{r4, r5}
 8007af2:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8007af4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8007af8:	d072      	beq.n	8007be0 <HAL_TIM_ConfigClockSource+0x16c>
 8007afa:	d943      	bls.n	8007b84 <HAL_TIM_ConfigClockSource+0x110>
 8007afc:	494a      	ldr	r1, [pc, #296]	; (8007c28 <HAL_TIM_ConfigClockSource+0x1b4>)
 8007afe:	428b      	cmp	r3, r1
 8007b00:	d008      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b02:	d92f      	bls.n	8007b64 <HAL_TIM_ConfigClockSource+0xf0>
 8007b04:	4949      	ldr	r1, [pc, #292]	; (8007c2c <HAL_TIM_ConfigClockSource+0x1b8>)
 8007b06:	428b      	cmp	r3, r1
 8007b08:	d004      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b0a:	f023 0c20 	bic.w	ip, r3, #32
 8007b0e:	3910      	subs	r1, #16
 8007b10:	458c      	cmp	ip, r1
 8007b12:	d1e7      	bne.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  tmpsmcr = TIMx->SMCR;
 8007b14:	68a1      	ldr	r1, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007b16:	f421 1140 	bic.w	r1, r1, #3145728	; 0x300000
 8007b1a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007b1e:	4319      	orrs	r1, r3
 8007b20:	f041 0107 	orr.w	r1, r1, #7
  HAL_StatusTypeDef status = HAL_OK;
 8007b24:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007b26:	60a1      	str	r1, [r4, #8]
}
 8007b28:	e7dc      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007b2a:	2b40      	cmp	r3, #64	; 0x40
 8007b2c:	d12f      	bne.n	8007b8e <HAL_TIM_ConfigClockSource+0x11a>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007b2e:	684b      	ldr	r3, [r1, #4]
 8007b30:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
 8007b32:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007b34:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8007b38:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007b3a:	6a23      	ldr	r3, [r4, #32]
 8007b3c:	f023 0301 	bic.w	r3, r3, #1
 8007b40:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007b42:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007b44:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007b48:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007b4c:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8007b4e:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8007b50:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007b52:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007b56:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007b5a:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  HAL_StatusTypeDef status = HAL_OK;
 8007b5e:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007b60:	60a3      	str	r3, [r4, #8]
}
 8007b62:	e7bf      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007b64:	3920      	subs	r1, #32
 8007b66:	428b      	cmp	r3, r1
 8007b68:	d0d4      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b6a:	d904      	bls.n	8007b76 <HAL_TIM_ConfigClockSource+0x102>
 8007b6c:	4930      	ldr	r1, [pc, #192]	; (8007c30 <HAL_TIM_ConfigClockSource+0x1bc>)
 8007b6e:	428b      	cmp	r3, r1
 8007b70:	d0d0      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b72:	2001      	movs	r0, #1
 8007b74:	e7b6      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
 8007b76:	f023 0110 	bic.w	r1, r3, #16
 8007b7a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8007b7e:	d0c9      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b80:	2001      	movs	r0, #1
 8007b82:	e7af      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  HAL_StatusTypeDef status = HAL_OK;
 8007b84:	f5b3 5080 	subs.w	r0, r3, #4096	; 0x1000
 8007b88:	bf18      	it	ne
 8007b8a:	2001      	movne	r0, #1
 8007b8c:	e7aa      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  switch (sClockSourceConfig->ClockSource)
 8007b8e:	d8a9      	bhi.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
 8007b90:	2b20      	cmp	r3, #32
 8007b92:	d0bf      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b94:	d903      	bls.n	8007b9e <HAL_TIM_ConfigClockSource+0x12a>
 8007b96:	2b30      	cmp	r3, #48	; 0x30
 8007b98:	d0bc      	beq.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
 8007b9a:	2001      	movs	r0, #1
 8007b9c:	e7a2      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
 8007b9e:	f033 0110 	bics.w	r1, r3, #16
 8007ba2:	d19f      	bne.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
 8007ba4:	e7b6      	b.n	8007b14 <HAL_TIM_ConfigClockSource+0xa0>
  __HAL_LOCK(htim);
 8007ba6:	2002      	movs	r0, #2
}
 8007ba8:	4770      	bx	lr
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007baa:	684b      	ldr	r3, [r1, #4]
 8007bac:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
 8007bae:	6a21      	ldr	r1, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007bb0:	f021 010a 	bic.w	r1, r1, #10
  tmpccer |= TIM_ICPolarity;
 8007bb4:	4319      	orrs	r1, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007bb6:	6a23      	ldr	r3, [r4, #32]
 8007bb8:	f023 0301 	bic.w	r3, r3, #1
 8007bbc:	6223      	str	r3, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007bbe:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007bc0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007bc4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007bc8:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8007bca:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8007bcc:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007bce:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007bd2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8007bd6:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  HAL_StatusTypeDef status = HAL_OK;
 8007bda:	2000      	movs	r0, #0
  TIMx->SMCR = tmpsmcr;
 8007bdc:	60a3      	str	r3, [r4, #8]
}
 8007bde:	e781      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007be0:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8007be4:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007be6:	432b      	orrs	r3, r5
 8007be8:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007bea:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007bee:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8007bf2:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8007bf4:	60a3      	str	r3, [r4, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8007bf6:	68a3      	ldr	r3, [r4, #8]
 8007bf8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  HAL_StatusTypeDef status = HAL_OK;
 8007bfc:	2000      	movs	r0, #0
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8007bfe:	60a3      	str	r3, [r4, #8]
      break;
 8007c00:	e770      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c02:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
  tmpsmcr = TIMx->SMCR;
 8007c06:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c08:	432b      	orrs	r3, r5
 8007c0a:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007c0c:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007c10:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8007c14:	430b      	orrs	r3, r1
  TIMx->SMCR = tmpsmcr;
 8007c16:	60a3      	str	r3, [r4, #8]
      tmpsmcr = htim->Instance->SMCR;
 8007c18:	68a3      	ldr	r3, [r4, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8007c1a:	f043 0377 	orr.w	r3, r3, #119	; 0x77
  HAL_StatusTypeDef status = HAL_OK;
 8007c1e:	2000      	movs	r0, #0
      htim->Instance->SMCR = tmpsmcr;
 8007c20:	60a3      	str	r3, [r4, #8]
      break;
 8007c22:	e75f      	b.n	8007ae4 <HAL_TIM_ConfigClockSource+0x70>
 8007c24:	ffce0088 	.word	0xffce0088
 8007c28:	00100040 	.word	0x00100040
 8007c2c:	00100060 	.word	0x00100060
 8007c30:	00100030 	.word	0x00100030

08007c34 <HAL_TIM_SlaveConfigSynchro>:
  __HAL_LOCK(htim);
 8007c34:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8007c38:	2b01      	cmp	r3, #1
 8007c3a:	d072      	beq.n	8007d22 <HAL_TIM_SlaveConfigSynchro+0xee>
 8007c3c:	4684      	mov	ip, r0
 8007c3e:	2201      	movs	r2, #1
  tmpsmcr = htim->Instance->SMCR;
 8007c40:	6800      	ldr	r0, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8007c42:	2302      	movs	r3, #2
{
 8007c44:	b410      	push	{r4}
  __HAL_LOCK(htim);
 8007c46:	f88c 203c 	strb.w	r2, [ip, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 8007c4a:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR;
 8007c4e:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8007c50:	684b      	ldr	r3, [r1, #4]
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8007c52:	680c      	ldr	r4, [r1, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 8007c54:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8007c58:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  tmpsmcr |= sSlaveConfig->InputTrigger;
 8007c5c:	431a      	orrs	r2, r3
  tmpsmcr &= ~TIM_SMCR_SMS;
 8007c5e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8007c62:	f022 0207 	bic.w	r2, r2, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
 8007c66:	4322      	orrs	r2, r4
  switch (sSlaveConfig->InputTrigger)
 8007c68:	2b60      	cmp	r3, #96	; 0x60
  htim->Instance->SMCR = tmpsmcr;
 8007c6a:	6082      	str	r2, [r0, #8]
  switch (sSlaveConfig->InputTrigger)
 8007c6c:	d067      	beq.n	8007d3e <HAL_TIM_SlaveConfigSynchro+0x10a>
 8007c6e:	d816      	bhi.n	8007c9e <HAL_TIM_SlaveConfigSynchro+0x6a>
 8007c70:	2b40      	cmp	r3, #64	; 0x40
 8007c72:	d077      	beq.n	8007d64 <HAL_TIM_SlaveConfigSynchro+0x130>
 8007c74:	d935      	bls.n	8007ce2 <HAL_TIM_SlaveConfigSynchro+0xae>
 8007c76:	2b50      	cmp	r3, #80	; 0x50
 8007c78:	d144      	bne.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
  tmpccer = TIMx->CCER;
 8007c7a:	6a03      	ldr	r3, [r0, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8007c7c:	688a      	ldr	r2, [r1, #8]
 8007c7e:	6909      	ldr	r1, [r1, #16]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8007c80:	f023 030a 	bic.w	r3, r3, #10
  tmpccer |= TIM_ICPolarity;
 8007c84:	431a      	orrs	r2, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007c86:	6a03      	ldr	r3, [r0, #32]
 8007c88:	f023 0301 	bic.w	r3, r3, #1
 8007c8c:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007c8e:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8007c90:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8007c94:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8007c98:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8007c9a:	6202      	str	r2, [r0, #32]
 8007c9c:	e00f      	b.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
  switch (sSlaveConfig->InputTrigger)
 8007c9e:	2b70      	cmp	r3, #112	; 0x70
 8007ca0:	d041      	beq.n	8007d26 <HAL_TIM_SlaveConfigSynchro+0xf2>
 8007ca2:	2b6f      	cmp	r3, #111	; 0x6f
 8007ca4:	d92e      	bls.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007ca6:	4a34      	ldr	r2, [pc, #208]	; (8007d78 <HAL_TIM_SlaveConfigSynchro+0x144>)
 8007ca8:	4293      	cmp	r3, r2
 8007caa:	d008      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cac:	d91f      	bls.n	8007cee <HAL_TIM_SlaveConfigSynchro+0xba>
 8007cae:	4a33      	ldr	r2, [pc, #204]	; (8007d7c <HAL_TIM_SlaveConfigSynchro+0x148>)
 8007cb0:	4293      	cmp	r3, r2
 8007cb2:	d004      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cb4:	3a10      	subs	r2, #16
 8007cb6:	f023 0320 	bic.w	r3, r3, #32
 8007cba:	4293      	cmp	r3, r2
 8007cbc:	d122      	bne.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
 8007cbe:	68c3      	ldr	r3, [r0, #12]
 8007cc0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007cc4:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8007cc6:	68c3      	ldr	r3, [r0, #12]
  __HAL_UNLOCK(htim);
 8007cc8:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8007cca:	2101      	movs	r1, #1
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
 8007ccc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007cd0:	60c3      	str	r3, [r0, #12]
  htim->State = HAL_TIM_STATE_READY;
 8007cd2:	f88c 103d 	strb.w	r1, [ip, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8007cd6:	f88c 203c 	strb.w	r2, [ip, #60]	; 0x3c
  return HAL_OK;
 8007cda:	4610      	mov	r0, r2
}
 8007cdc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007ce0:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 8007ce2:	2b20      	cmp	r3, #32
 8007ce4:	d0eb      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007ce6:	d90a      	bls.n	8007cfe <HAL_TIM_SlaveConfigSynchro+0xca>
 8007ce8:	2b30      	cmp	r3, #48	; 0x30
 8007cea:	d10b      	bne.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007cec:	e7e7      	b.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cee:	3a20      	subs	r2, #32
 8007cf0:	4293      	cmp	r3, r2
 8007cf2:	d0e4      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cf4:	d90f      	bls.n	8007d16 <HAL_TIM_SlaveConfigSynchro+0xe2>
 8007cf6:	4a22      	ldr	r2, [pc, #136]	; (8007d80 <HAL_TIM_SlaveConfigSynchro+0x14c>)
 8007cf8:	4293      	cmp	r3, r2
 8007cfa:	d0e0      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
 8007cfc:	e002      	b.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007cfe:	f033 0310 	bics.w	r3, r3, #16
 8007d02:	d0dc      	beq.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
    htim->State = HAL_TIM_STATE_READY;
 8007d04:	2001      	movs	r0, #1
    __HAL_UNLOCK(htim);
 8007d06:	2300      	movs	r3, #0
    htim->State = HAL_TIM_STATE_READY;
 8007d08:	f88c 003d 	strb.w	r0, [ip, #61]	; 0x3d
    __HAL_UNLOCK(htim);
 8007d0c:	f88c 303c 	strb.w	r3, [ip, #60]	; 0x3c
}
 8007d10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007d14:	4770      	bx	lr
  switch (sSlaveConfig->InputTrigger)
 8007d16:	f023 0310 	bic.w	r3, r3, #16
 8007d1a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8007d1e:	d1f1      	bne.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007d20:	e7cd      	b.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
  __HAL_LOCK(htim);
 8007d22:	2002      	movs	r0, #2
}
 8007d24:	4770      	bx	lr
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d26:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
  tmpsmcr = TIMx->SMCR;
 8007d2a:	6882      	ldr	r2, [r0, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d2c:	6909      	ldr	r1, [r1, #16]
 8007d2e:	4323      	orrs	r3, r4
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007d30:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8007d34:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007d38:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 8007d3a:	6083      	str	r3, [r0, #8]
 8007d3c:	e7bf      	b.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007d3e:	6a03      	ldr	r3, [r0, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8007d40:	688c      	ldr	r4, [r1, #8]
 8007d42:	6909      	ldr	r1, [r1, #16]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007d44:	f023 0310 	bic.w	r3, r3, #16
 8007d48:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8007d4a:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 8007d4c:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8007d4e:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8007d52:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8007d56:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 8007d5a:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 8007d5e:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8007d60:	6203      	str	r3, [r0, #32]
 8007d62:	e7ac      	b.n	8007cbe <HAL_TIM_SlaveConfigSynchro+0x8a>
      if ((sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED) || \
 8007d64:	2c05      	cmp	r4, #5
 8007d66:	d0cd      	beq.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
 8007d68:	f1b4 1f01 	cmp.w	r4, #65537	; 0x10001
 8007d6c:	d0ca      	beq.n	8007d04 <HAL_TIM_SlaveConfigSynchro+0xd0>
      tmpccer = htim->Instance->CCER;
 8007d6e:	6a02      	ldr	r2, [r0, #32]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
 8007d70:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
 8007d72:	6a03      	ldr	r3, [r0, #32]
 8007d74:	e788      	b.n	8007c88 <HAL_TIM_SlaveConfigSynchro+0x54>
 8007d76:	bf00      	nop
 8007d78:	00100040 	.word	0x00100040
 8007d7c:	00100060 	.word	0x00100060
 8007d80:	00100030 	.word	0x00100030

08007d84 <HAL_TIM_PeriodElapsedCallback>:
 8007d84:	4770      	bx	lr
 8007d86:	bf00      	nop

08007d88 <HAL_TIM_OC_DelayElapsedCallback>:
 8007d88:	4770      	bx	lr
 8007d8a:	bf00      	nop

08007d8c <HAL_TIM_IC_CaptureCallback>:
 8007d8c:	4770      	bx	lr
 8007d8e:	bf00      	nop

08007d90 <HAL_TIM_PWM_PulseFinishedCallback>:
 8007d90:	4770      	bx	lr
 8007d92:	bf00      	nop

08007d94 <HAL_TIM_TriggerCallback>:
 8007d94:	4770      	bx	lr
 8007d96:	bf00      	nop

08007d98 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8007d98:	6803      	ldr	r3, [r0, #0]
 8007d9a:	691a      	ldr	r2, [r3, #16]
 8007d9c:	0791      	lsls	r1, r2, #30
{
 8007d9e:	b510      	push	{r4, lr}
 8007da0:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8007da2:	d503      	bpl.n	8007dac <HAL_TIM_IRQHandler+0x14>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8007da4:	68da      	ldr	r2, [r3, #12]
 8007da6:	0792      	lsls	r2, r2, #30
 8007da8:	f100 808a 	bmi.w	8007ec0 <HAL_TIM_IRQHandler+0x128>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007dac:	691a      	ldr	r2, [r3, #16]
 8007dae:	0752      	lsls	r2, r2, #29
 8007db0:	d502      	bpl.n	8007db8 <HAL_TIM_IRQHandler+0x20>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8007db2:	68da      	ldr	r2, [r3, #12]
 8007db4:	0750      	lsls	r0, r2, #29
 8007db6:	d470      	bmi.n	8007e9a <HAL_TIM_IRQHandler+0x102>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8007db8:	691a      	ldr	r2, [r3, #16]
 8007dba:	0711      	lsls	r1, r2, #28
 8007dbc:	d502      	bpl.n	8007dc4 <HAL_TIM_IRQHandler+0x2c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8007dbe:	68da      	ldr	r2, [r3, #12]
 8007dc0:	0712      	lsls	r2, r2, #28
 8007dc2:	d458      	bmi.n	8007e76 <HAL_TIM_IRQHandler+0xde>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8007dc4:	691a      	ldr	r2, [r3, #16]
 8007dc6:	06d1      	lsls	r1, r2, #27
 8007dc8:	d502      	bpl.n	8007dd0 <HAL_TIM_IRQHandler+0x38>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8007dca:	68da      	ldr	r2, [r3, #12]
 8007dcc:	06d2      	lsls	r2, r2, #27
 8007dce:	d43e      	bmi.n	8007e4e <HAL_TIM_IRQHandler+0xb6>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8007dd0:	691a      	ldr	r2, [r3, #16]
 8007dd2:	07d0      	lsls	r0, r2, #31
 8007dd4:	d503      	bpl.n	8007dde <HAL_TIM_IRQHandler+0x46>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8007dd6:	68da      	ldr	r2, [r3, #12]
 8007dd8:	07d1      	lsls	r1, r2, #31
 8007dda:	f100 808a 	bmi.w	8007ef2 <HAL_TIM_IRQHandler+0x15a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007dde:	691a      	ldr	r2, [r3, #16]
 8007de0:	0612      	lsls	r2, r2, #24
 8007de2:	d503      	bpl.n	8007dec <HAL_TIM_IRQHandler+0x54>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8007de4:	68da      	ldr	r2, [r3, #12]
 8007de6:	0610      	lsls	r0, r2, #24
 8007de8:	f100 808b 	bmi.w	8007f02 <HAL_TIM_IRQHandler+0x16a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8007dec:	691a      	ldr	r2, [r3, #16]
 8007dee:	05d1      	lsls	r1, r2, #23
 8007df0:	d503      	bpl.n	8007dfa <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8007df2:	68da      	ldr	r2, [r3, #12]
 8007df4:	0612      	lsls	r2, r2, #24
 8007df6:	f100 808c 	bmi.w	8007f12 <HAL_TIM_IRQHandler+0x17a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8007dfa:	691a      	ldr	r2, [r3, #16]
 8007dfc:	0650      	lsls	r0, r2, #25
 8007dfe:	d503      	bpl.n	8007e08 <HAL_TIM_IRQHandler+0x70>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8007e00:	68da      	ldr	r2, [r3, #12]
 8007e02:	0651      	lsls	r1, r2, #25
 8007e04:	f100 808d 	bmi.w	8007f22 <HAL_TIM_IRQHandler+0x18a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8007e08:	691a      	ldr	r2, [r3, #16]
 8007e0a:	0692      	lsls	r2, r2, #26
 8007e0c:	d503      	bpl.n	8007e16 <HAL_TIM_IRQHandler+0x7e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8007e0e:	68da      	ldr	r2, [r3, #12]
 8007e10:	0690      	lsls	r0, r2, #26
 8007e12:	f100 808e 	bmi.w	8007f32 <HAL_TIM_IRQHandler+0x19a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IDX) != RESET)
 8007e16:	691a      	ldr	r2, [r3, #16]
 8007e18:	02d1      	lsls	r1, r2, #11
 8007e1a:	d503      	bpl.n	8007e24 <HAL_TIM_IRQHandler+0x8c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IDX) != RESET)
 8007e1c:	68da      	ldr	r2, [r3, #12]
 8007e1e:	02d2      	lsls	r2, r2, #11
 8007e20:	f100 808f 	bmi.w	8007f42 <HAL_TIM_IRQHandler+0x1aa>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_DIR) != RESET)
 8007e24:	691a      	ldr	r2, [r3, #16]
 8007e26:	0290      	lsls	r0, r2, #10
 8007e28:	d503      	bpl.n	8007e32 <HAL_TIM_IRQHandler+0x9a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_DIR) != RESET)
 8007e2a:	68da      	ldr	r2, [r3, #12]
 8007e2c:	0291      	lsls	r1, r2, #10
 8007e2e:	f100 8090 	bmi.w	8007f52 <HAL_TIM_IRQHandler+0x1ba>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IERR) != RESET)
 8007e32:	691a      	ldr	r2, [r3, #16]
 8007e34:	0252      	lsls	r2, r2, #9
 8007e36:	d503      	bpl.n	8007e40 <HAL_TIM_IRQHandler+0xa8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_IERR) != RESET)
 8007e38:	68da      	ldr	r2, [r3, #12]
 8007e3a:	0250      	lsls	r0, r2, #9
 8007e3c:	f100 8091 	bmi.w	8007f62 <HAL_TIM_IRQHandler+0x1ca>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TERR) != RESET)
 8007e40:	691a      	ldr	r2, [r3, #16]
 8007e42:	0211      	lsls	r1, r2, #8
 8007e44:	d502      	bpl.n	8007e4c <HAL_TIM_IRQHandler+0xb4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TERR) != RESET)
 8007e46:	68da      	ldr	r2, [r3, #12]
 8007e48:	0212      	lsls	r2, r2, #8
 8007e4a:	d44a      	bmi.n	8007ee2 <HAL_TIM_IRQHandler+0x14a>
}
 8007e4c:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8007e4e:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8007e52:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8007e54:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8007e56:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8007e58:	69db      	ldr	r3, [r3, #28]
 8007e5a:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8007e5e:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8007e60:	f040 8090 	bne.w	8007f84 <HAL_TIM_IRQHandler+0x1ec>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007e64:	f7ff ff90 	bl	8007d88 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007e68:	4620      	mov	r0, r4
 8007e6a:	f7ff ff91 	bl	8007d90 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007e6e:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8007e70:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007e72:	7722      	strb	r2, [r4, #28]
 8007e74:	e7ac      	b.n	8007dd0 <HAL_TIM_IRQHandler+0x38>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8007e76:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8007e7a:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8007e7c:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8007e7e:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8007e80:	69db      	ldr	r3, [r3, #28]
 8007e82:	079b      	lsls	r3, r3, #30
        HAL_TIM_IC_CaptureCallback(htim);
 8007e84:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8007e86:	d17a      	bne.n	8007f7e <HAL_TIM_IRQHandler+0x1e6>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007e88:	f7ff ff7e 	bl	8007d88 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007e8c:	4620      	mov	r0, r4
 8007e8e:	f7ff ff7f 	bl	8007d90 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007e92:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8007e94:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007e96:	7722      	strb	r2, [r4, #28]
 8007e98:	e794      	b.n	8007dc4 <HAL_TIM_IRQHandler+0x2c>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8007e9a:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8007e9e:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8007ea0:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8007ea2:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8007ea4:	699b      	ldr	r3, [r3, #24]
 8007ea6:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8007eaa:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8007eac:	d164      	bne.n	8007f78 <HAL_TIM_IRQHandler+0x1e0>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007eae:	f7ff ff6b 	bl	8007d88 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007eb2:	4620      	mov	r0, r4
 8007eb4:	f7ff ff6c 	bl	8007d90 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007eb8:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8007eba:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007ebc:	7722      	strb	r2, [r4, #28]
 8007ebe:	e77b      	b.n	8007db8 <HAL_TIM_IRQHandler+0x20>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007ec0:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8007ec4:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007ec6:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8007ec8:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8007eca:	699b      	ldr	r3, [r3, #24]
 8007ecc:	0799      	lsls	r1, r3, #30
 8007ece:	d150      	bne.n	8007f72 <HAL_TIM_IRQHandler+0x1da>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8007ed0:	f7ff ff5a 	bl	8007d88 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007ed4:	4620      	mov	r0, r4
 8007ed6:	f7ff ff5b 	bl	8007d90 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007eda:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007edc:	6823      	ldr	r3, [r4, #0]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007ede:	7722      	strb	r2, [r4, #28]
 8007ee0:	e764      	b.n	8007dac <HAL_TIM_IRQHandler+0x14>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_TERR);
 8007ee2:	f46f 0200 	mvn.w	r2, #8388608	; 0x800000
      HAL_TIMEx_TransitionErrorCallback(htim);
 8007ee6:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_TERR);
 8007ee8:	611a      	str	r2, [r3, #16]
}
 8007eea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_TransitionErrorCallback(htim);
 8007eee:	f000 ba63 	b.w	80083b8 <HAL_TIMEx_TransitionErrorCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8007ef2:	f06f 0201 	mvn.w	r2, #1
 8007ef6:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8007ef8:	4620      	mov	r0, r4
 8007efa:	f7ff ff43 	bl	8007d84 <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007efe:	6823      	ldr	r3, [r4, #0]
 8007f00:	e76d      	b.n	8007dde <HAL_TIM_IRQHandler+0x46>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8007f02:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8007f06:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8007f08:	4620      	mov	r0, r4
 8007f0a:	f000 fa4b 	bl	80083a4 <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8007f0e:	6823      	ldr	r3, [r4, #0]
 8007f10:	e76c      	b.n	8007dec <HAL_TIM_IRQHandler+0x54>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8007f12:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8007f16:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8007f18:	4620      	mov	r0, r4
 8007f1a:	f000 fa45 	bl	80083a8 <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8007f1e:	6823      	ldr	r3, [r4, #0]
 8007f20:	e76b      	b.n	8007dfa <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8007f22:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8007f26:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8007f28:	4620      	mov	r0, r4
 8007f2a:	f7ff ff33 	bl	8007d94 <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8007f2e:	6823      	ldr	r3, [r4, #0]
 8007f30:	e76a      	b.n	8007e08 <HAL_TIM_IRQHandler+0x70>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8007f32:	f06f 0220 	mvn.w	r2, #32
 8007f36:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8007f38:	4620      	mov	r0, r4
 8007f3a:	f000 fa31 	bl	80083a0 <HAL_TIMEx_CommutCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IDX) != RESET)
 8007f3e:	6823      	ldr	r3, [r4, #0]
 8007f40:	e769      	b.n	8007e16 <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IDX);
 8007f42:	f46f 1280 	mvn.w	r2, #1048576	; 0x100000
 8007f46:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_EncoderIndexCallback(htim);
 8007f48:	4620      	mov	r0, r4
 8007f4a:	f000 fa2f 	bl	80083ac <HAL_TIMEx_EncoderIndexCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_DIR) != RESET)
 8007f4e:	6823      	ldr	r3, [r4, #0]
 8007f50:	e768      	b.n	8007e24 <HAL_TIM_IRQHandler+0x8c>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_DIR);
 8007f52:	f46f 1200 	mvn.w	r2, #2097152	; 0x200000
 8007f56:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_DirectionChangeCallback(htim);
 8007f58:	4620      	mov	r0, r4
 8007f5a:	f000 fa29 	bl	80083b0 <HAL_TIMEx_DirectionChangeCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_IERR) != RESET)
 8007f5e:	6823      	ldr	r3, [r4, #0]
 8007f60:	e767      	b.n	8007e32 <HAL_TIM_IRQHandler+0x9a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_IERR);
 8007f62:	f46f 0280 	mvn.w	r2, #4194304	; 0x400000
 8007f66:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_IndexErrorCallback(htim);
 8007f68:	4620      	mov	r0, r4
 8007f6a:	f000 fa23 	bl	80083b4 <HAL_TIMEx_IndexErrorCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TERR) != RESET)
 8007f6e:	6823      	ldr	r3, [r4, #0]
 8007f70:	e766      	b.n	8007e40 <HAL_TIM_IRQHandler+0xa8>
          HAL_TIM_IC_CaptureCallback(htim);
 8007f72:	f7ff ff0b 	bl	8007d8c <HAL_TIM_IC_CaptureCallback>
 8007f76:	e7b0      	b.n	8007eda <HAL_TIM_IRQHandler+0x142>
        HAL_TIM_IC_CaptureCallback(htim);
 8007f78:	f7ff ff08 	bl	8007d8c <HAL_TIM_IC_CaptureCallback>
 8007f7c:	e79c      	b.n	8007eb8 <HAL_TIM_IRQHandler+0x120>
        HAL_TIM_IC_CaptureCallback(htim);
 8007f7e:	f7ff ff05 	bl	8007d8c <HAL_TIM_IC_CaptureCallback>
 8007f82:	e786      	b.n	8007e92 <HAL_TIM_IRQHandler+0xfa>
        HAL_TIM_IC_CaptureCallback(htim);
 8007f84:	f7ff ff02 	bl	8007d8c <HAL_TIM_IC_CaptureCallback>
 8007f88:	e771      	b.n	8007e6e <HAL_TIM_IRQHandler+0xd6>
 8007f8a:	bf00      	nop

08007f8c <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007f8c:	6a03      	ldr	r3, [r0, #32]
 8007f8e:	f023 0310 	bic.w	r3, r3, #16
 8007f92:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8007f94:	6a03      	ldr	r3, [r0, #32]
{
 8007f96:	b470      	push	{r4, r5, r6}
  tmpcr2 =  TIMx->CR2;
 8007f98:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8007f9a:	6982      	ldr	r2, [r0, #24]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007f9c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8007f9e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8007fa2:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007fa6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8007faa:	688d      	ldr	r5, [r1, #8]
  tmpccer &= ~TIM_CCER_CC2P;
 8007fac:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8007fb0:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8007fb4:	4d1c      	ldr	r5, [pc, #112]	; (8008028 <TIM_OC2_SetConfig+0x9c>)
 8007fb6:	42a8      	cmp	r0, r5
 8007fb8:	d017      	beq.n	8007fea <TIM_OC2_SetConfig+0x5e>
 8007fba:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007fbe:	42a8      	cmp	r0, r5
 8007fc0:	d013      	beq.n	8007fea <TIM_OC2_SetConfig+0x5e>
 8007fc2:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 8007fc6:	42a8      	cmp	r0, r5
 8007fc8:	d025      	beq.n	8008016 <TIM_OC2_SetConfig+0x8a>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007fca:	4d18      	ldr	r5, [pc, #96]	; (800802c <TIM_OC2_SetConfig+0xa0>)
 8007fcc:	42a8      	cmp	r0, r5
 8007fce:	d013      	beq.n	8007ff8 <TIM_OC2_SetConfig+0x6c>
 8007fd0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007fd4:	42a8      	cmp	r0, r5
 8007fd6:	d00f      	beq.n	8007ff8 <TIM_OC2_SetConfig+0x6c>
 8007fd8:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007fdc:	42a8      	cmp	r0, r5
 8007fde:	d00b      	beq.n	8007ff8 <TIM_OC2_SetConfig+0x6c>
 8007fe0:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8007fe4:	42a8      	cmp	r0, r5
 8007fe6:	d10f      	bne.n	8008008 <TIM_OC2_SetConfig+0x7c>
 8007fe8:	e006      	b.n	8007ff8 <TIM_OC2_SetConfig+0x6c>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8007fea:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8007fec:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8007ff0:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8007ff4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8007ff8:	e9d1 6505 	ldrd	r6, r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8007ffc:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008000:	ea46 0c05 	orr.w	ip, r6, r5
 8008004:	ea44 048c 	orr.w	r4, r4, ip, lsl #2
  TIMx->CCR2 = OC_Config->Pulse;
 8008008:	6849      	ldr	r1, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800800a:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 800800c:	6182      	str	r2, [r0, #24]
}
 800800e:	bc70      	pop	{r4, r5, r6}
  TIMx->CCR2 = OC_Config->Pulse;
 8008010:	6381      	str	r1, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8008012:	6203      	str	r3, [r0, #32]
}
 8008014:	4770      	bx	lr
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008016:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
 8008018:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800801c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8008020:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8008024:	e7d1      	b.n	8007fca <TIM_OC2_SetConfig+0x3e>
 8008026:	bf00      	nop
 8008028:	40012c00 	.word	0x40012c00
 800802c:	40014000 	.word	0x40014000

08008030 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8008030:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8008034:	2b01      	cmp	r3, #1
 8008036:	f000 80ff 	beq.w	8008238 <HAL_TIM_PWM_ConfigChannel+0x208>
 800803a:	2301      	movs	r3, #1
{
 800803c:	b570      	push	{r4, r5, r6, lr}
 800803e:	4604      	mov	r4, r0
 8008040:	460d      	mov	r5, r1
  __HAL_LOCK(htim);
 8008042:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 8008046:	2a14      	cmp	r2, #20
 8008048:	d80c      	bhi.n	8008064 <HAL_TIM_PWM_ConfigChannel+0x34>
 800804a:	e8df f002 	tbb	[pc, r2]
 800804e:	0b59      	.short	0x0b59
 8008050:	0b6e0b0b 	.word	0x0b6e0b0b
 8008054:	0b840b0b 	.word	0x0b840b0b
 8008058:	0b990b0b 	.word	0x0b990b0b
 800805c:	0baf0b0b 	.word	0x0baf0b0b
 8008060:	0b0b      	.short	0x0b0b
 8008062:	11          	.byte	0x11
 8008063:	00          	.byte	0x00
  __HAL_UNLOCK(htim);
 8008064:	2300      	movs	r3, #0
  switch (Channel)
 8008066:	2201      	movs	r2, #1
  __HAL_UNLOCK(htim);
 8008068:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800806c:	4610      	mov	r0, r2
 800806e:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8008070:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008072:	682e      	ldr	r6, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8008074:	6a1a      	ldr	r2, [r3, #32]
 8008076:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800807a:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 800807c:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800807e:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 8008080:	6d19      	ldr	r1, [r3, #80]	; 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8008082:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8008086:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800808a:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800808e:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8008090:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8008094:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8008098:	4e69      	ldr	r6, [pc, #420]	; (8008240 <HAL_TIM_PWM_ConfigChannel+0x210>)
 800809a:	42b3      	cmp	r3, r6
 800809c:	d013      	beq.n	80080c6 <HAL_TIM_PWM_ConfigChannel+0x96>
 800809e:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80080a2:	42b3      	cmp	r3, r6
 80080a4:	d00f      	beq.n	80080c6 <HAL_TIM_PWM_ConfigChannel+0x96>
 80080a6:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 80080aa:	42b3      	cmp	r3, r6
 80080ac:	d00b      	beq.n	80080c6 <HAL_TIM_PWM_ConfigChannel+0x96>
 80080ae:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80080b2:	42b3      	cmp	r3, r6
 80080b4:	d007      	beq.n	80080c6 <HAL_TIM_PWM_ConfigChannel+0x96>
 80080b6:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80080ba:	42b3      	cmp	r3, r6
 80080bc:	d003      	beq.n	80080c6 <HAL_TIM_PWM_ConfigChannel+0x96>
 80080be:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80080c2:	42b3      	cmp	r3, r6
 80080c4:	d104      	bne.n	80080d0 <HAL_TIM_PWM_ConfigChannel+0xa0>
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80080c6:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS6;
 80080c8:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80080cc:	ea40 2086 	orr.w	r0, r0, r6, lsl #10
  TIMx->CR2 = tmpcr2;
 80080d0:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 80080d2:	6519      	str	r1, [r3, #80]	; 0x50
  TIMx->CCR6 = OC_Config->Pulse;
 80080d4:	6869      	ldr	r1, [r5, #4]
 80080d6:	64d9      	str	r1, [r3, #76]	; 0x4c
  TIMx->CCER = tmpccer;
 80080d8:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80080da:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 80080dc:	6928      	ldr	r0, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80080de:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80080e2:	651a      	str	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 80080e4:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80080e6:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80080ea:	6519      	str	r1, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 80080ec:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80080ee:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 80080f2:	6519      	str	r1, [r3, #80]	; 0x50
  __HAL_UNLOCK(htim);
 80080f4:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 80080f6:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 80080f8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80080fc:	4610      	mov	r0, r2
 80080fe:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008100:	6800      	ldr	r0, [r0, #0]
 8008102:	f7ff f95d 	bl	80073c0 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8008106:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8008108:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800810a:	f043 0308 	orr.w	r3, r3, #8
 800810e:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8008110:	6983      	ldr	r3, [r0, #24]
 8008112:	f023 0304 	bic.w	r3, r3, #4
 8008116:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8008118:	6983      	ldr	r3, [r0, #24]
 800811a:	430b      	orrs	r3, r1
 800811c:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 800811e:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8008120:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008122:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8008126:	4610      	mov	r0, r2
 8008128:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800812a:	6800      	ldr	r0, [r0, #0]
 800812c:	f7ff ff2e 	bl	8007f8c <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8008130:	6983      	ldr	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8008132:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8008134:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8008138:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800813a:	6983      	ldr	r3, [r0, #24]
 800813c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008140:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8008142:	6983      	ldr	r3, [r0, #24]
 8008144:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8008148:	6183      	str	r3, [r0, #24]
  __HAL_UNLOCK(htim);
 800814a:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 800814c:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 800814e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8008152:	4610      	mov	r0, r2
 8008154:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8008156:	6800      	ldr	r0, [r0, #0]
 8008158:	f7ff f972 	bl	8007440 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800815c:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800815e:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8008160:	f043 0308 	orr.w	r3, r3, #8
 8008164:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8008166:	69c3      	ldr	r3, [r0, #28]
 8008168:	f023 0304 	bic.w	r3, r3, #4
 800816c:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800816e:	69c3      	ldr	r3, [r0, #28]
 8008170:	430b      	orrs	r3, r1
 8008172:	61c3      	str	r3, [r0, #28]
  __HAL_UNLOCK(htim);
 8008174:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 8008176:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008178:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800817c:	4610      	mov	r0, r2
 800817e:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8008180:	6800      	ldr	r0, [r0, #0]
 8008182:	f7ff f9ad 	bl	80074e0 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8008186:	69c3      	ldr	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8008188:	6929      	ldr	r1, [r5, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800818a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800818e:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8008190:	69c3      	ldr	r3, [r0, #28]
 8008192:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008196:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8008198:	69c3      	ldr	r3, [r0, #28]
 800819a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800819e:	61c3      	str	r3, [r0, #28]
  __HAL_UNLOCK(htim);
 80081a0:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 80081a2:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 80081a4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80081a8:	4610      	mov	r0, r2
 80081aa:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 80081ac:	6803      	ldr	r3, [r0, #0]
  tmpccmrx |= OC_Config->OCMode;
 80081ae:	682e      	ldr	r6, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80081b0:	6a1a      	ldr	r2, [r3, #32]
 80081b2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80081b6:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80081b8:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80081ba:	6858      	ldr	r0, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 80081bc:	6d19      	ldr	r1, [r3, #80]	; 0x50
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80081be:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80081c2:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 80081c6:	4331      	orrs	r1, r6
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80081c8:	68ae      	ldr	r6, [r5, #8]
  tmpccer &= ~TIM_CCER_CC5P;
 80081ca:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 80081ce:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80081d2:	4e1b      	ldr	r6, [pc, #108]	; (8008240 <HAL_TIM_PWM_ConfigChannel+0x210>)
 80081d4:	42b3      	cmp	r3, r6
 80081d6:	d013      	beq.n	8008200 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 80081d8:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80081dc:	42b3      	cmp	r3, r6
 80081de:	d00f      	beq.n	8008200 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 80081e0:	f506 6640 	add.w	r6, r6, #3072	; 0xc00
 80081e4:	42b3      	cmp	r3, r6
 80081e6:	d00b      	beq.n	8008200 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 80081e8:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80081ec:	42b3      	cmp	r3, r6
 80081ee:	d007      	beq.n	8008200 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 80081f0:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80081f4:	42b3      	cmp	r3, r6
 80081f6:	d003      	beq.n	8008200 <HAL_TIM_PWM_ConfigChannel+0x1d0>
 80081f8:	f506 6600 	add.w	r6, r6, #2048	; 0x800
 80081fc:	42b3      	cmp	r3, r6
 80081fe:	d104      	bne.n	800820a <HAL_TIM_PWM_ConfigChannel+0x1da>
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8008200:	696e      	ldr	r6, [r5, #20]
    tmpcr2 &= ~TIM_CR2_OIS5;
 8008202:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8008206:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  TIMx->CR2 = tmpcr2;
 800820a:	6058      	str	r0, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800820c:	6519      	str	r1, [r3, #80]	; 0x50
  TIMx->CCR5 = OC_Config->Pulse;
 800820e:	6869      	ldr	r1, [r5, #4]
 8008210:	6499      	str	r1, [r3, #72]	; 0x48
  TIMx->CCER = tmpccer;
 8008212:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8008214:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8008216:	6928      	ldr	r0, [r5, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8008218:	f042 0208 	orr.w	r2, r2, #8
 800821c:	651a      	str	r2, [r3, #80]	; 0x50
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800821e:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8008220:	f021 0104 	bic.w	r1, r1, #4
 8008224:	6519      	str	r1, [r3, #80]	; 0x50
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8008226:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8008228:	4301      	orrs	r1, r0
 800822a:	6519      	str	r1, [r3, #80]	; 0x50
  __HAL_UNLOCK(htim);
 800822c:	2300      	movs	r3, #0
  HAL_StatusTypeDef status = HAL_OK;
 800822e:	2200      	movs	r2, #0
  __HAL_UNLOCK(htim);
 8008230:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8008234:	4610      	mov	r0, r2
 8008236:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(htim);
 8008238:	2202      	movs	r2, #2
}
 800823a:	4610      	mov	r0, r2
 800823c:	4770      	bx	lr
 800823e:	bf00      	nop
 8008240:	40012c00 	.word	0x40012c00

08008244 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8008244:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8008248:	2b01      	cmp	r3, #1
 800824a:	d051      	beq.n	80082f0 <HAL_TIMEx_MasterConfigSynchronization+0xac>
{
 800824c:	b430      	push	{r4, r5}

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800824e:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8008250:	4d28      	ldr	r5, [pc, #160]	; (80082f4 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
  htim->State = HAL_TIM_STATE_BUSY;
 8008252:	2302      	movs	r3, #2
 8008254:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8008258:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 800825a:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 800825c:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800825e:	d03b      	beq.n	80082d8 <HAL_TIMEx_MasterConfigSynchronization+0x94>
 8008260:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8008264:	42aa      	cmp	r2, r5
 8008266:	d032      	beq.n	80082ce <HAL_TIMEx_MasterConfigSynchronization+0x8a>
 8008268:	f505 55e0 	add.w	r5, r5, #7168	; 0x1c00
 800826c:	42aa      	cmp	r2, r5
 800826e:	d02e      	beq.n	80082ce <HAL_TIMEx_MasterConfigSynchronization+0x8a>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8008270:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 8008272:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8008276:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800827a:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800827c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->Instance->CR2 = tmpcr2;
 8008280:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008282:	d016      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 8008284:	4b1c      	ldr	r3, [pc, #112]	; (80082f8 <HAL_TIMEx_MasterConfigSynchronization+0xb4>)
 8008286:	429a      	cmp	r2, r3
 8008288:	d013      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 800828a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800828e:	429a      	cmp	r2, r3
 8008290:	d00f      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 8008292:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8008296:	429a      	cmp	r2, r3
 8008298:	d00b      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 800829a:	f503 3394 	add.w	r3, r3, #75776	; 0x12800
 800829e:	429a      	cmp	r2, r3
 80082a0:	d007      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082a2:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 80082a6:	429a      	cmp	r2, r3
 80082a8:	d003      	beq.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 80082aa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80082ae:	429a      	cmp	r2, r3
 80082b0:	d104      	bne.n	80082bc <HAL_TIMEx_MasterConfigSynchronization+0x78>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80082b2:	688b      	ldr	r3, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 80082b4:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80082b8:	431c      	orrs	r4, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 80082ba:	6094      	str	r4, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 80082bc:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 80082be:	2201      	movs	r2, #1
 80082c0:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 80082c4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
}
 80082c8:	bc30      	pop	{r4, r5}
  return HAL_OK;
 80082ca:	4618      	mov	r0, r3
}
 80082cc:	4770      	bx	lr
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80082ce:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 80082d0:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80082d4:	432b      	orrs	r3, r5
 80082d6:	e7cb      	b.n	8008270 <HAL_TIMEx_MasterConfigSynchronization+0x2c>
 80082d8:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 80082da:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 80082de:	432b      	orrs	r3, r5
  tmpcr2 &= ~TIM_CR2_MMS;
 80082e0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80082e4:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 80082e6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80082ea:	432b      	orrs	r3, r5
  htim->Instance->CR2 = tmpcr2;
 80082ec:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80082ee:	e7e0      	b.n	80082b2 <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  __HAL_LOCK(htim);
 80082f0:	2002      	movs	r0, #2
}
 80082f2:	4770      	bx	lr
 80082f4:	40012c00 	.word	0x40012c00
 80082f8:	40000400 	.word	0x40000400

080082fc <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 80082fc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8008300:	2b01      	cmp	r3, #1
 8008302:	d048      	beq.n	8008396 <HAL_TIMEx_ConfigBreakDeadTime+0x9a>
{
 8008304:	b410      	push	{r4}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008306:	e9d1 4302 	ldrd	r4, r3, [r1, #8]
 800830a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800830e:	4602      	mov	r2, r0
 8008310:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8008312:	6848      	ldr	r0, [r1, #4]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8008314:	680c      	ldr	r4, [r1, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8008316:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800831a:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800831c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008320:	6908      	ldr	r0, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8008322:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008324:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008328:	694c      	ldr	r4, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800832a:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800832c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008330:	6b08      	ldr	r0, [r1, #48]	; 0x30
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008332:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008334:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8008338:	698c      	ldr	r4, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800833a:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800833c:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 8008340:	6810      	ldr	r0, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8008342:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 8008346:	4c15      	ldr	r4, [pc, #84]	; (800839c <HAL_TIMEx_ConfigBreakDeadTime+0xa0>)
 8008348:	42a0      	cmp	r0, r4
 800834a:	d007      	beq.n	800835c <HAL_TIMEx_ConfigBreakDeadTime+0x60>
 800834c:	f504 6400 	add.w	r4, r4, #2048	; 0x800
 8008350:	42a0      	cmp	r0, r4
 8008352:	d003      	beq.n	800835c <HAL_TIMEx_ConfigBreakDeadTime+0x60>
 8008354:	f504 54e0 	add.w	r4, r4, #7168	; 0x1c00
 8008358:	42a0      	cmp	r0, r4
 800835a:	d114      	bne.n	8008386 <HAL_TIMEx_ConfigBreakDeadTime+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));

    /* Set BREAK AF mode */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 800835c:	69cc      	ldr	r4, [r1, #28]
 800835e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008362:	4323      	orrs	r3, r4
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8008364:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 8008366:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800836a:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 800836e:	6a0c      	ldr	r4, [r1, #32]
 8008370:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008374:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8008376:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    {
      /* Check the parameters */
      assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));

      /* Set BREAK2 AF mode */
      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 8008378:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 800837a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 800837e:	4323      	orrs	r3, r4
      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 8008380:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8008384:	430b      	orrs	r3, r1
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 8008386:	2100      	movs	r1, #0
  htim->Instance->BDTR = tmpbdtr;
 8008388:	6443      	str	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(htim);
 800838a:	f882 103c 	strb.w	r1, [r2, #60]	; 0x3c

  return HAL_OK;
 800838e:	4608      	mov	r0, r1
}
 8008390:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008394:	4770      	bx	lr
  __HAL_LOCK(htim);
 8008396:	2002      	movs	r0, #2
}
 8008398:	4770      	bx	lr
 800839a:	bf00      	nop
 800839c:	40012c00 	.word	0x40012c00

080083a0 <HAL_TIMEx_CommutCallback>:
 80083a0:	4770      	bx	lr
 80083a2:	bf00      	nop

080083a4 <HAL_TIMEx_BreakCallback>:
 80083a4:	4770      	bx	lr
 80083a6:	bf00      	nop

080083a8 <HAL_TIMEx_Break2Callback>:
 80083a8:	4770      	bx	lr
 80083aa:	bf00      	nop

080083ac <HAL_TIMEx_EncoderIndexCallback>:
 80083ac:	4770      	bx	lr
 80083ae:	bf00      	nop

080083b0 <HAL_TIMEx_DirectionChangeCallback>:
 80083b0:	4770      	bx	lr
 80083b2:	bf00      	nop

080083b4 <HAL_TIMEx_IndexErrorCallback>:
 80083b4:	4770      	bx	lr
 80083b6:	bf00      	nop

080083b8 <HAL_TIMEx_TransitionErrorCallback>:
 80083b8:	4770      	bx	lr
 80083ba:	bf00      	nop

080083bc <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 80083bc:	b538      	push	{r3, r4, r5, lr}
 80083be:	4604      	mov	r4, r0
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 80083c0:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80083c2:	6882      	ldr	r2, [r0, #8]
 80083c4:	6900      	ldr	r0, [r0, #16]
 80083c6:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80083c8:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80083ca:	4302      	orrs	r2, r0
 80083cc:	430a      	orrs	r2, r1
 80083ce:	69e0      	ldr	r0, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80083d0:	49b2      	ldr	r1, [pc, #712]	; (800869c <UART_SetConfig+0x2e0>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80083d2:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80083d4:	4029      	ands	r1, r5
 80083d6:	430a      	orrs	r2, r1
 80083d8:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80083da:	685a      	ldr	r2, [r3, #4]
 80083dc:	68e1      	ldr	r1, [r4, #12]
 80083de:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80083e2:	430a      	orrs	r2, r1
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80083e4:	49ae      	ldr	r1, [pc, #696]	; (80086a0 <UART_SetConfig+0x2e4>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80083e6:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80083e8:	428b      	cmp	r3, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80083ea:	69a2      	ldr	r2, [r4, #24]
  {
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80083ec:	6899      	ldr	r1, [r3, #8]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80083ee:	f000 8081 	beq.w	80084f4 <UART_SetConfig+0x138>
    tmpreg |= huart->Init.OneBitSampling;
 80083f2:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80083f4:	f021 416e 	bic.w	r1, r1, #3992977408	; 0xee000000
 80083f8:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
    tmpreg |= huart->Init.OneBitSampling;
 80083fc:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80083fe:	430a      	orrs	r2, r1
 8008400:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8008402:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008404:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008406:	f022 020f 	bic.w	r2, r2, #15
 800840a:	430a      	orrs	r2, r1
 800840c:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800840e:	4aa5      	ldr	r2, [pc, #660]	; (80086a4 <UART_SetConfig+0x2e8>)
 8008410:	4293      	cmp	r3, r2
 8008412:	d027      	beq.n	8008464 <UART_SetConfig+0xa8>
 8008414:	4aa4      	ldr	r2, [pc, #656]	; (80086a8 <UART_SetConfig+0x2ec>)
 8008416:	4293      	cmp	r3, r2
 8008418:	d04b      	beq.n	80084b2 <UART_SetConfig+0xf6>
 800841a:	4aa4      	ldr	r2, [pc, #656]	; (80086ac <UART_SetConfig+0x2f0>)
 800841c:	4293      	cmp	r3, r2
 800841e:	f000 8111 	beq.w	8008644 <UART_SetConfig+0x288>
 8008422:	4aa3      	ldr	r2, [pc, #652]	; (80086b0 <UART_SetConfig+0x2f4>)
 8008424:	4293      	cmp	r3, r2
 8008426:	f000 80b9 	beq.w	800859c <UART_SetConfig+0x1e0>
 800842a:	4aa2      	ldr	r2, [pc, #648]	; (80086b4 <UART_SetConfig+0x2f8>)
 800842c:	4293      	cmp	r3, r2
 800842e:	d111      	bne.n	8008454 <UART_SetConfig+0x98>
 8008430:	4ba1      	ldr	r3, [pc, #644]	; (80086b8 <UART_SetConfig+0x2fc>)
 8008432:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8008436:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800843a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800843e:	f000 8126 	beq.w	800868e <UART_SetConfig+0x2d2>
 8008442:	f200 80d5 	bhi.w	80085f0 <UART_SetConfig+0x234>
 8008446:	2b00      	cmp	r3, #0
 8008448:	f000 80d9 	beq.w	80085fe <UART_SetConfig+0x242>
 800844c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008450:	f000 80b0 	beq.w	80085b4 <UART_SetConfig+0x1f8>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
        break;
      default:
        pclk = 0U;
        ret = HAL_ERROR;
 8008454:	2001      	movs	r0, #1
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8008456:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 8008458:	f04f 1201 	mov.w	r2, #65537	; 0x10001
  huart->TxISR = NULL;
 800845c:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
  huart->NbRxDataToProcess = 1;
 8008460:	66a2      	str	r2, [r4, #104]	; 0x68

  return ret;
}
 8008462:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008464:	4b94      	ldr	r3, [pc, #592]	; (80086b8 <UART_SetConfig+0x2fc>)
 8008466:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800846a:	f003 0303 	and.w	r3, r3, #3
 800846e:	3b01      	subs	r3, #1
 8008470:	2b02      	cmp	r3, #2
 8008472:	f240 808d 	bls.w	8008590 <UART_SetConfig+0x1d4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8008476:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800847a:	f000 8103 	beq.w	8008684 <UART_SetConfig+0x2c8>
        pclk = HAL_RCC_GetPCLK2Freq();
 800847e:	f7fe fdfd 	bl	800707c <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 8008482:	2800      	cmp	r0, #0
 8008484:	f000 80dc 	beq.w	8008640 <UART_SetConfig+0x284>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8008488:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800848a:	6862      	ldr	r2, [r4, #4]
 800848c:	4b8b      	ldr	r3, [pc, #556]	; (80086bc <UART_SetConfig+0x300>)
 800848e:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8008492:	fbb0 f3f3 	udiv	r3, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8008496:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800849a:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800849e:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80084a2:	f1a3 0210 	sub.w	r2, r3, #16
 80084a6:	428a      	cmp	r2, r1
 80084a8:	d8d4      	bhi.n	8008454 <UART_SetConfig+0x98>
        huart->Instance->BRR = (uint16_t)usartdiv;
 80084aa:	6822      	ldr	r2, [r4, #0]
 80084ac:	2000      	movs	r0, #0
 80084ae:	60d3      	str	r3, [r2, #12]
 80084b0:	e7d1      	b.n	8008456 <UART_SetConfig+0x9a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80084b2:	4b81      	ldr	r3, [pc, #516]	; (80086b8 <UART_SetConfig+0x2fc>)
 80084b4:	4a82      	ldr	r2, [pc, #520]	; (80086c0 <UART_SetConfig+0x304>)
 80084b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80084ba:	f003 030c 	and.w	r3, r3, #12
 80084be:	5cd3      	ldrb	r3, [r2, r3]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80084c0:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80084c4:	d07c      	beq.n	80085c0 <UART_SetConfig+0x204>
    switch (clocksource)
 80084c6:	2b08      	cmp	r3, #8
 80084c8:	d8c4      	bhi.n	8008454 <UART_SetConfig+0x98>
 80084ca:	a201      	add	r2, pc, #4	; (adr r2, 80084d0 <UART_SetConfig+0x114>)
 80084cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80084d0:	080085f9 	.word	0x080085f9
 80084d4:	0800847f 	.word	0x0800847f
 80084d8:	0800867b 	.word	0x0800867b
 80084dc:	08008455 	.word	0x08008455
 80084e0:	080085bb 	.word	0x080085bb
 80084e4:	08008455 	.word	0x08008455
 80084e8:	08008455 	.word	0x08008455
 80084ec:	08008455 	.word	0x08008455
 80084f0:	0800866b 	.word	0x0800866b
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80084f4:	f021 416e 	bic.w	r1, r1, #3992977408	; 0xee000000
 80084f8:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 80084fc:	4311      	orrs	r1, r2
 80084fe:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8008500:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008502:	6a61      	ldr	r1, [r4, #36]	; 0x24
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008504:	486c      	ldr	r0, [pc, #432]	; (80086b8 <UART_SetConfig+0x2fc>)
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8008506:	f022 020f 	bic.w	r2, r2, #15
 800850a:	430a      	orrs	r2, r1
 800850c:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800850e:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8008512:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8008516:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800851a:	f000 80ac 	beq.w	8008676 <UART_SetConfig+0x2ba>
 800851e:	d80b      	bhi.n	8008538 <UART_SetConfig+0x17c>
 8008520:	2b00      	cmp	r3, #0
 8008522:	d038      	beq.n	8008596 <UART_SetConfig+0x1da>
 8008524:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8008528:	d194      	bne.n	8008454 <UART_SetConfig+0x98>
        pclk = HAL_RCC_GetSysClockFreq();
 800852a:	f7fe fc53 	bl	8006dd4 <HAL_RCC_GetSysClockFreq>
    if (pclk != 0U)
 800852e:	2800      	cmp	r0, #0
 8008530:	f000 8086 	beq.w	8008640 <UART_SetConfig+0x284>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8008534:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008536:	e004      	b.n	8008542 <UART_SetConfig+0x186>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008538:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800853c:	d18a      	bne.n	8008454 <UART_SetConfig+0x98>
        pclk = (uint32_t) LSE_VALUE;
 800853e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8008542:	4b5e      	ldr	r3, [pc, #376]	; (80086bc <UART_SetConfig+0x300>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8008544:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8008546:	f833 2011 	ldrh.w	r2, [r3, r1, lsl #1]
 800854a:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800854e:	eb05 0145 	add.w	r1, r5, r5, lsl #1
 8008552:	4299      	cmp	r1, r3
 8008554:	f63f af7e 	bhi.w	8008454 <UART_SetConfig+0x98>
 8008558:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 800855c:	f63f af7a 	bhi.w	8008454 <UART_SetConfig+0x98>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8008560:	2300      	movs	r3, #0
 8008562:	4619      	mov	r1, r3
 8008564:	f7f8 faca 	bl	8000afc <__aeabi_uldivmod>
 8008568:	086a      	lsrs	r2, r5, #1
 800856a:	0203      	lsls	r3, r0, #8
 800856c:	0209      	lsls	r1, r1, #8
 800856e:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8008572:	1898      	adds	r0, r3, r2
 8008574:	f141 0100 	adc.w	r1, r1, #0
 8008578:	462a      	mov	r2, r5
 800857a:	2300      	movs	r3, #0
 800857c:	f7f8 fabe 	bl	8000afc <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8008580:	4a50      	ldr	r2, [pc, #320]	; (80086c4 <UART_SetConfig+0x308>)
 8008582:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 8008586:	4291      	cmp	r1, r2
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8008588:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800858a:	f63f af63 	bhi.w	8008454 <UART_SetConfig+0x98>
 800858e:	e78c      	b.n	80084aa <UART_SetConfig+0xee>
 8008590:	4a4d      	ldr	r2, [pc, #308]	; (80086c8 <UART_SetConfig+0x30c>)
 8008592:	5cd3      	ldrb	r3, [r2, r3]
  if (UART_INSTANCE_LOWPOWER(huart))
 8008594:	e794      	b.n	80084c0 <UART_SetConfig+0x104>
        pclk = HAL_RCC_GetPCLK1Freq();
 8008596:	f7fe fd5f 	bl	8007058 <HAL_RCC_GetPCLK1Freq>
        break;
 800859a:	e7c8      	b.n	800852e <UART_SetConfig+0x172>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800859c:	4b46      	ldr	r3, [pc, #280]	; (80086b8 <UART_SetConfig+0x2fc>)
 800859e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80085a2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80085a6:	2b80      	cmp	r3, #128	; 0x80
 80085a8:	d071      	beq.n	800868e <UART_SetConfig+0x2d2>
 80085aa:	d861      	bhi.n	8008670 <UART_SetConfig+0x2b4>
 80085ac:	b33b      	cbz	r3, 80085fe <UART_SetConfig+0x242>
 80085ae:	2b40      	cmp	r3, #64	; 0x40
 80085b0:	f47f af50 	bne.w	8008454 <UART_SetConfig+0x98>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80085b4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80085b8:	d061      	beq.n	800867e <UART_SetConfig+0x2c2>
        pclk = HAL_RCC_GetSysClockFreq();
 80085ba:	f7fe fc0b 	bl	8006dd4 <HAL_RCC_GetSysClockFreq>
        break;
 80085be:	e760      	b.n	8008482 <UART_SetConfig+0xc6>
    switch (clocksource)
 80085c0:	2b08      	cmp	r3, #8
 80085c2:	f63f af47 	bhi.w	8008454 <UART_SetConfig+0x98>
 80085c6:	a201      	add	r2, pc, #4	; (adr r2, 80085cc <UART_SetConfig+0x210>)
 80085c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80085cc:	08008605 	.word	0x08008605
 80085d0:	08008685 	.word	0x08008685
 80085d4:	0800868b 	.word	0x0800868b
 80085d8:	08008455 	.word	0x08008455
 80085dc:	0800867f 	.word	0x0800867f
 80085e0:	08008455 	.word	0x08008455
 80085e4:	08008455 	.word	0x08008455
 80085e8:	08008455 	.word	0x08008455
 80085ec:	0800860d 	.word	0x0800860d
  UART_GETCLOCKSOURCE(huart, clocksource);
 80085f0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80085f4:	d036      	beq.n	8008664 <UART_SetConfig+0x2a8>
 80085f6:	e72d      	b.n	8008454 <UART_SetConfig+0x98>
        pclk = HAL_RCC_GetPCLK1Freq();
 80085f8:	f7fe fd2e 	bl	8007058 <HAL_RCC_GetPCLK1Freq>
        break;
 80085fc:	e741      	b.n	8008482 <UART_SetConfig+0xc6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80085fe:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8008602:	d1f9      	bne.n	80085f8 <UART_SetConfig+0x23c>
        pclk = HAL_RCC_GetPCLK1Freq();
 8008604:	f7fe fd28 	bl	8007058 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8008608:	b1d0      	cbz	r0, 8008640 <UART_SetConfig+0x284>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800860a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800860c:	6862      	ldr	r2, [r4, #4]
 800860e:	4b2b      	ldr	r3, [pc, #172]	; (80086bc <UART_SetConfig+0x300>)
 8008610:	f833 1011 	ldrh.w	r1, [r3, r1, lsl #1]
 8008614:	fbb0 f0f1 	udiv	r0, r0, r1
 8008618:	0853      	lsrs	r3, r2, #1
 800861a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800861e:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8008622:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8008626:	f1a3 0210 	sub.w	r2, r3, #16
 800862a:	428a      	cmp	r2, r1
 800862c:	f63f af12 	bhi.w	8008454 <UART_SetConfig+0x98>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8008630:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 8008634:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8008636:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8008638:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 800863c:	4313      	orrs	r3, r2
 800863e:	60cb      	str	r3, [r1, #12]
 8008640:	2000      	movs	r0, #0
 8008642:	e708      	b.n	8008456 <UART_SetConfig+0x9a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008644:	4b1c      	ldr	r3, [pc, #112]	; (80086b8 <UART_SetConfig+0x2fc>)
 8008646:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800864a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800864e:	2b20      	cmp	r3, #32
 8008650:	d01d      	beq.n	800868e <UART_SetConfig+0x2d2>
 8008652:	d804      	bhi.n	800865e <UART_SetConfig+0x2a2>
 8008654:	2b00      	cmp	r3, #0
 8008656:	d0d2      	beq.n	80085fe <UART_SetConfig+0x242>
 8008658:	2b10      	cmp	r3, #16
 800865a:	d0ab      	beq.n	80085b4 <UART_SetConfig+0x1f8>
 800865c:	e6fa      	b.n	8008454 <UART_SetConfig+0x98>
 800865e:	2b30      	cmp	r3, #48	; 0x30
 8008660:	f47f aef8 	bne.w	8008454 <UART_SetConfig+0x98>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8008664:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8008668:	d0d0      	beq.n	800860c <UART_SetConfig+0x250>
    switch (clocksource)
 800866a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800866e:	e70c      	b.n	800848a <UART_SetConfig+0xce>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8008670:	2bc0      	cmp	r3, #192	; 0xc0
 8008672:	d0f7      	beq.n	8008664 <UART_SetConfig+0x2a8>
 8008674:	e6ee      	b.n	8008454 <UART_SetConfig+0x98>
 8008676:	4815      	ldr	r0, [pc, #84]	; (80086cc <UART_SetConfig+0x310>)
 8008678:	e763      	b.n	8008542 <UART_SetConfig+0x186>
        pclk = (uint32_t) HSI_VALUE;
 800867a:	4814      	ldr	r0, [pc, #80]	; (80086cc <UART_SetConfig+0x310>)
 800867c:	e705      	b.n	800848a <UART_SetConfig+0xce>
        pclk = HAL_RCC_GetSysClockFreq();
 800867e:	f7fe fba9 	bl	8006dd4 <HAL_RCC_GetSysClockFreq>
        break;
 8008682:	e7c1      	b.n	8008608 <UART_SetConfig+0x24c>
        pclk = HAL_RCC_GetPCLK2Freq();
 8008684:	f7fe fcfa 	bl	800707c <HAL_RCC_GetPCLK2Freq>
        break;
 8008688:	e7be      	b.n	8008608 <UART_SetConfig+0x24c>
        pclk = (uint32_t) HSI_VALUE;
 800868a:	4810      	ldr	r0, [pc, #64]	; (80086cc <UART_SetConfig+0x310>)
 800868c:	e7be      	b.n	800860c <UART_SetConfig+0x250>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800868e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
        pclk = (uint32_t) HSI_VALUE;
 8008692:	480e      	ldr	r0, [pc, #56]	; (80086cc <UART_SetConfig+0x310>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8008694:	f47f aef9 	bne.w	800848a <UART_SetConfig+0xce>
 8008698:	e7b8      	b.n	800860c <UART_SetConfig+0x250>
 800869a:	bf00      	nop
 800869c:	cfff69f3 	.word	0xcfff69f3
 80086a0:	40008000 	.word	0x40008000
 80086a4:	40013800 	.word	0x40013800
 80086a8:	40004400 	.word	0x40004400
 80086ac:	40004800 	.word	0x40004800
 80086b0:	40004c00 	.word	0x40004c00
 80086b4:	40005000 	.word	0x40005000
 80086b8:	40021000 	.word	0x40021000
 80086bc:	0801a1b0 	.word	0x0801a1b0
 80086c0:	0801a1a0 	.word	0x0801a1a0
 80086c4:	000ffcff 	.word	0x000ffcff
 80086c8:	0801a19c 	.word	0x0801a19c
 80086cc:	00f42400 	.word	0x00f42400

080086d0 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80086d0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80086d2:	07da      	lsls	r2, r3, #31
{
 80086d4:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80086d6:	d506      	bpl.n	80086e6 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80086d8:	6801      	ldr	r1, [r0, #0]
 80086da:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80086dc:	684a      	ldr	r2, [r1, #4]
 80086de:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80086e2:	4322      	orrs	r2, r4
 80086e4:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80086e6:	079c      	lsls	r4, r3, #30
 80086e8:	d506      	bpl.n	80086f8 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80086ea:	6801      	ldr	r1, [r0, #0]
 80086ec:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80086ee:	684a      	ldr	r2, [r1, #4]
 80086f0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80086f4:	4322      	orrs	r2, r4
 80086f6:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80086f8:	0759      	lsls	r1, r3, #29
 80086fa:	d506      	bpl.n	800870a <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80086fc:	6801      	ldr	r1, [r0, #0]
 80086fe:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8008700:	684a      	ldr	r2, [r1, #4]
 8008702:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008706:	4322      	orrs	r2, r4
 8008708:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800870a:	071a      	lsls	r2, r3, #28
 800870c:	d506      	bpl.n	800871c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800870e:	6801      	ldr	r1, [r0, #0]
 8008710:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8008712:	684a      	ldr	r2, [r1, #4]
 8008714:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008718:	4322      	orrs	r2, r4
 800871a:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800871c:	06dc      	lsls	r4, r3, #27
 800871e:	d506      	bpl.n	800872e <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8008720:	6801      	ldr	r1, [r0, #0]
 8008722:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8008724:	688a      	ldr	r2, [r1, #8]
 8008726:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800872a:	4322      	orrs	r2, r4
 800872c:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800872e:	0699      	lsls	r1, r3, #26
 8008730:	d506      	bpl.n	8008740 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8008732:	6801      	ldr	r1, [r0, #0]
 8008734:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8008736:	688a      	ldr	r2, [r1, #8]
 8008738:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800873c:	4322      	orrs	r2, r4
 800873e:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8008740:	065a      	lsls	r2, r3, #25
 8008742:	d509      	bpl.n	8008758 <UART_AdvFeatureConfig+0x88>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8008744:	6801      	ldr	r1, [r0, #0]
 8008746:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8008748:	684a      	ldr	r2, [r1, #4]
 800874a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800874e:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8008750:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8008754:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8008756:	d00b      	beq.n	8008770 <UART_AdvFeatureConfig+0xa0>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8008758:	061b      	lsls	r3, r3, #24
 800875a:	d506      	bpl.n	800876a <UART_AdvFeatureConfig+0x9a>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800875c:	6802      	ldr	r2, [r0, #0]
 800875e:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8008760:	6853      	ldr	r3, [r2, #4]
 8008762:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8008766:	430b      	orrs	r3, r1
 8008768:	6053      	str	r3, [r2, #4]
  }
}
 800876a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800876e:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8008770:	684a      	ldr	r2, [r1, #4]
 8008772:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8008774:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8008778:	4322      	orrs	r2, r4
 800877a:	604a      	str	r2, [r1, #4]
 800877c:	e7ec      	b.n	8008758 <UART_AdvFeatureConfig+0x88>
 800877e:	bf00      	nop

08008780 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8008780:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008784:	f8dd 8020 	ldr.w	r8, [sp, #32]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8008788:	6804      	ldr	r4, [r0, #0]
{
 800878a:	4607      	mov	r7, r0
 800878c:	460e      	mov	r6, r1
 800878e:	4615      	mov	r5, r2
 8008790:	4699      	mov	r9, r3
 8008792:	f1b8 3fff 	cmp.w	r8, #4294967295
 8008796:	d10a      	bne.n	80087ae <UART_WaitOnFlagUntilTimeout+0x2e>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8008798:	69e3      	ldr	r3, [r4, #28]
 800879a:	ea36 0303 	bics.w	r3, r6, r3
 800879e:	bf0c      	ite	eq
 80087a0:	2301      	moveq	r3, #1
 80087a2:	2300      	movne	r3, #0
 80087a4:	429d      	cmp	r5, r3
 80087a6:	d0f7      	beq.n	8008798 <UART_WaitOnFlagUntilTimeout+0x18>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 80087a8:	2000      	movs	r0, #0
}
 80087aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80087ae:	69e2      	ldr	r2, [r4, #28]
 80087b0:	ea36 0202 	bics.w	r2, r6, r2
 80087b4:	bf0c      	ite	eq
 80087b6:	2301      	moveq	r3, #1
 80087b8:	2300      	movne	r3, #0
 80087ba:	42ab      	cmp	r3, r5
 80087bc:	d1f4      	bne.n	80087a8 <UART_WaitOnFlagUntilTimeout+0x28>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80087be:	f7fc fe21 	bl	8005404 <HAL_GetTick>
 80087c2:	eba0 0009 	sub.w	r0, r0, r9
 80087c6:	4540      	cmp	r0, r8
 80087c8:	d833      	bhi.n	8008832 <UART_WaitOnFlagUntilTimeout+0xb2>
 80087ca:	f1b8 0f00 	cmp.w	r8, #0
 80087ce:	d030      	beq.n	8008832 <UART_WaitOnFlagUntilTimeout+0xb2>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80087d0:	683c      	ldr	r4, [r7, #0]
 80087d2:	6823      	ldr	r3, [r4, #0]
 80087d4:	0758      	lsls	r0, r3, #29
 80087d6:	4622      	mov	r2, r4
 80087d8:	d5db      	bpl.n	8008792 <UART_WaitOnFlagUntilTimeout+0x12>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80087da:	69e3      	ldr	r3, [r4, #28]
 80087dc:	0519      	lsls	r1, r3, #20
 80087de:	d5d8      	bpl.n	8008792 <UART_WaitOnFlagUntilTimeout+0x12>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80087e0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80087e4:	6223      	str	r3, [r4, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80087e6:	e854 3f00 	ldrex	r3, [r4]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 80087ea:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80087ee:	e844 3100 	strex	r1, r3, [r4]
 80087f2:	b139      	cbz	r1, 8008804 <UART_WaitOnFlagUntilTimeout+0x84>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80087f4:	e852 3f00 	ldrex	r3, [r2]
 80087f8:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80087fc:	e842 3100 	strex	r1, r3, [r2]
 8008800:	2900      	cmp	r1, #0
 8008802:	d1f7      	bne.n	80087f4 <UART_WaitOnFlagUntilTimeout+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008804:	f102 0308 	add.w	r3, r2, #8
 8008808:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800880c:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008810:	f102 0008 	add.w	r0, r2, #8
 8008814:	e840 3100 	strex	r1, r3, [r0]
 8008818:	2900      	cmp	r1, #0
 800881a:	d1f3      	bne.n	8008804 <UART_WaitOnFlagUntilTimeout+0x84>
          huart->gState = HAL_UART_STATE_READY;
 800881c:	2320      	movs	r3, #32
 800881e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
          __HAL_UNLOCK(huart);
 8008822:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 8008826:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
          return HAL_TIMEOUT;
 800882a:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800882c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          return HAL_TIMEOUT;
 8008830:	e7bb      	b.n	80087aa <UART_WaitOnFlagUntilTimeout+0x2a>
 8008832:	683a      	ldr	r2, [r7, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008834:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8008838:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800883c:	e842 3100 	strex	r1, r3, [r2]
 8008840:	2900      	cmp	r1, #0
 8008842:	d1f7      	bne.n	8008834 <UART_WaitOnFlagUntilTimeout+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008844:	f102 0308 	add.w	r3, r2, #8
 8008848:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800884c:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008850:	f102 0008 	add.w	r0, r2, #8
 8008854:	e840 3100 	strex	r1, r3, [r0]
 8008858:	2900      	cmp	r1, #0
 800885a:	d1f3      	bne.n	8008844 <UART_WaitOnFlagUntilTimeout+0xc4>
        huart->gState = HAL_UART_STATE_READY;
 800885c:	2320      	movs	r3, #32
 800885e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        __HAL_UNLOCK(huart);
 8008862:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 8008866:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        return HAL_TIMEOUT;
 800886a:	2003      	movs	r0, #3
 800886c:	e79d      	b.n	80087aa <UART_WaitOnFlagUntilTimeout+0x2a>
 800886e:	bf00      	nop

08008870 <HAL_UART_Init>:
  if (huart == NULL)
 8008870:	2800      	cmp	r0, #0
 8008872:	d066      	beq.n	8008942 <HAL_UART_Init+0xd2>
{
 8008874:	b570      	push	{r4, r5, r6, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 8008876:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 800887a:	b082      	sub	sp, #8
 800887c:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 800887e:	2b00      	cmp	r3, #0
 8008880:	d04c      	beq.n	800891c <HAL_UART_Init+0xac>
  __HAL_UART_DISABLE(huart);
 8008882:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8008884:	2324      	movs	r3, #36	; 0x24
 8008886:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 800888a:	6813      	ldr	r3, [r2, #0]
 800888c:	f023 0301 	bic.w	r3, r3, #1
  if (UART_SetConfig(huart) == HAL_ERROR)
 8008890:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 8008892:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8008894:	f7ff fd92 	bl	80083bc <UART_SetConfig>
 8008898:	2801      	cmp	r0, #1
 800889a:	d03c      	beq.n	8008916 <HAL_UART_Init+0xa6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800889c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800889e:	2b00      	cmp	r3, #0
 80088a0:	d135      	bne.n	800890e <HAL_UART_Init+0x9e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80088a2:	6823      	ldr	r3, [r4, #0]
 80088a4:	6859      	ldr	r1, [r3, #4]
 80088a6:	f421 4190 	bic.w	r1, r1, #18432	; 0x4800
 80088aa:	6059      	str	r1, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80088ac:	6899      	ldr	r1, [r3, #8]
 80088ae:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 80088b2:	6099      	str	r1, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80088b4:	6819      	ldr	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80088b6:	2500      	movs	r5, #0
  __HAL_UART_ENABLE(huart);
 80088b8:	f041 0101 	orr.w	r1, r1, #1
 80088bc:	6019      	str	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80088be:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  tickstart = HAL_GetTick();
 80088c2:	f7fc fd9f 	bl	8005404 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80088c6:	6823      	ldr	r3, [r4, #0]
 80088c8:	681a      	ldr	r2, [r3, #0]
 80088ca:	0712      	lsls	r2, r2, #28
  tickstart = HAL_GetTick();
 80088cc:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80088ce:	d40e      	bmi.n	80088ee <HAL_UART_Init+0x7e>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80088d0:	681b      	ldr	r3, [r3, #0]
 80088d2:	075b      	lsls	r3, r3, #29
 80088d4:	d427      	bmi.n	8008926 <HAL_UART_Init+0xb6>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80088d6:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 80088d8:	2220      	movs	r2, #32
 80088da:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80088de:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 80088e2:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
  return HAL_OK;
 80088e6:	4618      	mov	r0, r3
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80088e8:	66e3      	str	r3, [r4, #108]	; 0x6c
}
 80088ea:	b002      	add	sp, #8
 80088ec:	bd70      	pop	{r4, r5, r6, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80088ee:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80088f2:	9300      	str	r3, [sp, #0]
 80088f4:	462a      	mov	r2, r5
 80088f6:	4603      	mov	r3, r0
 80088f8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80088fc:	4620      	mov	r0, r4
 80088fe:	f7ff ff3f 	bl	8008780 <UART_WaitOnFlagUntilTimeout>
 8008902:	b9e0      	cbnz	r0, 800893e <HAL_UART_Init+0xce>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8008904:	6823      	ldr	r3, [r4, #0]
 8008906:	681b      	ldr	r3, [r3, #0]
 8008908:	075b      	lsls	r3, r3, #29
 800890a:	d40c      	bmi.n	8008926 <HAL_UART_Init+0xb6>
 800890c:	e7e3      	b.n	80088d6 <HAL_UART_Init+0x66>
    UART_AdvFeatureConfig(huart);
 800890e:	4620      	mov	r0, r4
 8008910:	f7ff fede 	bl	80086d0 <UART_AdvFeatureConfig>
 8008914:	e7c5      	b.n	80088a2 <HAL_UART_Init+0x32>
    return HAL_ERROR;
 8008916:	2001      	movs	r0, #1
}
 8008918:	b002      	add	sp, #8
 800891a:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 800891c:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8008920:	f7fc fc14 	bl	800514c <HAL_UART_MspInit>
 8008924:	e7ad      	b.n	8008882 <HAL_UART_Init+0x12>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8008926:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800892a:	9300      	str	r3, [sp, #0]
 800892c:	2200      	movs	r2, #0
 800892e:	4633      	mov	r3, r6
 8008930:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8008934:	4620      	mov	r0, r4
 8008936:	f7ff ff23 	bl	8008780 <UART_WaitOnFlagUntilTimeout>
 800893a:	2800      	cmp	r0, #0
 800893c:	d0cb      	beq.n	80088d6 <HAL_UART_Init+0x66>
      return HAL_TIMEOUT;
 800893e:	2003      	movs	r0, #3
 8008940:	e7d3      	b.n	80088ea <HAL_UART_Init+0x7a>
    return HAL_ERROR;
 8008942:	2001      	movs	r0, #1
}
 8008944:	4770      	bx	lr
 8008946:	bf00      	nop

08008948 <HAL_UARTEx_DisableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8008948:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800894c:	2b01      	cmp	r3, #1
 800894e:	d017      	beq.n	8008980 <HAL_UARTEx_DisableFifoMode+0x38>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008950:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8008952:	2324      	movs	r3, #36	; 0x24
{
 8008954:	b410      	push	{r4}
  huart->gState = HAL_UART_STATE_BUSY;
 8008956:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800895a:	6811      	ldr	r1, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800895c:	6814      	ldr	r4, [r2, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800895e:	2300      	movs	r3, #0
  __HAL_UART_DISABLE(huart);
 8008960:	f024 0401 	bic.w	r4, r4, #1
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8008964:	f021 5100 	bic.w	r1, r1, #536870912	; 0x20000000
  __HAL_UART_DISABLE(huart);
 8008968:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800896a:	6643      	str	r3, [r0, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800896c:	6011      	str	r1, [r2, #0]

  huart->gState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800896e:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_READY;
 8008972:	2220      	movs	r2, #32
 8008974:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84

  return HAL_OK;
}
 8008978:	f85d 4b04 	ldr.w	r4, [sp], #4
  return HAL_OK;
 800897c:	4618      	mov	r0, r3
}
 800897e:	4770      	bx	lr
  __HAL_LOCK(huart);
 8008980:	2002      	movs	r0, #2
}
 8008982:	4770      	bx	lr

08008984 <HAL_UARTEx_SetTxFifoThreshold>:
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 8008984:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8008988:	2a01      	cmp	r2, #1
 800898a:	d037      	beq.n	80089fc <HAL_UARTEx_SetTxFifoThreshold+0x78>

  huart->gState = HAL_UART_STATE_BUSY;
 800898c:	4603      	mov	r3, r0

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800898e:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8008990:	2024      	movs	r0, #36	; 0x24
{
 8008992:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8008994:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008998:	6814      	ldr	r4, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800899a:	6810      	ldr	r0, [r2, #0]
 800899c:	f020 0001 	bic.w	r0, r0, #1
 80089a0:	6010      	str	r0, [r2, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80089a2:	6890      	ldr	r0, [r2, #8]
 80089a4:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
 80089a8:	4301      	orrs	r1, r0
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80089aa:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80089ac:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80089ae:	b310      	cbz	r0, 80089f6 <HAL_UARTEx_SetTxFifoThreshold+0x72>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80089b0:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80089b2:	6890      	ldr	r0, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
 80089b4:	4d12      	ldr	r5, [pc, #72]	; (8008a00 <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80089b6:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80089ba:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80089be:	4911      	ldr	r1, [pc, #68]	; (8008a04 <HAL_UARTEx_SetTxFifoThreshold+0x80>)
 80089c0:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80089c4:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 80089c8:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 80089cc:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80089d0:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80089d2:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80089d4:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80089d8:	fbb1 f1f5 	udiv	r1, r1, r5
 80089dc:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 80089e0:	2100      	movs	r1, #0
 80089e2:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 80089e6:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80089e8:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 80089ea:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
  return HAL_OK;
 80089ee:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 80089f0:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
}
 80089f4:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 80089f6:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 80089f8:	4608      	mov	r0, r1
 80089fa:	e7ef      	b.n	80089dc <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 80089fc:	2002      	movs	r0, #2
}
 80089fe:	4770      	bx	lr
 8008a00:	0801a1c8 	.word	0x0801a1c8
 8008a04:	0801a1d0 	.word	0x0801a1d0

08008a08 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 8008a08:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8008a0c:	2a01      	cmp	r2, #1
 8008a0e:	d037      	beq.n	8008a80 <HAL_UARTEx_SetRxFifoThreshold+0x78>
  huart->gState = HAL_UART_STATE_BUSY;
 8008a10:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008a12:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8008a14:	2024      	movs	r0, #36	; 0x24
{
 8008a16:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8008a18:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8008a1c:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8008a1e:	6810      	ldr	r0, [r2, #0]
 8008a20:	f020 0001 	bic.w	r0, r0, #1
 8008a24:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8008a26:	6890      	ldr	r0, [r2, #8]
 8008a28:	f020 6060 	bic.w	r0, r0, #234881024	; 0xe000000
 8008a2c:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8008a2e:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8008a30:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8008a32:	b310      	cbz	r0, 8008a7a <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8008a34:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8008a36:	6890      	ldr	r0, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 8008a38:	4d12      	ldr	r5, [pc, #72]	; (8008a84 <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a3a:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8008a3e:	ea4f 7e50 	mov.w	lr, r0, lsr #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a42:	4911      	ldr	r1, [pc, #68]	; (8008a88 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
 8008a44:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a48:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8008a4c:	f815 e00e 	ldrb.w	lr, [r5, lr]
                               (uint16_t)denominator[rx_fifo_threshold];
 8008a50:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a54:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a56:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8008a58:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8008a5c:	fbb1 f1f5 	udiv	r1, r1, r5
 8008a60:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 8008a64:	2100      	movs	r1, #0
 8008a66:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 8008a6a:	2520      	movs	r5, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8008a6c:	6014      	str	r4, [r2, #0]
  __HAL_UNLOCK(huart);
 8008a6e:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
  return HAL_OK;
 8008a72:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8008a74:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
}
 8008a78:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8008a7a:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8008a7c:	4608      	mov	r0, r1
 8008a7e:	e7ef      	b.n	8008a60 <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8008a80:	2002      	movs	r0, #2
}
 8008a82:	4770      	bx	lr
 8008a84:	0801a1c8 	.word	0x0801a1c8
 8008a88:	0801a1d0 	.word	0x0801a1d0

08008a8c <VBS_GetAvBusVoltage_d>:
  }
  return (temp_avBusVoltage_d);
#else
  return (pHandle->AvBusVoltage_d);
#endif
}
 8008a8c:	88c0      	ldrh	r0, [r0, #6]
 8008a8e:	4770      	bx	lr

08008a90 <VBS_GetAvBusVoltage_V>:
    temp = 0U;
  }
  else
  {
#endif
    temp = (uint32_t)(pHandle->AvBusVoltage_d);
 8008a90:	88c3      	ldrh	r3, [r0, #6]
    temp *= pHandle->ConversionFactor;
 8008a92:	8840      	ldrh	r0, [r0, #2]
 8008a94:	fb03 f000 	mul.w	r0, r3, r0
    temp /= 65536U;
#ifdef NULL_PTR_CHECK_BUS_VOLT
  }
#endif
  return ((uint16_t)temp);
}
 8008a98:	0c00      	lsrs	r0, r0, #16
 8008a9a:	4770      	bx	lr

08008a9c <Circle_Limitation>:
  *  @f$v_q = \sqrt(MaxModule^2-v_d^2\ ) @f$

  *
  */
__weak qd_t Circle_Limitation(const CircleLimitation_Handle_t *pHandle, qd_t Vqd)
{
 8008a9c:	b570      	push	{r4, r5, r6, lr}
    int32_t square_limit;
    int32_t vd_square_limit;
    int32_t new_q;
    int32_t new_d;

    maxModule = (int32_t)pHandle->MaxModule;
 8008a9e:	8803      	ldrh	r3, [r0, #0]
 8008aa0:	140d      	asrs	r5, r1, #16
{
 8008aa2:	b084      	sub	sp, #16
 8008aa4:	b20c      	sxth	r4, r1

    square_q = ((int32_t)(Vqd.q)) * Vqd.q;
    square_d = ((int32_t)(Vqd.d)) * Vqd.d;
 8008aa6:	fb05 f205 	mul.w	r2, r5, r5
    square_limit = maxModule * maxModule;
 8008aaa:	fb03 f303 	mul.w	r3, r3, r3
{
 8008aae:	9101      	str	r1, [sp, #4]
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
    square_sum = square_q + square_d;
 8008ab0:	fb04 2104 	mla	r1, r4, r4, r2

    if (square_sum > square_limit)
 8008ab4:	428b      	cmp	r3, r1
 8008ab6:	da10      	bge.n	8008ada <Circle_Limitation+0x3e>
    vd_square_limit = ((int32_t)pHandle->MaxVd) * ((int32_t)pHandle->MaxVd);
 8008ab8:	8846      	ldrh	r6, [r0, #2]
 8008aba:	fb06 f006 	mul.w	r0, r6, r6
    {
      if (square_d <= vd_square_limit)
 8008abe:	4282      	cmp	r2, r0
 8008ac0:	dd14      	ble.n	8008aec <Circle_Limitation+0x50>
        new_d = Vqd.d;
      }
      else
      {
        new_d = (int32_t)pHandle->MaxVd;
        if (Vqd.d < 0)
 8008ac2:	2d00      	cmp	r5, #0
#if defined CIRCLE_LIMITATION_SQRT_M0
        square_temp = (square_limit - vd_square_limit) / 1048576;
        new_q = SqrtTable[square_temp];
#else
        square_temp = square_limit - vd_square_limit;
        new_q = MCM_Sqrt(square_temp);
 8008ac4:	eba3 0000 	sub.w	r0, r3, r0
          new_d = -new_d;
 8008ac8:	bfb8      	it	lt
 8008aca:	4276      	neglt	r6, r6
        new_q = MCM_Sqrt(square_temp);
 8008acc:	f7f9 fade 	bl	800208c <MCM_Sqrt>
#endif
        if (Vqd.q < 0)
 8008ad0:	2c00      	cmp	r4, #0
        {
          new_q = - new_q;
 8008ad2:	bfb8      	it	lt
 8008ad4:	4240      	neglt	r0, r0
        {
          /* Nothing to do */
        }
      }
      local_vqd.q = (int16_t)new_q;
      local_vqd.d = (int16_t)new_d;
 8008ad6:	b235      	sxth	r5, r6
      local_vqd.q = (int16_t)new_q;
 8008ad8:	b204      	sxth	r4, r0
    }
#ifdef NULL_PTR_CHECK_CRC_LIM
  }
#endif
  return (local_vqd);
 8008ada:	b2a4      	uxth	r4, r4
 8008adc:	2000      	movs	r0, #0
 8008ade:	f364 000f 	bfi	r0, r4, #0, #16
 8008ae2:	b2ad      	uxth	r5, r5
 8008ae4:	f365 401f 	bfi	r0, r5, #16, #16
}
 8008ae8:	b004      	add	sp, #16
 8008aea:	bd70      	pop	{r4, r5, r6, pc}
        new_q = MCM_Sqrt(square_temp);
 8008aec:	1a98      	subs	r0, r3, r2
 8008aee:	f7f9 facd 	bl	800208c <MCM_Sqrt>
        if (Vqd.q < 0)
 8008af2:	2c00      	cmp	r4, #0
 8008af4:	daf0      	bge.n	8008ad8 <Circle_Limitation+0x3c>
          new_q = -new_q;
 8008af6:	4240      	negs	r0, r0
 8008af8:	e7ee      	b.n	8008ad8 <Circle_Limitation+0x3c>
 8008afa:	bf00      	nop

08008afc <EAC_Init>:
  {
#endif
    pHandle->pSTC = pSTC;
    pHandle->pVSS = pVSS;
    pHandle->pENC = pENC;
    pHandle->EncAligned = false;
 8008afc:	f04f 0c00 	mov.w	ip, #0
    pHandle->pVSS = pVSS;
 8008b00:	e9c0 1200 	strd	r1, r2, [r0]
    pHandle->pENC = pENC;
 8008b04:	6083      	str	r3, [r0, #8]
    pHandle->EncAligned = false;
 8008b06:	f8a0 c00e 	strh.w	ip, [r0, #14]
    pHandle->EncRestart = false;
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008b0a:	4770      	bx	lr

08008b0c <EAC_StartAlignment>:
  * It configures the VSS (Virtual Speed Sensor) with the required angle and sets the
  * STC (Speed and Torque Controller) to execute the required torque ramp.
  * @param  pHandle: handler of the current instance of the EncAlignCtrl component.
  */
__weak void EAC_StartAlignment(EncAlign_Handle_t *pHandle)
{
 8008b0c:	b510      	push	{r4, lr}
  {
#endif
    uint32_t wAux;

    /* Set pVSS mechanical speed to zero */
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 8008b0e:	2200      	movs	r2, #0
{
 8008b10:	4604      	mov	r4, r0
    VSS_SetMecAcceleration(pHandle->pVSS, 0, 0U);
 8008b12:	4611      	mov	r1, r2
 8008b14:	6840      	ldr	r0, [r0, #4]
 8008b16:	f001 ff65 	bl	800a9e4 <VSS_SetMecAcceleration>

    /* Set pVSS mechanical angle */
    VSS_SetMecAngle(pHandle->pVSS, pHandle->hElAngle);
 8008b1a:	f9b4 1014 	ldrsh.w	r1, [r4, #20]
 8008b1e:	6860      	ldr	r0, [r4, #4]
 8008b20:	f001 ff58 	bl	800a9d4 <VSS_SetMecAngle>

    /* Set pSTC in MCM_TORQUE_MODE */
    STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 8008b24:	6820      	ldr	r0, [r4, #0]
 8008b26:	2104      	movs	r1, #4
 8008b28:	f001 fc52 	bl	800a3d0 <STC_SetControlMode>

    /* Set starting torque to Zero */
    (void)STC_ExecRamp(pHandle->pSTC, 0, 0U);
 8008b2c:	2200      	movs	r2, #0
 8008b2e:	4611      	mov	r1, r2
 8008b30:	6820      	ldr	r0, [r4, #0]
 8008b32:	f001 fc51 	bl	800a3d8 <STC_ExecRamp>

    /* Execute the torque ramp */
    (void)STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, (uint32_t)pHandle->hDurationms);
 8008b36:	8ae2      	ldrh	r2, [r4, #22]
 8008b38:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8008b3c:	6820      	ldr	r0, [r4, #0]
 8008b3e:	f001 fc4b 	bl	800a3d8 <STC_ExecRamp>
    /* Compute hRemainingTicks, the number of thick of alignment phase */
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 8008b42:	8ae3      	ldrh	r3, [r4, #22]
 8008b44:	8a21      	ldrh	r1, [r4, #16]
    wAux /= 1000U;
 8008b46:	4a04      	ldr	r2, [pc, #16]	; (8008b58 <EAC_StartAlignment+0x4c>)
    wAux = ((uint32_t)pHandle->hDurationms) * ((uint32_t)pHandle->hEACFrequencyHz);
 8008b48:	fb01 f303 	mul.w	r3, r1, r3
    wAux /= 1000U;
 8008b4c:	fba2 2303 	umull	r2, r3, r2, r3
 8008b50:	099b      	lsrs	r3, r3, #6
    pHandle->hRemainingTicks = (uint16_t)wAux;
    pHandle->hRemainingTicks++;
 8008b52:	3301      	adds	r3, #1
 8008b54:	81a3      	strh	r3, [r4, #12]
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008b56:	bd10      	pop	{r4, pc}
 8008b58:	10624dd3 	.word	0x10624dd3

08008b5c <EAC_Exec>:
    retVal = false;
  }
  else
  {
#endif
    if (pHandle->hRemainingTicks > 0U)
 8008b5c:	8983      	ldrh	r3, [r0, #12]
 8008b5e:	b13b      	cbz	r3, 8008b70 <EAC_Exec+0x14>
    {
      pHandle->hRemainingTicks--;
 8008b60:	3b01      	subs	r3, #1
 8008b62:	b29b      	uxth	r3, r3
{
 8008b64:	b510      	push	{r4, lr}
 8008b66:	4604      	mov	r4, r0
      pHandle->hRemainingTicks--;
 8008b68:	8183      	strh	r3, [r0, #12]

      if (0U == pHandle->hRemainingTicks)
 8008b6a:	b11b      	cbz	r3, 8008b74 <EAC_Exec+0x18>
        pHandle->EncAligned = true;
        retVal = true;
      }
      else
      {
        retVal = false;
 8008b6c:	2000      	movs	r0, #0
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif

  return (retVal);
}
 8008b6e:	bd10      	pop	{r4, pc}
  bool retVal = true;
 8008b70:	2001      	movs	r0, #1
}
 8008b72:	4770      	bx	lr
        ENC_SetMecAngle(pHandle->pENC, pHandle->hElAngle / ((int16_t)pHandle->bElToMecRatio));
 8008b74:	7e03      	ldrb	r3, [r0, #24]
 8008b76:	f9b0 1014 	ldrsh.w	r1, [r0, #20]
 8008b7a:	6880      	ldr	r0, [r0, #8]
 8008b7c:	fb91 f1f3 	sdiv	r1, r1, r3
 8008b80:	f000 f942 	bl	8008e08 <ENC_SetMecAngle>
        pHandle->EncAligned = true;
 8008b84:	2001      	movs	r0, #1
 8008b86:	73a0      	strb	r0, [r4, #14]
}
 8008b88:	bd10      	pop	{r4, pc}
 8008b8a:	bf00      	nop

08008b8c <EAC_IsAligned>:
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  return ((NULL == pHandle) ? false : pHandle->EncAligned);
#else
  return (pHandle->EncAligned);
#endif
}
 8008b8c:	7b80      	ldrb	r0, [r0, #14]
 8008b8e:	4770      	bx	lr

08008b90 <EAC_SetRestartState>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->EncRestart = restart;
 8008b90:	73c1      	strb	r1, [r0, #15]
#ifdef NULL_PTR_CHECK_ENC_ALI_CTRL
  }
#endif
}
 8008b92:	4770      	bx	lr

08008b94 <ENC_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008b94:	6a03      	ldr	r3, [r0, #32]
#endif
    /* Reset counter */
    LL_TIM_SetCounter(TIMx, 0);

    /*Calculations of convenience*/
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008b96:	f8b0 c06e 	ldrh.w	ip, [r0, #110]	; 0x6e
  SET_BIT(TIMx->CR1, TIM_CR1_UIFREMAP);
 8008b9a:	681a      	ldr	r2, [r3, #0]
 8008b9c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
{
 8008ba0:	b410      	push	{r4}
 8008ba2:	601a      	str	r2, [r3, #0]
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 8008ba4:	f8b0 206c 	ldrh.w	r2, [r0, #108]	; 0x6c
 8008ba8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8008bac:	0052      	lsls	r2, r2, #1
  WRITE_REG(TIMx->CNT, Counter);
 8008bae:	2100      	movs	r1, #0
 8008bb0:	6259      	str	r1, [r3, #36]	; 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008bb2:	f04f 34ff 	mov.w	r4, #4294967295
    pHandle->SpeedSamplingFreqUnit = ((uint32_t)pHandle->SpeedSamplingFreqHz * (uint32_t)SPEED_UNIT);
 8008bb6:	6242      	str	r2, [r0, #36]	; 0x24
    pHandle->U32MAXdivPulseNumber = UINT32_MAX / ((uint32_t) pHandle->PulseNumber);
 8008bb8:	fbb4 f4fc 	udiv	r4, r4, ip
 8008bbc:	6684      	str	r4, [r0, #104]	; 0x68
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008bbe:	699c      	ldr	r4, [r3, #24]
 8008bc0:	f8b0 207a 	ldrh.w	r2, [r0, #122]	; 0x7a
 8008bc4:	f024 0cf0 	bic.w	ip, r4, #240	; 0xf0
 8008bc8:	ea42 020c 	orr.w	r2, r2, ip
 8008bcc:	619a      	str	r2, [r3, #24]
 8008bce:	699a      	ldr	r2, [r3, #24]
 8008bd0:	f8b0 407a 	ldrh.w	r4, [r0, #122]	; 0x7a
 8008bd4:	f422 4270 	bic.w	r2, r2, #61440	; 0xf000
 8008bd8:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008bdc:	f06f 0401 	mvn.w	r4, #1
  MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
 8008be0:	619a      	str	r2, [r3, #24]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008be2:	611c      	str	r4, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008be4:	68da      	ldr	r2, [r3, #12]
 8008be6:	f042 0201 	orr.w	r2, r2, #1
 8008bea:	60da      	str	r2, [r3, #12]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8008bec:	681a      	ldr	r2, [r3, #0]
 8008bee:	f042 0201 	orr.w	r2, r2, #1
 8008bf2:	601a      	str	r2, [r3, #0]

    /* Enable the counting timer */
    LL_TIM_EnableCounter(TIMx);

    /* Erase speed buffer */
    bufferSize = pHandle->SpeedBufferSize;
 8008bf4:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74

    for (index = 0U; index < bufferSize; index++)
 8008bf8:	b12a      	cbz	r2, 8008c06 <ENC_Init+0x72>
      pHandle->DeltaCapturesBuffer[index] = 0;
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008bfa:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->DeltaCapturesBuffer[index] = 0;
 8008bfe:	0092      	lsls	r2, r2, #2
 8008c00:	3028      	adds	r0, #40	; 0x28
 8008c02:	f004 bd5f 	b.w	800d6c4 <memset>
}
 8008c06:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008c0a:	4770      	bx	lr

08008c0c <ENC_Clear>:
  *         This function must be called before starting the motor to initialize
  *         the speed measurement process.
  * @param  pHandle: handler of the current instance of the encoder component
  */
__weak void ENC_Clear(ENCODER_Handle_t *pHandle)
{
 8008c0c:	b510      	push	{r4, lr}
  else
  {
#endif
    uint8_t index;

    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 8008c0e:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
{
 8008c12:	4604      	mov	r4, r0
    for (index = 0u; index < pHandle->SpeedBufferSize; index++)
 8008c14:	b122      	cbz	r2, 8008c20 <ENC_Clear+0x14>
    {
      pHandle->DeltaCapturesBuffer[index] = 0;
 8008c16:	0092      	lsls	r2, r2, #2
 8008c18:	2100      	movs	r1, #0
 8008c1a:	3028      	adds	r0, #40	; 0x28
 8008c1c:	f004 fd52 	bl	800d6c4 <memset>
    }
    pHandle->SensorIsReliable = true;
 8008c20:	2301      	movs	r3, #1
 8008c22:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008c26:	bd10      	pop	{r4, pc}

08008c28 <ENC_CalcAngle>:
  *         of the instantaneous value of the timer counter.
  * @param  pHandle: handler of the current instance of the encoder component
  * @retval Measured electrical angle in [s16degree](measurement_units.md) format.
  */
__weak int16_t ENC_CalcAngle(ENCODER_Handle_t *pHandle)
{
 8008c28:	b410      	push	{r4}
    int16_t mecAngle; /* s16degree format */
    uint32_t uwtemp1;
    int32_t wtemp1;
    /* PR 52926 We need to keep only the 16 LSB, bit 31 could be at 1
     if the overflow occurs just after the entry in the High frequency task */
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 8008c2a:	6a03      	ldr	r3, [r0, #32]
 8008c2c:	6e84      	ldr	r4, [r0, #104]	; 0x68
  return (uint32_t)(READ_REG(TIMx->CNT));
 8008c2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    wtemp1 = (int32_t)uwtemp1 / 65536;
#endif
    /* Computes and stores the rotor mechanical angle */
    mecAngle = (int16_t)wtemp1;

    int16_t hMecAnglePrev = pHandle->_Super.hMecAngle;
 8008c30:	f9b0 1006 	ldrsh.w	r1, [r0, #6]

    pHandle->_Super.hMecAngle = mecAngle;

    /* Computes and stores the rotor electrical angle */
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c34:	7842      	ldrb	r2, [r0, #1]
    uwtemp1 = (LL_TIM_GetCounter(pHandle->TIMx) & 0xffffU) * (pHandle->U32MAXdivPulseNumber);
 8008c36:	b29b      	uxth	r3, r3
 8008c38:	fb04 f303 	mul.w	r3, r4, r3
    wtemp1 = (int32_t)uwtemp1 >> 16U;  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 8008c3c:	141b      	asrs	r3, r3, #16
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c3e:	fb03 f202 	mul.w	r2, r3, r2

    pHandle->_Super.hElAngle = elAngle;

    int16_t hMecSpeedDpp = mecAngle - hMecAnglePrev;
 8008c42:	1a59      	subs	r1, r3, r1
    mecAngle = (int16_t)wtemp1;
 8008c44:	80c3      	strh	r3, [r0, #6]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c46:	6883      	ldr	r3, [r0, #8]
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  /*Returns rotor electrical angle*/
  return (elAngle);
}
 8008c48:	f85d 4b04 	ldr.w	r4, [sp], #4
    elAngle = mecAngle * (int16_t)(pHandle->_Super.bElToMecRatio);
 8008c4c:	b212      	sxth	r2, r2
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c4e:	fa03 f381 	sxtah	r3, r3, r1
    pHandle->_Super.hElAngle = elAngle;
 8008c52:	8082      	strh	r2, [r0, #4]
    pHandle->_Super.wMecAngle += ((int32_t)hMecSpeedDpp);
 8008c54:	6083      	str	r3, [r0, #8]
}
 8008c56:	4610      	mov	r0, r2
 8008c58:	4770      	bx	lr
 8008c5a:	bf00      	nop

08008c5c <ENC_CalcAvrgMecSpeedUnit>:
  * @param  pMecSpeedUnit pointer used to return the rotor average mechanical speed
  *         expressed in the unit defined by #SPEED_UNIT
  * @retval true = sensor information is reliable. false = sensor information is not reliable
  */
__weak bool ENC_CalcAvrgMecSpeedUnit(ENCODER_Handle_t *pHandle, int16_t *pMecSpeedUnit)
{
 8008c5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    int32_t wtemp2;
    uint32_t OverflowCntSample;
    uint32_t CntCapture;
    uint32_t directionSample;
    int32_t wOverallAngleVariation = 0;
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008c5e:	6a03      	ldr	r3, [r0, #32]
    uint8_t bBufferSize = pHandle->SpeedBufferSize;
 8008c60:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008c64:	68dc      	ldr	r4, [r3, #12]
 8008c66:	f024 0401 	bic.w	r4, r4, #1
 8008c6a:	60dc      	str	r4, [r3, #12]
  return (uint32_t)(READ_REG(TIMx->CNT));
 8008c6c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
#ifdef TIM_CNT_UIFCPY
    /* disable Interrupt generation */
    LL_TIM_DisableIT_UPDATE(TIMx);
#endif
    CntCapture = LL_TIM_GetCounter(TIMx);
    OverflowCntSample = pHandle->TimerOverflowNb;
 8008c6e:	f8b0 c070 	ldrh.w	ip, [r0, #112]	; 0x70
    pHandle->TimerOverflowNb = 0;
 8008c72:	2500      	movs	r5, #0
 8008c74:	f8a0 5070 	strh.w	r5, [r0, #112]	; 0x70
    directionSample = LL_TIM_GetDirection(TIMx);
#ifdef TIM_CNT_UIFCPY
    OFbit = __LL_TIM_GETFLAG_UIFCPY(CntCapture);
    if (0U == OFbit)
 8008c78:	0fe5      	lsrs	r5, r4, #31
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008c7a:	bf18      	it	ne
 8008c7c:	f06f 0701 	mvnne.w	r7, #1
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 8008c80:	681e      	ldr	r6, [r3, #0]
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8008c82:	bf18      	it	ne
 8008c84:	611f      	strne	r7, [r3, #16]
    OverflowCntSample = pHandle->TimerOverflowNb;
 8008c86:	fa1f fc8c 	uxth.w	ip, ip

    /* If UIFCPY is not present, OverflowCntSample can not be used safely for
    speed computation, but we still use it to check that we do not exceed one overflow
    (sample frequency not less than mechanical motor speed */

    if ((OverflowCntSample + OFbit) > ENC_MAX_OVERFLOW_NB)
 8008c8a:	4465      	add	r5, ip
    CLEAR_BIT(CntCapture, TIM_CNT_UIFCPY);
 8008c8c:	f024 4c00 	bic.w	ip, r4, #2147483648	; 0x80000000
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8008c90:	68dc      	ldr	r4, [r3, #12]
    if ((OverflowCntSample + OFbit) > ENC_MAX_OVERFLOW_NB)
 8008c92:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8008c96:	f044 0401 	orr.w	r4, r4, #1
 8008c9a:	60dc      	str	r4, [r3, #12]
  return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
 8008c9c:	f006 0610 	and.w	r6, r6, #16
    {
      pHandle->TimerOverflowError = true;
 8008ca0:	bf8a      	itet	hi
 8008ca2:	2401      	movhi	r4, #1
    {
      /* Nothing to do */
    }

    /* Checks the reliability status, then stores and returns it */
    if (pHandle->TimerOverflowError)
 8008ca4:	f890 407d 	ldrbls.w	r4, [r0, #125]	; 0x7d
      pHandle->TimerOverflowError = true;
 8008ca8:	f880 407d 	strbhi.w	r4, [r0, #125]	; 0x7d
    if (LL_TIM_COUNTERDIRECTION_DOWN == directionSample)
 8008cac:	2e00      	cmp	r6, #0
 8008cae:	f000 8093 	beq.w	8008dd8 <ENC_CalcAvrgMecSpeedUnit+0x17c>
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008cb2:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008cb6:	f8b0 3072 	ldrh.w	r3, [r0, #114]	; 0x72
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008cba:	f8b0 e06e 	ldrh.w	lr, [r0, #110]	; 0x6e
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008cbe:	360a      	adds	r6, #10
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008cc0:	ebac 0303 	sub.w	r3, ip, r3
        - ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008cc4:	fb0e 3315 	mls	r3, lr, r5, r3
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008cc8:	f840 3026 	str.w	r3, [r0, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008ccc:	2a00      	cmp	r2, #0
 8008cce:	f000 8093 	beq.w	8008df8 <ENC_CalcAvrgMecSpeedUnit+0x19c>
 8008cd2:	2a01      	cmp	r2, #1
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cd4:	6a83      	ldr	r3, [r0, #40]	; 0x28
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cd6:	d039      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cd8:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cda:	2a02      	cmp	r2, #2
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cdc:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cde:	d035      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008ce0:	6b05      	ldr	r5, [r0, #48]	; 0x30
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008ce2:	2a03      	cmp	r2, #3
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008ce4:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008ce6:	d031      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008ce8:	6b45      	ldr	r5, [r0, #52]	; 0x34
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cea:	2a04      	cmp	r2, #4
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cec:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cee:	d02d      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cf0:	6b85      	ldr	r5, [r0, #56]	; 0x38
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cf2:	2a05      	cmp	r2, #5
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cf4:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cf6:	d029      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cf8:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cfa:	2a06      	cmp	r2, #6
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008cfc:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008cfe:	d025      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d00:	6c05      	ldr	r5, [r0, #64]	; 0x40
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d02:	2a07      	cmp	r2, #7
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d04:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d06:	d021      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d08:	6c45      	ldr	r5, [r0, #68]	; 0x44
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d0a:	2a08      	cmp	r2, #8
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d0c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d0e:	d01d      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d10:	6c85      	ldr	r5, [r0, #72]	; 0x48
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d12:	2a09      	cmp	r2, #9
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d14:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d16:	d019      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d18:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d1a:	2a0a      	cmp	r2, #10
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d1c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d1e:	d015      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d20:	6d05      	ldr	r5, [r0, #80]	; 0x50
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d22:	2a0b      	cmp	r2, #11
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d24:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d26:	d011      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d28:	6d45      	ldr	r5, [r0, #84]	; 0x54
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d2a:	2a0c      	cmp	r2, #12
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d2c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d2e:	d00d      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d30:	6d85      	ldr	r5, [r0, #88]	; 0x58
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d32:	2a0d      	cmp	r2, #13
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d34:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d36:	d009      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d38:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d3a:	2a0e      	cmp	r2, #14
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d3c:	442b      	add	r3, r5
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d3e:	d005      	beq.n	8008d4c <ENC_CalcAvrgMecSpeedUnit+0xf0>
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d40:	6e05      	ldr	r5, [r0, #96]	; 0x60
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008d42:	2a0f      	cmp	r2, #15
      wOverallAngleVariation += pHandle->DeltaCapturesBuffer[bBufferIndex];
 8008d44:	442b      	add	r3, r5
 8008d46:	bf1c      	itt	ne
 8008d48:	6e45      	ldrne	r5, [r0, #100]	; 0x64
 8008d4a:	195b      	addne	r3, r3, r5
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 8008d4c:	6a46      	ldr	r6, [r0, #36]	; 0x24
    wtemp2 = ((int32_t)pHandle->PulseNumber) * ((int32_t)pHandle->SpeedBufferSize);
 8008d4e:	fb0e f502 	mul.w	r5, lr, r2
    wtemp1 = wOverallAngleVariation * ((int32_t)pHandle->SpeedSamplingFreqUnit);
 8008d52:	fb06 f303 	mul.w	r3, r6, r3
    wtemp1 = ((0 == wtemp2) ? wtemp1 : (wtemp1 / wtemp2));
 8008d56:	b10d      	cbz	r5, 8008d5c <ENC_CalcAvrgMecSpeedUnit+0x100>
 8008d58:	fb93 f3f5 	sdiv	r3, r3, r5
    *pMecSpeedUnit = (int16_t)wtemp1;
 8008d5c:	b21e      	sxth	r6, r3
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008d5e:	b29b      	uxth	r3, r3
    *pMecSpeedUnit = (int16_t)wtemp1;
 8008d60:	800e      	strh	r6, [r1, #0]
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d62:	f890 507c 	ldrb.w	r5, [r0, #124]	; 0x7c
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008d66:	8987      	ldrh	r7, [r0, #12]
    pHandle->DeltaCapturesIndex++;
 8008d68:	f890 e07c 	ldrb.w	lr, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d6c:	350a      	adds	r5, #10
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008d6e:	1bdb      	subs	r3, r3, r7
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d70:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
    pHandle->_Super.hMecAccelUnitP = (int16_t)(wtemp1 - pHandle->_Super.hAvrMecSpeedUnit);
 8008d74:	8243      	strh	r3, [r0, #18]
    pHandle->DeltaCapturesIndex++;
 8008d76:	f10e 0e01 	add.w	lr, lr, #1
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d7a:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wtemp1;
 8008d7e:	8186      	strh	r6, [r0, #12]
    pHandle->DeltaCapturesIndex++;
 8008d80:	fa5f fe8e 	uxtb.w	lr, lr
 8008d84:	f880 e07c 	strb.w	lr, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d88:	fb05 f303 	mul.w	r3, r5, r3
             * ((int32_t)pHandle->_Super.bElToMecRatio);
 8008d8c:	7845      	ldrb	r5, [r0, #1]
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 8008d8e:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
    wtemp1 = pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] * ((int32_t)pHandle->SpeedSamplingFreqHz)
 8008d92:	fb05 f303 	mul.w	r3, r5, r3
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008d96:	f64f 77fe 	movw	r7, #65534	; 0xfffe
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008d9a:	69c5      	ldr	r5, [r0, #28]
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008d9c:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8008da0:	45bc      	cmp	ip, r7
 8008da2:	bf88      	it	hi
 8008da4:	46f4      	movhi	ip, lr
    if (pHandle->DeltaCapturesIndex >= pHandle->SpeedBufferSize)
 8008da6:	4296      	cmp	r6, r2
    pHandle->PreviousCapture = (CntCapture >= (uint32_t)65535) ? 65535U : (uint16_t)CntCapture;
 8008da8:	f8a0 c072 	strh.w	ip, [r0, #114]	; 0x72
    wtemp1 /= ((int32_t)pHandle->PulseNumber);
 8008dac:	f8b0 c06e 	ldrh.w	ip, [r0, #110]	; 0x6e
 8008db0:	fb93 f3fc 	sdiv	r3, r3, ip
    wtemp1 *= ((int32_t)pHandle->_Super.DPPConvFactor);
 8008db4:	fb05 f303 	mul.w	r3, r5, r3
    wtemp1 /= ((int32_t)pHandle->_Super.hMeasurementFrequency);
 8008db8:	8b45      	ldrh	r5, [r0, #26]
 8008dba:	fb93 f3f5 	sdiv	r3, r3, r5
    pHandle->_Super.hElSpeedDpp = (int16_t)wtemp1;
 8008dbe:	81c3      	strh	r3, [r0, #14]
      pHandle->DeltaCapturesIndex = 0U;
 8008dc0:	bf24      	itt	cs
 8008dc2:	2300      	movcs	r3, #0
 8008dc4:	f880 307c 	strbcs.w	r3, [r0, #124]	; 0x7c
    if (pHandle->TimerOverflowError)
 8008dc8:	b1cc      	cbz	r4, 8008dfe <ENC_CalcAvrgMecSpeedUnit+0x1a2>
    {
      bReliability = false;
      pHandle->SensorIsReliable = false;
      pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 8008dca:	78c2      	ldrb	r2, [r0, #3]
 8008dcc:	7002      	strb	r2, [r0, #0]
      pHandle->SensorIsReliable = false;
 8008dce:	2300      	movs	r3, #0
 8008dd0:	f880 3075 	strb.w	r3, [r0, #117]	; 0x75
    }
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
  return (bReliability);
}
 8008dd4:	4618      	mov	r0, r3
 8008dd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008dd8:	f890 607c 	ldrb.w	r6, [r0, #124]	; 0x7c
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008ddc:	f8b0 3072 	ldrh.w	r3, [r0, #114]	; 0x72
        + ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008de0:	f8b0 e06e 	ldrh.w	lr, [r0, #110]	; 0x6e
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008de4:	360a      	adds	r6, #10
        ((int32_t)CntCapture) - ((int32_t)pHandle->PreviousCapture)
 8008de6:	ebac 0303 	sub.w	r3, ip, r3
        + ((((int32_t)OverflowCntSample) + (int32_t)OFbit) * ((int32_t)pHandle->PulseNumber));
 8008dea:	fb0e 3305 	mla	r3, lr, r5, r3
      pHandle->DeltaCapturesBuffer[pHandle->DeltaCapturesIndex] =
 8008dee:	f840 3026 	str.w	r3, [r0, r6, lsl #2]
    for (bBufferIndex = 0U; bBufferIndex < bBufferSize; bBufferIndex++)
 8008df2:	2a00      	cmp	r2, #0
 8008df4:	f47f af6d 	bne.w	8008cd2 <ENC_CalcAvrgMecSpeedUnit+0x76>
 8008df8:	4613      	mov	r3, r2
 8008dfa:	4616      	mov	r6, r2
 8008dfc:	e7b0      	b.n	8008d60 <ENC_CalcAvrgMecSpeedUnit+0x104>
}
 8008dfe:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      bReliability = SPD_IsMecSpeedReliable(&pHandle->_Super, pMecSpeedUnit);
 8008e02:	f001 ba83 	b.w	800a30c <SPD_IsMecSpeedReliable>
 8008e06:	bf00      	nop

08008e08 <ENC_SetMecAngle>:
    uint16_t hAngleCounts;
    uint16_t hMecAngleuint;
    int16_t localhMecAngle = hMecAngle;

    pHandle->_Super.hMecAngle = localhMecAngle;
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e08:	7843      	ldrb	r3, [r0, #1]
    pHandle->_Super.hMecAngle = localhMecAngle;
 8008e0a:	80c1      	strh	r1, [r0, #6]
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e0c:	b28a      	uxth	r2, r1
 8008e0e:	fb01 f303 	mul.w	r3, r1, r3
    if (localhMecAngle < 0)
 8008e12:	2900      	cmp	r1, #0
    pHandle->_Super.hElAngle = localhMecAngle * (int16_t)pHandle->_Super.bElToMecRatio;
 8008e14:	8083      	strh	r3, [r0, #4]
 8008e16:	bfb8      	it	lt
 8008e18:	f102 32ff 	addlt.w	r2, r2, #4294967295
    else
    {
      hMecAngleuint = (uint16_t)localhMecAngle;
    }

    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e1c:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
 8008e20:	4906      	ldr	r1, [pc, #24]	; (8008e3c <ENC_SetMecAngle+0x34>)
 8008e22:	bfb8      	it	lt
 8008e24:	b292      	uxthlt	r2, r2
 8008e26:	fb02 f303 	mul.w	r3, r2, r3
{
 8008e2a:	b410      	push	{r4}
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e2c:	fba1 1303 	umull	r1, r3, r1, r3
    TIM_TypeDef *TIMx = pHandle->TIMx;
 8008e30:	6a04      	ldr	r4, [r0, #32]
    hAngleCounts = (uint16_t)((((uint32_t)hMecAngleuint) * ((uint32_t)pHandle->PulseNumber)) / 65535U);
 8008e32:	0bdb      	lsrs	r3, r3, #15

    TIMx->CNT = (uint16_t)hAngleCounts;
 8008e34:	6263      	str	r3, [r4, #36]	; 0x24
#ifdef NULL_PTR_CHECK_ENC_SPD_POS_FDB
  }
#endif
}
 8008e36:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008e3a:	4770      	bx	lr
 8008e3c:	80008001 	.word	0x80008001

08008e40 <ENC_IRQHandler>:
/**
  * @brief  TIMER ENCODER Overflow interrupt counter update
  * @param  pHandleVoid: handler of the current instance of the encoder component
  */
__weak void *ENC_IRQHandler(void *pHandleVoid)
{
 8008e40:	4602      	mov	r2, r0
  /* Updates the number of overflows occurred */
  /* The handling of overflow error is done in ENC_CalcAvrgMecSpeedUnit */
  pHandle->TimerOverflowNb += 1U;

  return (MC_NULL);
}
 8008e42:	2000      	movs	r0, #0
  pHandle->TimerOverflowNb += 1U;
 8008e44:	f8b2 3070 	ldrh.w	r3, [r2, #112]	; 0x70
 8008e48:	3301      	adds	r3, #1
 8008e4a:	b29b      	uxth	r3, r3
 8008e4c:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
}
 8008e50:	4770      	bx	lr
 8008e52:	bf00      	nop

08008e54 <MCPA_dataLog>:
  * @brief  Allocates and fills buffer with asynchronous data to be sent to controller
  *
  * @param  *pHandle Pointer to the MCPA Handle
  */
void MCPA_dataLog(MCPA_Handle_t *pHandle)
{
 8008e54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8008e56:	7fc3      	ldrb	r3, [r0, #31]
 8008e58:	f890 2022 	ldrb.w	r2, [r0, #34]	; 0x22
 8008e5c:	429a      	cmp	r2, r3
{
 8008e5e:	4604      	mov	r4, r0
    if (pHandle->HFIndex == pHandle->HFRateBuff) /*  */
 8008e60:	d002      	beq.n	8008e68 <MCPA_dataLog+0x14>
      }
    }
    else
    {
      /* Nothing to log just waiting next call to MCPA_datalog */
      pHandle->HFIndex++;
 8008e62:	3301      	adds	r3, #1
 8008e64:	77c3      	strb	r3, [r0, #31]
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 8008e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (0U == pHandle->bufferIndex)
 8008e68:	8b05      	ldrh	r5, [r0, #24]
      pHandle->HFIndex = 0U;
 8008e6a:	2300      	movs	r3, #0
 8008e6c:	77c3      	strb	r3, [r0, #31]
      if (0U == pHandle->bufferIndex)
 8008e6e:	b1a5      	cbz	r5, 8008e9a <MCPA_dataLog+0x46>
 8008e70:	6961      	ldr	r1, [r4, #20]
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008e72:	8ba2      	ldrh	r2, [r4, #28]
 8008e74:	42aa      	cmp	r2, r5
 8008e76:	d24e      	bcs.n	8008f16 <MCPA_dataLog+0xc2>
 8008e78:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
        if (pHandle->MFRateBuff == 254U) /* MFRateBuff = 254 means we dump MF data once per buffer */
 8008e7c:	2bfe      	cmp	r3, #254	; 0xfe
 8008e7e:	d066      	beq.n	8008f4e <MCPA_dataLog+0xfa>
        *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8008e80:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 8008e84:	534b      	strh	r3, [r1, r5]
        pHandle->pTransportLayer->fSendPacket(pHandle->pTransportLayer, pHandle->currentBuffer,
 8008e86:	8b22      	ldrh	r2, [r4, #24]
 8008e88:	6820      	ldr	r0, [r4, #0]
 8008e8a:	3202      	adds	r2, #2
 8008e8c:	2309      	movs	r3, #9
 8008e8e:	6845      	ldr	r5, [r0, #4]
 8008e90:	b292      	uxth	r2, r2
 8008e92:	47a8      	blx	r5
        pHandle->bufferIndex = 0U;
 8008e94:	2300      	movs	r3, #0
 8008e96:	8323      	strh	r3, [r4, #24]
}
 8008e98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (0U == pHandle->pTransportLayer->fGetBuffer (pHandle->pTransportLayer,
 8008e9a:	4601      	mov	r1, r0
 8008e9c:	2209      	movs	r2, #9
 8008e9e:	f851 0b14 	ldr.w	r0, [r1], #20
 8008ea2:	6803      	ldr	r3, [r0, #0]
 8008ea4:	4798      	blx	r3
 8008ea6:	b390      	cbz	r0, 8008f0e <MCPA_dataLog+0xba>
          *logValue = GLOBAL_TIMESTAMP; /* 32 first bits is used to store Timestamp */
 8008ea8:	4b4b      	ldr	r3, [pc, #300]	; (8008fd8 <MCPA_dataLog+0x184>)
 8008eaa:	6961      	ldr	r1, [r4, #20]
 8008eac:	681b      	ldr	r3, [r3, #0]
 8008eae:	600b      	str	r3, [r1, #0]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008eb0:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
 8008eb4:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
          pHandle->MFIndex = 0U; /* Restart the motif from scratch at each buffer */
 8008eb8:	f884 5020 	strb.w	r5, [r4, #32]
          pHandle->bufferIndex = 4U;
 8008ebc:	2304      	movs	r3, #4
          if (pHandle->Mark == pHandle->MarkBuff)
 8008ebe:	4282      	cmp	r2, r0
          pHandle->bufferIndex = 4U;
 8008ec0:	8323      	strh	r3, [r4, #24]
          if (pHandle->Mark == pHandle->MarkBuff)
 8008ec2:	d101      	bne.n	8008ec8 <MCPA_dataLog+0x74>
 8008ec4:	461d      	mov	r5, r3
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008ec6:	e7d4      	b.n	8008e72 <MCPA_dataLog+0x1e>
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008ec8:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008ecc:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008ed0:	f894 1025 	ldrb.w	r1, [r4, #37]	; 0x25
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008ed4:	f894 5021 	ldrb.w	r5, [r4, #33]	; 0x21
            pHandle->HFNumBuff           = pHandle->HFNum;
 8008ed8:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
            pHandle->MFNumBuff           = pHandle->MFNum;
 8008edc:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                         ((uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum) * 4U); /* We store pointer here,
 8008ee0:	441a      	add	r2, r3
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008ee2:	8b63      	ldrh	r3, [r4, #26]
            pHandle->MarkBuff            = pHandle->Mark;
 8008ee4:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008ee8:	0092      	lsls	r2, r2, #2
            pHandle->MFRateBuff          = pHandle->MFRate;
 8008eea:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
            pHandle->bufferTxTriggerBuff = pHandle->bufferTxTrigger;
 8008eee:	83a3      	strh	r3, [r4, #28]
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008ef0:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
            pHandle->HFRateBuff          = pHandle->HFRate;
 8008ef4:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
            (void)memcpy(pHandle->dataPtrTableBuff, pHandle->dataPtrTable,
 8008ef8:	f004 fc6f 	bl	800d7da <memcpy>
                         (uint32_t)pHandle->HFNum + (uint32_t)pHandle->MFNum); /* 1 size byte per ID */
 8008efc:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
 8008f00:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
            (void)memcpy(pHandle->dataSizeTableBuff, pHandle->dataSizeTable,
 8008f04:	e9d4 1003 	ldrd	r1, r0, [r4, #12]
 8008f08:	441a      	add	r2, r3
 8008f0a:	f004 fc66 	bl	800d7da <memcpy>
      if ((pHandle->bufferIndex > 0U)  && (pHandle->bufferIndex <= pHandle->bufferTxTriggerBuff))
 8008f0e:	8b25      	ldrh	r5, [r4, #24]
 8008f10:	2d00      	cmp	r5, #0
 8008f12:	d1ad      	bne.n	8008e70 <MCPA_dataLog+0x1c>
}
 8008f14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f16:	f894 6024 	ldrb.w	r6, [r4, #36]	; 0x24
        logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8008f1a:	194b      	adds	r3, r1, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f1c:	b36e      	cbz	r6, 8008f7a <MCPA_dataLog+0x126>
 8008f1e:	68a2      	ldr	r2, [r4, #8]
 8008f20:	eb03 0c46 	add.w	ip, r3, r6, lsl #1
 8008f24:	3a04      	subs	r2, #4
          *logValue16 = *((uint16_t *) pHandle->dataPtrTableBuff[i]) ; //cstat !MISRAC2012-Rule-11.5
 8008f26:	f852 0f04 	ldr.w	r0, [r2, #4]!
 8008f2a:	8800      	ldrh	r0, [r0, #0]
 8008f2c:	f823 0b02 	strh.w	r0, [r3], #2
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 8008f30:	8b25      	ldrh	r5, [r4, #24]
 8008f32:	3502      	adds	r5, #2
 8008f34:	b2ad      	uxth	r5, r5
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f36:	4563      	cmp	r3, ip
          pHandle->bufferIndex = pHandle->bufferIndex + 2U;
 8008f38:	8325      	strh	r5, [r4, #24]
        for (i = 0U; i < pHandle->HFNumBuff; i++)
 8008f3a:	d1f4      	bne.n	8008f26 <MCPA_dataLog+0xd2>
        if (pHandle->MFRateBuff < 254U)
 8008f3c:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f40:	8ba2      	ldrh	r2, [r4, #28]
        if (pHandle->MFRateBuff < 254U)
 8008f42:	2bfd      	cmp	r3, #253	; 0xfd
 8008f44:	4618      	mov	r0, r3
 8008f46:	d91d      	bls.n	8008f84 <MCPA_dataLog+0x130>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f48:	4295      	cmp	r5, r2
 8008f4a:	d897      	bhi.n	8008e7c <MCPA_dataLog+0x28>
}
 8008f4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f4e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8008f52:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 8008f56:	4418      	add	r0, r3
 8008f58:	4298      	cmp	r0, r3
 8008f5a:	dd91      	ble.n	8008e80 <MCPA_dataLog+0x2c>
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008f5c:	68a7      	ldr	r7, [r4, #8]
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008f5e:	6926      	ldr	r6, [r4, #16]
            *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008f60:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8008f64:	6812      	ldr	r2, [r2, #0]
 8008f66:	514a      	str	r2, [r1, r5]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f68:	1c5a      	adds	r2, r3, #1
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008f6a:	5cf3      	ldrb	r3, [r6, r3]
 8008f6c:	442b      	add	r3, r5
 8008f6e:	b29d      	uxth	r5, r3
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f70:	b2d3      	uxtb	r3, r2
 8008f72:	4283      	cmp	r3, r0
            pHandle->bufferIndex = pHandle->bufferIndex + pHandle->dataSizeTableBuff[i];
 8008f74:	8325      	strh	r5, [r4, #24]
          for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f76:	dbf3      	blt.n	8008f60 <MCPA_dataLog+0x10c>
 8008f78:	e782      	b.n	8008e80 <MCPA_dataLog+0x2c>
        if (pHandle->MFRateBuff < 254U)
 8008f7a:	f894 0026 	ldrb.w	r0, [r4, #38]	; 0x26
 8008f7e:	28fd      	cmp	r0, #253	; 0xfd
 8008f80:	f63f af71 	bhi.w	8008e66 <MCPA_dataLog+0x12>
          if (pHandle->MFIndex == pHandle->MFRateBuff)
 8008f84:	f894 3020 	ldrb.w	r3, [r4, #32]
 8008f88:	4283      	cmp	r3, r0
 8008f8a:	d007      	beq.n	8008f9c <MCPA_dataLog+0x148>
            pHandle->MFIndex ++;
 8008f8c:	3301      	adds	r3, #1
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f8e:	8b25      	ldrh	r5, [r4, #24]
            pHandle->MFIndex ++;
 8008f90:	f884 3020 	strb.w	r3, [r4, #32]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008f94:	42aa      	cmp	r2, r5
 8008f96:	f4ff af73 	bcc.w	8008e80 <MCPA_dataLog+0x2c>
}
 8008f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008f9c:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
 8008fa0:	4437      	add	r7, r6
            pHandle->MFIndex = 0U;
 8008fa2:	2300      	movs	r3, #0
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fa4:	42b7      	cmp	r7, r6
            pHandle->MFIndex = 0U;
 8008fa6:	f884 3020 	strb.w	r3, [r4, #32]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008faa:	dd12      	ble.n	8008fd2 <MCPA_dataLog+0x17e>
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008fac:	f8d4 e008 	ldr.w	lr, [r4, #8]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008fb0:	f8d4 c010 	ldr.w	ip, [r4, #16]
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008fb4:	8b25      	ldrh	r5, [r4, #24]
              *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 8008fb6:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 8008fba:	681b      	ldr	r3, [r3, #0]
 8008fbc:	514b      	str	r3, [r1, r5]
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008fbe:	f81c 3006 	ldrb.w	r3, [ip, r6]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fc2:	1c70      	adds	r0, r6, #1
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008fc4:	442b      	add	r3, r5
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fc6:	b2c6      	uxtb	r6, r0
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008fc8:	b29d      	uxth	r5, r3
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fca:	42be      	cmp	r6, r7
              pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8008fcc:	8325      	strh	r5, [r4, #24]
            for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8008fce:	dbf2      	blt.n	8008fb6 <MCPA_dataLog+0x162>
 8008fd0:	e7e0      	b.n	8008f94 <MCPA_dataLog+0x140>
      if (pHandle->bufferIndex > pHandle->bufferTxTriggerBuff)
 8008fd2:	8b25      	ldrh	r5, [r4, #24]
 8008fd4:	e7de      	b.n	8008f94 <MCPA_dataLog+0x140>
 8008fd6:	bf00      	nop
 8008fd8:	200030a8 	.word	0x200030a8

08008fdc <MCPA_flushDataLog>:
#endif
    uint32_t *logValue;
    uint16_t *logValue16;
    uint8_t i;

    if (pHandle->bufferIndex > 0U)
 8008fdc:	8b03      	ldrh	r3, [r0, #24]
 8008fde:	b19b      	cbz	r3, 8009008 <MCPA_flushDataLog+0x2c>
{
 8008fe0:	b570      	push	{r4, r5, r6, lr}
    {  /* If buffer is allocated, we must send it */
      if (pHandle->MFRateBuff == 254U) /* In case of flush, we must respect the packet format to allow
 8008fe2:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
 8008fe6:	2afe      	cmp	r2, #254	; 0xfe
 8008fe8:	4604      	mov	r4, r0
 8008fea:	d00e      	beq.n	800900a <MCPA_flushDataLog+0x2e>
                                          proper decoding */
      {
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
        {
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8008fec:	6941      	ldr	r1, [r0, #20]
      else
      {
        /* Nothing to do */
      }
      logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
      *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 8008fee:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 8008ff2:	52ca      	strh	r2, [r1, r3]
                                          the MARK */
      pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 8008ff4:	8b22      	ldrh	r2, [r4, #24]
 8008ff6:	6820      	ldr	r0, [r4, #0]
 8008ff8:	3202      	adds	r2, #2
 8008ffa:	2309      	movs	r3, #9
 8008ffc:	6845      	ldr	r5, [r0, #4]
 8008ffe:	b292      	uxth	r2, r2
 8009000:	47a8      	blx	r5
                                             pHandle->bufferIndex + 2U, MCTL_ASYNC);
      pHandle->bufferIndex = 0U;
 8009002:	2300      	movs	r3, #0
 8009004:	8323      	strh	r3, [r4, #24]
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
}
 8009006:	bd70      	pop	{r4, r5, r6, pc}
 8009008:	4770      	bx	lr
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800900a:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 800900e:	f890 c028 	ldrb.w	ip, [r0, #40]	; 0x28
         logValue = (uint32_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 8009012:	6941      	ldr	r1, [r0, #20]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009014:	4494      	add	ip, r2
 8009016:	4562      	cmp	r2, ip
 8009018:	dae9      	bge.n	8008fee <MCPA_flushDataLog+0x12>
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 800901a:	6886      	ldr	r6, [r0, #8]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800901c:	6905      	ldr	r5, [r0, #16]
         *logValue = *((uint32_t *)pHandle->dataPtrTableBuff[i]); //cstat !MISRAC2012-Rule-11.5
 800901e:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
 8009022:	6800      	ldr	r0, [r0, #0]
 8009024:	50c8      	str	r0, [r1, r3]
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009026:	5ca8      	ldrb	r0, [r5, r2]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009028:	3201      	adds	r2, #1
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800902a:	4403      	add	r3, r0
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 800902c:	b2d2      	uxtb	r2, r2
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 800902e:	b29b      	uxth	r3, r3
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009030:	4562      	cmp	r2, ip
         pHandle->bufferIndex = pHandle->bufferIndex+pHandle->dataSizeTableBuff[i];
 8009032:	8323      	strh	r3, [r4, #24]
        for (i = pHandle->HFNumBuff; i < (pHandle->MFNumBuff + pHandle->HFNumBuff); i++)
 8009034:	dbf3      	blt.n	800901e <MCPA_flushDataLog+0x42>
 8009036:	e7da      	b.n	8008fee <MCPA_flushDataLog+0x12>

08009038 <MCPA_cfgLog>:
  *
  * @param  *pHandle Pointer to the MCPA Handle
  * @param  *cfgdata Configuration of the Async communication
  */
uint8_t MCPA_cfgLog(MCPA_Handle_t *pHandle, uint8_t *cfgdata)
{
 8009038:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
    uint16_t newID, buffSize;
    uint8_t *pCfgData = cfgdata;

    buffSize = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 800903c:	880f      	ldrh	r7, [r1, #0]
{
 800903e:	4604      	mov	r4, r0

    if (buffSize == 0U)
 8009040:	2f00      	cmp	r7, #0
 8009042:	d044      	beq.n	80090ce <MCPA_cfgLog+0x96>
    { 
      /* Switch Off condition */
      MCPA_stopDataLog(pHandle);
    }
    else if (buffSize > pHandle->pTransportLayer->txAsyncMaxPayload)
 8009044:	6803      	ldr	r3, [r0, #0]
 8009046:	89db      	ldrh	r3, [r3, #14]
 8009048:	42bb      	cmp	r3, r7
 800904a:	d33d      	bcc.n	80090c8 <MCPA_cfgLog+0x90>
    {
      result = MCP_ERROR_NO_TXASYNC_SPACE;
    }
    else
    {
      pHandle->HFRate = *((uint8_t *)&pCfgData[2]);
 800904c:	788b      	ldrb	r3, [r1, #2]
 800904e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
      pHandle->HFNum  = *((uint8_t *)&pCfgData[3]);
 8009052:	78ce      	ldrb	r6, [r1, #3]
 8009054:	f880 6023 	strb.w	r6, [r0, #35]	; 0x23
      pHandle->MFRate = *((uint8_t *)&pCfgData[4]);
 8009058:	790b      	ldrb	r3, [r1, #4]
 800905a:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
      pHandle->MFNum  = *((uint8_t *)&pCfgData[5]);
 800905e:	794b      	ldrb	r3, [r1, #5]
 8009060:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */

      if ((pHandle->HFNum + pHandle->MFNum) <= pHandle->nbrOfDataLog)
 8009064:	441e      	add	r6, r3
 8009066:	7f83      	ldrb	r3, [r0, #30]
 8009068:	429e      	cmp	r6, r3
 800906a:	dc52      	bgt.n	8009112 <MCPA_cfgLog+0xda>
      pCfgData = &pCfgData[6]; /* Start of the HF IDs */
 800906c:	3106      	adds	r1, #6
      {
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800906e:	2e00      	cmp	r6, #0
 8009070:	d056      	beq.n	8009120 <MCPA_cfgLog+0xe8>
    uint16_t logSize = 0U; /* Max size of a log per iteration (HF+MF) */
 8009072:	2600      	movs	r6, #0
 8009074:	4688      	mov	r8, r1
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8009076:	4635      	mov	r5, r6
 8009078:	e011      	b.n	800909e <MCPA_cfgLog+0x66>
        {
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
          /* HF Data are fixed to 2 bytes */
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 800907a:	68e3      	ldr	r3, [r4, #12]
 800907c:	5558      	strb	r0, [r3, r5]
          pCfgData++; /* Point to the next UID */
          pCfgData++;
          logSize = logSize+pHandle->dataSizeTable[i];
 800907e:	68e2      	ldr	r2, [r4, #12]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8009080:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 8009084:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
          logSize = logSize+pHandle->dataSizeTable[i];
 8009088:	5d52      	ldrb	r2, [r2, r5]
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800908a:	f105 0c01 	add.w	ip, r5, #1
 800908e:	fa5f f58c 	uxtb.w	r5, ip
 8009092:	4403      	add	r3, r0
          logSize = logSize+pHandle->dataSizeTable[i];
 8009094:	4432      	add	r2, r6
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8009096:	429d      	cmp	r5, r3
          pCfgData++;
 8009098:	4641      	mov	r1, r8
          logSize = logSize+pHandle->dataSizeTable[i];
 800909a:	b296      	uxth	r6, r2
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 800909c:	da11      	bge.n	80090c2 <MCPA_cfgLog+0x8a>
          newID = *((uint16_t *)pCfgData); //cstat !MISRAC2012-Rule-11.3
 800909e:	f838 9b02 	ldrh.w	r9, [r8], #2
          (void)RI_GetPtrReg(newID, &pHandle->dataPtrTable[i]);
 80090a2:	6861      	ldr	r1, [r4, #4]
 80090a4:	4648      	mov	r0, r9
 80090a6:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 80090aa:	f7fb f94f 	bl	800434c <RI_GetPtrReg>
          pHandle->dataSizeTable[i] = (i < pHandle->HFNum ) ? 2U : RI_GetIDSize(newID);
 80090ae:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 80090b2:	42ab      	cmp	r3, r5
 80090b4:	f04f 0002 	mov.w	r0, #2
 80090b8:	d8df      	bhi.n	800907a <MCPA_cfgLog+0x42>
 80090ba:	4648      	mov	r0, r9
 80090bc:	f7fb f93a 	bl	8004334 <RI_GetIDSize>
 80090c0:	e7db      	b.n	800907a <MCPA_cfgLog+0x42>
        }

        /* Smallest packet must be able to contain logSize Markbyte AsyncID and TimeStamp */
        if (buffSize < (logSize + 2U + 4U))
 80090c2:	1db3      	adds	r3, r6, #6
 80090c4:	429f      	cmp	r7, r3
 80090c6:	d21a      	bcs.n	80090fe <MCPA_cfgLog+0xc6>
      result = MCP_ERROR_NO_TXASYNC_SPACE;
 80090c8:	2009      	movs	r0, #9
    }
#ifdef NULL_PTR_CHECK_MCPA
  }
#endif
  return (result);
}
 80090ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 80090ce:	8b03      	ldrh	r3, [r0, #24]
  pHandle->Mark = 0U;
 80090d0:	f880 7029 	strb.w	r7, [r0, #41]	; 0x29
  if (pHandle->bufferIndex > 0U)
 80090d4:	b153      	cbz	r3, 80090ec <MCPA_cfgLog+0xb4>
    logValue16 = (uint16_t *)&pHandle->currentBuffer[pHandle->bufferIndex]; //cstat !MISRAC2012-Rule-11.3
 80090d6:	6961      	ldr	r1, [r4, #20]
    *logValue16 = pHandle->MarkBuff; /* MarkBuff is actually 8 bits, but we add also 8 bits of the ASYNCID=0 after
 80090d8:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 80090dc:	52ca      	strh	r2, [r1, r3]
    pHandle->pTransportLayer->fSendPacket (pHandle->pTransportLayer, pHandle->currentBuffer,
 80090de:	8b22      	ldrh	r2, [r4, #24]
 80090e0:	6820      	ldr	r0, [r4, #0]
 80090e2:	3202      	adds	r2, #2
 80090e4:	6845      	ldr	r5, [r0, #4]
 80090e6:	b292      	uxth	r2, r2
 80090e8:	2309      	movs	r3, #9
 80090ea:	47a8      	blx	r5
  pHandle->bufferIndex = 0U;
 80090ec:	2000      	movs	r0, #0
  pHandle->MarkBuff    = 0U;
 80090ee:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
  pHandle->HFIndex     = 0U;
 80090f2:	77e0      	strb	r0, [r4, #31]
  pHandle->HFRateBuff  = 0U; /* We do not want to miss any sample at the restart */
 80090f4:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
  pHandle->bufferIndex = 0U;
 80090f8:	8320      	strh	r0, [r4, #24]
}
 80090fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          pHandle->bufferTxTrigger = buffSize-logSize - 2U; /* 2 is required to add the last Mark byte and NUL
 80090fe:	3f02      	subs	r7, #2
 8009100:	1bbf      	subs	r7, r7, r6
 8009102:	8367      	strh	r7, [r4, #26]
          pHandle->Mark = *((uint8_t *)pCfgData);
 8009104:	780b      	ldrb	r3, [r1, #0]
 8009106:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
          if (0U == pHandle->Mark)
 800910a:	b12b      	cbz	r3, 8009118 <MCPA_cfgLog+0xe0>
  uint8_t result = MCP_CMD_OK;
 800910c:	2000      	movs	r0, #0
}
 800910e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        result = MCP_ERROR_BAD_RAW_FORMAT;
 8009112:	200a      	movs	r0, #10
}
 8009114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (pHandle->bufferIndex > 0U)
 8009118:	8b23      	ldrh	r3, [r4, #24]
 800911a:	2b00      	cmp	r3, #0
 800911c:	d0e6      	beq.n	80090ec <MCPA_cfgLog+0xb4>
 800911e:	e7da      	b.n	80090d6 <MCPA_cfgLog+0x9e>
        for (i = 0; i < (pHandle->HFNum + pHandle->MFNum); i++)
 8009120:	2306      	movs	r3, #6
 8009122:	e7cf      	b.n	80090c4 <MCPA_cfgLog+0x8c>

08009124 <NTC_Clear>:
    /* nothing to do */
  }
  else
  {
#endif
    pHandle->hAvTemp_d = 0U;
 8009124:	2300      	movs	r3, #0
 8009126:	8043      	strh	r3, [r0, #2]
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
}
 8009128:	4770      	bx	lr
 800912a:	bf00      	nop

0800912c <NTC_Init>:
    if (REAL_SENSOR == pHandle->bSensorType)
 800912c:	7802      	ldrb	r2, [r0, #0]
{
 800912e:	b508      	push	{r3, lr}
    if (REAL_SENSOR == pHandle->bSensorType)
 8009130:	b122      	cbz	r2, 800913c <NTC_Init+0x10>
      pHandle->hAvTemp_d = pHandle->hExpectedTemp_d;
 8009132:	8882      	ldrh	r2, [r0, #4]
 8009134:	8042      	strh	r2, [r0, #2]
      pHandle->hFaultState = MC_NO_ERROR;
 8009136:	2100      	movs	r1, #0
 8009138:	8101      	strh	r1, [r0, #8]
}
 800913a:	bd08      	pop	{r3, pc}
      NTC_Clear(pHandle);
 800913c:	f7ff fff2 	bl	8009124 <NTC_Clear>
}
 8009140:	bd08      	pop	{r3, pc}
 8009142:	bf00      	nop

08009144 <NTC_GetAvTemp_C>:
  else
  {
#endif
    int32_t wTemp;

    if (REAL_SENSOR == pHandle->bSensorType)
 8009144:	7803      	ldrb	r3, [r0, #0]
 8009146:	b95b      	cbnz	r3, 8009160 <NTC_GetAvTemp_C+0x1c>
    {
      wTemp = (int32_t)pHandle->hAvTemp_d;
 8009148:	8842      	ldrh	r2, [r0, #2]
      wTemp -= ((int32_t)pHandle->wV0);
 800914a:	6941      	ldr	r1, [r0, #20]
      wTemp *= pHandle->hSensitivity;
 800914c:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
#ifndef FULL_MISRA_C_COMPLIANCY_NTC_TEMP
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8009150:	8b00      	ldrh	r0, [r0, #24]
      wTemp -= ((int32_t)pHandle->wV0);
 8009152:	1a52      	subs	r2, r2, r1
      wTemp *= pHandle->hSensitivity;
 8009154:	fb02 f303 	mul.w	r3, r2, r3
      wTemp = (wTemp >> 16) + (int32_t)pHandle->hT0;
 8009158:	eb00 4023 	add.w	r0, r0, r3, asr #16
    returnValue = (int16_t)wTemp;
#ifdef NULL_PTR_CHECK_NTC_TEMP_SENS
  }
#endif
  return (returnValue);
}
 800915c:	b200      	sxth	r0, r0
 800915e:	4770      	bx	lr
      wTemp = (int32_t)pHandle->hExpectedTemp_C;
 8009160:	88c0      	ldrh	r0, [r0, #6]
}
 8009162:	b200      	sxth	r0, r0
 8009164:	4770      	bx	lr
 8009166:	bf00      	nop

08009168 <PID_HandleInit>:
  {
#endif
    pHandle->hKpGain =  pHandle->hDefKpGain;
    pHandle->hKiGain =  pHandle->hDefKiGain;
    pHandle->hKdGain =  pHandle->hDefKdGain;
    pHandle->wIntegralTerm = 0;
 8009168:	2300      	movs	r3, #0
    pHandle->hKpGain =  pHandle->hDefKpGain;
 800916a:	6801      	ldr	r1, [r0, #0]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 800916c:	8c02      	ldrh	r2, [r0, #32]
    pHandle->hKpGain =  pHandle->hDefKpGain;
 800916e:	6041      	str	r1, [r0, #4]
    pHandle->hKdGain =  pHandle->hDefKdGain;
 8009170:	8442      	strh	r2, [r0, #34]	; 0x22
    pHandle->wIntegralTerm = 0;
 8009172:	6083      	str	r3, [r0, #8]
    pHandle->wPrevProcessVarError = 0;
 8009174:	6283      	str	r3, [r0, #40]	; 0x28
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 8009176:	4770      	bx	lr

08009178 <PID_SetKP>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKpGain = hKpGain;
 8009178:	8081      	strh	r1, [r0, #4]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 800917a:	4770      	bx	lr

0800917c <PID_SetKI>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKiGain = hKiGain;
 800917c:	80c1      	strh	r1, [r0, #6]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 800917e:	4770      	bx	lr

08009180 <PID_GetKP>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKpGain);
#else
  return (pHandle->hKpGain);
#endif
}
 8009180:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 8009184:	4770      	bx	lr
 8009186:	bf00      	nop

08009188 <PID_GetKI>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKiGain);
#else
  return (pHandle->hKiGain);
#endif
}
 8009188:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 800918c:	4770      	bx	lr
 800918e:	bf00      	nop

08009190 <PID_SetIntegralTerm>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wIntegralTerm = wIntegralTermValue;
 8009190:	6081      	str	r1, [r0, #8]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return;
}
 8009192:	4770      	bx	lr

08009194 <PID_GetKPDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKpDivisorPOW2);
#else
  return (pHandle->hKpDivisorPOW2);
#endif
}
 8009194:	8b80      	ldrh	r0, [r0, #28]
 8009196:	4770      	bx	lr

08009198 <PID_SetKPDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 8009198:	2301      	movs	r3, #1
 800919a:	408b      	lsls	r3, r1
    pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
 800919c:	8381      	strh	r1, [r0, #28]
    pHandle->hKpDivisor = (((uint16_t)1) << hKpDivisorPOW2);
 800919e:	8303      	strh	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091a0:	4770      	bx	lr
 80091a2:	bf00      	nop

080091a4 <PID_GetKIDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKiDivisorPOW2);
#else
  return (pHandle->hKiDivisorPOW2);
#endif
}
 80091a4:	8bc0      	ldrh	r0, [r0, #30]
 80091a6:	4770      	bx	lr

080091a8 <PID_SetLowerIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wLowerIntegralLimit = wLowerLimit;
 80091a8:	6101      	str	r1, [r0, #16]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091aa:	4770      	bx	lr

080091ac <PID_SetUpperIntegralTermLimit>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->wUpperIntegralLimit = wUpperLimit;
 80091ac:	60c1      	str	r1, [r0, #12]
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091ae:	4770      	bx	lr

080091b0 <PID_SetKIDivisorPOW2>:
{
 80091b0:	b538      	push	{r3, r4, r5, lr}
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80091b2:	2301      	movs	r3, #1
{
 80091b4:	460c      	mov	r4, r1
    uint32_t wKiDiv = (((uint32_t)1) << hKiDivisorPOW2);
 80091b6:	408b      	lsls	r3, r1
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 80091b8:	f647 71ff 	movw	r1, #32767	; 0x7fff
 80091bc:	40a1      	lsls	r1, r4
    pHandle->hKiDivisorPOW2 = hKiDivisorPOW2;
 80091be:	83c4      	strh	r4, [r0, #30]
    pHandle->hKiDivisor = (uint16_t)wKiDiv;
 80091c0:	8343      	strh	r3, [r0, #26]
{
 80091c2:	4605      	mov	r5, r0
    PID_SetUpperIntegralTermLimit(pHandle, (int32_t)INT16_MAX * (int32_t)wKiDiv);
 80091c4:	f7ff fff2 	bl	80091ac <PID_SetUpperIntegralTermLimit>
    PID_SetLowerIntegralTermLimit(pHandle, (int32_t)(-INT16_MAX) * (int32_t)wKiDiv);
 80091c8:	4902      	ldr	r1, [pc, #8]	; (80091d4 <PID_SetKIDivisorPOW2+0x24>)
 80091ca:	4628      	mov	r0, r5
 80091cc:	40a1      	lsls	r1, r4
 80091ce:	f7ff ffeb 	bl	80091a8 <PID_SetLowerIntegralTermLimit>
}
 80091d2:	bd38      	pop	{r3, r4, r5, pc}
 80091d4:	ffff8001 	.word	0xffff8001

080091d8 <PID_SetKD>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hKdGain = hKdGain;
 80091d8:	8441      	strh	r1, [r0, #34]	; 0x22
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091da:	4770      	bx	lr

080091dc <PID_GetKD>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0 : pHandle->hKdGain);
#else
  return (pHandle->hKdGain);
#endif
}
 80091dc:	f9b0 0022 	ldrsh.w	r0, [r0, #34]	; 0x22
 80091e0:	4770      	bx	lr
 80091e2:	bf00      	nop

080091e4 <PID_GetKDDivisorPOW2>:
#ifdef NULL_PTR_CHECK_PID_REG
  return ((MC_NULL == pHandle) ? 0U : pHandle->hKdDivisorPOW2);
#else
  return (pHandle->hKdDivisorPOW2);
#endif
}
 80091e4:	8cc0      	ldrh	r0, [r0, #38]	; 0x26
 80091e6:	4770      	bx	lr

080091e8 <PID_SetKDDivisorPOW2>:
  }
  else
  {
#endif
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 80091e8:	2301      	movs	r3, #1
 80091ea:	408b      	lsls	r3, r1
    pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
 80091ec:	84c1      	strh	r1, [r0, #38]	; 0x26
    pHandle->hKdDivisor = (((uint16_t)1) << hKdDivisorPOW2);
 80091ee:	8483      	strh	r3, [r0, #36]	; 0x24
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
}
 80091f0:	4770      	bx	lr
 80091f2:	bf00      	nop

080091f4 <PI_Controller>:
    int32_t wDischarge = 0;
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;

    /* Proportional term computation*/
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 80091f4:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
{
 80091f8:	4603      	mov	r3, r0
 80091fa:	b510      	push	{r4, lr}

    /* Integral term computation */
    if (0 == pHandle->hKiGain)
 80091fc:	f9b0 4006 	ldrsh.w	r4, [r0, #6]
    int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;
 8009200:	f9b3 c016 	ldrsh.w	ip, [r3, #22]
    int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
 8009204:	f9b0 0014 	ldrsh.w	r0, [r0, #20]
    wProportional_Term = pHandle->hKpGain * wProcessVarError;
 8009208:	fb01 f202 	mul.w	r2, r1, r2
    if (0 == pHandle->hKiGain)
 800920c:	b18c      	cbz	r4, 8009232 <PI_Controller+0x3e>
    {
      pHandle->wIntegralTerm = 0;
    }
    else
    {
      wIntegral_Term = pHandle->hKiGain * wProcessVarError;
 800920e:	fb04 f101 	mul.w	r1, r4, r1
      wIntegral_sum_temp = pHandle->wIntegralTerm + wIntegral_Term;
 8009212:	689c      	ldr	r4, [r3, #8]

      if (wIntegral_sum_temp < 0)
 8009214:	eb14 0e01 	adds.w	lr, r4, r1
 8009218:	d421      	bmi.n	800925e <PI_Controller+0x6a>
      {
        if (pHandle->wIntegralTerm < 0)
        {
          if (wIntegral_Term < 0)
          {
            wIntegral_sum_temp = -INT32_MAX;
 800921a:	420c      	tst	r4, r1
 800921c:	4916      	ldr	r1, [pc, #88]	; (8009278 <PI_Controller+0x84>)
 800921e:	bf48      	it	mi
 8009220:	468e      	movmi	lr, r1
        {
          /* Nothing to do */
        }
      }

      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8009222:	68d9      	ldr	r1, [r3, #12]
 8009224:	4571      	cmp	r1, lr
 8009226:	db05      	blt.n	8009234 <PI_Controller+0x40>
      {
        pHandle->wIntegralTerm = pHandle->wUpperIntegralLimit;
      }
      else if (wIntegral_sum_temp < pHandle->wLowerIntegralLimit)
 8009228:	6919      	ldr	r1, [r3, #16]
 800922a:	4571      	cmp	r1, lr
 800922c:	dc02      	bgt.n	8009234 <PI_Controller+0x40>
      {
        pHandle->wIntegralTerm = pHandle->wLowerIntegralLimit;
      }
      else
      {
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 800922e:	4671      	mov	r1, lr
 8009230:	e000      	b.n	8009234 <PI_Controller+0x40>
 8009232:	4621      	mov	r1, r4
    /* WARNING: the below instruction is not MISRA compliant, user should verify
               that Cortex-M3 assembly instruction ASR (arithmetic shift right)
               is used by the compiler to perform the shifts (instead of LSR
               logical shift right)*/
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
    wOutput_32 = (wProportional_Term >> pHandle->hKpDivisorPOW2) + (pHandle->wIntegralTerm >> pHandle->hKiDivisorPOW2);
 8009234:	8b9c      	ldrh	r4, [r3, #28]
 8009236:	4122      	asrs	r2, r4
 8009238:	8bdc      	ldrh	r4, [r3, #30]
 800923a:	fa41 f404 	asr.w	r4, r1, r4
 800923e:	4422      	add	r2, r4
#else
    wOutput_32 = (wProportional_Term / (int32_t)pHandle->hKpDivisor)
              + (pHandle->wIntegralTerm / (int32_t)pHandle->hKiDivisor);
#endif

    if (wOutput_32 > hUpperOutputLimit)
 8009240:	4290      	cmp	r0, r2
 8009242:	da03      	bge.n	800924c <PI_Controller+0x58>
    {
      wDischarge = hUpperOutputLimit - wOutput_32;
 8009244:	1a82      	subs	r2, r0, r2
    else
    {
      /* Nothing to do here */
    }

    pHandle->wIntegralTerm += wDischarge;
 8009246:	4411      	add	r1, r2
 8009248:	6099      	str	r1, [r3, #8]
    returnValue = (int16_t)wOutput_32;
#ifdef NULL_PTR_CHECK_PID_REG
  }
#endif
  return (returnValue);
}
 800924a:	bd10      	pop	{r4, pc}
    else if (wOutput_32 < hLowerOutputLimit)
 800924c:	4594      	cmp	ip, r2
      wDischarge = hLowerOutputLimit - wOutput_32;
 800924e:	bfc5      	ittet	gt
 8009250:	ebac 0202 	subgt.w	r2, ip, r2
    pHandle->wIntegralTerm += wDischarge;
 8009254:	1889      	addgt	r1, r1, r2
    returnValue = (int16_t)wOutput_32;
 8009256:	b210      	sxthle	r0, r2
      wOutput_32 = hLowerOutputLimit;
 8009258:	4660      	movgt	r0, ip
    pHandle->wIntegralTerm += wDischarge;
 800925a:	6099      	str	r1, [r3, #8]
}
 800925c:	bd10      	pop	{r4, pc}
        if (pHandle->wIntegralTerm > 0)
 800925e:	2c00      	cmp	r4, #0
 8009260:	dddf      	ble.n	8009222 <PI_Controller+0x2e>
          if (wIntegral_Term > 0)
 8009262:	2900      	cmp	r1, #0
 8009264:	dddd      	ble.n	8009222 <PI_Controller+0x2e>
      if (wIntegral_sum_temp > pHandle->wUpperIntegralLimit)
 8009266:	68d9      	ldr	r1, [r3, #12]
 8009268:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800926c:	42a1      	cmp	r1, r4
 800926e:	d1e1      	bne.n	8009234 <PI_Controller+0x40>
            wIntegral_sum_temp = INT32_MAX;
 8009270:	468e      	mov	lr, r1
        pHandle->wIntegralTerm = wIntegral_sum_temp;
 8009272:	4671      	mov	r1, lr
 8009274:	e7de      	b.n	8009234 <PI_Controller+0x40>
 8009276:	bf00      	nop
 8009278:	80000001 	.word	0x80000001

0800927c <PQD_CalcElMotorPower>:
  }
  else
  {
#endif
    int32_t wAux;
    qd_t Iqd = pHandle->pFOCVars->Iqd;
 800927c:	6882      	ldr	r2, [r0, #8]
{
 800927e:	b500      	push	{lr}
    qd_t Vqd = pHandle->pFOCVars->Vqd;

    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 8009280:	89d1      	ldrh	r1, [r2, #14]
 8009282:	f8b2 e018 	ldrh.w	lr, [r2, #24]
    wAux = ((int32_t)Iqd.q * (int32_t)Vqd.q)
 8009286:	8993      	ldrh	r3, [r2, #12]
 8009288:	f8b2 c016 	ldrh.w	ip, [r2, #22]
         + ((int32_t)Iqd.d * (int32_t)Vqd.d);
 800928c:	fb11 f20e 	smulbb	r2, r1, lr
    wAux /= 65536;
 8009290:	fb13 230c 	smlabb	r3, r3, ip, r2
 8009294:	2b00      	cmp	r3, #0

    /* pHandle->hAvrgElMotorPower += (wAux - pHandle->hAvrgElMotorPower) >> 4 */
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 8009296:	f9b0 2000 	ldrsh.w	r2, [r0]
    wAux /= 65536;
 800929a:	bfbc      	itt	lt
 800929c:	f503 437f 	addlt.w	r3, r3, #65280	; 0xff00
 80092a0:	33ff      	addlt	r3, #255	; 0xff
    pHandle->hAvrgElMotorPower += (int16_t)((wAux - (int32_t)pHandle->hAvrgElMotorPower) / 16);
 80092a2:	ebd2 4323 	rsbs	r3, r2, r3, asr #16
 80092a6:	bf48      	it	mi
 80092a8:	330f      	addmi	r3, #15
 80092aa:	eb02 1223 	add.w	r2, r2, r3, asr #4
 80092ae:	8002      	strh	r2, [r0, #0]

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
}
 80092b0:	f85d fb04 	ldr.w	pc, [sp], #4

080092b4 <PQD_Clear>:
    /* nothing to do */
  }
  else
  {
#endif
    pHandle->hAvrgElMotorPower = 0;
 80092b4:	2300      	movs	r3, #0
 80092b6:	8003      	strh	r3, [r0, #0]
#ifdef NULL_PTR_CHECK_MOT_POW_MES
  }
#endif
}
 80092b8:	4770      	bx	lr
 80092ba:	bf00      	nop

080092bc <PQD_GetAvrgElMotorPowerW>:
  * 
  * @param pHandle pointer on the related component instance.
  * @retval float_t The average measured motor power expressed in Watts.
  */
__weak float_t PQD_GetAvrgElMotorPowerW(const PQD_MotorPowMeas_Handle_t *pHandle)
{
 80092bc:	b510      	push	{r4, lr}
  else
  {
#endif

  /* First perform an integer multiplication, then a float one. */
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 80092be:	f9b0 3000 	ldrsh.w	r3, [r0]
{
 80092c2:	ed2d 8b02 	vpush	{d8}
 80092c6:	4604      	mov	r4, r0
  PowerW = ((float_t)pHandle->hAvrgElMotorPower * (float_t)VBS_GetAvBusVoltage_V(pHandle->pVBS)) * pHandle->ConvFact;
 80092c8:	68c0      	ldr	r0, [r0, #12]
 80092ca:	ee08 3a10 	vmov	s16, r3
 80092ce:	f7ff fbdf 	bl	8008a90 <VBS_GetAvBusVoltage_V>
 80092d2:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 80092d6:	edd4 7a01 	vldr	s15, [r4, #4]
 80092da:	ee07 0a10 	vmov	s14, r0
 80092de:	ee28 8a27 	vmul.f32	s16, s16, s15
 80092e2:	eeb8 0a47 	vcvt.f32.u32	s0, s14

#ifdef NULL_PTR_CHECK_PQD_MOT_POW_MEAS
  }
#endif
  return (PowerW);
}
 80092e6:	ee28 0a00 	vmul.f32	s0, s16, s0
 80092ea:	ecbd 8b02 	vpop	{d8}
 80092ee:	bd10      	pop	{r4, pc}

080092f0 <startTimers>:
  * When this function is called, TIM1 and/or TIM8 must be in a frozen state
  * with CNT, ARR, REP RATE and trigger correctly set (these settings are
  * usually performed in the Init method accordingly with the configuration)
  */
__weak void startTimers(void)
{
 80092f0:	b410      	push	{r4}
  *         (*) value not defined in all devices.
  * @retval State of Periphs (1 or 0).
  */
__STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
{
  return ((READ_BIT(RCC->APB1ENR1, Periphs) == Periphs) ? 1UL : 0UL);
 80092f2:	4b19      	ldr	r3, [pc, #100]	; (8009358 <startTimers+0x68>)
 80092f4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80092f6:	07d2      	lsls	r2, r2, #31
 80092f8:	b083      	sub	sp, #12
 80092fa:	d416      	bmi.n	800932a <startTimers+0x3a>
  SET_BIT(RCC->APB1ENR1, Periphs);
 80092fc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80092fe:	f042 0201 	orr.w	r2, r2, #1
 8009302:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8009304:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009306:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800930a:	f002 0201 	and.w	r2, r2, #1
 800930e:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8009310:	9a01      	ldr	r2, [sp, #4]
 8009312:	694a      	ldr	r2, [r1, #20]
 8009314:	f042 0201 	orr.w	r2, r2, #1
 8009318:	614a      	str	r2, [r1, #20]
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 800931a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800931c:	f022 0201 	bic.w	r2, r2, #1
 8009320:	659a      	str	r2, [r3, #88]	; 0x58
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
    LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
    LL_TIM_GenerateEvent_UPDATE(TIM2);
    LL_TIM_SetTriggerOutput(TIM2, trigOut);
  }
}
 8009322:	b003      	add	sp, #12
 8009324:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009328:	4770      	bx	lr
    trigOut = LL_TIM_ReadReg(TIM2, CR2) & TIM_CR2_MMS;
 800932a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800932e:	480b      	ldr	r0, [pc, #44]	; (800935c <startTimers+0x6c>)
 8009330:	685a      	ldr	r2, [r3, #4]
 8009332:	6859      	ldr	r1, [r3, #4]
 8009334:	4c0a      	ldr	r4, [pc, #40]	; (8009360 <startTimers+0x70>)
 8009336:	4001      	ands	r1, r0
 8009338:	f041 0120 	orr.w	r1, r1, #32
 800933c:	6059      	str	r1, [r3, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 800933e:	6959      	ldr	r1, [r3, #20]
 8009340:	f041 0101 	orr.w	r1, r1, #1
 8009344:	6159      	str	r1, [r3, #20]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009346:	6859      	ldr	r1, [r3, #4]
 8009348:	4022      	ands	r2, r4
 800934a:	4001      	ands	r1, r0
 800934c:	430a      	orrs	r2, r1
 800934e:	605a      	str	r2, [r3, #4]
}
 8009350:	b003      	add	sp, #12
 8009352:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009356:	4770      	bx	lr
 8009358:	40021000 	.word	0x40021000
 800935c:	fdffff8f 	.word	0xfdffff8f
 8009360:	02000070 	.word	0x02000070

08009364 <waitForPolarizationEnd>:
  {
#endif
    uint16_t hCalibrationPeriodCounter;
    uint16_t hMaxPeriodsNumber;

    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 8009364:	3201      	adds	r2, #1
{
 8009366:	b570      	push	{r4, r5, r6, lr}
    hMaxPeriodsNumber = ((uint16_t)2 * NB_CONVERSIONS) * (((uint16_t)repCnt + 1U) >> 1);
 8009368:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800936a:	f06f 0602 	mvn.w	r6, #2
 800936e:	0155      	lsls	r5, r2, #5
 8009370:	6106      	str	r6, [r0, #16]

    /* Wait for NB_CONVERSIONS to be executed */
    LL_TIM_ClearFlag_CC1(TIMx);
    hCalibrationPeriodCounter = 0u;
 8009372:	2200      	movs	r2, #0
    while (*cnt < NB_CONVERSIONS)
 8009374:	f893 c000 	ldrb.w	ip, [r3]
 8009378:	f1bc 0f0f 	cmp.w	ip, #15
    {
      if ((uint32_t)ERROR == LL_TIM_IsActiveFlag_CC1(TIMx))
      {
        LL_TIM_ClearFlag_CC1(TIMx);
        hCalibrationPeriodCounter++;
 800937c:	f102 0e01 	add.w	lr, r2, #1
    while (*cnt < NB_CONVERSIONS)
 8009380:	d80c      	bhi.n	800939c <waitForPolarizationEnd+0x38>
  return ((READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF)) ? 1UL : 0UL);
 8009382:	6904      	ldr	r4, [r0, #16]
 8009384:	07a4      	lsls	r4, r4, #30
 8009386:	d5f5      	bpl.n	8009374 <waitForPolarizationEnd+0x10>
        hCalibrationPeriodCounter++;
 8009388:	fa1f f28e 	uxth.w	r2, lr
        if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
 800938c:	4295      	cmp	r5, r2
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800938e:	6106      	str	r6, [r0, #16]
 8009390:	d8f0      	bhi.n	8009374 <waitForPolarizationEnd+0x10>
        {
          if (*cnt < NB_CONVERSIONS)
 8009392:	781c      	ldrb	r4, [r3, #0]
 8009394:	2c0f      	cmp	r4, #15
 8009396:	d8ed      	bhi.n	8009374 <waitForPolarizationEnd+0x10>
          {
            *SWerror = 1u;
 8009398:	2301      	movs	r3, #1
 800939a:	800b      	strh	r3, [r1, #0]
      }
    }
#ifdef NULL_PTR_CHECK_POW_COM
  }
#endif
  }
 800939c:	bd70      	pop	{r4, r5, r6, pc}
 800939e:	bf00      	nop

080093a0 <R3_1_GetPhaseCurrents>:
  * @brief  Computes and stores in the handler the latest converted motor phase currents in ab_t format.
  *
  */
__weak void R3_1_GetPhaseCurrents(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80093a0:	b1c1      	cbz	r1, 80093d4 <R3_1_GetPhaseCurrents+0x34>

    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl;  //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80093a2:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
{
 80093a6:	b470      	push	{r4, r5, r6}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80093a8:	e9d2 3400 	ldrd	r3, r4, [r2]
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint8_t Sector;

    Sector = (uint8_t)pHandle->_Super.Sector;
    ADCDataReg1 = ADCx->JDR1;
 80093ac:	f8d3 5080 	ldr.w	r5, [r3, #128]	; 0x80
    ADCDataReg2 = ADCx->JDR2;
 80093b0:	f8d3 6084 	ldr.w	r6, [r3, #132]	; 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 80093b4:	6863      	ldr	r3, [r4, #4]
    Sector = (uint8_t)pHandle->_Super.Sector;
 80093b6:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 80093ba:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80093be:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80093c2:	6063      	str	r3, [r4, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    switch (Sector)
 80093c4:	2a05      	cmp	r2, #5
 80093c6:	f200 809b 	bhi.w	8009500 <R3_1_GetPhaseCurrents+0x160>
 80093ca:	e8df f002 	tbb	[pc, r2]
 80093ce:	3729      	.short	0x3729
 80093d0:	29040437 	.word	0x29040437
 80093d4:	4770      	bx	lr
      case SECTOR_4:
      case SECTOR_5:
      {
        /* Current on Phase C is not accessible     */
        /* Ia = PhaseAOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 80093d6:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88

        /* Saturation of Ia */
        if (Aux < -INT16_MAX)
 80093da:	4b4d      	ldr	r3, [pc, #308]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 80093dc:	1b52      	subs	r2, r2, r5
        if (Aux < -INT16_MAX)
 80093de:	429a      	cmp	r2, r3
 80093e0:	db05      	blt.n	80093ee <R3_1_GetPhaseCurrents+0x4e>
        {
          Iab->a = -INT16_MAX;
        }
        else  if (Aux > INT16_MAX)
 80093e2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
        {
          Iab->a = INT16_MAX;
        }
        else
        {
          Iab->a = (int16_t)Aux;
 80093e6:	bfb4      	ite	lt
 80093e8:	b213      	sxthlt	r3, r2
 80093ea:	f647 73ff 	movwge	r3, #32767	; 0x7fff
        }

        /* Ib = PhaseBOffset - ADC converted value) */
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 80093ee:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c

        /* Saturation of Ib */
        if (Aux < -INT16_MAX)
 80093f2:	4a47      	ldr	r2, [pc, #284]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
          Iab->a = -INT16_MAX;
 80093f4:	800b      	strh	r3, [r1, #0]
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg2);
 80093f6:	1bad      	subs	r5, r5, r6
        if (Aux < -INT16_MAX)
 80093f8:	4295      	cmp	r5, r2
      }

      default:
        break;
    }
    Iab->a = -Iab->a;
 80093fa:	b29b      	uxth	r3, r3
        if (Aux < -INT16_MAX)
 80093fc:	da2c      	bge.n	8009458 <R3_1_GetPhaseCurrents+0xb8>
    Iab->a = -Iab->a;
 80093fe:	425c      	negs	r4, r3
 8009400:	b224      	sxth	r4, r4
 8009402:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8009406:	f248 0501 	movw	r5, #32769	; 0x8001
    Iab->b = -Iab->b;
    pHandle->_Super.Ia = Iab->a;
    pHandle->_Super.Ib = Iab->b;
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 800940a:	442b      	add	r3, r5
    Iab->a = -Iab->a;
 800940c:	800c      	strh	r4, [r1, #0]
    Iab->b = -Iab->b;
 800940e:	804a      	strh	r2, [r1, #2]
    pHandle->_Super.Ia = Iab->a;
 8009410:	f8a0 4062 	strh.w	r4, [r0, #98]	; 0x62
    pHandle->_Super.Ib = Iab->b;
 8009414:	f8a0 2064 	strh.w	r2, [r0, #100]	; 0x64
  }
}
 8009418:	bc70      	pop	{r4, r5, r6}
    pHandle->_Super.Ic = -Iab->a - Iab->b;
 800941a:	f8a0 3066 	strh.w	r3, [r0, #102]	; 0x66
}
 800941e:	4770      	bx	lr
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8009420:	f8d0 408c 	ldr.w	r4, [r0, #140]	; 0x8c
        if (Aux < -INT16_MAX)
 8009424:	4a3a      	ldr	r2, [pc, #232]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseBOffset) - (int32_t)(ADCDataReg1);
 8009426:	1b64      	subs	r4, r4, r5
        if (Aux < -INT16_MAX)
 8009428:	4294      	cmp	r4, r2
 800942a:	db1d      	blt.n	8009468 <R3_1_GetPhaseCurrents+0xc8>
        else  if (Aux > INT16_MAX)
 800942c:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
 8009430:	db61      	blt.n	80094f6 <R3_1_GetPhaseCurrents+0x156>
 8009432:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8009436:	461d      	mov	r5, r3
 8009438:	461c      	mov	r4, r3
 800943a:	e01b      	b.n	8009474 <R3_1_GetPhaseCurrents+0xd4>
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 800943c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
        if (Aux < -INT16_MAX)
 8009440:	4c33      	ldr	r4, [pc, #204]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
        Aux = (int32_t)(pHandle->PhaseAOffset) - (int32_t)(ADCDataReg1);
 8009442:	1b5d      	subs	r5, r3, r5
        if (Aux < -INT16_MAX)
 8009444:	42a5      	cmp	r5, r4
 8009446:	db25      	blt.n	8009494 <R3_1_GetPhaseCurrents+0xf4>
        else  if (Aux > INT16_MAX)
 8009448:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 800944c:	db4e      	blt.n	80094ec <R3_1_GetPhaseCurrents+0x14c>
 800944e:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8009452:	4613      	mov	r3, r2
 8009454:	4615      	mov	r5, r2
 8009456:	e023      	b.n	80094a0 <R3_1_GetPhaseCurrents+0x100>
        else  if (Aux > INT16_MAX)
 8009458:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 800945c:	db40      	blt.n	80094e0 <R3_1_GetPhaseCurrents+0x140>
    Iab->a = -Iab->a;
 800945e:	425c      	negs	r4, r3
 8009460:	b224      	sxth	r4, r4
 8009462:	f647 75ff 	movw	r5, #32767	; 0x7fff
 8009466:	e7d0      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
 8009468:	4613      	mov	r3, r2
 800946a:	f248 0501 	movw	r5, #32769	; 0x8001
 800946e:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8009472:	461c      	mov	r4, r3
          Iab->b = -INT16_MAX;
 8009474:	804b      	strh	r3, [r1, #2]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 8009476:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
 800947a:	1af3      	subs	r3, r6, r3
        Aux -= (int32_t)Iab->b;             /* Ia  */
 800947c:	1b1b      	subs	r3, r3, r4
        if (Aux > INT16_MAX)
 800947e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009482:	da1d      	bge.n	80094c0 <R3_1_GetPhaseCurrents+0x120>
        else  if (Aux < -INT16_MAX)
 8009484:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8009488:	dc26      	bgt.n	80094d8 <R3_1_GetPhaseCurrents+0x138>
 800948a:	f647 74ff 	movw	r4, #32767	; 0x7fff
 800948e:	f248 0301 	movw	r3, #32769	; 0x8001
 8009492:	e7ba      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
 8009494:	4622      	mov	r2, r4
 8009496:	f248 0301 	movw	r3, #32769	; 0x8001
 800949a:	f647 74ff 	movw	r4, #32767	; 0x7fff
 800949e:	4615      	mov	r5, r2
          Iab->a = -INT16_MAX;
 80094a0:	800a      	strh	r2, [r1, #0]
        Aux = (int32_t)(ADCDataReg2) - (int32_t)(pHandle->PhaseCOffset); /* -Ic */
 80094a2:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 80094a6:	1ab2      	subs	r2, r6, r2
        Aux -= (int32_t)Iab->a;             /* Ib */
 80094a8:	1b52      	subs	r2, r2, r5
        if (Aux > INT16_MAX)
 80094aa:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80094ae:	da0b      	bge.n	80094c8 <R3_1_GetPhaseCurrents+0x128>
        else  if (Aux < -INT16_MAX)
 80094b0:	f512 4f00 	cmn.w	r2, #32768	; 0x8000
 80094b4:	dc0c      	bgt.n	80094d0 <R3_1_GetPhaseCurrents+0x130>
 80094b6:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80094ba:	f248 0501 	movw	r5, #32769	; 0x8001
 80094be:	e7a4      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
 80094c0:	4c13      	ldr	r4, [pc, #76]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
 80094c2:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80094c6:	e7a0      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
 80094c8:	4a11      	ldr	r2, [pc, #68]	; (8009510 <R3_1_GetPhaseCurrents+0x170>)
 80094ca:	f647 75ff 	movw	r5, #32767	; 0x7fff
 80094ce:	e79c      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
    Iab->b = -Iab->b;
 80094d0:	b295      	uxth	r5, r2
 80094d2:	426a      	negs	r2, r5
 80094d4:	b212      	sxth	r2, r2
 80094d6:	e798      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
    Iab->a = -Iab->a;
 80094d8:	b29b      	uxth	r3, r3
 80094da:	425c      	negs	r4, r3
 80094dc:	b224      	sxth	r4, r4
 80094de:	e794      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
    Iab->b = -Iab->b;
 80094e0:	b2ad      	uxth	r5, r5
    Iab->a = -Iab->a;
 80094e2:	425c      	negs	r4, r3
    Iab->b = -Iab->b;
 80094e4:	426a      	negs	r2, r5
    Iab->a = -Iab->a;
 80094e6:	b224      	sxth	r4, r4
    Iab->b = -Iab->b;
 80094e8:	b212      	sxth	r2, r2
 80094ea:	e78e      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
    Iab->a = -Iab->a;
 80094ec:	b2ab      	uxth	r3, r5
 80094ee:	425c      	negs	r4, r3
          Iab->a = (int16_t)Aux;
 80094f0:	b22a      	sxth	r2, r5
    Iab->a = -Iab->a;
 80094f2:	b224      	sxth	r4, r4
 80094f4:	e7d4      	b.n	80094a0 <R3_1_GetPhaseCurrents+0x100>
    Iab->b = -Iab->b;
 80094f6:	b2a5      	uxth	r5, r4
 80094f8:	426a      	negs	r2, r5
          Iab->b = (int16_t)Aux;
 80094fa:	b223      	sxth	r3, r4
    Iab->b = -Iab->b;
 80094fc:	b212      	sxth	r2, r2
 80094fe:	e7b9      	b.n	8009474 <R3_1_GetPhaseCurrents+0xd4>
    Iab->a = -Iab->a;
 8009500:	880b      	ldrh	r3, [r1, #0]
    Iab->b = -Iab->b;
 8009502:	884d      	ldrh	r5, [r1, #2]
    Iab->a = -Iab->a;
 8009504:	425c      	negs	r4, r3
    Iab->b = -Iab->b;
 8009506:	426a      	negs	r2, r5
    Iab->a = -Iab->a;
 8009508:	b224      	sxth	r4, r4
    Iab->b = -Iab->b;
 800950a:	b212      	sxth	r2, r2
 800950c:	e77d      	b.n	800940a <R3_1_GetPhaseCurrents+0x6a>
 800950e:	bf00      	nop
 8009510:	ffff8001 	.word	0xffff8001

08009514 <R3_1_SetADCSampPointPolarization>:
  *
  * @param  pHdl: Handler of the current instance of the PWM component.
  * @retval uint16_t Returns the return value of R3_1_WriteTIMRegisters.
  */
uint16_t R3_1_SetADCSampPointPolarization(PWMC_Handle_t *pHdl)
{
 8009514:	b410      	push	{r4}
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009516:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  pHandle->_Super.Sector = pHandle->PolarizationSector;
 800951a:	f890 4099 	ldrb.w	r4, [r0, #153]	; 0x99
 800951e:	f880 407c 	strb.w	r4, [r0, #124]	; 0x7c
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 8009522:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009526:	685b      	ldr	r3, [r3, #4]
  uint16_t Aux;


  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8009528:	f8b0 4050 	ldrh.w	r4, [r0, #80]	; 0x50
  WRITE_REG(TIMx->CCR1, CompareValue);
 800952c:	635c      	str	r4, [r3, #52]	; 0x34
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 800952e:	3a01      	subs	r2, #1
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8009530:	f8b0 4052 	ldrh.w	r4, [r0, #82]	; 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 8009534:	f8b0 0054 	ldrh.w	r0, [r0, #84]	; 0x54
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009538:	639c      	str	r4, [r3, #56]	; 0x38
  return R3_1_WriteTIMRegisters(&pHandle->_Super, (pHandle->Half_PWMPeriod - (uint16_t)1));
 800953a:	b292      	uxth	r2, r2
  WRITE_REG(TIMx->CCR3, CompareValue);
 800953c:	63d8      	str	r0, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 800953e:	641a      	str	r2, [r3, #64]	; 0x40
  LL_TIM_OC_SetCompareCH4(TIMx, (uint32_t) SamplingPoint);

  /* Limit for update event */

//  if ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 1u )
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009540:	4904      	ldr	r1, [pc, #16]	; (8009554 <R3_1_SetADCSampPointPolarization+0x40>)
 8009542:	685b      	ldr	r3, [r3, #4]
}
 8009544:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009548:	420b      	tst	r3, r1
}
 800954a:	bf14      	ite	ne
 800954c:	2001      	movne	r0, #1
 800954e:	2000      	moveq	r0, #0
 8009550:	4770      	bx	lr
 8009552:	bf00      	nop
 8009554:	02000070 	.word	0x02000070

08009558 <R3_1_HFCurrentsPolarizationAB>:
  * @param  Iab: Pointer to the structure that will receive motor current
  *         of phase A and B in ab_t format.
  */
static void R3_1_HFCurrentsPolarizationAB(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 8009558:	b321      	cbz	r1, 80095a4 <R3_1_HFCurrentsPolarizationAB+0x4c>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800955a:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800955e:	e9d2 3200 	ldrd	r3, r2, [r2]
{
 8009562:	b430      	push	{r4, r5}
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    uint32_t ADCDataReg1 = ADCx->JDR1;
 8009564:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
    uint32_t ADCDataReg2 = ADCx->JDR2;
 8009568:	f8d3 5084 	ldr.w	r5, [r3, #132]	; 0x84
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800956c:	6853      	ldr	r3, [r2, #4]
 800956e:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009572:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009576:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 8009578:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 800957c:	2b0f      	cmp	r3, #15
 800957e:	d80d      	bhi.n	800959c <R3_1_HFCurrentsPolarizationAB+0x44>
    {
      pHandle-> PhaseAOffset += ADCDataReg1;
 8009580:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
      pHandle-> PhaseBOffset += ADCDataReg2;
 8009584:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
      pHandle-> PhaseAOffset += ADCDataReg1;
 8009588:	441c      	add	r4, r3
      pHandle->PolarizationCounter++;
 800958a:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
      pHandle-> PhaseBOffset += ADCDataReg2;
 800958e:	442a      	add	r2, r5
      pHandle->PolarizationCounter++;
 8009590:	3301      	adds	r3, #1
      pHandle-> PhaseBOffset += ADCDataReg2;
 8009592:	e9c0 4222 	strd	r4, r2, [r0, #136]	; 0x88
      pHandle->PolarizationCounter++;
 8009596:	b2db      	uxtb	r3, r3
 8009598:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 800959c:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 800959e:	bc30      	pop	{r4, r5}
    Iab->a = 0;
 80095a0:	600b      	str	r3, [r1, #0]
}
 80095a2:	4770      	bx	lr
 80095a4:	4770      	bx	lr
 80095a6:	bf00      	nop

080095a8 <R3_1_HFCurrentsPolarizationC>:
  *                Min value: 0 (low sides ON)
  *                Max value: PWM_PERIOD_CYCLES/2 (low sides OFF)
  */
static void R3_1_HFCurrentsPolarizationC(PWMC_Handle_t *pHdl, ab_t *Iab)
{
  if (MC_NULL == Iab)
 80095a8:	b301      	cbz	r1, 80095ec <R3_1_HFCurrentsPolarizationC+0x44>
#endif /* __ICCARM__ */
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80095aa:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
 80095ae:	e9d3 3200 	ldrd	r3, r2, [r3]
{
 80095b2:	b410      	push	{r4}
    uint32_t ADCDataReg2 = ADCx->JDR2;
 80095b4:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 80095b8:	6853      	ldr	r3, [r2, #4]
 80095ba:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80095be:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80095c2:	6053      	str	r3, [r2, #4]

    /* disable ADC trigger source */
    /* LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4) */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    if (pHandle->PolarizationCounter < NB_CONVERSIONS)
 80095c4:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 80095c8:	2b0f      	cmp	r3, #15
 80095ca:	d80a      	bhi.n	80095e2 <R3_1_HFCurrentsPolarizationC+0x3a>
    {
      /* Phase C is read from SECTOR_1, second value */
      pHandle-> PhaseCOffset += ADCDataReg2;
      pHandle->PolarizationCounter++;
 80095cc:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
      pHandle-> PhaseCOffset += ADCDataReg2;
 80095d0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
      pHandle->PolarizationCounter++;
 80095d4:	3301      	adds	r3, #1
      pHandle-> PhaseCOffset += ADCDataReg2;
 80095d6:	4422      	add	r2, r4
      pHandle->PolarizationCounter++;
 80095d8:	b2db      	uxtb	r3, r3
      pHandle-> PhaseCOffset += ADCDataReg2;
 80095da:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
      pHandle->PolarizationCounter++;
 80095de:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    {
      /* Nothing to do */
    }

    /* during offset calibration no current is flowing in the phases */
    Iab->a = 0;
 80095e2:	2300      	movs	r3, #0
    Iab->b = 0;
  }
}
 80095e4:	f85d 4b04 	ldr.w	r4, [sp], #4
    Iab->a = 0;
 80095e8:	600b      	str	r3, [r1, #0]
}
 80095ea:	4770      	bx	lr
 80095ec:	4770      	bx	lr
 80095ee:	bf00      	nop

080095f0 <R3_1_SwitchOnPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80095f0:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  pHandle->ADCRegularLocked = true;

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Set all duty to 50% */
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 80095f4:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80095f8:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 80095fa:	f04f 0c01 	mov.w	ip, #1
{
 80095fe:	b530      	push	{r4, r5, lr}
  LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
 8009600:	fa22 f10c 	lsr.w	r1, r2, ip
  pHandle->_Super.TurnOnLowSidesAction = false;
 8009604:	f04f 0e00 	mov.w	lr, #0
 8009608:	f880 e07e 	strb.w	lr, [r0, #126]	; 0x7e
  pHandle->ADCRegularLocked = true;
 800960c:	f880 c0a0 	strb.w	ip, [r0, #160]	; 0xa0
  LL_TIM_OC_SetCompareCH2(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH3(TIMx, ((uint32_t)pHandle->Half_PWMPeriod / (uint32_t)2));
  LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t)pHandle->Half_PWMPeriod - (uint32_t)5));
 8009610:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009612:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009614:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009616:	63d9      	str	r1, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009618:	f06f 0101 	mvn.w	r1, #1
  WRITE_REG(TIMx->CCR4, CompareValue);
 800961c:	641a      	str	r2, [r3, #64]	; 0x40
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800961e:	6119      	str	r1, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009620:	691a      	ldr	r2, [r3, #16]
 8009622:	07d2      	lsls	r2, r2, #31
 8009624:	d5fc      	bpl.n	8009620 <R3_1_SwitchOnPWM+0x30>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009626:	f06f 0201 	mvn.w	r2, #1
 800962a:	611a      	str	r2, [r3, #16]
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* Main PWM Output Enable */
  TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
 800962c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800962e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009632:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009634:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009636:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800963a:	645a      	str	r2, [r3, #68]	; 0x44
  LL_TIM_EnableAllOutputs(TIMx);

  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 800963c:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 8009640:	2a02      	cmp	r2, #2
 8009642:	d007      	beq.n	8009654 <R3_1_SwitchOnPWM+0x64>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009644:	f06f 0201 	mvn.w	r2, #1
 8009648:	611a      	str	r2, [r3, #16]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 800964a:	68da      	ldr	r2, [r3, #12]
 800964c:	f042 0201 	orr.w	r2, r2, #1
 8009650:	60da      	str	r2, [r3, #12]
  }
  /* Clear Update Flag */
  LL_TIM_ClearFlag_UPDATE(TIMx);
  /* Enable Update IRQ */
  LL_TIM_EnableIT_UPDATE(TIMx);
}
 8009652:	bd30      	pop	{r4, r5, pc}
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 8009654:	6a19      	ldr	r1, [r3, #32]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8009656:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 800965a:	f240 5255 	movw	r2, #1365	; 0x555
 800965e:	4211      	tst	r1, r2
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009660:	e9d0 140f 	ldrd	r1, r4, [r0, #60]	; 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009664:	6c42      	ldr	r2, [r0, #68]	; 0x44
    if ((TIMx->CCER & TIMxCCER_MASK_CH123) != 0U)
 8009666:	d007      	beq.n	8009678 <R3_1_SwitchOnPWM+0x88>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 8009668:	618d      	str	r5, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800966a:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800966e:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 8009672:	61a5      	str	r5, [r4, #24]
 8009674:	6191      	str	r1, [r2, #24]
}
 8009676:	e7e5      	b.n	8009644 <R3_1_SwitchOnPWM+0x54>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 8009678:	628d      	str	r5, [r1, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800967a:	f8b0 504a 	ldrh.w	r5, [r0, #74]	; 0x4a
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800967e:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 8009682:	62a5      	str	r5, [r4, #40]	; 0x28
 8009684:	6291      	str	r1, [r2, #40]	; 0x28
}
 8009686:	e7dd      	b.n	8009644 <R3_1_SwitchOnPWM+0x54>

08009688 <R3_1_SwitchOffPWM>:
#endif /* __ICCARM__ */
  PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
#if defined (__ICCARM__)
  #pragma cstat_restore = "MISRAC2012-Rule-11.3"
#endif /* __ICCARM__ */
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009688:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c

  pHandle->_Super.TurnOnLowSidesAction = false;

  /* Main PWM Output Disable */
  LL_TIM_DisableAllOutputs(TIMx);
  if (true == pHandle->_Super.BrakeActionLock)
 800968c:	f890 1085 	ldrb.w	r1, [r0, #133]	; 0x85
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009690:	685b      	ldr	r3, [r3, #4]
  CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009692:	68da      	ldr	r2, [r3, #12]
 8009694:	f022 0201 	bic.w	r2, r2, #1
 8009698:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800969a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  pHandle->_Super.TurnOnLowSidesAction = false;
 800969c:	f04f 0c00 	mov.w	ip, #0
 80096a0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80096a4:	f880 c07e 	strb.w	ip, [r0, #126]	; 0x7e
 80096a8:	645a      	str	r2, [r3, #68]	; 0x44
  if (true == pHandle->_Super.BrakeActionLock)
 80096aa:	b919      	cbnz	r1, 80096b4 <R3_1_SwitchOffPWM+0x2c>
  {
    /* Nothing to do */
  }
  else
  {
    if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 80096ac:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 80096b0:	2a02      	cmp	r2, #2
 80096b2:	d00c      	beq.n	80096ce <R3_1_SwitchOffPWM+0x46>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80096b4:	f06f 0201 	mvn.w	r2, #1
 80096b8:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80096ba:	691a      	ldr	r2, [r3, #16]
 80096bc:	07d2      	lsls	r2, r2, #31
 80096be:	d5fc      	bpl.n	80096ba <R3_1_SwitchOffPWM+0x32>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80096c0:	f06f 0101 	mvn.w	r1, #1
    /* Nothing to do */
  }
  LL_TIM_ClearFlag_UPDATE(TIMx);

  /* We allow ADC usage for regular conversion on Systick*/
  pHandle->ADCRegularLocked = false;
 80096c4:	2200      	movs	r2, #0
 80096c6:	6119      	str	r1, [r3, #16]
 80096c8:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
 80096cc:	4770      	bx	lr
{
 80096ce:	b430      	push	{r4, r5}
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80096d0:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	; 0x3c
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80096d4:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80096d8:	6c42      	ldr	r2, [r0, #68]	; 0x44
  WRITE_REG(GPIOx->BRR, PinMask);
 80096da:	62a5      	str	r5, [r4, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80096dc:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 80096e0:	628c      	str	r4, [r1, #40]	; 0x28
      LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80096e2:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 80096e6:	6291      	str	r1, [r2, #40]	; 0x28
 80096e8:	f06f 0201 	mvn.w	r2, #1
 80096ec:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80096ee:	691a      	ldr	r2, [r3, #16]
 80096f0:	07d1      	lsls	r1, r2, #31
 80096f2:	d5fc      	bpl.n	80096ee <R3_1_SwitchOffPWM+0x66>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80096f4:	f06f 0101 	mvn.w	r1, #1
  pHandle->ADCRegularLocked = false;
 80096f8:	2200      	movs	r2, #0
 80096fa:	6119      	str	r1, [r3, #16]
}
 80096fc:	bc30      	pop	{r4, r5}
  pHandle->ADCRegularLocked = false;
 80096fe:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
}
 8009702:	4770      	bx	lr

08009704 <R3_1_RLGetPhaseCurrents>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009704:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    int32_t wAux;

    /* Disable ADC trigger source */
    LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);

    wAux = ((int32_t)pHandle->PhaseBOffset)
 8009708:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
{
 800970c:	b410      	push	{r4}
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 800970e:	e9d3 4200 	ldrd	r4, r2, [r3]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009712:	6853      	ldr	r3, [r2, #4]
 8009714:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009718:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800971c:	6053      	str	r3, [r2, #4]
         - (int32_t)ADCx->JDR2;
 800971e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84

    /* Check saturation */
    if (wAux > -INT16_MAX)
 8009722:	4c0c      	ldr	r4, [pc, #48]	; (8009754 <R3_1_RLGetPhaseCurrents+0x50>)
    wAux = ((int32_t)pHandle->PhaseBOffset)
 8009724:	1ac2      	subs	r2, r0, r3
    if (wAux > -INT16_MAX)
 8009726:	42a2      	cmp	r2, r4
 8009728:	db06      	blt.n	8009738 <R3_1_RLGetPhaseCurrents+0x34>
    {
      if (wAux < INT16_MAX)
 800972a:	f647 74fe 	movw	r4, #32766	; 0x7ffe
 800972e:	42a2      	cmp	r2, r4
 8009730:	dc0d      	bgt.n	800974e <R3_1_RLGetPhaseCurrents+0x4a>
    }
    else
    {
      wAux = -INT16_MAX;
    }
    wAux = -wAux;
 8009732:	1a1b      	subs	r3, r3, r0
    pStator_Currents->a = (int16_t)wAux;
 8009734:	b21b      	sxth	r3, r3
 8009736:	e001      	b.n	800973c <R3_1_RLGetPhaseCurrents+0x38>
 8009738:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800973c:	2200      	movs	r2, #0
 800973e:	f363 020f 	bfi	r2, r3, #0, #16
 8009742:	f363 421f 	bfi	r2, r3, #16, #16
    pStator_Currents->b = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 8009746:	f85d 4b04 	ldr.w	r4, [sp], #4
    pStator_Currents->a = (int16_t)wAux;
 800974a:	600a      	str	r2, [r1, #0]
}
 800974c:	4770      	bx	lr
 800974e:	4b02      	ldr	r3, [pc, #8]	; (8009758 <R3_1_RLGetPhaseCurrents+0x54>)
 8009750:	e7f4      	b.n	800973c <R3_1_RLGetPhaseCurrents+0x38>
 8009752:	bf00      	nop
 8009754:	ffff8002 	.word	0xffff8002
 8009758:	ffff8001 	.word	0xffff8001

0800975c <R3_1_RLSwitchOnPWM>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800975c:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009760:	e9d2 1300 	ldrd	r1, r3, [r2]
{
 8009764:	b430      	push	{r4, r5}
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009766:	f06f 0201 	mvn.w	r2, #1

    pHandle->ADCRegularLocked=true;
 800976a:	2401      	movs	r4, #1
 800976c:	f880 40a0 	strb.w	r4, [r0, #160]	; 0xa0
 8009770:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009772:	691a      	ldr	r2, [r3, #16]
 8009774:	07d4      	lsls	r4, r2, #31
 8009776:	d5fc      	bpl.n	8009772 <R3_1_RLSwitchOnPWM+0x16>
    }
    /* Clear Update Flag */
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 1U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 8009778:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800977c:	f06f 0401 	mvn.w	r4, #1
 8009780:	611c      	str	r4, [r3, #16]
 8009782:	3a05      	subs	r2, #5
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009784:	2401      	movs	r4, #1
 8009786:	635c      	str	r4, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009788:	641a      	str	r2, [r3, #64]	; 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800978a:	691a      	ldr	r2, [r3, #16]
 800978c:	07d2      	lsls	r2, r2, #31
 800978e:	d5fc      	bpl.n	800978a <R3_1_RLSwitchOnPWM+0x2e>
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 8009790:	68da      	ldr	r2, [r3, #12]
 8009792:	f042 0201 	orr.w	r2, r2, #1
 8009796:	60da      	str	r2, [r3, #12]

    /* Enable TIMx update interrupt */
    LL_TIM_EnableIT_UPDATE(TIMx);

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 8009798:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800979a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800979e:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 80097a0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80097a2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80097a6:	645a      	str	r2, [r3, #68]	; 0x44
    LL_TIM_EnableAllOutputs(TIMx);

    if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 80097a8:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 80097ac:	2a02      	cmp	r2, #2
 80097ae:	d00c      	beq.n	80097ca <R3_1_RLSwitchOnPWM+0x6e>
      /* Nothing to do */
    }

    /* Set the sector that correspond to Phase B and C sampling
     * B will be sampled by ADCx */
    pHdl->Sector = SECTOR_4;
 80097b0:	2303      	movs	r3, #3
 80097b2:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
  MODIFY_REG(ADCx->CR,
 80097b6:	688b      	ldr	r3, [r1, #8]
 80097b8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80097bc:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80097c0:	f043 0308 	orr.w	r3, r3, #8
    LL_ADC_INJ_StartConversion(ADCx);

#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 80097c4:	bc30      	pop	{r4, r5}
 80097c6:	608b      	str	r3, [r1, #8]
 80097c8:	4770      	bx	lr
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 80097ca:	6a1a      	ldr	r2, [r3, #32]
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 80097cc:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80097ce:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 80097d2:	f240 5355 	movw	r3, #1365	; 0x555
 80097d6:	421a      	tst	r2, r3
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80097d8:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
      if ((TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0U)
 80097dc:	d007      	beq.n	80097ee <R3_1_RLSwitchOnPWM+0x92>
  WRITE_REG(GPIOx->BSRR, PinMask);
 80097de:	61a5      	str	r5, [r4, #24]
        LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80097e0:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 80097e4:	6194      	str	r4, [r2, #24]
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80097e6:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 80097ea:	629a      	str	r2, [r3, #40]	; 0x28
}
 80097ec:	e7e0      	b.n	80097b0 <R3_1_RLSwitchOnPWM+0x54>
  WRITE_REG(GPIOx->BRR, PinMask);
 80097ee:	62a5      	str	r5, [r4, #40]	; 0x28
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 80097f0:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 80097f4:	6294      	str	r4, [r2, #40]	; 0x28
        LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 80097f6:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 80097fa:	629a      	str	r2, [r3, #40]	; 0x28
}
 80097fc:	e7d8      	b.n	80097b0 <R3_1_RLSwitchOnPWM+0x54>
 80097fe:	bf00      	nop

08009800 <R3_1_TurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009800:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 8009804:	685b      	ldr	r3, [r3, #4]
  pHandle->_Super.TurnOnLowSidesAction = true;
 8009806:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800980a:	f06f 0201 	mvn.w	r2, #1
 800980e:	f880 c07e 	strb.w	ip, [r0, #126]	; 0x7e
 8009812:	611a      	str	r2, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009814:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009816:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009818:	63d9      	str	r1, [r3, #60]	; 0x3c
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800981a:	691a      	ldr	r2, [r3, #16]
 800981c:	07d2      	lsls	r2, r2, #31
 800981e:	d5fc      	bpl.n	800981a <R3_1_TurnOnLowSides+0x1a>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 8009820:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009822:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009826:	645a      	str	r2, [r3, #68]	; 0x44
  if ((ES_GPIO == pHandle->_Super.LowSideOutputs))
 8009828:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 800982c:	2b02      	cmp	r3, #2
 800982e:	d000      	beq.n	8009832 <R3_1_TurnOnLowSides+0x32>
 8009830:	4770      	bx	lr
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009832:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	; 0x3c
{
 8009836:	b410      	push	{r4}
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009838:	6c43      	ldr	r3, [r0, #68]	; 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800983a:	f8b0 4048 	ldrh.w	r4, [r0, #72]	; 0x48
  WRITE_REG(GPIOx->BSRR, PinMask);
 800983e:	6194      	str	r4, [r2, #24]
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 8009840:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009844:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
 8009848:	618c      	str	r4, [r1, #24]
}
 800984a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800984e:	619a      	str	r2, [r3, #24]
 8009850:	4770      	bx	lr
 8009852:	bf00      	nop

08009854 <R3_1_SetAOReferenceVoltage>:
  * @param  Data Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_DAC_ConvertData12LeftAligned(DAC_TypeDef *DACx, uint32_t DAC_Channel, uint32_t Data)
{
  __IO uint32_t *preg = __DAC_PTR_REG_OFFSET(DACx->DHR12R1, (DAC_Channel >> DAC_REG_DHR12LX_REGOFFSET_BITOFFSET_POS)
 8009854:	ea4f 4c90 	mov.w	ip, r0, lsr #18
{
 8009858:	b510      	push	{r4, lr}
 800985a:	f00c 0c3c 	and.w	ip, ip, #60	; 0x3c
 800985e:	f101 0e08 	add.w	lr, r1, #8
 8009862:	b082      	sub	sp, #8
                                             & DAC_REG_DHR_REGOFFSET_MASK_POSBIT0);

  MODIFY_REG(*preg, DAC_DHR12L1_DACC1DHR, Data);
 8009864:	f85e 300c 	ldr.w	r3, [lr, ip]
 8009868:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800986c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8009870:	431a      	orrs	r2, r3
 8009872:	f84e 200c 	str.w	r2, [lr, ip]
  SET_BIT(DACx->SWTRIGR,
 8009876:	684a      	ldr	r2, [r1, #4]
 8009878:	f000 0303 	and.w	r3, r0, #3
 800987c:	4313      	orrs	r3, r2
 800987e:	604b      	str	r3, [r1, #4]
  return ((READ_BIT(DACx->CR,
 8009880:	680a      	ldr	r2, [r1, #0]
 8009882:	f000 0010 	and.w	r0, r0, #16
 8009886:	2301      	movs	r3, #1
 8009888:	4083      	lsls	r3, r0
           == (DAC_CR_EN1 << (DAC_Channel & DAC_CR_CHX_BITOFFSET_MASK))) ? 1UL : 0UL);
 800988a:	ea33 0202 	bics.w	r2, r3, r2
 800988e:	d014      	beq.n	80098ba <R3_1_SetAOReferenceVoltage+0x66>
                                         * (SystemCoreClock / (1000000UL * 2UL)));
 8009890:	4a14      	ldr	r2, [pc, #80]	; (80098e4 <R3_1_SetAOReferenceVoltage+0x90>)
 8009892:	4815      	ldr	r0, [pc, #84]	; (80098e8 <R3_1_SetAOReferenceVoltage+0x94>)
 8009894:	6812      	ldr	r2, [r2, #0]
  SET_BIT(DACx->CR,
 8009896:	680c      	ldr	r4, [r1, #0]
 8009898:	fba0 0202 	umull	r0, r2, r0, r2
 800989c:	0cd2      	lsrs	r2, r2, #19
 800989e:	4323      	orrs	r3, r4
 80098a0:	00d2      	lsls	r2, r2, #3
 80098a2:	600b      	str	r3, [r1, #0]
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US)
 80098a4:	9200      	str	r2, [sp, #0]
    while (wait_loop_index != 0UL)
 80098a6:	9b00      	ldr	r3, [sp, #0]
 80098a8:	b12b      	cbz	r3, 80098b6 <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 80098aa:	9b00      	ldr	r3, [sp, #0]
 80098ac:	3b01      	subs	r3, #1
 80098ae:	9300      	str	r3, [sp, #0]
    while (wait_loop_index != 0UL)
 80098b0:	9b00      	ldr	r3, [sp, #0]
 80098b2:	2b00      	cmp	r3, #0
 80098b4:	d1f9      	bne.n	80098aa <R3_1_SetAOReferenceVoltage+0x56>
}
 80098b6:	b002      	add	sp, #8
 80098b8:	bd10      	pop	{r4, pc}
    volatile uint32_t wait_loop_index = ((LL_DAC_DELAY_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));
 80098ba:	4b0a      	ldr	r3, [pc, #40]	; (80098e4 <R3_1_SetAOReferenceVoltage+0x90>)
 80098bc:	4a0a      	ldr	r2, [pc, #40]	; (80098e8 <R3_1_SetAOReferenceVoltage+0x94>)
 80098be:	681b      	ldr	r3, [r3, #0]
 80098c0:	fba2 2303 	umull	r2, r3, r2, r3
 80098c4:	0cdb      	lsrs	r3, r3, #19
 80098c6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80098ca:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80098cc:	9b01      	ldr	r3, [sp, #4]
 80098ce:	2b00      	cmp	r3, #0
 80098d0:	d0f1      	beq.n	80098b6 <R3_1_SetAOReferenceVoltage+0x62>
      wait_loop_index--;
 80098d2:	9b01      	ldr	r3, [sp, #4]
 80098d4:	3b01      	subs	r3, #1
 80098d6:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80098d8:	9b01      	ldr	r3, [sp, #4]
 80098da:	2b00      	cmp	r3, #0
 80098dc:	d1f9      	bne.n	80098d2 <R3_1_SetAOReferenceVoltage+0x7e>
}
 80098de:	b002      	add	sp, #8
 80098e0:	bd10      	pop	{r4, pc}
 80098e2:	bf00      	nop
 80098e4:	200014a4 	.word	0x200014a4
 80098e8:	431bde83 	.word	0x431bde83

080098ec <R3_1_RLTurnOnLowSides>:
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 80098ec:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 80098f0:	685b      	ldr	r3, [r3, #4]
  pHandle->ADCRegularLocked = true;
 80098f2:	f04f 0c01 	mov.w	ip, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 80098f6:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80098f8:	f06f 0201 	mvn.w	r2, #1
 80098fc:	f880 c0a0 	strb.w	ip, [r0, #160]	; 0xa0
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009900:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 8009902:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 8009904:	691a      	ldr	r2, [r3, #16]
 8009906:	07d2      	lsls	r2, r2, #31
 8009908:	d5fc      	bpl.n	8009904 <R3_1_RLTurnOnLowSides+0x18>
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800990a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800990c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8009910:	645a      	str	r2, [r3, #68]	; 0x44
  if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8009912:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 8009916:	2b02      	cmp	r3, #2
 8009918:	d000      	beq.n	800991c <R3_1_RLTurnOnLowSides+0x30>
 800991a:	4770      	bx	lr
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800991c:	e9d0 210f 	ldrd	r2, r1, [r0, #60]	; 0x3c
{
 8009920:	b410      	push	{r4}
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 8009922:	6c43      	ldr	r3, [r0, #68]	; 0x44
    LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 8009924:	f8b0 4048 	ldrh.w	r4, [r0, #72]	; 0x48
 8009928:	6194      	str	r4, [r2, #24]
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800992a:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
    LL_GPIO_ResetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800992e:	f8b0 204c 	ldrh.w	r2, [r0, #76]	; 0x4c
  WRITE_REG(GPIOx->BRR, PinMask);
 8009932:	628c      	str	r4, [r1, #40]	; 0x28
}
 8009934:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009938:	629a      	str	r2, [r3, #40]	; 0x28
 800993a:	4770      	bx	lr

0800993c <R3_1_Init>:
  if (MC_NULL == pHandle)
 800993c:	2800      	cmp	r0, #0
 800993e:	f000 8140 	beq.w	8009bc2 <R3_1_Init+0x286>
{
 8009942:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    R3_3_OPAMPParams_t *OPAMPParams = pHandle->pParams_str->OPAMPParams;
 8009946:	f8d0 509c 	ldr.w	r5, [r0, #156]	; 0x9c
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 800994a:	682e      	ldr	r6, [r5, #0]
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 800994c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 800994e:	6872      	ldr	r2, [r6, #4]
    COMP_TypeDef *COMP_OCPBx = pHandle->pParams_str->CompOCPBSelection;
 8009950:	f8d5 a010 	ldr.w	sl, [r5, #16]
{
 8009954:	b087      	sub	sp, #28
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8009956:	f04f 0c04 	mov.w	ip, #4
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_EOC);
 800995a:	f022 0204 	bic.w	r2, r2, #4
    DAC_TypeDef *DAC_OCPCx = pHandle->pParams_str->DAC_OCP_CSelection;
 800995e:	9401      	str	r4, [sp, #4]
    DAC_TypeDef *DAC_OVPx = pHandle->pParams_str->DAC_OVP_Selection;
 8009960:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8009962:	9402      	str	r4, [sp, #8]
    COMP_TypeDef *COMP_OVPx = pHandle->pParams_str->CompOVPSelection;
 8009964:	e9d5 9805 	ldrd	r9, r8, [r5, #20]
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009968:	686c      	ldr	r4, [r5, #4]
    DAC_TypeDef *DAC_OCPBx = pHandle->pParams_str->DAC_OCP_BSelection;
 800996a:	e9d5 1b07 	ldrd	r1, fp, [r5, #28]
 800996e:	4607      	mov	r7, r0
    COMP_TypeDef *COMP_OCPAx = pHandle->pParams_str->CompOCPASelection;
 8009970:	e9d5 0302 	ldrd	r0, r3, [r5, #8]
 8009974:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_EOC);
 8009976:	f8c6 c000 	str.w	ip, [r6]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 800997a:	6872      	ldr	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 800997c:	f04f 0c20 	mov.w	ip, #32
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_JEOC);
 8009980:	f022 0220 	bic.w	r2, r2, #32
 8009984:	6072      	str	r2, [r6, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOC);
 8009986:	f8c6 c000 	str.w	ip, [r6]
      if (TIM1 ==  TIMx)
 800998a:	4aaa      	ldr	r2, [pc, #680]	; (8009c34 <R3_1_Init+0x2f8>)
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_DBGMCU_APB2_GRP1_FreezePeriph(uint32_t Periphs)
{
  SET_BIT(DBGMCU->APB2FZ, Periphs);
 800998c:	f8df c2b4 	ldr.w	ip, [pc, #692]	; 8009c44 <R3_1_Init+0x308>
 8009990:	4294      	cmp	r4, r2
 8009992:	f8dc 2010 	ldr.w	r2, [ip, #16]
 8009996:	bf0c      	ite	eq
 8009998:	f442 6200 	orreq.w	r2, r2, #2048	; 0x800
 800999c:	f442 5200 	orrne.w	r2, r2, #8192	; 0x2000
 80099a0:	f8cc 2010 	str.w	r2, [ip, #16]
      if (OPAMPParams != NULL)
 80099a4:	b190      	cbz	r0, 80099cc <R3_1_Init+0x90>
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_1[1]);
 80099a6:	e9d0 2c00 	ldrd	r2, ip, [r0]
  * @param  OPAMPx OPAMP instance
  * @retval None
  */
__STATIC_INLINE void LL_OPAMP_Enable(OPAMP_TypeDef *OPAMPx)
{
  SET_BIT(OPAMPx->CSR, OPAMP_CSR_OPAMPxEN);
 80099aa:	f8d2 e000 	ldr.w	lr, [r2]
        LL_OPAMP_Enable(OPAMPParams->OPAMPSelect_2[0]);
 80099ae:	6980      	ldr	r0, [r0, #24]
 80099b0:	f04e 0e01 	orr.w	lr, lr, #1
 80099b4:	f8c2 e000 	str.w	lr, [r2]
 80099b8:	f8dc 2000 	ldr.w	r2, [ip]
 80099bc:	f042 0201 	orr.w	r2, r2, #1
 80099c0:	f8cc 2000 	str.w	r2, [ip]
 80099c4:	6802      	ldr	r2, [r0, #0]
 80099c6:	f042 0201 	orr.w	r2, r2, #1
 80099ca:	6002      	str	r2, [r0, #0]
      if (COMP_OCPAx != NULL)
 80099cc:	b19b      	cbz	r3, 80099f6 <R3_1_Init+0xba>
        if ((pHandle->pParams_str->CompOCPAInvInput_MODE != EXT_MODE) && (DAC_OCPAx != MC_NULL))
 80099ce:	f895 2063 	ldrb.w	r2, [r5, #99]	; 0x63
 80099d2:	2a01      	cmp	r2, #1
 80099d4:	d007      	beq.n	80099e6 <R3_1_Init+0xaa>
 80099d6:	b131      	cbz	r1, 80099e6 <R3_1_Init+0xaa>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPA, DAC_OCPAx,
 80099d8:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 80099dc:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80099de:	9303      	str	r3, [sp, #12]
 80099e0:	f7ff ff38 	bl	8009854 <R3_1_SetAOReferenceVoltage>
 80099e4:	9b03      	ldr	r3, [sp, #12]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Enable(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 80099e6:	681a      	ldr	r2, [r3, #0]
 80099e8:	f042 0201 	orr.w	r2, r2, #1
 80099ec:	601a      	str	r2, [r3, #0]
  * @param  COMPx Comparator instance
  * @retval None
  */
__STATIC_INLINE void LL_COMP_Lock(COMP_TypeDef *COMPx)
{
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 80099ee:	681a      	ldr	r2, [r3, #0]
 80099f0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80099f4:	601a      	str	r2, [r3, #0]
      if (COMP_OCPBx != NULL)
 80099f6:	f1ba 0f00 	cmp.w	sl, #0
 80099fa:	d018      	beq.n	8009a2e <R3_1_Init+0xf2>
        if ((pHandle->pParams_str->CompOCPBInvInput_MODE != EXT_MODE) && (DAC_OCPBx != MC_NULL))
 80099fc:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
 8009a00:	2b01      	cmp	r3, #1
 8009a02:	d008      	beq.n	8009a16 <R3_1_Init+0xda>
 8009a04:	f1bb 0f00 	cmp.w	fp, #0
 8009a08:	d005      	beq.n	8009a16 <R3_1_Init+0xda>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPB, DAC_OCPBx,
 8009a0a:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 8009a0e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8009a10:	4659      	mov	r1, fp
 8009a12:	f7ff ff1f 	bl	8009854 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a16:	f8da 3000 	ldr.w	r3, [sl]
 8009a1a:	f043 0301 	orr.w	r3, r3, #1
 8009a1e:	f8ca 3000 	str.w	r3, [sl]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009a22:	f8da 3000 	ldr.w	r3, [sl]
 8009a26:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009a2a:	f8ca 3000 	str.w	r3, [sl]
      if (COMP_OCPCx != NULL)
 8009a2e:	f1b9 0f00 	cmp.w	r9, #0
 8009a32:	d017      	beq.n	8009a64 <R3_1_Init+0x128>
        if ((pHandle->pParams_str->CompOCPCInvInput_MODE != EXT_MODE)  && (DAC_OCPCx != MC_NULL))
 8009a34:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 8009a38:	2b01      	cmp	r3, #1
 8009a3a:	d007      	beq.n	8009a4c <R3_1_Init+0x110>
 8009a3c:	9b01      	ldr	r3, [sp, #4]
 8009a3e:	b12b      	cbz	r3, 8009a4c <R3_1_Init+0x110>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OCPC, DAC_OCPCx,
 8009a40:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
 8009a44:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8009a46:	4619      	mov	r1, r3
 8009a48:	f7ff ff04 	bl	8009854 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a4c:	f8d9 3000 	ldr.w	r3, [r9]
 8009a50:	f043 0301 	orr.w	r3, r3, #1
 8009a54:	f8c9 3000 	str.w	r3, [r9]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009a58:	f8d9 3000 	ldr.w	r3, [r9]
 8009a5c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009a60:	f8c9 3000 	str.w	r3, [r9]
      if (COMP_OVPx != NULL)
 8009a64:	f1b8 0f00 	cmp.w	r8, #0
 8009a68:	d017      	beq.n	8009a9a <R3_1_Init+0x15e>
        if ((pHandle->pParams_str->CompOVPInvInput_MODE != EXT_MODE) && (DAC_OVPx != MC_NULL))
 8009a6a:	f895 3066 	ldrb.w	r3, [r5, #102]	; 0x66
 8009a6e:	2b01      	cmp	r3, #1
 8009a70:	d007      	beq.n	8009a82 <R3_1_Init+0x146>
 8009a72:	9b02      	ldr	r3, [sp, #8]
 8009a74:	b12b      	cbz	r3, 8009a82 <R3_1_Init+0x146>
          R3_1_SetAOReferenceVoltage(pHandle->pParams_str->DAC_Channel_OVP, DAC_OVPx,
 8009a76:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
 8009a7a:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8009a7c:	4619      	mov	r1, r3
 8009a7e:	f7ff fee9 	bl	8009854 <R3_1_SetAOReferenceVoltage>
  SET_BIT(COMPx->CSR, COMP_CSR_EN);
 8009a82:	f8d8 3000 	ldr.w	r3, [r8]
 8009a86:	f043 0301 	orr.w	r3, r3, #1
 8009a8a:	f8c8 3000 	str.w	r3, [r8]
  SET_BIT(COMPx->CSR, COMP_CSR_LOCK);
 8009a8e:	f8d8 3000 	ldr.w	r3, [r8]
 8009a92:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009a96:	f8c8 3000 	str.w	r3, [r8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8009a9a:	68b3      	ldr	r3, [r6, #8]
 8009a9c:	07da      	lsls	r2, r3, #31
 8009a9e:	d45a      	bmi.n	8009b56 <R3_1_Init+0x21a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8009aa0:	68b3      	ldr	r3, [r6, #8]
 8009aa2:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8009aa6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009aaa:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8009aac:	68b3      	ldr	r3, [r6, #8]
 8009aae:	00db      	lsls	r3, r3, #3
 8009ab0:	d418      	bmi.n	8009ae4 <R3_1_Init+0x1a8>
  MODIFY_REG(ADCx->CR,
 8009ab2:	68b3      	ldr	r3, [r6, #8]
                                         * (SystemCoreClock / (100000UL * 2UL)));
 8009ab4:	4a60      	ldr	r2, [pc, #384]	; (8009c38 <R3_1_Init+0x2fc>)
 8009ab6:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8009aba:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009abe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009ac2:	60b3      	str	r3, [r6, #8]
 8009ac4:	4b5d      	ldr	r3, [pc, #372]	; (8009c3c <R3_1_Init+0x300>)
 8009ac6:	681b      	ldr	r3, [r3, #0]
 8009ac8:	099b      	lsrs	r3, r3, #6
 8009aca:	fba2 2303 	umull	r2, r3, r2, r3
 8009ace:	099b      	lsrs	r3, r3, #6
 8009ad0:	005b      	lsls	r3, r3, #1
    volatile uint32_t wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL)
 8009ad2:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8009ad4:	9b04      	ldr	r3, [sp, #16]
 8009ad6:	b12b      	cbz	r3, 8009ae4 <R3_1_Init+0x1a8>
      wait_loop_index--;
 8009ad8:	9b04      	ldr	r3, [sp, #16]
 8009ada:	3b01      	subs	r3, #1
 8009adc:	9304      	str	r3, [sp, #16]
    while (wait_loop_index != 0UL)
 8009ade:	9b04      	ldr	r3, [sp, #16]
 8009ae0:	2b00      	cmp	r3, #0
 8009ae2:	d1f9      	bne.n	8009ad8 <R3_1_Init+0x19c>
  MODIFY_REG(ADCx->CR,
 8009ae4:	68b3      	ldr	r3, [r6, #8]
 8009ae6:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8009aea:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009aee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009af2:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8009af4:	68b3      	ldr	r3, [r6, #8]
 8009af6:	2b00      	cmp	r3, #0
 8009af8:	dbfc      	blt.n	8009af4 <R3_1_Init+0x1b8>
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009afa:	6833      	ldr	r3, [r6, #0]
 8009afc:	07d8      	lsls	r0, r3, #31
 8009afe:	d408      	bmi.n	8009b12 <R3_1_Init+0x1d6>
  MODIFY_REG(ADCx->CR,
 8009b00:	4a4f      	ldr	r2, [pc, #316]	; (8009c40 <R3_1_Init+0x304>)
 8009b02:	68b3      	ldr	r3, [r6, #8]
 8009b04:	4013      	ands	r3, r2
 8009b06:	f043 0301 	orr.w	r3, r3, #1
 8009b0a:	60b3      	str	r3, [r6, #8]
  return ((READ_BIT(ADCx->ISR, LL_ADC_FLAG_ADRDY) == (LL_ADC_FLAG_ADRDY)) ? 1UL : 0UL);
 8009b0c:	6833      	ldr	r3, [r6, #0]
 8009b0e:	07d9      	lsls	r1, r3, #31
 8009b10:	d5f7      	bpl.n	8009b02 <R3_1_Init+0x1c6>
  MODIFY_REG(ADCx->CR,
 8009b12:	68b3      	ldr	r3, [r6, #8]
 8009b14:	4a4a      	ldr	r2, [pc, #296]	; (8009c40 <R3_1_Init+0x304>)
 8009b16:	4013      	ands	r3, r2
 8009b18:	f043 0308 	orr.w	r3, r3, #8
 8009b1c:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CR,
 8009b1e:	68b3      	ldr	r3, [r6, #8]
 8009b20:	4013      	ands	r3, r2
 8009b22:	f043 0320 	orr.w	r3, r3, #32
 8009b26:	60b3      	str	r3, [r6, #8]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 8009b28:	68f3      	ldr	r3, [r6, #12]
 8009b2a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009b2e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8009b32:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8009b36:	60f3      	str	r3, [r6, #12]
  MODIFY_REG(ADCx->SQR1, ADC_SQR1_L, SequencerNbRanks);
 8009b38:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8009b3a:	f023 030f 	bic.w	r3, r3, #15
 8009b3e:	6333      	str	r3, [r6, #48]	; 0x30
  MODIFY_REG(ADCx->CR,
 8009b40:	68b3      	ldr	r3, [r6, #8]
 8009b42:	4013      	ands	r3, r2
 8009b44:	f043 0304 	orr.w	r3, r3, #4
 8009b48:	60b3      	str	r3, [r6, #8]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_JEOS);
 8009b4a:	2340      	movs	r3, #64	; 0x40
 8009b4c:	6033      	str	r3, [r6, #0]
  SET_BIT(ADCx->IER, LL_ADC_IT_JEOS);
 8009b4e:	6873      	ldr	r3, [r6, #4]
 8009b50:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009b54:	6073      	str	r3, [r6, #4]
  volatile uint32_t Brk2Timeout = 1000;
 8009b56:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009b5a:	9305      	str	r3, [sp, #20]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
 8009b5c:	6823      	ldr	r3, [r4, #0]
 8009b5e:	f023 0301 	bic.w	r3, r3, #1
 8009b62:	6023      	str	r3, [r4, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009b64:	6863      	ldr	r3, [r4, #4]
 8009b66:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009b6a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009b6e:	6063      	str	r3, [r4, #4]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009b70:	69a3      	ldr	r3, [r4, #24]
 8009b72:	f043 0308 	orr.w	r3, r3, #8
 8009b76:	61a3      	str	r3, [r4, #24]
 8009b78:	69a3      	ldr	r3, [r4, #24]
 8009b7a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009b7e:	61a3      	str	r3, [r4, #24]
 8009b80:	69e3      	ldr	r3, [r4, #28]
 8009b82:	f043 0308 	orr.w	r3, r3, #8
 8009b86:	61e3      	str	r3, [r4, #28]
 8009b88:	69e3      	ldr	r3, [r4, #28]
 8009b8a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009b8e:	61e3      	str	r3, [r4, #28]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009b90:	6963      	ldr	r3, [r4, #20]
 8009b92:	f043 0301 	orr.w	r3, r3, #1
 8009b96:	6163      	str	r3, [r4, #20]
  if (2U == pHandle->pParams_str->FreqRatio)
 8009b98:	f895 3067 	ldrb.w	r3, [r5, #103]	; 0x67
 8009b9c:	2b02      	cmp	r3, #2
 8009b9e:	d011      	beq.n	8009bc4 <R3_1_Init+0x288>
    if (M1 == pHandle->_Super.Motor)
 8009ba0:	f897 307a 	ldrb.w	r3, [r7, #122]	; 0x7a
 8009ba4:	b9b3      	cbnz	r3, 8009bd4 <R3_1_Init+0x298>
      if (1U == pHandle->pParams_str->RepetitionCounter)
 8009ba6:	f895 3062 	ldrb.w	r3, [r5, #98]	; 0x62
 8009baa:	2b01      	cmp	r3, #1
 8009bac:	d00e      	beq.n	8009bcc <R3_1_Init+0x290>
      else if (3U == pHandle->pParams_str->RepetitionCounter)
 8009bae:	2b03      	cmp	r3, #3
 8009bb0:	d110      	bne.n	8009bd4 <R3_1_Init+0x298>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009bb2:	2201      	movs	r2, #1
 8009bb4:	6322      	str	r2, [r4, #48]	; 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009bb6:	6962      	ldr	r2, [r4, #20]
 8009bb8:	f042 0201 	orr.w	r2, r2, #1
 8009bbc:	6162      	str	r2, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009bbe:	6323      	str	r3, [r4, #48]	; 0x30
}
 8009bc0:	e008      	b.n	8009bd4 <R3_1_Init+0x298>
 8009bc2:	4770      	bx	lr
    if (HIGHER_FREQ == pHandle->pParams_str->IsHigherFreqTim)
 8009bc4:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
 8009bc8:	2b01      	cmp	r3, #1
 8009bca:	d028      	beq.n	8009c1e <R3_1_Init+0x2e2>
        LL_TIM_SetCounter(TIMx, (uint32_t)(pHandle->Half_PWMPeriod) - 1U);
 8009bcc:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
 8009bd0:	3b01      	subs	r3, #1
  WRITE_REG(TIMx->CNT, Counter);
 8009bd2:	6263      	str	r3, [r4, #36]	; 0x24
  WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
 8009bd4:	f06f 0380 	mvn.w	r3, #128	; 0x80
 8009bd8:	6123      	str	r3, [r4, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8009bda:	6923      	ldr	r3, [r4, #16]
 8009bdc:	05db      	lsls	r3, r3, #23
 8009bde:	d51c      	bpl.n	8009c1a <R3_1_Init+0x2de>
  while ((Brk2Timeout != 0u) && (1U == result))
 8009be0:	9b05      	ldr	r3, [sp, #20]
 8009be2:	b153      	cbz	r3, 8009bfa <R3_1_Init+0x2be>
  WRITE_REG(TIMx->SR, ~(TIM_SR_B2IF));
 8009be4:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009be8:	6122      	str	r2, [r4, #16]
    Brk2Timeout--;
 8009bea:	9b05      	ldr	r3, [sp, #20]
 8009bec:	3b01      	subs	r3, #1
 8009bee:	9305      	str	r3, [sp, #20]
  return ((READ_BIT(TIMx->SR, TIM_SR_B2IF) == (TIM_SR_B2IF)) ? 1UL : 0UL);
 8009bf0:	6923      	ldr	r3, [r4, #16]
 8009bf2:	f413 7f80 	tst.w	r3, #256	; 0x100
  while ((Brk2Timeout != 0u) && (1U == result))
 8009bf6:	9b05      	ldr	r3, [sp, #20]
 8009bf8:	d10c      	bne.n	8009c14 <R3_1_Init+0x2d8>
  SET_BIT(TIMx->DIER, TIM_DIER_BIE);
 8009bfa:	68e3      	ldr	r3, [r4, #12]
 8009bfc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009c00:	60e3      	str	r3, [r4, #12]
  SET_BIT(TIMx->CCER, Channels);
 8009c02:	6a23      	ldr	r3, [r4, #32]
 8009c04:	f443 63aa 	orr.w	r3, r3, #1360	; 0x550
 8009c08:	f043 0305 	orr.w	r3, r3, #5
 8009c0c:	6223      	str	r3, [r4, #32]
}
 8009c0e:	b007      	add	sp, #28
 8009c10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while ((Brk2Timeout != 0u) && (1U == result))
 8009c14:	2b00      	cmp	r3, #0
 8009c16:	d1e7      	bne.n	8009be8 <R3_1_Init+0x2ac>
 8009c18:	e7ef      	b.n	8009bfa <R3_1_Init+0x2be>
 8009c1a:	9b05      	ldr	r3, [sp, #20]
 8009c1c:	e7ed      	b.n	8009bfa <R3_1_Init+0x2be>
      if (3U == pHandle->pParams_str->RepetitionCounter)
 8009c1e:	f895 2062 	ldrb.w	r2, [r5, #98]	; 0x62
 8009c22:	2a03      	cmp	r2, #3
 8009c24:	d1d2      	bne.n	8009bcc <R3_1_Init+0x290>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009c26:	6323      	str	r3, [r4, #48]	; 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8009c28:	6963      	ldr	r3, [r4, #20]
 8009c2a:	f043 0301 	orr.w	r3, r3, #1
 8009c2e:	6163      	str	r3, [r4, #20]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8009c30:	6322      	str	r2, [r4, #48]	; 0x30
}
 8009c32:	e7cb      	b.n	8009bcc <R3_1_Init+0x290>
 8009c34:	40012c00 	.word	0x40012c00
 8009c38:	053e2d63 	.word	0x053e2d63
 8009c3c:	200014a4 	.word	0x200014a4
 8009c40:	7fffffc0 	.word	0x7fffffc0
 8009c44:	e0042000 	.word	0xe0042000

08009c48 <R3_1_SetOffsetCalib>:
{
 8009c48:	b410      	push	{r4}
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8009c4a:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 8009c4e:	680b      	ldr	r3, [r1, #0]
 8009c50:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  pHdl->offsetCalibStatus = true;
 8009c54:	2301      	movs	r3, #1
  pHandle->PhaseAOffset = offsets->phaseAOffset;
 8009c56:	e9c0 4223 	strd	r4, r2, [r0, #140]	; 0x8c
  pHdl->offsetCalibStatus = true;
 8009c5a:	f880 3081 	strb.w	r3, [r0, #129]	; 0x81
}
 8009c5e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009c62:	4770      	bx	lr

08009c64 <R3_1_GetOffsetCalib>:
  offsets->phaseAOffset = pHandle->PhaseAOffset;
 8009c64:	e9d0 2323 	ldrd	r2, r3, [r0, #140]	; 0x8c
 8009c68:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8009c6c:	608b      	str	r3, [r1, #8]
 8009c6e:	e9c1 0200 	strd	r0, r2, [r1]
}
 8009c72:	4770      	bx	lr

08009c74 <R3_1_CurrentReadingPolarization>:
{
 8009c74:	b570      	push	{r4, r5, r6, lr}
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009c76:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009c7a:	e9d3 6500 	ldrd	r6, r5, [r3]
  if (true == pHandle->_Super.offsetCalibStatus)
 8009c7e:	f890 3081 	ldrb.w	r3, [r0, #129]	; 0x81
{
 8009c82:	b084      	sub	sp, #16
 8009c84:	4604      	mov	r4, r0
  if (true == pHandle->_Super.offsetCalibStatus)
 8009c86:	b193      	cbz	r3, 8009cae <R3_1_CurrentReadingPolarization+0x3a>
  MODIFY_REG(ADCx->CR,
 8009c88:	68b3      	ldr	r3, [r6, #8]
 8009c8a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009c8e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009c92:	2280      	movs	r2, #128	; 0x80
 8009c94:	f043 0308 	orr.w	r3, r3, #8
 8009c98:	60b3      	str	r3, [r6, #8]
 8009c9a:	f8a0 2096 	strh.w	r2, [r0, #150]	; 0x96
  pHandle->_Super.Sector = SECTOR_5;
 8009c9e:	2204      	movs	r2, #4
  pHandle->_Super.BrakeActionLock = false;
 8009ca0:	2300      	movs	r3, #0
  pHandle->_Super.Sector = SECTOR_5;
 8009ca2:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
  pHandle->_Super.BrakeActionLock = false;
 8009ca6:	f884 3085 	strb.w	r3, [r4, #133]	; 0x85
}
 8009caa:	b004      	add	sp, #16
 8009cac:	bd70      	pop	{r4, r5, r6, pc}
    GetPhaseCurrCbSave = pHandle->_Super.pFctGetPhaseCurrents;
 8009cae:	6802      	ldr	r2, [r0, #0]
 8009cb0:	9202      	str	r2, [sp, #8]
    SetSampPointSectXCbSave = pHandle->_Super.pFctSetADCSampPointSectX;
 8009cb2:	6942      	ldr	r2, [r0, #20]
 8009cb4:	9203      	str	r2, [sp, #12]
    pHandle->PolarizationCounter = 0U;
 8009cb6:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    pHandle->PhaseBOffset = 0U;
 8009cba:	e9c0 3322 	strd	r3, r3, [r0, #136]	; 0x88
    pHandle->PhaseCOffset = 0U;
 8009cbe:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
  CLEAR_BIT(TIMx->CCER, Channels);
 8009cc2:	6a2b      	ldr	r3, [r5, #32]
 8009cc4:	f423 63aa 	bic.w	r3, r3, #1360	; 0x550
 8009cc8:	f023 0305 	bic.w	r3, r3, #5
 8009ccc:	622b      	str	r3, [r5, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationAB;
 8009cce:	4b3e      	ldr	r3, [pc, #248]	; (8009dc8 <R3_1_CurrentReadingPolarization+0x154>)
 8009cd0:	6003      	str	r3, [r0, #0]
    pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointPolarization;
 8009cd2:	4b3e      	ldr	r3, [pc, #248]	; (8009dcc <R3_1_CurrentReadingPolarization+0x158>)
 8009cd4:	6143      	str	r3, [r0, #20]
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009cd6:	2380      	movs	r3, #128	; 0x80
 8009cd8:	f8a0 3096 	strh.w	r3, [r0, #150]	; 0x96
  pHandle->PolarizationSector=SECTOR_5;
 8009cdc:	2304      	movs	r3, #4
 8009cde:	f880 3099 	strb.w	r3, [r0, #153]	; 0x99
  pHandle->_Super.Sector = SECTOR_5;   
 8009ce2:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8009ce6:	f7ff fc83 	bl	80095f0 <R3_1_SwitchOnPWM>
    while (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_OC4REF)
 8009cea:	4a39      	ldr	r2, [pc, #228]	; (8009dd0 <R3_1_CurrentReadingPolarization+0x15c>)
 8009cec:	686b      	ldr	r3, [r5, #4]
 8009cee:	4013      	ands	r3, r2
 8009cf0:	2b70      	cmp	r3, #112	; 0x70
 8009cf2:	d1fb      	bne.n	8009cec <R3_1_CurrentReadingPolarization+0x78>
 8009cf4:	68b3      	ldr	r3, [r6, #8]
                           pHandle->pParams_str->RepetitionCounter,
 8009cf6:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 8009cfa:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009cfe:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8009d02:	f043 0308 	orr.w	r3, r3, #8
 8009d06:	60b3      	str	r3, [r6, #8]
    waitForPolarizationEnd(TIMx,
 8009d08:	f104 0156 	add.w	r1, r4, #86	; 0x56
 8009d0c:	f104 0398 	add.w	r3, r4, #152	; 0x98
 8009d10:	f892 2062 	ldrb.w	r2, [r2, #98]	; 0x62
 8009d14:	4628      	mov	r0, r5
 8009d16:	e9cd 1300 	strd	r1, r3, [sp]
 8009d1a:	f7ff fb23 	bl	8009364 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8009d1e:	4620      	mov	r0, r4
 8009d20:	f7ff fcb2 	bl	8009688 <R3_1_SwitchOffPWM>
    pHandle->PolarizationCounter = 0U;
 8009d24:	2200      	movs	r2, #0
 8009d26:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98
  pHandle->PolarizationSector=SECTOR_1;
 8009d2a:	f884 2099 	strb.w	r2, [r4, #153]	; 0x99
  pHandle->_Super.Sector = SECTOR_1;   
 8009d2e:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationC;
 8009d32:	4a28      	ldr	r2, [pc, #160]	; (8009dd4 <R3_1_CurrentReadingPolarization+0x160>)
 8009d34:	6022      	str	r2, [r4, #0]
    R3_1_SwitchOnPWM(&pHandle->_Super);
 8009d36:	4620      	mov	r0, r4
 8009d38:	f7ff fc5a 	bl	80095f0 <R3_1_SwitchOnPWM>
                           pHandle->pParams_str->RepetitionCounter,
 8009d3c:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
    waitForPolarizationEnd(TIMx,
 8009d40:	9b01      	ldr	r3, [sp, #4]
 8009d42:	f892 2062 	ldrb.w	r2, [r2, #98]	; 0x62
 8009d46:	9900      	ldr	r1, [sp, #0]
 8009d48:	4628      	mov	r0, r5
 8009d4a:	f7ff fb0b 	bl	8009364 <waitForPolarizationEnd>
    R3_1_SwitchOffPWM(&pHandle->_Super);
 8009d4e:	4620      	mov	r0, r4
 8009d50:	f7ff fc9a 	bl	8009688 <R3_1_SwitchOffPWM>
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009d54:	e9d4 1222 	ldrd	r1, r2, [r4, #136]	; 0x88
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8009d58:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009d5c:	0912      	lsrs	r2, r2, #4
    pHandle->PhaseAOffset /= NB_CONVERSIONS;
 8009d5e:	0909      	lsrs	r1, r1, #4
    pHandle->PhaseBOffset /= NB_CONVERSIONS;
 8009d60:	e9c4 1222 	strd	r1, r2, [r4, #136]	; 0x88
    if (0U == pHandle->_Super.SWerror)
 8009d64:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
    pHandle->PhaseCOffset /= NB_CONVERSIONS;
 8009d68:	091b      	lsrs	r3, r3, #4
 8009d6a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    if (0U == pHandle->_Super.SWerror)
 8009d6e:	b912      	cbnz	r2, 8009d76 <R3_1_CurrentReadingPolarization+0x102>
      pHandle->_Super.offsetCalibStatus = true;
 8009d70:	2301      	movs	r3, #1
 8009d72:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8009d76:	9902      	ldr	r1, [sp, #8]
    pHandle->_Super.pFctSetADCSampPointSectX = SetSampPointSectXCbSave;
 8009d78:	9a03      	ldr	r2, [sp, #12]
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009d7a:	69ab      	ldr	r3, [r5, #24]
 8009d7c:	6162      	str	r2, [r4, #20]
 8009d7e:	f023 0308 	bic.w	r3, r3, #8
    pHandle->_Super.pFctGetPhaseCurrents = GetPhaseCurrCbSave;
 8009d82:	6021      	str	r1, [r4, #0]
 8009d84:	61ab      	str	r3, [r5, #24]
 8009d86:	69aa      	ldr	r2, [r5, #24]
  LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod);
 8009d88:	f8b4 3094 	ldrh.w	r3, [r4, #148]	; 0x94
 8009d8c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8009d90:	61aa      	str	r2, [r5, #24]
 8009d92:	69ea      	ldr	r2, [r5, #28]
 8009d94:	f022 0208 	bic.w	r2, r2, #8
 8009d98:	61ea      	str	r2, [r5, #28]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009d9a:	636b      	str	r3, [r5, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009d9c:	63ab      	str	r3, [r5, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009d9e:	63eb      	str	r3, [r5, #60]	; 0x3c
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009da0:	69ab      	ldr	r3, [r5, #24]
 8009da2:	f043 0308 	orr.w	r3, r3, #8
 8009da6:	61ab      	str	r3, [r5, #24]
 8009da8:	69ab      	ldr	r3, [r5, #24]
 8009daa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009dae:	61ab      	str	r3, [r5, #24]
 8009db0:	69eb      	ldr	r3, [r5, #28]
 8009db2:	f043 0308 	orr.w	r3, r3, #8
 8009db6:	61eb      	str	r3, [r5, #28]
  SET_BIT(TIMx->CCER, Channels);
 8009db8:	6a2b      	ldr	r3, [r5, #32]
 8009dba:	f443 63aa 	orr.w	r3, r3, #1360	; 0x550
 8009dbe:	f043 0305 	orr.w	r3, r3, #5
 8009dc2:	622b      	str	r3, [r5, #32]
}
 8009dc4:	e76b      	b.n	8009c9e <R3_1_CurrentReadingPolarization+0x2a>
 8009dc6:	bf00      	nop
 8009dc8:	08009559 	.word	0x08009559
 8009dcc:	08009515 	.word	0x08009515
 8009dd0:	02000070 	.word	0x02000070
 8009dd4:	080095a9 	.word	0x080095a9

08009dd8 <R3_1_SetADCSampPointSectX>:
  if (MC_NULL == pHdl)
 8009dd8:	2800      	cmp	r0, #0
 8009dda:	d03b      	beq.n	8009e54 <R3_1_SetADCSampPointSectX+0x7c>
{
 8009ddc:	b530      	push	{r4, r5, lr}
    if ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) > pHandle->pParams_str->Tafter)
 8009dde:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 8009de2:	f8b0 e094 	ldrh.w	lr, [r0, #148]	; 0x94
 8009de6:	f8d0 109c 	ldr.w	r1, [r0, #156]	; 0x9c
 8009dea:	ebae 0203 	sub.w	r2, lr, r3
 8009dee:	f8b1 4054 	ldrh.w	r4, [r1, #84]	; 0x54
 8009df2:	b292      	uxth	r2, r2
 8009df4:	42a2      	cmp	r2, r4
 8009df6:	d917      	bls.n	8009e28 <R3_1_SetADCSampPointSectX+0x50>
      pHandle->_Super.Sector = SECTOR_5;
 8009df8:	2204      	movs	r2, #4
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8009dfa:	f10e 33ff 	add.w	r3, lr, #4294967295
      pHandle->_Super.Sector = SECTOR_5;
 8009dfe:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
      SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t)1;
 8009e02:	b29b      	uxth	r3, r3
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009e04:	684a      	ldr	r2, [r1, #4]
  LL_TIM_OC_SetCompareCH1(TIMx, (uint32_t) pHandle->_Super.CntPhA);
 8009e06:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
  LL_TIM_OC_SetCompareCH2(TIMx, (uint32_t) pHandle->_Super.CntPhB);
 8009e0a:	f8b0 4052 	ldrh.w	r4, [r0, #82]	; 0x52
  LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t) pHandle->_Super.CntPhC);
 8009e0e:	f8b0 1054 	ldrh.w	r1, [r0, #84]	; 0x54
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009e12:	6355      	str	r5, [r2, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 8009e14:	6394      	str	r4, [r2, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 8009e16:	63d1      	str	r1, [r2, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 8009e18:	6413      	str	r3, [r2, #64]	; 0x40
  if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 8009e1a:	6852      	ldr	r2, [r2, #4]
 8009e1c:	4b10      	ldr	r3, [pc, #64]	; (8009e60 <R3_1_SetADCSampPointSectX+0x88>)
 8009e1e:	421a      	tst	r2, r3
    returnValue = 0U;
 8009e20:	bf14      	ite	ne
 8009e22:	2001      	movne	r0, #1
 8009e24:	2000      	moveq	r0, #0
}
 8009e26:	bd30      	pop	{r4, r5, pc}
      DeltaDuty = (uint16_t)(pHdl->lowDuty - pHdl->midDuty);
 8009e28:	f8b0 c05a 	ldrh.w	ip, [r0, #90]	; 0x5a
 8009e2c:	eba3 0c0c 	sub.w	ip, r3, ip
      if (DeltaDuty > ((uint16_t)(pHandle->Half_PWMPeriod - pHdl->lowDuty) * 2U))
 8009e30:	fa1f fc8c 	uxth.w	ip, ip
 8009e34:	ebbc 0f42 	cmp.w	ip, r2, lsl #1
 8009e38:	d80d      	bhi.n	8009e56 <R3_1_SetADCSampPointSectX+0x7e>
        SamplingPoint = pHdl->lowDuty + pHandle->pParams_str->Tafter;
 8009e3a:	4423      	add	r3, r4
 8009e3c:	b29b      	uxth	r3, r3
        if (SamplingPoint >= pHandle->Half_PWMPeriod)
 8009e3e:	459e      	cmp	lr, r3
 8009e40:	d8e0      	bhi.n	8009e04 <R3_1_SetADCSampPointSectX+0x2c>
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e42:	43db      	mvns	r3, r3
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8009e44:	f44f 7280 	mov.w	r2, #256	; 0x100
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e48:	eb03 034e 	add.w	r3, r3, lr, lsl #1
          pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_FALLING;
 8009e4c:	f8a0 2096 	strh.w	r2, [r0, #150]	; 0x96
          SamplingPoint = (2U * pHandle->Half_PWMPeriod) - SamplingPoint - (uint16_t)1;
 8009e50:	b29b      	uxth	r3, r3
 8009e52:	e7d7      	b.n	8009e04 <R3_1_SetADCSampPointSectX+0x2c>
}
 8009e54:	4770      	bx	lr
        SamplingPoint = pHdl->lowDuty - pHandle->pParams_str->Tbefore;
 8009e56:	f8b1 2058 	ldrh.w	r2, [r1, #88]	; 0x58
 8009e5a:	1a9b      	subs	r3, r3, r2
 8009e5c:	b29b      	uxth	r3, r3
 8009e5e:	e7d1      	b.n	8009e04 <R3_1_SetADCSampPointSectX+0x2c>
 8009e60:	02000070 	.word	0x02000070

08009e64 <R3_1_TIMx_UP_IRQHandler>:
  if (MC_NULL == pHandle)
 8009e64:	4602      	mov	r2, r0
 8009e66:	2800      	cmp	r0, #0
 8009e68:	d03b      	beq.n	8009ee2 <R3_1_TIMx_UP_IRQHandler+0x7e>
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009e6a:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
{
 8009e6e:	b4f0      	push	{r4, r5, r6, r7}
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009e70:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    ADC_TypeDef *ADCx = pHandle->pParams_str->ADCx;
 8009e74:	6801      	ldr	r1, [r0, #0]
    if (OPAMPParams != NULL)
 8009e76:	b38c      	cbz	r4, 8009edc <R3_1_TIMx_UP_IRQHandler+0x78>
      while (ADCx->JSQR != 0x0u)
 8009e78:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 8009e7a:	2b00      	cmp	r3, #0
 8009e7c:	d1fc      	bne.n	8009e78 <R3_1_TIMx_UP_IRQHandler+0x14>
      operationAmp = OPAMPParams->OPAMPSelect_1[pHandle->_Super.Sector];
 8009e7e:	f892 307c 	ldrb.w	r3, [r2, #124]	; 0x7c
 8009e82:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
      if (operationAmp != NULL)
 8009e86:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8009e8a:	f1bc 0f00 	cmp.w	ip, #0
 8009e8e:	d007      	beq.n	8009ea0 <R3_1_TIMx_UP_IRQHandler+0x3c>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8009e90:	f8dc 6000 	ldr.w	r6, [ip]
 8009e94:	6b27      	ldr	r7, [r4, #48]	; 0x30
 8009e96:	f426 7686 	bic.w	r6, r6, #268	; 0x10c
 8009e9a:	433e      	orrs	r6, r7
 8009e9c:	f8cc 6000 	str.w	r6, [ip]
      operationAmp = OPAMPParams->OPAMPSelect_2[pHandle->_Super.Sector];
 8009ea0:	69a6      	ldr	r6, [r4, #24]
      if (operationAmp != NULL)
 8009ea2:	b12e      	cbz	r6, 8009eb0 <R3_1_TIMx_UP_IRQHandler+0x4c>
        MODIFY_REG(operationAmp->CSR, (OPAMP_CSR_OPAMPINTEN | OPAMP_CSR_VPSEL), OpampConfig);
 8009ea4:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 8009ea6:	6834      	ldr	r4, [r6, #0]
 8009ea8:	f424 7486 	bic.w	r4, r4, #268	; 0x10c
 8009eac:	433c      	orrs	r4, r7
 8009eae:	6034      	str	r4, [r6, #0]
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8009eb0:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8009eb4:	f8b2 3096 	ldrh.w	r3, [r2, #150]	; 0x96
 8009eb8:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8009eba:	4303      	orrs	r3, r0
 8009ebc:	64cb      	str	r3, [r1, #76]	; 0x4c
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8009ebe:	686b      	ldr	r3, [r5, #4]
 8009ec0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009ec4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009ec8:	2180      	movs	r1, #128	; 0x80
 8009eca:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8009ece:	606b      	str	r3, [r5, #4]
    tempPointer = &(pHandle->_Super.Motor);
 8009ed0:	f102 007a 	add.w	r0, r2, #122	; 0x7a
}
 8009ed4:	bcf0      	pop	{r4, r5, r6, r7}
    pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
 8009ed6:	f8a2 1096 	strh.w	r1, [r2, #150]	; 0x96
}
 8009eda:	4770      	bx	lr
    ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
 8009edc:	f892 307c 	ldrb.w	r3, [r2, #124]	; 0x7c
 8009ee0:	e7e6      	b.n	8009eb0 <R3_1_TIMx_UP_IRQHandler+0x4c>
}
 8009ee2:	4770      	bx	lr

08009ee4 <R3_1_RLDetectionModeEnable>:
  if (false == pHandle->_Super.RLDetectionMode)
 8009ee4:	f890 1080 	ldrb.w	r1, [r0, #128]	; 0x80
{
 8009ee8:	b410      	push	{r4}
  if (false == pHandle->_Super.RLDetectionMode)
 8009eea:	2900      	cmp	r1, #0
 8009eec:	d13f      	bne.n	8009f6e <R3_1_RLDetectionModeEnable+0x8a>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009eee:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 8009ef2:	685b      	ldr	r3, [r3, #4]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009ef4:	699a      	ldr	r2, [r3, #24]
 8009ef6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009efa:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009efe:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009f02:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009f04:	6a1a      	ldr	r2, [r3, #32]
 8009f06:	f042 0201 	orr.w	r2, r2, #1
 8009f0a:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f0c:	6a1a      	ldr	r2, [r3, #32]
 8009f0e:	f022 0204 	bic.w	r2, r2, #4
 8009f12:	621a      	str	r2, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009f14:	6359      	str	r1, [r3, #52]	; 0x34
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009f16:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 8009f1a:	2a01      	cmp	r2, #1
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8009f1c:	f103 0418 	add.w	r4, r3, #24
 8009f20:	d033      	beq.n	8009f8a <R3_1_RLDetectionModeEnable+0xa6>
    else if (ES_GPIO ==  pHandle->_Super.LowSideOutputs)
 8009f22:	2a02      	cmp	r2, #2
 8009f24:	d10f      	bne.n	8009f46 <R3_1_RLDetectionModeEnable+0x62>
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f26:	699a      	ldr	r2, [r3, #24]
 8009f28:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009f2c:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 8009f30:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8009f34:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009f36:	6a1a      	ldr	r2, [r3, #32]
 8009f38:	f042 0210 	orr.w	r2, r2, #16
 8009f3c:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f3e:	6a1a      	ldr	r2, [r3, #32]
 8009f40:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009f44:	621a      	str	r2, [r3, #32]
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f46:	6862      	ldr	r2, [r4, #4]
 8009f48:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009f4c:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009f50:	f042 0270 	orr.w	r2, r2, #112	; 0x70
 8009f54:	6062      	str	r2, [r4, #4]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f56:	6a1a      	ldr	r2, [r3, #32]
    pHandle->PhaseAOffset = pHandle->PhaseBOffset; /* Use only the offset of phB */
 8009f58:	f8d0 108c 	ldr.w	r1, [r0, #140]	; 0x8c
 8009f5c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009f60:	621a      	str	r2, [r3, #32]
 8009f62:	6a1a      	ldr	r2, [r3, #32]
 8009f64:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009f68:	621a      	str	r2, [r3, #32]
 8009f6a:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 8009f6e:	4b0f      	ldr	r3, [pc, #60]	; (8009fac <R3_1_RLDetectionModeEnable+0xc8>)
  pHandle->_Super.pFctSwitchOnPwm = &R3_1_RLSwitchOnPWM;
 8009f70:	490f      	ldr	r1, [pc, #60]	; (8009fb0 <R3_1_RLDetectionModeEnable+0xcc>)
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009f72:	4a10      	ldr	r2, [pc, #64]	; (8009fb4 <R3_1_RLDetectionModeEnable+0xd0>)
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 8009f74:	4c10      	ldr	r4, [pc, #64]	; (8009fb8 <R3_1_RLDetectionModeEnable+0xd4>)
  pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
 8009f76:	6103      	str	r3, [r0, #16]
  pHandle->_Super.RLDetectionMode = true;
 8009f78:	2301      	movs	r3, #1
  pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
 8009f7a:	6004      	str	r4, [r0, #0]
  pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 8009f7c:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 8009f80:	f85d 4b04 	ldr.w	r4, [sp], #4
  pHandle->_Super.RLDetectionMode = true;
 8009f84:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
}
 8009f88:	4770      	bx	lr
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009f8a:	699a      	ldr	r2, [r3, #24]
 8009f8c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009f90:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
 8009f94:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009f98:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(TIMx->CCER, Channels);
 8009f9a:	6a1a      	ldr	r2, [r3, #32]
 8009f9c:	f022 0210 	bic.w	r2, r2, #16
 8009fa0:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CCER, Channels);
 8009fa2:	6a1a      	ldr	r2, [r3, #32]
 8009fa4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009fa8:	621a      	str	r2, [r3, #32]
}
 8009faa:	e7cc      	b.n	8009f46 <R3_1_RLDetectionModeEnable+0x62>
 8009fac:	080098ed 	.word	0x080098ed
 8009fb0:	0800975d 	.word	0x0800975d
 8009fb4:	08009689 	.word	0x08009689
 8009fb8:	08009705 	.word	0x08009705

08009fbc <R3_1_RLDetectionModeDisable>:
  if (true ==  pHandle->_Super.RLDetectionMode)
 8009fbc:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8009fc0:	2b00      	cmp	r3, #0
 8009fc2:	d03c      	beq.n	800a03e <R3_1_RLDetectionModeDisable+0x82>
  TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 8009fc4:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 8009fc8:	685b      	ldr	r3, [r3, #4]
{
 8009fca:	b410      	push	{r4}
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009fcc:	699a      	ldr	r2, [r3, #24]
 8009fce:	4c43      	ldr	r4, [pc, #268]	; (800a0dc <R3_1_RLDetectionModeDisable+0x120>)
 8009fd0:	4022      	ands	r2, r4
 8009fd2:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009fd6:	619a      	str	r2, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 8009fd8:	6a1a      	ldr	r2, [r3, #32]
 8009fda:	f042 0201 	orr.w	r2, r2, #1
 8009fde:	621a      	str	r2, [r3, #32]
    if (LS_PWM_TIMER == pHandle->_Super.LowSideOutputs)
 8009fe0:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 8009fe4:	2a01      	cmp	r2, #1
 8009fe6:	d02b      	beq.n	800a040 <R3_1_RLDetectionModeDisable+0x84>
    else if (ES_GPIO == pHandle->_Super.LowSideOutputs)
 8009fe8:	2a02      	cmp	r2, #2
 8009fea:	d050      	beq.n	800a08e <R3_1_RLDetectionModeDisable+0xd2>
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 8009fec:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 8009ff0:	0852      	lsrs	r2, r2, #1
  WRITE_REG(TIMx->CCR1, CompareValue);
 8009ff2:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 8009ff4:	6999      	ldr	r1, [r3, #24]
 8009ff6:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8009ffa:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 8009ffe:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a002:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a004:	6a19      	ldr	r1, [r3, #32]
 800a006:	f041 0110 	orr.w	r1, r1, #16
 800a00a:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a00c:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a00e:	69d9      	ldr	r1, [r3, #28]
 800a010:	4021      	ands	r1, r4
 800a012:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a016:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a018:	6a19      	ldr	r1, [r3, #32]
 800a01a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a01e:	6219      	str	r1, [r3, #32]
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800a020:	492f      	ldr	r1, [pc, #188]	; (800a0e0 <R3_1_RLDetectionModeDisable+0x124>)
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a022:	63da      	str	r2, [r3, #60]	; 0x3c
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800a024:	4a2f      	ldr	r2, [pc, #188]	; (800a0e4 <R3_1_RLDetectionModeDisable+0x128>)
    pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
 800a026:	6001      	str	r1, [r0, #0]
    pHandle->_Super.pFctSwitchOnPwm = &R3_1_SwitchOnPWM;
 800a028:	492f      	ldr	r1, [pc, #188]	; (800a0e8 <R3_1_RLDetectionModeDisable+0x12c>)
    pHandle->_Super.pFctTurnOnLowSides = &R3_1_TurnOnLowSides;
 800a02a:	4c30      	ldr	r4, [pc, #192]	; (800a0ec <R3_1_RLDetectionModeDisable+0x130>)
 800a02c:	6104      	str	r4, [r0, #16]
    pHandle->_Super.RLDetectionMode = false;
 800a02e:	2300      	movs	r3, #0
    pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
 800a030:	e9c0 2101 	strd	r2, r1, [r0, #4]
}
 800a034:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->_Super.RLDetectionMode = false;
 800a038:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
}
 800a03c:	4770      	bx	lr
 800a03e:	4770      	bx	lr
  SET_BIT(TIMx->CCER, Channels);
 800a040:	6a19      	ldr	r1, [r3, #32]
    LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t)pHandle->Half_PWMPeriod) >> 1);
 800a042:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 800a046:	f041 0104 	orr.w	r1, r1, #4
 800a04a:	0852      	lsrs	r2, r2, #1
 800a04c:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a04e:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a050:	6999      	ldr	r1, [r3, #24]
 800a052:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800a056:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 800a05a:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a05e:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a060:	6a19      	ldr	r1, [r3, #32]
 800a062:	f041 0110 	orr.w	r1, r1, #16
 800a066:	6219      	str	r1, [r3, #32]
 800a068:	6a19      	ldr	r1, [r3, #32]
 800a06a:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 800a06e:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a070:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a072:	69d9      	ldr	r1, [r3, #28]
 800a074:	4021      	ands	r1, r4
 800a076:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a07a:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a07c:	6a19      	ldr	r1, [r3, #32]
 800a07e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a082:	6219      	str	r1, [r3, #32]
 800a084:	6a19      	ldr	r1, [r3, #32]
 800a086:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 800a08a:	6219      	str	r1, [r3, #32]
}
 800a08c:	e7c8      	b.n	800a020 <R3_1_RLDetectionModeDisable+0x64>
  CLEAR_BIT(TIMx->CCER, Channels);
 800a08e:	6a19      	ldr	r1, [r3, #32]
 800a090:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
 800a094:	f021 0104 	bic.w	r1, r1, #4
 800a098:	0852      	lsrs	r2, r2, #1
 800a09a:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a09c:	635a      	str	r2, [r3, #52]	; 0x34
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a09e:	6999      	ldr	r1, [r3, #24]
 800a0a0:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800a0a4:	f421 41e6 	bic.w	r1, r1, #29440	; 0x7300
 800a0a8:	f441 41c0 	orr.w	r1, r1, #24576	; 0x6000
 800a0ac:	6199      	str	r1, [r3, #24]
  SET_BIT(TIMx->CCER, Channels);
 800a0ae:	6a19      	ldr	r1, [r3, #32]
 800a0b0:	f041 0110 	orr.w	r1, r1, #16
 800a0b4:	6219      	str	r1, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 800a0b6:	6a19      	ldr	r1, [r3, #32]
 800a0b8:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 800a0bc:	6219      	str	r1, [r3, #32]
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a0be:	639a      	str	r2, [r3, #56]	; 0x38
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a0c0:	69d9      	ldr	r1, [r3, #28]
 800a0c2:	4021      	ands	r1, r4
 800a0c4:	f041 0160 	orr.w	r1, r1, #96	; 0x60
 800a0c8:	61d9      	str	r1, [r3, #28]
  SET_BIT(TIMx->CCER, Channels);
 800a0ca:	6a19      	ldr	r1, [r3, #32]
 800a0cc:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800a0d0:	6219      	str	r1, [r3, #32]
  CLEAR_BIT(TIMx->CCER, Channels);
 800a0d2:	6a19      	ldr	r1, [r3, #32]
 800a0d4:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800a0d8:	6219      	str	r1, [r3, #32]
}
 800a0da:	e7a1      	b.n	800a020 <R3_1_RLDetectionModeDisable+0x64>
 800a0dc:	fffeff8c 	.word	0xfffeff8c
 800a0e0:	080093a1 	.word	0x080093a1
 800a0e4:	08009689 	.word	0x08009689
 800a0e8:	080095f1 	.word	0x080095f1
 800a0ec:	08009801 	.word	0x08009801

0800a0f0 <R3_1_RLDetectionModeSetDuty>:
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a0f0:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a0f4:	f8b0 c094 	ldrh.w	ip, [r0, #148]	; 0x94
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a0f8:	6852      	ldr	r2, [r2, #4]
{
 800a0fa:	4603      	mov	r3, r0
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]), Mode << SHIFT_TAB_OCxx[iChannel]);
 800a0fc:	69d0      	ldr	r0, [r2, #28]
 800a0fe:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a102:	fb0c f101 	mul.w	r1, ip, r1
 800a106:	f420 40e6 	bic.w	r0, r0, #29440	; 0x7300
{
 800a10a:	b410      	push	{r4}
    val = (((uint32_t)pHandle->Half_PWMPeriod) * ((uint32_t)hDuty)) >> 16;
 800a10c:	0c09      	lsrs	r1, r1, #16
    pHandle->ADCRegularLocked = true;
 800a10e:	2401      	movs	r4, #1
 800a110:	f440 40e0 	orr.w	r0, r0, #28672	; 0x7000
 800a114:	f883 40a0 	strb.w	r4, [r3, #160]	; 0xa0
    pHandle->_Super.CntPhA = (uint16_t)val;
 800a118:	f8a3 1050 	strh.w	r1, [r3, #80]	; 0x50
 800a11c:	61d0      	str	r0, [r2, #28]
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800a11e:	f8b3 0076 	ldrh.w	r0, [r3, #118]	; 0x76
    LL_TIM_OC_SetCompareCH3(TIMx, (uint32_t)pHandle->_Super.Toff);
 800a122:	f8b3 4078 	ldrh.w	r4, [r3, #120]	; 0x78
    LL_TIM_OC_SetCompareCH4(TIMx, (((uint32_t)pHandle->Half_PWMPeriod) - ((uint32_t)pHandle->_Super.Ton)));
 800a126:	ebac 0000 	sub.w	r0, ip, r0
  WRITE_REG(TIMx->CCR4, CompareValue);
 800a12a:	6410      	str	r0, [r2, #64]	; 0x40
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a12c:	63d4      	str	r4, [r2, #60]	; 0x3c
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a12e:	6351      	str	r1, [r2, #52]	; 0x34
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 800a130:	6851      	ldr	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a132:	f8b3 0056 	ldrh.w	r0, [r3, #86]	; 0x56
 800a136:	f021 7100 	bic.w	r1, r1, #33554432	; 0x2000000
 800a13a:	f021 0170 	bic.w	r1, r1, #112	; 0x70
    pHdl->Sector = SECTOR_4;
 800a13e:	f04f 0c03 	mov.w	ip, #3
 800a142:	f041 0170 	orr.w	r1, r1, #112	; 0x70
 800a146:	6051      	str	r1, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a148:	2801      	cmp	r0, #1
    pHdl->Sector = SECTOR_4;
 800a14a:	f883 c07c 	strb.w	ip, [r3, #124]	; 0x7c
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a14e:	6852      	ldr	r2, [r2, #4]
    if (1U ==  pHandle->_Super.SWerror)
 800a150:	d007      	beq.n	800a162 <R3_1_RLDetectionModeSetDuty+0x72>
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a152:	4b07      	ldr	r3, [pc, #28]	; (800a170 <R3_1_RLDetectionModeSetDuty+0x80>)
}
 800a154:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET)
 800a158:	421a      	tst	r2, r3
      hAux = MC_DURATION;
 800a15a:	bf14      	ite	ne
 800a15c:	2001      	movne	r0, #1
 800a15e:	2000      	moveq	r0, #0
}
 800a160:	4770      	bx	lr
      pHandle->_Super.SWerror = 0U;
 800a162:	2200      	movs	r2, #0
}
 800a164:	f85d 4b04 	ldr.w	r4, [sp], #4
      pHandle->_Super.SWerror = 0U;
 800a168:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
}
 800a16c:	4770      	bx	lr
 800a16e:	bf00      	nop
 800a170:	02000070 	.word	0x02000070

0800a174 <R3_1_RLTurnOnLowSidesAndStart>:
  }
  else
  {
#endif
    PWMC_R3_1_Handle_t *pHandle = (PWMC_R3_1_Handle_t *)pHdl; //cstat !MISRAC2012-Rule-11.3
    TIM_TypeDef *TIMx = pHandle->pParams_str->TIMx;
 800a174:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 800a178:	685b      	ldr	r3, [r3, #4]

    pHandle->ADCRegularLocked=true;
 800a17a:	2101      	movs	r1, #1
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800a17c:	f06f 0201 	mvn.w	r2, #1
{
 800a180:	b430      	push	{r4, r5}
    pHandle->ADCRegularLocked=true;
 800a182:	f880 10a0 	strb.w	r1, [r0, #160]	; 0xa0
 800a186:	611a      	str	r2, [r3, #16]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800a188:	691a      	ldr	r2, [r3, #16]
 800a18a:	07d1      	lsls	r1, r2, #31
 800a18c:	d5fc      	bpl.n	800a188 <R3_1_RLTurnOnLowSidesAndStart+0x14>
    LL_TIM_ClearFlag_UPDATE(TIMx);

    LL_TIM_OC_SetCompareCH1(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH2(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH3(TIMx, 0x0U);
    LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t )pHandle->Half_PWMPeriod) - 5U);
 800a18e:	f8b0 2094 	ldrh.w	r2, [r0, #148]	; 0x94
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a192:	2100      	movs	r1, #0
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 800a194:	f06f 0401 	mvn.w	r4, #1
 800a198:	3a05      	subs	r2, #5
 800a19a:	611c      	str	r4, [r3, #16]
  WRITE_REG(TIMx->CCR1, CompareValue);
 800a19c:	6359      	str	r1, [r3, #52]	; 0x34
  WRITE_REG(TIMx->CCR2, CompareValue);
 800a19e:	6399      	str	r1, [r3, #56]	; 0x38
  WRITE_REG(TIMx->CCR3, CompareValue);
 800a1a0:	63d9      	str	r1, [r3, #60]	; 0x3c
  WRITE_REG(TIMx->CCR4, CompareValue);
 800a1a2:	641a      	str	r2, [r3, #64]	; 0x40
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 800a1a4:	691a      	ldr	r2, [r3, #16]
 800a1a6:	07d2      	lsls	r2, r2, #31
 800a1a8:	d5fc      	bpl.n	800a1a4 <R3_1_RLTurnOnLowSidesAndStart+0x30>
    {
      /* Nothing to do */
    }

    /* Main PWM Output Enable */
    TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
 800a1aa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1ac:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a1b0:	645a      	str	r2, [r3, #68]	; 0x44
  SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 800a1b2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1b4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800a1b8:	645a      	str	r2, [r3, #68]	; 0x44
    LL_TIM_EnableAllOutputs (TIMx);

    if (ES_GPIO == pHandle->_Super.LowSideOutputs )
 800a1ba:	f890 207d 	ldrb.w	r2, [r0, #125]	; 0x7d
 800a1be:	2a02      	cmp	r2, #2
 800a1c0:	d10b      	bne.n	800a1da <R3_1_RLTurnOnLowSidesAndStart+0x66>
    {
      /* It is executed during calibration phase the EN signal shall stay off */
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800a1c2:	e9d0 410f 	ldrd	r4, r1, [r0, #60]	; 0x3c
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_u_port, pHandle->_Super.pwm_en_u_pin);
 800a1c6:	f8b0 5048 	ldrh.w	r5, [r0, #72]	; 0x48
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800a1ca:	6c42      	ldr	r2, [r0, #68]	; 0x44
  WRITE_REG(GPIOx->BSRR, PinMask);
 800a1cc:	61a5      	str	r5, [r4, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_v_port, pHandle->_Super.pwm_en_v_pin);
 800a1ce:	f8b0 404a 	ldrh.w	r4, [r0, #74]	; 0x4a
 800a1d2:	618c      	str	r4, [r1, #24]
      LL_GPIO_SetOutputPin(pHandle->_Super.pwm_en_w_port, pHandle->_Super.pwm_en_w_pin);
 800a1d4:	f8b0 104c 	ldrh.w	r1, [r0, #76]	; 0x4c
 800a1d8:	6191      	str	r1, [r2, #24]
    else
    {
      /* Nothing to do */
    }

    pHdl->Sector = SECTOR_4;
 800a1da:	2203      	movs	r2, #3
 800a1dc:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
  SET_BIT(TIMx->CCER, Channels);
 800a1e0:	6a1a      	ldr	r2, [r3, #32]
 800a1e2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a1e6:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 800a1e8:	68da      	ldr	r2, [r3, #12]
 800a1ea:	f042 0201 	orr.w	r2, r2, #1

    LL_TIM_EnableIT_UPDATE(TIMx);
#ifdef NULL_PTR_CHECK_R3_1_PWM_CURR_FDB
  }
#endif
}
 800a1ee:	bc30      	pop	{r4, r5}
 800a1f0:	60da      	str	r2, [r3, #12]
 800a1f2:	4770      	bx	lr

0800a1f4 <RVBS_Clear>:
  {
#endif
    uint16_t aux;
    uint16_t index;

    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 800a1f4:	f8b0 c00c 	ldrh.w	ip, [r0, #12]
 800a1f8:	8a42      	ldrh	r2, [r0, #18]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a1fa:	8943      	ldrh	r3, [r0, #10]
    aux = (pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold) / 2U;
 800a1fc:	4494      	add	ip, r2
 800a1fe:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
{
 800a202:	b430      	push	{r4, r5}
 800a204:	2500      	movs	r5, #0
 800a206:	f36c 050f 	bfi	r5, ip, #0, #16
 800a20a:	f36c 451f 	bfi	r5, ip, #16, #16
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a20e:	b14b      	cbz	r3, 800a224 <RVBS_Clear+0x30>
    {
      pHandle->aBuffer[index] = aux;
 800a210:	6944      	ldr	r4, [r0, #20]
 800a212:	2300      	movs	r3, #0
 800a214:	b29a      	uxth	r2, r3
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a216:	3301      	adds	r3, #1
      pHandle->aBuffer[index] = aux;
 800a218:	f824 c012 	strh.w	ip, [r4, r2, lsl #1]
    for (index = 0U; index < pHandle->LowPassFilterBW; index++)
 800a21c:	8941      	ldrh	r1, [r0, #10]
 800a21e:	b29a      	uxth	r2, r3
 800a220:	4291      	cmp	r1, r2
 800a222:	d8f7      	bhi.n	800a214 <RVBS_Clear+0x20>
    }
    pHandle->_Super.LatestConv = aux;
    pHandle->_Super.AvBusVoltage_d = aux;
    pHandle->index = 0U;
 800a224:	2300      	movs	r3, #0
    pHandle->_Super.LatestConv = aux;
 800a226:	6045      	str	r5, [r0, #4]
    pHandle->index = 0U;
 800a228:	7643      	strb	r3, [r0, #25]
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
}
 800a22a:	bc30      	pop	{r4, r5}
 800a22c:	4770      	bx	lr
 800a22e:	bf00      	nop

0800a230 <RVBS_Init>:
{
 800a230:	b508      	push	{r3, lr}
    RVBS_Clear(pHandle);
 800a232:	f7ff ffdf 	bl	800a1f4 <RVBS_Clear>
}
 800a236:	bd08      	pop	{r3, pc}

0800a238 <RVBS_CheckFaultState>:
  }
  else
  {
#endif
	/* If both thresholds are equal, single threshold feature is used */
	if (pHandle->OverVoltageThreshold == pHandle->OverVoltageThresholdLow)
 800a238:	8982      	ldrh	r2, [r0, #12]
 800a23a:	89c1      	ldrh	r1, [r0, #14]
 800a23c:	428a      	cmp	r2, r1
 800a23e:	d00e      	beq.n	800a25e <RVBS_CheckFaultState+0x26>
      }
	}
    else
    {
      /* If both thresholds are different, hysteresis feature is used (Brake mode) */
      if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 800a240:	f8b0 c006 	ldrh.w	ip, [r0, #6]
 800a244:	8a43      	ldrh	r3, [r0, #18]
 800a246:	4563      	cmp	r3, ip
 800a248:	d807      	bhi.n	800a25a <RVBS_CheckFaultState+0x22>
      {
        fault = MC_UNDER_VOLT;
      }
      else if ( false == pHandle->OverVoltageHysteresisUpDir )
 800a24a:	7c03      	ldrb	r3, [r0, #16]
 800a24c:	b98b      	cbnz	r3, 800a272 <RVBS_CheckFaultState+0x3a>
      {
        if (pHandle->_Super.AvBusVoltage_d < pHandle->OverVoltageThresholdLow)
 800a24e:	4561      	cmp	r1, ip
 800a250:	d913      	bls.n	800a27a <RVBS_CheckFaultState+0x42>
        {
          pHandle->OverVoltageHysteresisUpDir = true;
 800a252:	2201      	movs	r2, #1
 800a254:	7402      	strb	r2, [r0, #16]
          fault = MC_NO_ERROR;
 800a256:	4618      	mov	r0, r3
 800a258:	4770      	bx	lr
        fault = MC_UNDER_VOLT;
 800a25a:	2004      	movs	r0, #4
 800a25c:	4770      	bx	lr
      if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 800a25e:	88c3      	ldrh	r3, [r0, #6]
 800a260:	429a      	cmp	r2, r3
 800a262:	d30a      	bcc.n	800a27a <RVBS_CheckFaultState+0x42>
      else if (pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold)
 800a264:	8a40      	ldrh	r0, [r0, #18]
 800a266:	4298      	cmp	r0, r3
 800a268:	bf94      	ite	ls
 800a26a:	2000      	movls	r0, #0
 800a26c:	2001      	movhi	r0, #1
 800a26e:	0080      	lsls	r0, r0, #2
 800a270:	4770      	bx	lr
          fault = MC_OVER_VOLT;
        }
      }
      else
      {
        if (pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold)
 800a272:	4562      	cmp	r2, ip
 800a274:	d303      	bcc.n	800a27e <RVBS_CheckFaultState+0x46>
        {
          pHandle->OverVoltageHysteresisUpDir = false;
          fault = MC_OVER_VOLT;
        }
        else{
          fault = MC_NO_ERROR;
 800a276:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_RDIV_BUS_VLT_SNS
  }
#endif
  return (fault);
}
 800a278:	4770      	bx	lr
        fault = MC_OVER_VOLT;
 800a27a:	2002      	movs	r0, #2
 800a27c:	4770      	bx	lr
          pHandle->OverVoltageHysteresisUpDir = false;
 800a27e:	2300      	movs	r3, #0
 800a280:	7403      	strb	r3, [r0, #16]
          fault = MC_OVER_VOLT;
 800a282:	2002      	movs	r0, #2
 800a284:	4770      	bx	lr
 800a286:	bf00      	nop

0800a288 <RVBS_CalcAvVbus>:
{
 800a288:	b538      	push	{r3, r4, r5, lr}
    if (0xFFFFU == hAux)
 800a28a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800a28e:	4299      	cmp	r1, r3
{
 800a290:	4604      	mov	r4, r0
    if (0xFFFFU == hAux)
 800a292:	d021      	beq.n	800a2d8 <RVBS_CalcAvVbus+0x50>
      pHandle->aBuffer[pHandle->index] = hAux;
 800a294:	6943      	ldr	r3, [r0, #20]
 800a296:	7e45      	ldrb	r5, [r0, #25]
 800a298:	f823 1015 	strh.w	r1, [r3, r5, lsl #1]
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a29c:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
 800a2a0:	f01e 02ff 	ands.w	r2, lr, #255	; 0xff
 800a2a4:	d00d      	beq.n	800a2c2 <RVBS_CalcAvVbus+0x3a>
 800a2a6:	3a01      	subs	r2, #1
 800a2a8:	b2d2      	uxtb	r2, r2
 800a2aa:	eb03 0042 	add.w	r0, r3, r2, lsl #1
 800a2ae:	3b02      	subs	r3, #2
      wtemp = 0u;
 800a2b0:	2200      	movs	r2, #0
        wtemp += pHandle->aBuffer[i];
 800a2b2:	f833 cf02 	ldrh.w	ip, [r3, #2]!
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a2b6:	4298      	cmp	r0, r3
        wtemp += pHandle->aBuffer[i];
 800a2b8:	4462      	add	r2, ip
      for (i = 0U; i < (uint8_t)pHandle->LowPassFilterBW; i++)
 800a2ba:	d1fa      	bne.n	800a2b2 <RVBS_CalcAvVbus+0x2a>
      wtemp /= pHandle->LowPassFilterBW;
 800a2bc:	fbb2 f2fe 	udiv	r2, r2, lr
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 800a2c0:	b292      	uxth	r2, r2
      if ((uint16_t)pHandle->index < (pHandle->LowPassFilterBW - 1U))
 800a2c2:	f10e 3eff 	add.w	lr, lr, #4294967295
 800a2c6:	4575      	cmp	r5, lr
        pHandle->index++;
 800a2c8:	bf34      	ite	cc
 800a2ca:	3501      	addcc	r5, #1
        pHandle->index = 0U;
 800a2cc:	2300      	movcs	r3, #0
      pHandle->_Super.AvBusVoltage_d = (uint16_t)wtemp;
 800a2ce:	80e2      	strh	r2, [r4, #6]
      pHandle->_Super.LatestConv = hAux;
 800a2d0:	80a1      	strh	r1, [r4, #4]
        pHandle->index++;
 800a2d2:	bf34      	ite	cc
 800a2d4:	7665      	strbcc	r5, [r4, #25]
        pHandle->index = 0U;
 800a2d6:	7663      	strbcs	r3, [r4, #25]
    pHandle->_Super.FaultState = RVBS_CheckFaultState(pHandle);
 800a2d8:	4620      	mov	r0, r4
 800a2da:	f7ff ffad 	bl	800a238 <RVBS_CheckFaultState>
 800a2de:	8120      	strh	r0, [r4, #8]
}
 800a2e0:	bd38      	pop	{r3, r4, r5, pc}
 800a2e2:	bf00      	nop

0800a2e4 <REMNG_Init>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->Ext = 0;
 800a2e4:	2300      	movs	r3, #0
    pHandle->TargetFinal = 0;
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
    pHandle->ScalingFactor = 1U;
 800a2e6:	2201      	movs	r2, #1
    pHandle->TargetFinal = 0;
 800a2e8:	e9c0 3301 	strd	r3, r3, [r0, #4]
    pHandle->IncDecAmount = 0;
 800a2ec:	e9c0 3303 	strd	r3, r3, [r0, #12]
    pHandle->ScalingFactor = 1U;
 800a2f0:	6142      	str	r2, [r0, #20]
#ifdef NULL_PTR_CHECK_RMP_EXT_MNG
  }
#endif
}
 800a2f2:	4770      	bx	lr

0800a2f4 <SPD_GetElAngle>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hElAngle);
#else
  return (pHandle->hElAngle);
#endif
}
 800a2f4:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 800a2f8:	4770      	bx	lr
 800a2fa:	bf00      	nop

0800a2fc <SPD_GetAvrgMecSpeedUnit>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->hAvrMecSpeedUnit);
#else
  return (pHandle->hAvrMecSpeedUnit);
#endif
}
 800a2fc:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 800a300:	4770      	bx	lr
 800a302:	bf00      	nop

0800a304 <SPD_GetInstElSpeedDpp>:
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  return ((MC_NULL == pHandle) ? 0 : pHandle->InstantaneousElSpeedDpp);
#else
  return (pHandle->InstantaneousElSpeedDpp);
#endif
}
 800a304:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
 800a308:	4770      	bx	lr
 800a30a:	bf00      	nop

0800a30c <SPD_IsMecSpeedReliable>:
    bool SpeedError = false;

    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;

    /* Compute absoulte value of mechanical speed */
    if (*pMecSpeedUnit < 0)
 800a30c:	f9b1 3000 	ldrsh.w	r3, [r1]
    else
    {
      /* Nothing to do */
    }

    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a310:	f8b0 c016 	ldrh.w	ip, [r0, #22]
{
 800a314:	b410      	push	{r4}
    if (*pMecSpeedUnit < 0)
 800a316:	2b00      	cmp	r3, #0
      hAux = -(*pMecSpeedUnit);
 800a318:	bfb8      	it	lt
 800a31a:	425b      	neglt	r3, r3
      hAbsMecSpeedUnit = (uint16_t)(*pMecSpeedUnit);
 800a31c:	b29b      	uxth	r3, r3
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a31e:	459c      	cmp	ip, r3
    uint8_t bMaximumSpeedErrorsNumber = pHandle->bMaximumSpeedErrorsNumber;
 800a320:	78c1      	ldrb	r1, [r0, #3]
    bSpeedErrorNumber = pHandle->bSpeedErrorNumber;
 800a322:	7802      	ldrb	r2, [r0, #0]
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 800a324:	8a84      	ldrh	r4, [r0, #20]
    if (hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit)
 800a326:	d819      	bhi.n	800a35c <SPD_IsMecSpeedReliable+0x50>
    if (hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit)
 800a328:	429c      	cmp	r4, r3
 800a32a:	bf2c      	ite	cs
 800a32c:	2400      	movcs	r4, #0
 800a32e:	2401      	movcc	r4, #1
    {
      /* Nothing to do */
    }

    /* Compute absoulte value of mechanical acceleration */
    if (pHandle->hMecAccelUnitP < 0)
 800a330:	f9b0 3012 	ldrsh.w	r3, [r0, #18]
    else
    {
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
    }

    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 800a334:	f8b0 c018 	ldrh.w	ip, [r0, #24]
    if (pHandle->hMecAccelUnitP < 0)
 800a338:	2b00      	cmp	r3, #0
      hAux = -(pHandle->hMecAccelUnitP);
 800a33a:	bfb8      	it	lt
 800a33c:	425b      	neglt	r3, r3
      hAbsMecAccelUnitP = (uint16_t)pHandle->hMecAccelUnitP;
 800a33e:	b29b      	uxth	r3, r3
    if (hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP)
 800a340:	459c      	cmp	ip, r3
 800a342:	d300      	bcc.n	800a346 <SPD_IsMecSpeedReliable+0x3a>
    else
    {
      /* Nothing to do */
    }

    if (true == SpeedError)
 800a344:	b164      	cbz	r4, 800a360 <SPD_IsMecSpeedReliable+0x54>
    {
      if (bSpeedErrorNumber < bMaximumSpeedErrorsNumber)
 800a346:	4291      	cmp	r1, r2
 800a348:	d901      	bls.n	800a34e <SPD_IsMecSpeedReliable+0x42>
      {
        bSpeedErrorNumber++;
 800a34a:	3201      	adds	r2, #1
 800a34c:	b2d2      	uxtb	r2, r2
    else
    {
      /* Nothing to do */
    }

    pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
 800a34e:	7002      	strb	r2, [r0, #0]
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (SpeedSensorReliability);
}
 800a350:	1a50      	subs	r0, r2, r1
 800a352:	bf18      	it	ne
 800a354:	2001      	movne	r0, #1
 800a356:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a35a:	4770      	bx	lr
      SpeedError = true;
 800a35c:	2401      	movs	r4, #1
 800a35e:	e7e7      	b.n	800a330 <SPD_IsMecSpeedReliable+0x24>
        bSpeedErrorNumber = 0u;
 800a360:	4291      	cmp	r1, r2
 800a362:	bf88      	it	hi
 800a364:	2200      	movhi	r2, #0
 800a366:	e7f2      	b.n	800a34e <SPD_IsMecSpeedReliable+0x42>

0800a368 <SPD_GetS16Speed>:
  }
  else
  {
#endif
    int32_t wAux = (int32_t)pHandle->hAvrMecSpeedUnit;
    wAux *= INT16_MAX;
 800a368:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 800a36c:	f9b0 2014 	ldrsh.w	r2, [r0, #20]
    wAux *= INT16_MAX;
 800a370:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    wAux /= (int16_t)pHandle->hMaxReliableMecSpeedUnit;
 800a374:	fb93 f0f2 	sdiv	r0, r3, r2
    tempValue = (int16_t)wAux;
#ifdef NULL_PTR_CHECK_SPD_POS_FBK
  }
#endif
  return (tempValue);
}
 800a378:	b200      	sxth	r0, r0
 800a37a:	4770      	bx	lr

0800a37c <STC_Init>:
  {
#endif
    pHandle->PISpeed = pPI;
    pHandle->SPD = SPD_Handle;
    pHandle->Mode = pHandle->ModeDefault;
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 800a37c:	f9b0 c02c 	ldrsh.w	ip, [r0, #44]	; 0x2c
    pHandle->PISpeed = pPI;
 800a380:	6101      	str	r1, [r0, #16]
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800a382:	f9b0 102e 	ldrsh.w	r1, [r0, #46]	; 0x2e
    pHandle->SPD = SPD_Handle;
 800a386:	6142      	str	r2, [r0, #20]
{
 800a388:	b410      	push	{r4}
    pHandle->Mode = pHandle->ModeDefault;
 800a38a:	f890 402a 	ldrb.w	r4, [r0, #42]	; 0x2a
 800a38e:	7004      	strb	r4, [r0, #0]
    pHandle->TargetFinal = 0;
 800a390:	2300      	movs	r3, #0
    pHandle->SpeedRefUnitExt = ((int32_t)pHandle->MecSpeedRefUnitDefault) * 65536;
 800a392:	ea4f 440c 	mov.w	r4, ip, lsl #16
    pHandle->TorqueRef = ((int32_t)pHandle->TorqueRefDefault) * 65536;
 800a396:	0409      	lsls	r1, r1, #16
 800a398:	e9c0 4101 	strd	r4, r1, [r0, #4]
    pHandle->TargetFinal = 0;
 800a39c:	8043      	strh	r3, [r0, #2]
    pHandle->RampRemainingStep = 0U;
    pHandle->IncDecAmount = 0;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a39e:	f85d 4b04 	ldr.w	r4, [sp], #4
    pHandle->RampRemainingStep = 0U;
 800a3a2:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 800a3a4:	6183      	str	r3, [r0, #24]
}
 800a3a6:	4770      	bx	lr

0800a3a8 <STC_SetSpeedSensor>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SPD = SPD_Handle;
 800a3a8:	6141      	str	r1, [r0, #20]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3aa:	4770      	bx	lr

0800a3ac <STC_GetSpeedSensor>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL ==  pHandle) ? MC_NULL : pHandle->SPD);
#else
  return (pHandle->SPD);
#endif
}
 800a3ac:	6940      	ldr	r0, [r0, #20]
 800a3ae:	4770      	bx	lr

0800a3b0 <STC_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a3b0:	7803      	ldrb	r3, [r0, #0]
 800a3b2:	2b03      	cmp	r3, #3
 800a3b4:	d000      	beq.n	800a3b8 <STC_Clear+0x8>
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3b6:	4770      	bx	lr
      PID_SetIntegralTerm(pHandle->PISpeed, 0);
 800a3b8:	6900      	ldr	r0, [r0, #16]
 800a3ba:	2100      	movs	r1, #0
 800a3bc:	f7fe bee8 	b.w	8009190 <PID_SetIntegralTerm>

0800a3c0 <STC_GetMecSpeedRefUnit>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->SpeedRefUnitExt / 65536));
#else
  return ((int16_t)(pHandle->SpeedRefUnitExt / 65536));
#endif
#endif
}
 800a3c0:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 800a3c4:	4770      	bx	lr
 800a3c6:	bf00      	nop

0800a3c8 <STC_GetTorqueRef>:
  return ((MC_NULL == pHandle) ? 0 : (int16_t)(pHandle->TorqueRef / 65536));
#else
  return ((int16_t)(pHandle->TorqueRef / 65536));
#endif
#endif
}
 800a3c8:	f9b0 000a 	ldrsh.w	r0, [r0, #10]
 800a3cc:	4770      	bx	lr
 800a3ce:	bf00      	nop

0800a3d0 <STC_SetControlMode>:
  }
  else
  {
#endif
    pHandle->Mode = bMode;
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 800a3d0:	2300      	movs	r3, #0
    pHandle->Mode = bMode;
 800a3d2:	7001      	strb	r1, [r0, #0]
    pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp */
 800a3d4:	60c3      	str	r3, [r0, #12]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a3d6:	4770      	bx	lr

0800a3d8 <STC_ExecRamp>:
  * @ref EncAlignCtrl "Encoder Alignment Control",
  * @ref PositionControl "Position Control" loop or
  * speed regulation with @ref SpeedRegulatorPotentiometer Speed potentiometer.
  */
__weak bool STC_ExecRamp(SpeednTorqCtrl_Handle_t *pHandle, int16_t hTargetFinal, uint32_t hDurationms)
{
 800a3d8:	b570      	push	{r4, r5, r6, lr}
    uint32_t wAux;
    int32_t wAux1;
    int16_t hCurrentReference;

    /* Check if the hTargetFinal is out of the bound of application */
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a3da:	7803      	ldrb	r3, [r0, #0]
 800a3dc:	2b04      	cmp	r3, #4
{
 800a3de:	4604      	mov	r4, r0
 800a3e0:	460d      	mov	r5, r1
 800a3e2:	4616      	mov	r6, r2
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a3e4:	d01e      	beq.n	800a424 <STC_ExecRamp+0x4c>
#else
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt / 65536);
#endif

#ifdef CHECK_BOUNDARY
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 800a3e6:	8bc3      	ldrh	r3, [r0, #30]
      hCurrentReference = (int16_t)(pHandle->SpeedRefUnitExt >> 16);
 800a3e8:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxAppPositiveMecSpeedUnit)
 800a3ec:	4299      	cmp	r1, r3
 800a3ee:	dd01      	ble.n	800a3f4 <STC_ExecRamp+0x1c>
        allowedRange = false;
 800a3f0:	2000      	movs	r0, #0
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (allowedRange);
}
 800a3f2:	bd70      	pop	{r4, r5, r6, pc}
      else if (hTargetFinal < pHandle->MinAppNegativeMecSpeedUnit)
 800a3f4:	f9b4 3024 	ldrsh.w	r3, [r4, #36]	; 0x24
 800a3f8:	428b      	cmp	r3, r1
 800a3fa:	dcf9      	bgt.n	800a3f0 <STC_ExecRamp+0x18>
      else if ((int32_t)hTargetFinal < (int32_t)pHandle->MinAppPositiveMecSpeedUnit)
 800a3fc:	8c23      	ldrh	r3, [r4, #32]
 800a3fe:	4299      	cmp	r1, r3
 800a400:	da03      	bge.n	800a40a <STC_ExecRamp+0x32>
        if (hTargetFinal > pHandle->MaxAppNegativeMecSpeedUnit)
 800a402:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
 800a406:	428b      	cmp	r3, r1
 800a408:	dbf2      	blt.n	800a3f0 <STC_ExecRamp+0x18>
      if (0U == hDurationms)
 800a40a:	b9ae      	cbnz	r6, 800a438 <STC_ExecRamp+0x60>
        if (MCM_SPEED_MODE == pHandle->Mode)
 800a40c:	7823      	ldrb	r3, [r4, #0]
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 800a40e:	042d      	lsls	r5, r5, #16
        if (MCM_SPEED_MODE == pHandle->Mode)
 800a410:	2b03      	cmp	r3, #3
        pHandle->RampRemainingStep = 0U;
 800a412:	f04f 0300 	mov.w	r3, #0
          pHandle->SpeedRefUnitExt = ((int32_t)hTargetFinal) * 65536;
 800a416:	bf0c      	ite	eq
 800a418:	6065      	streq	r5, [r4, #4]
          pHandle->TorqueRef = ((int32_t)hTargetFinal) * 65536;
 800a41a:	60a5      	strne	r5, [r4, #8]
        pHandle->RampRemainingStep = 0U;
 800a41c:	60e3      	str	r3, [r4, #12]
        pHandle->IncDecAmount = 0;
 800a41e:	61a3      	str	r3, [r4, #24]
 800a420:	2001      	movs	r0, #1
}
 800a422:	bd70      	pop	{r4, r5, r6, pc}
      hCurrentReference = STC_GetTorqueRef(pHandle);
 800a424:	f7ff ffd0 	bl	800a3c8 <STC_GetTorqueRef>
      if ((int32_t)hTargetFinal > (int32_t)pHandle->MaxPositiveTorque)
 800a428:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800a42a:	429d      	cmp	r5, r3
 800a42c:	dce0      	bgt.n	800a3f0 <STC_ExecRamp+0x18>
      if ((int32_t)hTargetFinal < (int32_t)pHandle->MinNegativeTorque)
 800a42e:	f9b4 3028 	ldrsh.w	r3, [r4, #40]	; 0x28
 800a432:	42ab      	cmp	r3, r5
 800a434:	dcdc      	bgt.n	800a3f0 <STC_ExecRamp+0x18>
 800a436:	e7e8      	b.n	800a40a <STC_ExecRamp+0x32>
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 800a438:	8ba3      	ldrh	r3, [r4, #28]
        wAux /= 1000U;
 800a43a:	4a08      	ldr	r2, [pc, #32]	; (800a45c <STC_ExecRamp+0x84>)
        pHandle->TargetFinal = hTargetFinal;
 800a43c:	8065      	strh	r5, [r4, #2]
        wAux = ((uint32_t)hDurationms) * ((uint32_t)pHandle->STCFrequencyHz);
 800a43e:	fb06 f303 	mul.w	r3, r6, r3
        wAux /= 1000U;
 800a442:	fba2 2303 	umull	r2, r3, r2, r3
 800a446:	099b      	lsrs	r3, r3, #6
        pHandle->RampRemainingStep++;
 800a448:	3301      	adds	r3, #1
        wAux1 = (((int32_t)hTargetFinal) - ((int32_t)hCurrentReference)) * 65536;
 800a44a:	1a28      	subs	r0, r5, r0
 800a44c:	0400      	lsls	r0, r0, #16
        pHandle->RampRemainingStep++;
 800a44e:	60e3      	str	r3, [r4, #12]
        wAux1 /= ((int32_t)pHandle->RampRemainingStep);
 800a450:	fb90 f0f3 	sdiv	r0, r0, r3
        pHandle->IncDecAmount = wAux1;
 800a454:	61a0      	str	r0, [r4, #24]
 800a456:	2001      	movs	r0, #1
}
 800a458:	bd70      	pop	{r4, r5, r6, pc}
 800a45a:	bf00      	nop
 800a45c:	10624dd3 	.word	0x10624dd3

0800a460 <STC_StopRamp>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->RampRemainingStep = 0U;
 800a460:	2300      	movs	r3, #0
 800a462:	60c3      	str	r3, [r0, #12]
    pHandle->IncDecAmount = 0;
 800a464:	6183      	str	r3, [r0, #24]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a466:	4770      	bx	lr

0800a468 <STC_CalcTorqueReference>:
  * - Must be called at fixed time equal to hSTCFrequencyHz. It is called
  * passing as parameter the speed sensor used to perform the speed regulation.
  * - Called during START and ALIGNEMENT states of the MC state machine into MediumFrequencyTask.
  */
__weak int16_t STC_CalcTorqueReference(SpeednTorqCtrl_Handle_t *pHandle)
{
 800a468:	b538      	push	{r3, r4, r5, lr}
    int16_t hTargetSpeed;
    int16_t hError;

    if (MCM_TORQUE_MODE == pHandle->Mode)
    {
      wCurrentReference = pHandle->TorqueRef;
 800a46a:	e9d0 5101 	ldrd	r5, r1, [r0, #4]
    if (MCM_TORQUE_MODE == pHandle->Mode)
 800a46e:	7802      	ldrb	r2, [r0, #0]
      wCurrentReference = pHandle->SpeedRefUnitExt;
    }

    /* Update the speed reference or the torque reference according to the mode
       and terminates the ramp if needed */
    if (pHandle->RampRemainingStep > 1U)
 800a470:	68c3      	ldr	r3, [r0, #12]
      wCurrentReference = pHandle->TorqueRef;
 800a472:	2a04      	cmp	r2, #4
 800a474:	bf08      	it	eq
 800a476:	460d      	moveq	r5, r1
    if (pHandle->RampRemainingStep > 1U)
 800a478:	2b01      	cmp	r3, #1
{
 800a47a:	4604      	mov	r4, r0
    if (pHandle->RampRemainingStep > 1U)
 800a47c:	d908      	bls.n	800a490 <STC_CalcTorqueReference+0x28>
    {
      /* Increment/decrement the reference value */
      wCurrentReference += pHandle->IncDecAmount;
 800a47e:	6981      	ldr	r1, [r0, #24]

      /* Decrement the number of remaining steps */
      pHandle->RampRemainingStep--;
 800a480:	3b01      	subs	r3, #1
      wCurrentReference += pHandle->IncDecAmount;
 800a482:	440d      	add	r5, r1
      pHandle->RampRemainingStep--;
 800a484:	60c3      	str	r3, [r0, #12]
    else
    {
      /* Do nothing */
    }

    if (MCM_SPEED_MODE == pHandle->Mode)
 800a486:	2a03      	cmp	r2, #3
 800a488:	d00b      	beq.n	800a4a2 <STC_CalcTorqueReference+0x3a>
    else
    {
      pHandle->TorqueRef = wCurrentReference;
#ifndef FULL_MISRA_C_COMPLIANCY_SPD_TORQ_CTRL
      //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hTorqueReference = (int16_t)(wCurrentReference >> 16);
 800a48a:	1428      	asrs	r0, r5, #16
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 800a48c:	60a5      	str	r5, [r4, #8]
    }
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (hTorqueReference);
}
 800a48e:	bd38      	pop	{r3, r4, r5, pc}
    else if (1U == pHandle->RampRemainingStep)
 800a490:	d1f9      	bne.n	800a486 <STC_CalcTorqueReference+0x1e>
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 800a492:	f9b0 5002 	ldrsh.w	r5, [r0, #2]
      pHandle->RampRemainingStep = 0U;
 800a496:	2300      	movs	r3, #0
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a498:	2a03      	cmp	r2, #3
      wCurrentReference = ((int32_t)pHandle->TargetFinal) * 65536;
 800a49a:	ea4f 4505 	mov.w	r5, r5, lsl #16
      pHandle->RampRemainingStep = 0U;
 800a49e:	60c3      	str	r3, [r0, #12]
    if (MCM_SPEED_MODE == pHandle->Mode)
 800a4a0:	d1f3      	bne.n	800a48a <STC_CalcTorqueReference+0x22>
      hMeasuredSpeed = SPD_GetAvrgMecSpeedUnit(pHandle->SPD);
 800a4a2:	6960      	ldr	r0, [r4, #20]
 800a4a4:	f7ff ff2a 	bl	800a2fc <SPD_GetAvrgMecSpeedUnit>
      hError = hTargetSpeed - hMeasuredSpeed;
 800a4a8:	ebc0 4125 	rsb	r1, r0, r5, asr #16
      hTorqueReference = PI_Controller(pHandle->PISpeed, (int32_t)hError);
 800a4ac:	b209      	sxth	r1, r1
 800a4ae:	6920      	ldr	r0, [r4, #16]
 800a4b0:	f7fe fea0 	bl	80091f4 <PI_Controller>
      pHandle->SpeedRefUnitExt = wCurrentReference;
 800a4b4:	6065      	str	r5, [r4, #4]
      pHandle->TorqueRef = ((int32_t)hTorqueReference) * 65536;
 800a4b6:	0405      	lsls	r5, r0, #16
 800a4b8:	60a5      	str	r5, [r4, #8]
}
 800a4ba:	bd38      	pop	{r3, r4, r5, pc}

0800a4bc <STC_GetMecSpeedRefUnitDefault>:
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  return ((MC_NULL == pHandle) ? 0 : pHandle->MecSpeedRefUnitDefault);
#else
  return (pHandle->MecSpeedRefUnitDefault);
#endif
}
 800a4bc:	f9b0 002c 	ldrsh.w	r0, [r0, #44]	; 0x2c
 800a4c0:	4770      	bx	lr
 800a4c2:	bf00      	nop

0800a4c4 <STC_GetDefaultIqdref>:
    IqdRefDefault.d = 0;
  }
  else
  {
#endif
    IqdRefDefault.q = pHandle->TorqueRefDefault;
 800a4c4:	f8d0 302e 	ldr.w	r3, [r0, #46]	; 0x2e
    IqdRefDefault.d = pHandle->IdrefDefault;
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
  return (IqdRefDefault);
 800a4c8:	2200      	movs	r2, #0
 800a4ca:	b299      	uxth	r1, r3
 800a4cc:	f361 020f 	bfi	r2, r1, #0, #16
 800a4d0:	0c1b      	lsrs	r3, r3, #16
 800a4d2:	f363 421f 	bfi	r2, r3, #16, #16
{
 800a4d6:	b082      	sub	sp, #8
}
 800a4d8:	4610      	mov	r0, r2
 800a4da:	b002      	add	sp, #8
 800a4dc:	4770      	bx	lr
 800a4de:	bf00      	nop

0800a4e0 <STC_ForceSpeedReferenceToCurrentSpeed>:
  *
  * - Called during the CHARGE_BOOT_CAP, SWITCH_OVER and WAIT_STOP_MOTOR states of the MC state machine
  * into MediumFrequencyTask to initialize the speed reference.
  */
__weak void STC_ForceSpeedReferenceToCurrentSpeed(SpeednTorqCtrl_Handle_t *pHandle)
{
 800a4e0:	b510      	push	{r4, lr}
 800a4e2:	4604      	mov	r4, r0
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->SpeedRefUnitExt = ((int32_t)SPD_GetAvrgMecSpeedUnit(pHandle->SPD)) * (int32_t)65536;
 800a4e4:	6940      	ldr	r0, [r0, #20]
 800a4e6:	f7ff ff09 	bl	800a2fc <SPD_GetAvrgMecSpeedUnit>
 800a4ea:	0400      	lsls	r0, r0, #16
 800a4ec:	6060      	str	r0, [r4, #4]
#ifdef NULL_PTR_CHECK_SPD_TRQ_CTL
  }
#endif
}
 800a4ee:	bd10      	pop	{r4, pc}

0800a4f0 <STO_PLL_CalcElAngle>:
  * @param  pInput: Pointer to the observer inputs structure.
  * @retval int16_t Rotor electrical angle (s16Degrees).
  */
//cstat !MISRAC2012-Rule-8.13
__weak int16_t STO_PLL_CalcElAngle(STO_PLL_Handle_t *pHandle, Observer_Inputs_t *pInputs)
{
 800a4f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int16_t retValue;

  if ((MC_NULL == pHandle) || (MC_NULL == pInputs))
 800a4f4:	4604      	mov	r4, r0
{
 800a4f6:	b089      	sub	sp, #36	; 0x24
  if ((MC_NULL == pHandle) || (MC_NULL == pInputs))
 800a4f8:	2800      	cmp	r0, #0
 800a4fa:	f000 80cf 	beq.w	800a69c <STO_PLL_CalcElAngle+0x1ac>
 800a4fe:	2900      	cmp	r1, #0
 800a500:	f000 80cf 	beq.w	800a6a2 <STO_PLL_CalcElAngle+0x1b2>
    int16_t hIbeta_err;
    int16_t hRotor_Speed;
    int16_t hValfa;
    int16_t hVbeta;

    if (pHandle->wBemf_alfa_est > (((int32_t)pHandle->hF2) * INT16_MAX))
 800a504:	f9b0 302e 	ldrsh.w	r3, [r0, #46]	; 0x2e
 800a508:	6e87      	ldr	r7, [r0, #104]	; 0x68
 800a50a:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800a50e:	429f      	cmp	r7, r3
 800a510:	f340 80d1 	ble.w	800a6b6 <STO_PLL_CalcElAngle+0x1c6>
    {
      pHandle->wBemf_alfa_est = INT16_MAX * ((int32_t)pHandle->hF2);
 800a514:	6683      	str	r3, [r0, #104]	; 0x68
 800a516:	461f      	mov	r7, r3
    {
      /* Nothing to do */
    }
#ifndef FULL_MISRA_C_COMPLIANCY_STO_PLL
    //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a518:	f8b4 511e 	ldrh.w	r5, [r4, #286]	; 0x11e
#else
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est / pHandle->hF2);
#endif

    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a51c:	6ee6      	ldr	r6, [r4, #108]	; 0x6c
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a51e:	fa47 f205 	asr.w	r2, r7, r5
    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a522:	42b3      	cmp	r3, r6
      hAux_Alfa = (int16_t)(pHandle->wBemf_alfa_est >> pHandle->F2LOG);
 800a524:	9201      	str	r2, [sp, #4]
 800a526:	fa0f fe82 	sxth.w	lr, r2
    if (pHandle->wBemf_beta_est > (INT16_MAX * ((int32_t)pHandle->hF2)))
 800a52a:	f2c0 80c1 	blt.w	800a6b0 <STO_PLL_CalcElAngle+0x1c0>
    {
      pHandle->wBemf_beta_est = INT16_MAX * ((int32_t)pHandle->hF2);
    }
    else if (pHandle->wBemf_beta_est <= (-INT16_MAX * ((int32_t)pHandle->hF2)))
 800a52e:	425b      	negs	r3, r3
 800a530:	429e      	cmp	r6, r3
 800a532:	f340 80bd 	ble.w	800a6b0 <STO_PLL_CalcElAngle+0x1c0>
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
#else
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est / pHandle->hF2);
#endif

    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a536:	f9b4 302c 	ldrsh.w	r3, [r4, #44]	; 0x2c
 800a53a:	f8d4 9060 	ldr.w	r9, [r4, #96]	; 0x60
 800a53e:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 800a542:	fa46 f505 	asr.w	r5, r6, r5
    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a546:	4599      	cmp	r9, r3
    hAux_Beta = (int16_t)(pHandle->wBemf_beta_est >> pHandle->F2LOG);
 800a548:	fa0f fc85 	sxth.w	ip, r5
    if (pHandle->Ialfa_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a54c:	f340 80b9 	ble.w	800a6c2 <STO_PLL_CalcElAngle+0x1d2>
    {
      pHandle->Ialfa_est = INT16_MAX * ((int32_t)pHandle->hF1);
 800a550:	6623      	str	r3, [r4, #96]	; 0x60
 800a552:	4699      	mov	r9, r3
    else
    {
      /* Nothing to do */
    }

    if (pHandle->Ibeta_est > (INT16_MAX * ((int32_t)pHandle->hF1)))
 800a554:	f8d4 8064 	ldr.w	r8, [r4, #100]	; 0x64
 800a558:	4543      	cmp	r3, r8
 800a55a:	f2c0 80a6 	blt.w	800a6aa <STO_PLL_CalcElAngle+0x1ba>
    {
      pHandle->Ibeta_est = INT16_MAX * ((int32_t)pHandle->hF1);
    }
    else if (pHandle->Ibeta_est <= (-INT16_MAX * ((int32_t)pHandle->hF1)))
 800a55e:	425b      	negs	r3, r3
 800a560:	4598      	cmp	r8, r3
 800a562:	f340 80a2 	ble.w	800a6aa <STO_PLL_CalcElAngle+0x1ba>
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
#else
    hIbeta_err = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif

    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a566:	88c8      	ldrh	r0, [r1, #6]

    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a568:	f8b1 a008 	ldrh.w	sl, [r1, #8]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a56c:	888b      	ldrh	r3, [r1, #4]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a56e:	f8ad 0014 	strh.w	r0, [sp, #20]
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
#else
    hValfa = (int16_t)(wAux / 65536);
#endif

    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.beta;
 800a572:	f9b1 0002 	ldrsh.w	r0, [r1, #2]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a576:	f8ad 3010 	strh.w	r3, [sp, #16]
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a57a:	f9b1 3000 	ldrsh.w	r3, [r1]
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a57e:	f8b4 211c 	ldrh.w	r2, [r4, #284]	; 0x11c
    hAux = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
#else
    hAux = (int16_t)(pHandle->Ialfa_est / pHandle->hF1);
#endif

    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a582:	f9b4 b020 	ldrsh.w	fp, [r4, #32]
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a586:	9904      	ldr	r1, [sp, #16]
    wAux = wAux * pHandle->hC6;
    wAux = pHandle->_Super.hElSpeedDpp * wAux;
    wBemf_beta_est_Next -= wAux;

    /* Calls the PLL blockset */
    pHandle->hBemf_alfa_est = hAux_Alfa;
 800a588:	f8a4 e070 	strh.w	lr, [r4, #112]	; 0x70
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.beta;
 800a58c:	fb0a f000 	mul.w	r0, sl, r0
    wAux = ((int32_t)pInputs->Vbus) * pInputs->Valfa_beta.alpha;
 800a590:	fb0a f303 	mul.w	r3, sl, r3
    hVbeta = ( int16_t ) ( wAux >> 16 ); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a594:	1400      	asrs	r0, r0, #16
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a596:	141b      	asrs	r3, r3, #16
    hVbeta = ( int16_t ) ( wAux >> 16 ); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a598:	9003      	str	r0, [sp, #12]
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a59a:	9805      	ldr	r0, [sp, #20]
    hValfa = (int16_t)(wAux >> 16); //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a59c:	9302      	str	r3, [sp, #8]
    hIalfa_err = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a59e:	fa49 f302 	asr.w	r3, r9, r2
    hIbeta_err = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 800a5a2:	fa48 f202 	asr.w	r2, r8, r2
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5a6:	eba2 0a00 	sub.w	sl, r2, r0
    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a5aa:	fb12 f20b 	smulbb	r2, r2, fp
    wIbeta_est_Next = pHandle->Ibeta_est - wAux;
 800a5ae:	eba8 0202 	sub.w	r2, r8, r2
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5b2:	1a59      	subs	r1, r3, r1
    wAux = ((int32_t)pHandle->hC2) * hIalfa_err;
 800a5b4:	f9b4 8022 	ldrsh.w	r8, [r4, #34]	; 0x22
    wIalfa_est_Next += wAux;
 800a5b8:	9802      	ldr	r0, [sp, #8]
    pHandle->hBemf_beta_est = hAux_Beta;
 800a5ba:	f8a4 c072 	strh.w	ip, [r4, #114]	; 0x72
    wAux = ((int32_t)pHandle->hC1) * hAux;
 800a5be:	fb13 f30b 	smulbb	r3, r3, fp
    wIalfa_est_Next = pHandle->Ialfa_est - wAux;
 800a5c2:	eba9 0303 	sub.w	r3, r9, r3
    hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
 800a5c6:	b209      	sxth	r1, r1
    wAux = ((int32_t)pHandle->hC5) * hValfa;
 800a5c8:	f9b4 9028 	ldrsh.w	r9, [r4, #40]	; 0x28
    wIalfa_est_Next += wAux;
 800a5cc:	fb08 3301 	mla	r3, r8, r1, r3
    wIalfa_est_Next += wAux;
 800a5d0:	fb09 3300 	mla	r3, r9, r0, r3
    hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
 800a5d4:	fa0f fa8a 	sxth.w	sl, sl
    wIbeta_est_Next += wAux;
 800a5d8:	9803      	ldr	r0, [sp, #12]
    wIbeta_est_Next += wAux;
 800a5da:	fb08 280a 	mla	r8, r8, sl, r2
    wIbeta_est_Next += wAux;
 800a5de:	fb09 8800 	mla	r8, r9, r0, r8
    wAux = ((int32_t)pHandle->hC4) * hIalfa_err;
 800a5e2:	f9b4 0026 	ldrsh.w	r0, [r4, #38]	; 0x26
    wAux = (int32_t)hAux_Beta >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a5e6:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    wAux = wAux * pHandle->hC6;
 800a5e8:	f9b4 902a 	ldrsh.w	r9, [r4, #42]	; 0x2a
    wBemf_alfa_est_Next = pHandle->wBemf_alfa_est + wAux;
 800a5ec:	fb01 7100 	mla	r1, r1, r0, r7
    wBemf_beta_est_Next = pHandle->wBemf_beta_est + wAux;
 800a5f0:	fb00 600a 	mla	r0, r0, sl, r6
    wAux = ((int32_t)pHandle->hC3) * hAux_Alfa;
 800a5f4:	f9b4 6024 	ldrsh.w	r6, [r4, #36]	; 0x24
    wIalfa_est_Next -= wAux;
 800a5f8:	fb06 371e 	mls	r7, r6, lr, r3
    wIbeta_est_Next -= wAux;
 800a5fc:	fb06 861c 	mls	r6, r6, ip, r8
    wAux = (int32_t)hAux_Alfa >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a600:	fa4e fe02 	asr.w	lr, lr, r2
    wAux = (int32_t)hAux_Beta >> pHandle->F3POW2; //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
 800a604:	fa4c fc02 	asr.w	ip, ip, r2
    wAux = pHandle->_Super.hElSpeedDpp * wAux;
 800a608:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
    wAux = wAux * pHandle->hC6;
 800a60c:	fb0e f309 	mul.w	r3, lr, r9
    wBemf_beta_est_Next -= wAux;
 800a610:	fb03 0812 	mls	r8, r3, r2, r0

    if (0 == pHandle->hForcedDirection)
 800a614:	f994 3124 	ldrsb.w	r3, [r4, #292]	; 0x124
    wAux = wAux * pHandle->hC6;
 800a618:	fb0c fc09 	mul.w	ip, ip, r9
    wBemf_alfa_est_Next += wAux;
 800a61c:	fb0c 1902 	mla	r9, ip, r2, r1
    if (0 == pHandle->hForcedDirection)
 800a620:	2b00      	cmp	r3, #0
 800a622:	d154      	bne.n	800a6ce <STO_PLL_CalcElAngle+0x1de>
    {
      /* We are in auxiliary mode, then rely on the speed detected */
      if(pHandle->_Super.hElSpeedDpp >= 0)
 800a624:	2a00      	cmp	r2, #0
 800a626:	f64f 7aff 	movw	sl, #65535	; 0xffff
 800a62a:	bfa8      	it	ge
 800a62c:	f04f 0a01 	movge.w	sl, #1
  int16_t hAux1;
  int16_t hAux2;
  int16_t hOutput;
  Trig_Components Local_Components;

  Local_Components = MCM_Trig_Functions(pHandle->_Super.hElAngle);
 800a630:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 800a634:	f7f7 fcb2 	bl	8001f9c <MCM_Trig_Functions>
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a638:	9b01      	ldr	r3, [sp, #4]
    hAux_Beta = (int16_t)(hAux_Beta * wDirection);
 800a63a:	fb15 f50a 	smulbb	r5, r5, sl
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a63e:	fb13 f30a 	smulbb	r3, r3, sl
    hRotor_Speed = STO_ExecutePLL(pHandle, hAux_Alfa, -hAux_Beta);
 800a642:	426d      	negs	r5, r5

  /* Alfa & Beta BEMF multiplied by Cos & Sin */
  wAlfa_Sin_tmp = ((int32_t )hBemf_alfa_est) * ((int32_t )Local_Components.hSin);
  wBeta_Cos_tmp = ((int32_t )hBemf_beta_est) * ((int32_t )Local_Components.hCos);
 800a644:	fb10 f505 	smulbb	r5, r0, r5
  wAlfa_Sin_tmp = ((int32_t )hBemf_alfa_est) * ((int32_t )Local_Components.hSin);
 800a648:	fb10 f023 	smultb	r0, r0, r3
#else
  hAux2 = (int16_t)(wAlfa_Sin_tmp / 32768);
#endif

  /* Speed PI regulator */
  hOutput = PI_Controller(& pHandle->PIRegulator, (int32_t)(hAux1 ) - hAux2);
 800a64c:	f340 31cf 	sbfx	r1, r0, #15, #16
 800a650:	f345 35cf 	sbfx	r5, r5, #15, #16
 800a654:	1a69      	subs	r1, r5, r1
 800a656:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800a65a:	f7fe fdcb 	bl	80091f4 <PI_Controller>
  uint8_t bBuffer_index = pHandle->Speed_Buffer_Index;
 800a65e:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 800a662:	f894 210e 	ldrb.w	r2, [r4, #270]	; 0x10e
    pHandle->_Super.InstantaneousElSpeedDpp = hRotor_Speed;
 800a666:	8220      	strh	r0, [r4, #16]
  bBuffer_index++;
 800a668:	3301      	adds	r3, #1
 800a66a:	b2db      	uxtb	r3, r3
  if (bBuffer_index == pHandle->SpeedBufferSizeUnit)
 800a66c:	429a      	cmp	r2, r3
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 800a66e:	bf12      	itee	ne
 800a670:	461a      	movne	r2, r3
 800a672:	2200      	moveq	r2, #0
    bBuffer_index = 0U;
 800a674:	4613      	moveq	r3, r2
  pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
 800a676:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 800a67a:	f9b2 1074 	ldrsh.w	r1, [r2, #116]	; 0x74
 800a67e:	f8a4 110c 	strh.w	r1, [r4, #268]	; 0x10c
  pHandle->Speed_Buffer[bBuffer_index] = hRotor_Speed;
 800a682:	f8a2 0074 	strh.w	r0, [r2, #116]	; 0x74
  pHandle->Speed_Buffer_Index = bBuffer_index;
 800a686:	f884 30f4 	strb.w	r3, [r4, #244]	; 0xf4
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a68a:	88a3      	ldrh	r3, [r4, #4]
    pHandle->Ialfa_est = wIalfa_est_Next;
 800a68c:	6627      	str	r7, [r4, #96]	; 0x60
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a68e:	4418      	add	r0, r3
    pHandle->Ibeta_est = wIbeta_est_Next;
 800a690:	e9c4 6919 	strd	r6, r9, [r4, #100]	; 0x64
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a694:	b200      	sxth	r0, r0
    pHandle->wBemf_beta_est = wBemf_beta_est_Next;
 800a696:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
    pHandle->_Super.hElAngle += hRotor_Speed;
 800a69a:	80a0      	strh	r0, [r4, #4]
}
 800a69c:	b009      	add	sp, #36	; 0x24
 800a69e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    retValue = 0;
 800a6a2:	4608      	mov	r0, r1
}
 800a6a4:	b009      	add	sp, #36	; 0x24
 800a6a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      pHandle->Ibeta_est = -INT16_MAX * ((int32_t)pHandle->hF1);
 800a6aa:	6663      	str	r3, [r4, #100]	; 0x64
 800a6ac:	4698      	mov	r8, r3
 800a6ae:	e75a      	b.n	800a566 <STO_PLL_CalcElAngle+0x76>
      pHandle->wBemf_beta_est = (-INT16_MAX * ((int32_t)pHandle->hF2));
 800a6b0:	66e3      	str	r3, [r4, #108]	; 0x6c
 800a6b2:	461e      	mov	r6, r3
 800a6b4:	e73f      	b.n	800a536 <STO_PLL_CalcElAngle+0x46>
    else if (pHandle->wBemf_alfa_est <= (-INT16_MAX * ((int32_t)pHandle->hF2)))
 800a6b6:	425a      	negs	r2, r3
 800a6b8:	4297      	cmp	r7, r2
      pHandle->wBemf_alfa_est = -INT16_MAX * ((int32_t)pHandle->hF2);
 800a6ba:	bfdc      	itt	le
 800a6bc:	6682      	strle	r2, [r0, #104]	; 0x68
 800a6be:	4617      	movle	r7, r2
 800a6c0:	e72a      	b.n	800a518 <STO_PLL_CalcElAngle+0x28>
    else if (pHandle->Ialfa_est <= (-INT16_MAX * ((int32_t)pHandle->hF1)))
 800a6c2:	425a      	negs	r2, r3
 800a6c4:	4591      	cmp	r9, r2
      pHandle->Ialfa_est = -INT16_MAX * ((int32_t)pHandle->hF1);
 800a6c6:	bfdc      	itt	le
 800a6c8:	6622      	strle	r2, [r4, #96]	; 0x60
 800a6ca:	4691      	movle	r9, r2
 800a6cc:	e742      	b.n	800a554 <STO_PLL_CalcElAngle+0x64>
    hAux_Alfa = (int16_t)(hAux_Alfa * wDirection);
 800a6ce:	fa1f fa83 	uxth.w	sl, r3
 800a6d2:	e7ad      	b.n	800a630 <STO_PLL_CalcElAngle+0x140>

0800a6d4 <STO_PLL_CalcAvrgMecSpeedUnit>:
{
 800a6d4:	b570      	push	{r4, r5, r6, lr}
    uint8_t i, bSpeedBufferSizeUnit = pHandle->SpeedBufferSizeUnit;
 800a6d6:	f890 510e 	ldrb.w	r5, [r0, #270]	; 0x10e
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a6da:	2d00      	cmp	r5, #0
 800a6dc:	f000 809c 	beq.w	800a818 <STO_PLL_CalcAvrgMecSpeedUnit+0x144>
 800a6e0:	1e6b      	subs	r3, r5, #1
 800a6e2:	b2db      	uxtb	r3, r3
 800a6e4:	f100 0472 	add.w	r4, r0, #114	; 0x72
 800a6e8:	f100 0c74 	add.w	ip, r0, #116	; 0x74
 800a6ec:	eb0c 0c43 	add.w	ip, ip, r3, lsl #1
    int32_t wAvrSpeed_dpp = (int32_t)0;
 800a6f0:	2200      	movs	r2, #0
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a6f2:	4623      	mov	r3, r4
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 800a6f4:	f933 ef02 	ldrsh.w	lr, [r3, #2]!
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a6f8:	459c      	cmp	ip, r3
      wAvrSpeed_dpp += (int32_t)(pHandle->Speed_Buffer[i]);
 800a6fa:	4472      	add	r2, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a6fc:	d1fa      	bne.n	800a6f4 <STO_PLL_CalcAvrgMecSpeedUnit+0x20>
      wAvrSpeed_dpp = wAvrSpeed_dpp / ((int16_t)bSpeedBufferSizeUnit);
 800a6fe:	fb92 fef5 	sdiv	lr, r2, r5
 800a702:	2200      	movs	r2, #0
      wError = ((int32_t)pHandle->Speed_Buffer[i]) - wAvrSpeed_dpp;
 800a704:	f934 3f02 	ldrsh.w	r3, [r4, #2]!
 800a708:	eba3 030e 	sub.w	r3, r3, lr
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a70c:	45a4      	cmp	ip, r4
      wAvrQuadraticError += wError;
 800a70e:	fb03 2203 	mla	r2, r3, r3, r2
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a712:	d1f7      	bne.n	800a704 <STO_PLL_CalcAvrgMecSpeedUnit+0x30>
    wAvrQuadraticError = wAvrQuadraticError / ((int16_t)bSpeedBufferSizeUnit);
 800a714:	fbb2 f2f5 	udiv	r2, r2, r5
    wAvrSquareSpeed = wAvrSpeed_dpp * wAvrSpeed_dpp;
 800a718:	fb0e f30e 	mul.w	r3, lr, lr
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 800a71c:	17de      	asrs	r6, r3, #31
 800a71e:	f8b0 c110 	ldrh.w	ip, [r0, #272]	; 0x110
    wAux = wAvrSpeed_dpp * ((int32_t)pHandle->_Super.hMeasurementFrequency);
 800a722:	8b45      	ldrh	r5, [r0, #26]
    int64_t lAvrSquareSpeed = (int64_t)(wAvrSquareSpeed) * (int64_t)pHandle->VariancePercentage;
 800a724:	fbac 4303 	umull	r4, r3, ip, r3
 800a728:	fb0c 3306 	mla	r3, ip, r6, r3
    wAvrSquareSpeed = (int32_t)(lAvrSquareSpeed / (int64_t)128);
 800a72c:	09e4      	lsrs	r4, r4, #7
 800a72e:	ea44 6443 	orr.w	r4, r4, r3, lsl #25
    wAux = wAux * ((int32_t)pHandle->_Super.SpeedUnit);
 800a732:	7883      	ldrb	r3, [r0, #2]
    if (true == pHandle->EnableDualCheck) /* Do algorithm if it's enabled */
 800a734:	f890 6104 	ldrb.w	r6, [r0, #260]	; 0x104
    wAux = wAvrSpeed_dpp * ((int32_t)pHandle->_Super.hMeasurementFrequency);
 800a738:	fb0e f505 	mul.w	r5, lr, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a73c:	4294      	cmp	r4, r2
    wAux = wAux * ((int32_t)pHandle->_Super.SpeedUnit);
 800a73e:	fb05 f303 	mul.w	r3, r5, r3
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a742:	bfd8      	it	le
 800a744:	f04f 0c00 	movle.w	ip, #0
    wAux = wAux / ((int32_t)pHandle->_Super.DPPConvFactor);
 800a748:	69c5      	ldr	r5, [r0, #28]
 800a74a:	fb93 f3f5 	sdiv	r3, r3, r5
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a74e:	bfc8      	it	gt
 800a750:	f04f 0c01 	movgt.w	ip, #1
    wAux = wAux / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a754:	7845      	ldrb	r5, [r0, #1]
 800a756:	fb93 f3f5 	sdiv	r3, r3, r5
    *pMecSpeedUnit = (int16_t)wAux;
 800a75a:	b21d      	sxth	r5, r3
 800a75c:	800d      	strh	r5, [r1, #0]
    pHandle->_Super.hAvrMecSpeedUnit = (int16_t)wAux;
 800a75e:	8185      	strh	r5, [r0, #12]
    if (wAvrQuadraticError < wAvrSquareSpeed)
 800a760:	f880 c0f5 	strb.w	ip, [r0, #245]	; 0xf5
    if (true == pHandle->EnableDualCheck) /* Do algorithm if it's enabled */
 800a764:	b9ae      	cbnz	r6, 800a792 <STO_PLL_CalcAvrgMecSpeedUnit+0xbe>
    if (false == pHandle->IsAlgorithmConverged)
 800a766:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
 800a76a:	b353      	cbz	r3, 800a7c2 <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
      if ((false == pHandle->IsSpeedReliable) || (false == bIs_Bemf_Consistent))
 800a76c:	4294      	cmp	r4, r2
 800a76e:	dc25      	bgt.n	800a7bc <STO_PLL_CalcAvrgMecSpeedUnit+0xe8>
        pHandle->ReliabilityCounter++;
 800a770:	f890 30f7 	ldrb.w	r3, [r0, #247]	; 0xf7
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a774:	f890 2117 	ldrb.w	r2, [r0, #279]	; 0x117
        pHandle->ReliabilityCounter++;
 800a778:	3301      	adds	r3, #1
 800a77a:	b2db      	uxtb	r3, r3
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a77c:	429a      	cmp	r2, r3
        pHandle->ReliabilityCounter++;
 800a77e:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
        if (pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys)
 800a782:	d81e      	bhi.n	800a7c2 <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
          pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
 800a784:	78c2      	ldrb	r2, [r0, #3]
 800a786:	7002      	strb	r2, [r0, #0]
          pHandle->ReliabilityCounter = 0U;
 800a788:	2300      	movs	r3, #0
 800a78a:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
}
 800a78e:	4618      	mov	r0, r3
 800a790:	bd70      	pop	{r4, r5, r6, pc}
      wAux = ((wAux < 0) ? (-wAux) : (wAux));
 800a792:	2b00      	cmp	r3, #0
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 800a794:	f8b0 511a 	ldrh.w	r5, [r0, #282]	; 0x11a
      wAux = ((wAux < 0) ? (-wAux) : (wAux));
 800a798:	bfb8      	it	lt
 800a79a:	425b      	neglt	r3, r3
      if (wAux < (int32_t)(pHandle->MaxAppPositiveMecSpeedUnit))
 800a79c:	429d      	cmp	r5, r3
 800a79e:	dc14      	bgt.n	800a7ca <STO_PLL_CalcAvrgMecSpeedUnit+0xf6>
    bool bIs_Bemf_Consistent = false;
 800a7a0:	2500      	movs	r5, #0
    int32_t wEstBemfSq = 0;
 800a7a2:	462b      	mov	r3, r5
    int32_t wObsBemfSq = 0;
 800a7a4:	462e      	mov	r6, r5
      pHandle->Est_Bemf_Level = wEstBemfSq;
 800a7a6:	e9c0 633f 	strd	r6, r3, [r0, #252]	; 0xfc
    if (false == pHandle->IsAlgorithmConverged)
 800a7aa:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
      pHandle->IsBemfConsistent = bIs_Bemf_Consistent;
 800a7ae:	f880 50f9 	strb.w	r5, [r0, #249]	; 0xf9
    if (false == pHandle->IsAlgorithmConverged)
 800a7b2:	b133      	cbz	r3, 800a7c2 <STO_PLL_CalcAvrgMecSpeedUnit+0xee>
      if ((false == pHandle->IsSpeedReliable) || (false == bIs_Bemf_Consistent))
 800a7b4:	4294      	cmp	r4, r2
 800a7b6:	dddb      	ble.n	800a770 <STO_PLL_CalcAvrgMecSpeedUnit+0x9c>
 800a7b8:	2d00      	cmp	r5, #0
 800a7ba:	d0d9      	beq.n	800a770 <STO_PLL_CalcAvrgMecSpeedUnit+0x9c>
        pHandle->ReliabilityCounter = 0U;
 800a7bc:	2300      	movs	r3, #0
 800a7be:	f880 30f7 	strb.w	r3, [r0, #247]	; 0xf7
}
 800a7c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        bAux = SPD_IsMecSpeedReliable (&pHandle->_Super, pMecSpeedUnit);
 800a7c6:	f7ff bda1 	b.w	800a30c <SPD_IsMecSpeedReliable>
        wObsBemf = (int32_t)pHandle->hBemf_alfa_est;
 800a7ca:	f9b0 5070 	ldrsh.w	r5, [r0, #112]	; 0x70
        wObsBemf = (int32_t)pHandle->hBemf_beta_est;
 800a7ce:	f9b0 6072 	ldrsh.w	r6, [r0, #114]	; 0x72
        wObsBemfSq = wObsBemf * wObsBemf;
 800a7d2:	fb05 fc05 	mul.w	ip, r5, r5
        wEstBemfSq = (wEstBemf * ((int32_t)pHandle->BemfConsistencyGain)) / 64;
 800a7d6:	f890 5119 	ldrb.w	r5, [r0, #281]	; 0x119
        wObsBemfSq += wObsBemf * wObsBemf;
 800a7da:	fb06 c606 	mla	r6, r6, r6, ip
        wEstBemf = (wAux * 32767) / ((int16_t)pHandle->_Super.hMaxReliableMecSpeedUnit);
 800a7de:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
 800a7e2:	f9b0 c014 	ldrsh.w	ip, [r0, #20]
 800a7e6:	fb93 f3fc 	sdiv	r3, r3, ip
        wEstBemfSq = (wEstBemf * ((int32_t)pHandle->BemfConsistencyGain)) / 64;
 800a7ea:	fb03 f505 	mul.w	r5, r3, r5
 800a7ee:	2d00      	cmp	r5, #0
 800a7f0:	bfb8      	it	lt
 800a7f2:	353f      	addlt	r5, #63	; 0x3f
 800a7f4:	11ad      	asrs	r5, r5, #6
        wEstBemfSq *= wEstBemf;
 800a7f6:	fb05 f303 	mul.w	r3, r5, r3
        wEstBemfSqLo = wEstBemfSq - ((wEstBemfSq / 64) * ((int32_t)pHandle->BemfConsistencyCheck));
 800a7fa:	2b00      	cmp	r3, #0
 800a7fc:	461d      	mov	r5, r3
 800a7fe:	f890 c118 	ldrb.w	ip, [r0, #280]	; 0x118
 800a802:	bfb8      	it	lt
 800a804:	f103 053f 	addlt.w	r5, r3, #63	; 0x3f
 800a808:	11ad      	asrs	r5, r5, #6
 800a80a:	fb0c 3515 	mls	r5, ip, r5, r3
        if (wObsBemfSq > wEstBemfSqLo)
 800a80e:	42ae      	cmp	r6, r5
 800a810:	bfd4      	ite	le
 800a812:	2500      	movle	r5, #0
 800a814:	2501      	movgt	r5, #1
 800a816:	e7c6      	b.n	800a7a6 <STO_PLL_CalcAvrgMecSpeedUnit+0xd2>
    for (i = 0U; i < bSpeedBufferSizeUnit; i++)
 800a818:	462a      	mov	r2, r5
 800a81a:	462b      	mov	r3, r5
 800a81c:	462e      	mov	r6, r5
    int32_t wAvrSpeed_dpp = (int32_t)0;
 800a81e:	46ae      	mov	lr, r5
 800a820:	e77d      	b.n	800a71e <STO_PLL_CalcAvrgMecSpeedUnit+0x4a>
 800a822:	bf00      	nop

0800a824 <STO_PLL_CalcAvrgElSpeedDpp>:
    int16_t hSpeedBufferSizeUnit = (int16_t)pHandle->SpeedBufferSizeUnit;
 800a824:	f890 110e 	ldrb.w	r1, [r0, #270]	; 0x10e
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 800a828:	f890 310f 	ldrb.w	r3, [r0, #271]	; 0x10f
    int16_t hIndexNew = (int16_t)pHandle->Speed_Buffer_Index;
 800a82c:	f890 20f4 	ldrb.w	r2, [r0, #244]	; 0xf4
    hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
 800a830:	1acb      	subs	r3, r1, r3
 800a832:	b29b      	uxth	r3, r3
{
 800a834:	b510      	push	{r4, lr}
    int32_t wSum = pHandle->DppBufferSum;
 800a836:	f8d0 4108 	ldr.w	r4, [r0, #264]	; 0x108
    if (0 == hBufferSizeDiff)
 800a83a:	b973      	cbnz	r3, 800a85a <STO_PLL_CalcAvrgElSpeedDpp+0x36>
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->SpeedBufferOldestEl;
 800a83c:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 800a840:	f9b0 110c 	ldrsh.w	r1, [r0, #268]	; 0x10c
 800a844:	f9b2 3074 	ldrsh.w	r3, [r2, #116]	; 0x74
 800a848:	4423      	add	r3, r4
 800a84a:	1a5b      	subs	r3, r3, r1
  wAvrSpeed_dpp = wSum >> pHandle->SpeedBufferSizeDppLOG;
 800a84c:	f8b0 2120 	ldrh.w	r2, [r0, #288]	; 0x120
    pHandle->DppBufferSum = wSum;
 800a850:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  wAvrSpeed_dpp = wSum >> pHandle->SpeedBufferSizeDppLOG;
 800a854:	4113      	asrs	r3, r2
    pHandle->_Super.hElSpeedDpp = (int16_t)wAvrSpeed_dpp;
 800a856:	81c3      	strh	r3, [r0, #14]
}
 800a858:	bd10      	pop	{r4, pc}
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 800a85a:	4413      	add	r3, r2
 800a85c:	fa0f fc83 	sxth.w	ip, r3
      if (hIndexOldTemp >= hSpeedBufferSizeUnit)
 800a860:	4561      	cmp	r1, ip
      hIndexOldTemp = hIndexNew + hBufferSizeDiff;
 800a862:	b29b      	uxth	r3, r3
      if (hIndexOldTemp >= hSpeedBufferSizeUnit)
 800a864:	dc05      	bgt.n	800a872 <STO_PLL_CalcAvrgElSpeedDpp+0x4e>
 800a866:	fa1f fe81 	uxth.w	lr, r1
        hIndexOld = hIndexOldTemp - hSpeedBufferSizeUnit;
 800a86a:	eba3 030e 	sub.w	r3, r3, lr
 800a86e:	fa0f fc83 	sxth.w	ip, r3
      wSum = wSum + pHandle->Speed_Buffer[hIndexNew] - pHandle->Speed_Buffer[hIndexOld];
 800a872:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 800a876:	eb00 0c4c 	add.w	ip, r0, ip, lsl #1
 800a87a:	f9b2 3074 	ldrsh.w	r3, [r2, #116]	; 0x74
 800a87e:	f9bc 2074 	ldrsh.w	r2, [ip, #116]	; 0x74
 800a882:	4423      	add	r3, r4
 800a884:	1a9b      	subs	r3, r3, r2
 800a886:	e7e1      	b.n	800a84c <STO_PLL_CalcAvrgElSpeedDpp+0x28>

0800a888 <STO_PLL_Clear>:
{
 800a888:	b510      	push	{r4, lr}
  *
  */
static void STO_InitSpeedBuffer(STO_PLL_Handle_t * pHandle)
{
  uint8_t b_i;
  uint8_t bSpeedBufferSize = pHandle->SpeedBufferSizeUnit;
 800a88a:	f890 210e 	ldrb.w	r2, [r0, #270]	; 0x10e
    pHandle->Ialfa_est = (int32_t)0;
 800a88e:	2100      	movs	r1, #0
    pHandle->Ibeta_est = (int32_t)0;
 800a890:	e9c0 1118 	strd	r1, r1, [r0, #96]	; 0x60
    pHandle->wBemf_beta_est = (int32_t)0;
 800a894:	e9c0 111a 	strd	r1, r1, [r0, #104]	; 0x68
    pHandle->Est_Bemf_Level = (int32_t)0;
 800a898:	e9c0 113f 	strd	r1, r1, [r0, #252]	; 0xfc
{
 800a89c:	4604      	mov	r4, r0
    pHandle->_Super.hElAngle = (int16_t)0;
 800a89e:	8081      	strh	r1, [r0, #4]
    pHandle->_Super.hElSpeedDpp = (int16_t)0;
 800a8a0:	81c1      	strh	r1, [r0, #14]
    pHandle->ConsistencyCounter = 0u;
 800a8a2:	f8a0 10f6 	strh.w	r1, [r0, #246]	; 0xf6
    pHandle->IsAlgorithmConverged = false;
 800a8a6:	f8a0 10f8 	strh.w	r1, [r0, #248]	; 0xf8
    pHandle->DppBufferSum = (int32_t)0;
 800a8aa:	f8c0 1108 	str.w	r1, [r0, #264]	; 0x108
    pHandle->ForceConvergency = false;
 800a8ae:	f8a0 1122 	strh.w	r1, [r0, #290]	; 0x122

  /* Init speed buffer */
  for (b_i = 0U; b_i < bSpeedBufferSize; b_i++)
 800a8b2:	b11a      	cbz	r2, 800a8bc <STO_PLL_Clear+0x34>
  {
    pHandle->Speed_Buffer[b_i] = (int16_t)0;
 800a8b4:	0052      	lsls	r2, r2, #1
 800a8b6:	3074      	adds	r0, #116	; 0x74
 800a8b8:	f002 ff04 	bl	800d6c4 <memset>
  }
  pHandle->Speed_Buffer_Index = 0U;
 800a8bc:	2100      	movs	r1, #0
 800a8be:	f884 10f4 	strb.w	r1, [r4, #244]	; 0xf4
  pHandle->SpeedBufferOldestEl = (int16_t)0;
 800a8c2:	f8a4 110c 	strh.w	r1, [r4, #268]	; 0x10c
    PID_SetIntegralTerm(& pHandle->PIRegulator, (int32_t)0);
 800a8c6:	f104 0034 	add.w	r0, r4, #52	; 0x34
}
 800a8ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    PID_SetIntegralTerm(& pHandle->PIRegulator, (int32_t)0);
 800a8ce:	f7fe bc5f 	b.w	8009190 <PID_SetIntegralTerm>
 800a8d2:	bf00      	nop

0800a8d4 <STO_PLL_Init>:
{
 800a8d4:	b510      	push	{r4, lr}
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 800a8d6:	f890 1116 	ldrb.w	r1, [r0, #278]	; 0x116
    htempk = (int16_t)(C6_COMP_CONST1 / pHandle->hF2);
 800a8da:	4b19      	ldr	r3, [pc, #100]	; (800a940 <STO_PLL_Init+0x6c>)
 800a8dc:	f9b0 e02e 	ldrsh.w	lr, [r0, #46]	; 0x2e
    pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
 800a8e0:	f880 10f6 	strb.w	r1, [r0, #246]	; 0xf6
    pHandle->EnableDualCheck = true;
 800a8e4:	2201      	movs	r2, #1
    pHandle->F3POW2 = 0U;
 800a8e6:	2100      	movs	r1, #0
    htempk = (int16_t)(C6_COMP_CONST1 / pHandle->hF2);
 800a8e8:	fb93 f3fe 	sdiv	r3, r3, lr
 800a8ec:	b21b      	sxth	r3, r3
{
 800a8ee:	4604      	mov	r4, r0
    pHandle->EnableDualCheck = true;
 800a8f0:	f880 2104 	strb.w	r2, [r0, #260]	; 0x104
    pHandle->F3POW2 = 0U;
 800a8f4:	8641      	strh	r1, [r0, #50]	; 0x32
    while (htempk != 0)
 800a8f6:	b30b      	cbz	r3, 800a93c <STO_PLL_Init+0x68>
    wAux = ((int32_t)1);
 800a8f8:	4611      	mov	r1, r2
      htempk /= ((int16_t)2);
 800a8fa:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    while (htempk != 0)
 800a8fe:	f102 0c01 	add.w	ip, r2, #1
 800a902:	105b      	asrs	r3, r3, #1
 800a904:	4610      	mov	r0, r2
      wAux *= ((int32_t)2);
 800a906:	ea4f 0141 	mov.w	r1, r1, lsl #1
    while (htempk != 0)
 800a90a:	fa1f f28c 	uxth.w	r2, ip
 800a90e:	d1f4      	bne.n	800a8fa <STO_PLL_Init+0x26>
    pHandle->hF3 = (int16_t)wAux;
 800a910:	b20a      	sxth	r2, r1
 800a912:	8660      	strh	r0, [r4, #50]	; 0x32
    wAux = ((int32_t)(pHandle->hF2)) * pHandle->hF3;
 800a914:	fb0e f102 	mul.w	r1, lr, r2
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 800a918:	480a      	ldr	r0, [pc, #40]	; (800a944 <STO_PLL_Init+0x70>)
    pHandle->hF3 = (int16_t)wAux;
 800a91a:	8622      	strh	r2, [r4, #48]	; 0x30
    pHandle->hC6 = (int16_t)(wAux / C6_COMP_CONST2);
 800a91c:	17cb      	asrs	r3, r1, #31
 800a91e:	fb80 0101 	smull	r0, r1, r0, r1
 800a922:	ebc3 2321 	rsb	r3, r3, r1, asr #8
 800a926:	8563      	strh	r3, [r4, #42]	; 0x2a
    STO_PLL_Clear(pHandle);
 800a928:	4620      	mov	r0, r4
 800a92a:	f7ff ffad 	bl	800a888 <STO_PLL_Clear>
    PID_HandleInit(&pHandle->PIRegulator);
 800a92e:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800a932:	f7fe fc19 	bl	8009168 <PID_HandleInit>
    pHandle->_Super.hMecAccelUnitP = 0;
 800a936:	2300      	movs	r3, #0
 800a938:	8263      	strh	r3, [r4, #18]
}
 800a93a:	bd10      	pop	{r4, pc}
 800a93c:	4671      	mov	r1, lr
 800a93e:	e7eb      	b.n	800a918 <STO_PLL_Init+0x44>
 800a940:	000fea5e 	.word	0x000fea5e
 800a944:	06488dc5 	.word	0x06488dc5

0800a948 <STO_PLL_GetEstimatedBemf>:
    vaux.alpha = pHandle->hBemf_alfa_est;
    vaux.beta = pHandle->hBemf_beta_est;
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
  return (vaux);
 800a948:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800a94a:	2200      	movs	r2, #0
 800a94c:	b299      	uxth	r1, r3
 800a94e:	f361 020f 	bfi	r2, r1, #0, #16
 800a952:	0c1b      	lsrs	r3, r3, #16
 800a954:	f363 421f 	bfi	r2, r3, #16, #16
{
 800a958:	b082      	sub	sp, #8
}
 800a95a:	4610      	mov	r0, r2
 800a95c:	b002      	add	sp, #8
 800a95e:	4770      	bx	lr

0800a960 <STO_PLL_GetEstimatedCurrent>:
  iaux.alpha = (int16_t)(pHandle->Ialfa_est / pHandle->hF1);
#endif

#ifndef FULL_MISRA_C_COMPLIANCY_STO_PLL
  //cstat !MISRAC2012-Rule-1.3_n !ATH-shift-neg !MISRAC2012-Rule-10.1_R6
  iaux.beta = (int16_t)(pHandle->Ibeta_est >> pHandle->F1LOG);
 800a960:	e9d0 2318 	ldrd	r2, r3, [r0, #96]	; 0x60
  iaux.alpha = (int16_t)(pHandle->Ialfa_est >> pHandle->F1LOG);
 800a964:	f8b0 c11c 	ldrh.w	ip, [r0, #284]	; 0x11c
 800a968:	fa42 f20c 	asr.w	r2, r2, ip
  iaux.beta = (int16_t)(pHandle->Ibeta_est / pHandle->hF1);
#endif
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
  return (iaux);
 800a96c:	fa43 f30c 	asr.w	r3, r3, ip
 800a970:	b292      	uxth	r2, r2
 800a972:	2100      	movs	r1, #0
 800a974:	f362 010f 	bfi	r1, r2, #0, #16
 800a978:	b29b      	uxth	r3, r3
 800a97a:	f363 411f 	bfi	r1, r3, #16, #16
{
 800a97e:	b082      	sub	sp, #8
}
 800a980:	4608      	mov	r0, r1
 800a982:	b002      	add	sp, #8
 800a984:	4770      	bx	lr
 800a986:	bf00      	nop

0800a988 <STO_PLL_GetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    *phC2 = pHandle->hC2;
 800a988:	f9b0 3022 	ldrsh.w	r3, [r0, #34]	; 0x22
 800a98c:	800b      	strh	r3, [r1, #0]
    *phC4 = pHandle->hC4;
 800a98e:	f9b0 3026 	ldrsh.w	r3, [r0, #38]	; 0x26
 800a992:	8013      	strh	r3, [r2, #0]
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
}
 800a994:	4770      	bx	lr
 800a996:	bf00      	nop

0800a998 <STO_PLL_SetObserverGains>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->hC2 = hhC1;
 800a998:	8441      	strh	r1, [r0, #34]	; 0x22
    pHandle->hC4 = hhC2;
 800a99a:	84c2      	strh	r2, [r0, #38]	; 0x26
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  }
#endif
}
 800a99c:	4770      	bx	lr
 800a99e:	bf00      	nop

0800a9a0 <STO_PLL_GetEstimatedBemfLevel>:
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  return ((MC_NULL == pHandle) ? 0 : pHandle->Est_Bemf_Level);
#else
  return (pHandle->Est_Bemf_Level);
#endif
}
 800a9a0:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 800a9a4:	4770      	bx	lr
 800a9a6:	bf00      	nop

0800a9a8 <STO_PLL_GetObservedBemfLevel>:
#ifdef NULL_PTR_CHECK_STO_PLL_SPD_POS_FDB
  return ((MC_NULL == pHandle) ? 0 : pHandle->Obs_Bemf_Level);
#else
  return (pHandle->Obs_Bemf_Level);
#endif
}
 800a9a8:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 800a9ac:	4770      	bx	lr
 800a9ae:	bf00      	nop

0800a9b0 <VSS_Clear>:
    /* Nothing to do */
  }
  else
  {
#endif
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a9b0:	2300      	movs	r3, #0
    pHandle->hRemainingStep = 0U;
    pHandle->hElAngleAccu = 0;

    pHandle->bTransitionStarted = false;
    pHandle->bTransitionEnded = false;
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800a9b2:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
    pHandle->_Super.bSpeedErrorNumber = 0U;
 800a9b4:	7003      	strb	r3, [r0, #0]
    pHandle->wElSpeedDpp32 = 0;
 800a9b6:	e9c0 3308 	strd	r3, r3, [r0, #32]
    pHandle->_Super.hElAngle = 0;
 800a9ba:	6043      	str	r3, [r0, #4]
    pHandle->_Super.hAvrMecSpeedUnit = 0;
 800a9bc:	60c3      	str	r3, [r0, #12]
    pHandle->_Super.hMecAccelUnitP = 0;
 800a9be:	8243      	strh	r3, [r0, #18]
    pHandle->hRemainingStep = 0U;
 800a9c0:	8503      	strh	r3, [r0, #40]	; 0x28
    pHandle->bTransitionStarted = false;
 800a9c2:	8583      	strh	r3, [r0, #44]	; 0x2c
    pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
 800a9c4:	85c2      	strh	r2, [r0, #46]	; 0x2e
    pHandle->hElAngleAccu = 0;
 800a9c6:	6303      	str	r3, [r0, #48]	; 0x30

    pHandle->bCopyObserver = false;
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800a9c8:	4770      	bx	lr
 800a9ca:	bf00      	nop

0800a9cc <VSS_Init>:
{
 800a9cc:	b508      	push	{r3, lr}
  VSS_Clear(pHandle);
 800a9ce:	f7ff ffef 	bl	800a9b0 <VSS_Clear>
}
 800a9d2:	bd08      	pop	{r3, pc}

0800a9d4 <VSS_SetMecAngle>:
  }
  else
  {
#endif
    pHandle->hElAngleAccu = hMecAngle;
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a9d4:	7843      	ldrb	r3, [r0, #1]
    pHandle->hElAngleAccu = hMecAngle;
 800a9d6:	8601      	strh	r1, [r0, #48]	; 0x30
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a9d8:	fb91 f3f3 	sdiv	r3, r1, r3
    pHandle->_Super.hElAngle = hMecAngle;
 800a9dc:	8081      	strh	r1, [r0, #4]
    pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ((int16_t)pHandle->_Super.bElToMecRatio);
 800a9de:	80c3      	strh	r3, [r0, #6]
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800a9e0:	4770      	bx	lr
 800a9e2:	bf00      	nop

0800a9e4 <VSS_SetMecAcceleration>:
    int32_t wMecAccDppP32;
    uint16_t hNbrStep;
    int16_t hCurrentMecSpeedDpp;
    int16_t hFinalMecSpeedDpp;

    if (false == pHandle->bTransitionStarted)
 800a9e4:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800a9e8:	b99b      	cbnz	r3, 800aa12 <VSS_SetMecAcceleration+0x2e>
{
 800a9ea:	b510      	push	{r4, lr}
    {
      if (0U == hDurationms)
 800a9ec:	b992      	cbnz	r2, 800aa14 <VSS_SetMecAcceleration+0x30>
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;

        pHandle->_Super.hElSpeedDpp = (int16_t)((((int32_t)hFinalMecSpeedUnit)
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
                                              / (((int32_t)SPEED_UNIT)
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a9ee:	8b43      	ldrh	r3, [r0, #26]
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a9f0:	69c4      	ldr	r4, [r0, #28]
        pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;
 800a9f2:	8181      	strh	r1, [r0, #12]
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a9f4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
                                               * ((int32_t)pHandle->_Super.DPPConvFactor))
 800a9f8:	fb04 fc01 	mul.w	ip, r4, r1
                                               * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800a9fc:	005b      	lsls	r3, r3, #1
                                              / (((int32_t)SPEED_UNIT)
 800a9fe:	fb9c f3f3 	sdiv	r3, ip, r3

        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa02:	f890 c001 	ldrb.w	ip, [r0, #1]

        pHandle->hRemainingStep = 0U;
 800aa06:	8502      	strh	r2, [r0, #40]	; 0x28
        pHandle->_Super.hElSpeedDpp *= ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa08:	fb1c f303 	smulbb	r3, ip, r3
 800aa0c:	81c3      	strh	r3, [r0, #14]

        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa0e:	8541      	strh	r1, [r0, #42]	; 0x2a
      /* Nothing to do */
    }
#ifdef NULL_PTR_CHECK_VIR_SPD_SEN
  }
#endif
}
 800aa10:	bd10      	pop	{r4, pc}
 800aa12:	4770      	bx	lr
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800aa14:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 800aa16:	4c16      	ldr	r4, [pc, #88]	; (800aa70 <VSS_SetMecAcceleration+0x8c>)
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa18:	f9b0 c00e 	ldrsh.w	ip, [r0, #14]
        hNbrStep = (uint16_t)((((uint32_t)hDurationms) * ((uint32_t)pHandle->hSpeedSamplingFreqHz)) / 1000U);
 800aa1c:	fb02 f303 	mul.w	r3, r2, r3
 800aa20:	fba4 4303 	umull	r4, r3, r4, r3
 800aa24:	f3c3 138f 	ubfx	r3, r3, #6, #16
        hNbrStep++;
 800aa28:	3301      	adds	r3, #1
 800aa2a:	b29b      	uxth	r3, r3
        pHandle->hRemainingStep = hNbrStep;
 800aa2c:	8503      	strh	r3, [r0, #40]	; 0x28
        if (0U == hNbrStep)
 800aa2e:	b923      	cbnz	r3, 800aa3a <VSS_SetMecAcceleration+0x56>
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aa30:	ea4f 430c 	mov.w	r3, ip, lsl #16
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa34:	8541      	strh	r1, [r0, #42]	; 0x2a
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aa36:	6243      	str	r3, [r0, #36]	; 0x24
}
 800aa38:	bd10      	pop	{r4, pc}
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa3a:	8b42      	ldrh	r2, [r0, #26]
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa3c:	7844      	ldrb	r4, [r0, #1]
        pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
 800aa3e:	8541      	strh	r1, [r0, #42]	; 0x2a
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa40:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800aa44:	ea4f 0e42 	mov.w	lr, r2, lsl #1
        hFinalMecSpeedDpp = (int16_t)((((int32_t )hFinalMecSpeedUnit) * ((int32_t)pHandle->_Super.DPPConvFactor))
 800aa48:	69c2      	ldr	r2, [r0, #28]
 800aa4a:	fb01 f202 	mul.w	r2, r1, r2
                                    / (((int32_t )SPEED_UNIT) * ((int32_t)pHandle->_Super.hMeasurementFrequency)));
 800aa4e:	fb92 f2fe 	sdiv	r2, r2, lr
        hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp / ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa52:	fb9c fef4 	sdiv	lr, ip, r4
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800aa56:	eba2 020e 	sub.w	r2, r2, lr
                         * ((int32_t)65536)) / ((int32_t )hNbrStep);
 800aa5a:	0412      	lsls	r2, r2, #16
          wMecAccDppP32 = ((((int32_t)hFinalMecSpeedDpp) - ((int32_t)hCurrentMecSpeedDpp))
 800aa5c:	fb92 f3f3 	sdiv	r3, r2, r3
          pHandle->wElAccDppP32 = wMecAccDppP32 * ((int16_t)pHandle->_Super.bElToMecRatio);
 800aa60:	fb04 f303 	mul.w	r3, r4, r3
 800aa64:	6203      	str	r3, [r0, #32]
        pHandle->wElSpeedDpp32 = ((int32_t)pHandle->_Super.hElSpeedDpp) * ((int32_t)65536);
 800aa66:	ea4f 430c 	mov.w	r3, ip, lsl #16
 800aa6a:	6243      	str	r3, [r0, #36]	; 0x24
    }
 800aa6c:	e7e4      	b.n	800aa38 <VSS_SetMecAcceleration+0x54>
 800aa6e:	bf00      	nop
 800aa70:	10624dd3 	.word	0x10624dd3

0800aa74 <ai_buffer_get_size>:
 800aa74:	b378      	cbz	r0, 800aad6 <ai_buffer_get_size+0x62>
 800aa76:	b410      	push	{r4}
 800aa78:	6803      	ldr	r3, [r0, #0]
 800aa7a:	4a17      	ldr	r2, [pc, #92]	; (800aad8 <ai_buffer_get_size+0x64>)
 800aa7c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
 800aa80:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800aa84:	4293      	cmp	r3, r2
 800aa86:	d01e      	beq.n	800aac6 <ai_buffer_get_size+0x52>
 800aa88:	6984      	ldr	r4, [r0, #24]
 800aa8a:	6862      	ldr	r2, [r4, #4]
 800aa8c:	7d03      	ldrb	r3, [r0, #20]
 800aa8e:	6941      	ldr	r1, [r0, #20]
 800aa90:	f1a3 0301 	sub.w	r3, r3, #1
 800aa94:	fab3 f383 	clz	r3, r3
 800aa98:	095b      	lsrs	r3, r3, #5
 800aa9a:	ebb3 2f11 	cmp.w	r3, r1, lsr #8
 800aa9e:	f3c1 2017 	ubfx	r0, r1, #8, #24
 800aaa2:	da0b      	bge.n	800aabc <ai_buffer_get_size+0x48>
 800aaa4:	2b01      	cmp	r3, #1
 800aaa6:	d102      	bne.n	800aaae <ai_buffer_get_size+0x3a>
 800aaa8:	2802      	cmp	r0, #2
 800aaaa:	d007      	beq.n	800aabc <ai_buffer_get_size+0x48>
 800aaac:	2302      	movs	r3, #2
 800aaae:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 800aab2:	3301      	adds	r3, #1
 800aab4:	4298      	cmp	r0, r3
 800aab6:	fb01 f202 	mul.w	r2, r1, r2
 800aaba:	d1f3      	bne.n	800aaa4 <ai_buffer_get_size+0x30>
 800aabc:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
 800aac0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800aac4:	4770      	bx	lr
 800aac6:	2900      	cmp	r1, #0
 800aac8:	d0de      	beq.n	800aa88 <ai_buffer_get_size+0x14>
 800aaca:	6984      	ldr	r4, [r0, #24]
 800aacc:	6863      	ldr	r3, [r4, #4]
 800aace:	331f      	adds	r3, #31
 800aad0:	f023 021f 	bic.w	r2, r3, #31
 800aad4:	e7da      	b.n	800aa8c <ai_buffer_get_size+0x18>
 800aad6:	4770      	bx	lr
 800aad8:	000400c0 	.word	0x000400c0

0800aadc <ai_buffer_array_sane>:
 800aadc:	b138      	cbz	r0, 800aaee <ai_buffer_array_sane+0x12>
 800aade:	6843      	ldr	r3, [r0, #4]
 800aae0:	b123      	cbz	r3, 800aaec <ai_buffer_array_sane+0x10>
 800aae2:	8840      	ldrh	r0, [r0, #2]
 800aae4:	3800      	subs	r0, #0
 800aae6:	bf18      	it	ne
 800aae8:	2001      	movne	r0, #1
 800aaea:	4770      	bx	lr
 800aaec:	4618      	mov	r0, r3
 800aaee:	4770      	bx	lr

0800aaf0 <ai_buffer_array_item_set_address>:
 800aaf0:	b150      	cbz	r0, 800ab08 <ai_buffer_array_item_set_address+0x18>
 800aaf2:	6843      	ldr	r3, [r0, #4]
 800aaf4:	b14b      	cbz	r3, 800ab0a <ai_buffer_array_item_set_address+0x1a>
 800aaf6:	8840      	ldrh	r0, [r0, #2]
 800aaf8:	b900      	cbnz	r0, 800aafc <ai_buffer_array_item_set_address+0xc>
 800aafa:	4770      	bx	lr
 800aafc:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800ab00:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800ab04:	2001      	movs	r0, #1
 800ab06:	604a      	str	r2, [r1, #4]
 800ab08:	4770      	bx	lr
 800ab0a:	4618      	mov	r0, r3
 800ab0c:	4770      	bx	lr
 800ab0e:	bf00      	nop

0800ab10 <_ai_platform_acquire_crc>:
 800ab10:	2001      	movs	r0, #1
 800ab12:	4770      	bx	lr

0800ab14 <_ai_platform_release_crc>:
 800ab14:	4770      	bx	lr
 800ab16:	bf00      	nop

0800ab18 <ai_platform_get_weights_map>:
 800ab18:	2a00      	cmp	r2, #0
 800ab1a:	d037      	beq.n	800ab8c <ai_platform_get_weights_map+0x74>
 800ab1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ab1e:	4604      	mov	r4, r0
 800ab20:	b1a0      	cbz	r0, 800ab4c <ai_platform_get_weights_map+0x34>
 800ab22:	460f      	mov	r7, r1
 800ab24:	b191      	cbz	r1, 800ab4c <ai_platform_get_weights_map+0x34>
 800ab26:	4b25      	ldr	r3, [pc, #148]	; (800abbc <ai_platform_get_weights_map+0xa4>)
 800ab28:	6810      	ldr	r0, [r2, #0]
 800ab2a:	4298      	cmp	r0, r3
 800ab2c:	4615      	mov	r5, r2
 800ab2e:	d00f      	beq.n	800ab50 <ai_platform_get_weights_map+0x38>
 800ab30:	6855      	ldr	r5, [r2, #4]
 800ab32:	b15d      	cbz	r5, 800ab4c <ai_platform_get_weights_map+0x34>
 800ab34:	682e      	ldr	r6, [r5, #0]
 800ab36:	429e      	cmp	r6, r3
 800ab38:	d02a      	beq.n	800ab90 <ai_platform_get_weights_map+0x78>
 800ab3a:	f1a1 0001 	sub.w	r0, r1, #1
 800ab3e:	6025      	str	r5, [r4, #0]
 800ab40:	fab0 f080 	clz	r0, r0
 800ab44:	0940      	lsrs	r0, r0, #5
 800ab46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab48:	42a7      	cmp	r7, r4
 800ab4a:	d034      	beq.n	800abb6 <ai_platform_get_weights_map+0x9e>
 800ab4c:	2000      	movs	r0, #0
 800ab4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab50:	1d10      	adds	r0, r2, #4
 800ab52:	f7ff ffc3 	bl	800aadc <ai_buffer_array_sane>
 800ab56:	2800      	cmp	r0, #0
 800ab58:	d0f8      	beq.n	800ab4c <ai_platform_get_weights_map+0x34>
 800ab5a:	88eb      	ldrh	r3, [r5, #6]
 800ab5c:	429f      	cmp	r7, r3
 800ab5e:	d1f5      	bne.n	800ab4c <ai_platform_get_weights_map+0x34>
 800ab60:	f04f 0e00 	mov.w	lr, #0
 800ab64:	1f23      	subs	r3, r4, #4
 800ab66:	4670      	mov	r0, lr
 800ab68:	68aa      	ldr	r2, [r5, #8]
 800ab6a:	eb02 0c0e 	add.w	ip, r2, lr
 800ab6e:	f10e 0e1c 	add.w	lr, lr, #28
 800ab72:	f8dc 4004 	ldr.w	r4, [ip, #4]
 800ab76:	b124      	cbz	r4, 800ab82 <ai_platform_get_weights_map+0x6a>
 800ab78:	3001      	adds	r0, #1
 800ab7a:	4287      	cmp	r7, r0
 800ab7c:	f843 4f04 	str.w	r4, [r3, #4]!
 800ab80:	d1f2      	bne.n	800ab68 <ai_platform_get_weights_map+0x50>
 800ab82:	1a38      	subs	r0, r7, r0
 800ab84:	fab0 f080 	clz	r0, r0
 800ab88:	0940      	lsrs	r0, r0, #5
 800ab8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab8c:	2000      	movs	r0, #0
 800ab8e:	4770      	bx	lr
 800ab90:	1f23      	subs	r3, r4, #4
 800ab92:	4628      	mov	r0, r5
 800ab94:	2400      	movs	r4, #0
 800ab96:	e000      	b.n	800ab9a <ai_platform_get_weights_map+0x82>
 800ab98:	4614      	mov	r4, r2
 800ab9a:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800ab9e:	42b2      	cmp	r2, r6
 800aba0:	d0d2      	beq.n	800ab48 <ai_platform_get_weights_map+0x30>
 800aba2:	f843 2f04 	str.w	r2, [r3, #4]!
 800aba6:	1c62      	adds	r2, r4, #1
 800aba8:	4297      	cmp	r7, r2
 800abaa:	d1f5      	bne.n	800ab98 <ai_platform_get_weights_map+0x80>
 800abac:	3402      	adds	r4, #2
 800abae:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800abb2:	42b3      	cmp	r3, r6
 800abb4:	d1ca      	bne.n	800ab4c <ai_platform_get_weights_map+0x34>
 800abb6:	2001      	movs	r0, #1
 800abb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abba:	bf00      	nop
 800abbc:	a1facade 	.word	0xa1facade

0800abc0 <ai_platform_get_activations_map>:
 800abc0:	2a00      	cmp	r2, #0
 800abc2:	d038      	beq.n	800ac36 <ai_platform_get_activations_map+0x76>
 800abc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800abc6:	4604      	mov	r4, r0
 800abc8:	b1a0      	cbz	r0, 800abf4 <ai_platform_get_activations_map+0x34>
 800abca:	460f      	mov	r7, r1
 800abcc:	b191      	cbz	r1, 800abf4 <ai_platform_get_activations_map+0x34>
 800abce:	4b25      	ldr	r3, [pc, #148]	; (800ac64 <ai_platform_get_activations_map+0xa4>)
 800abd0:	6810      	ldr	r0, [r2, #0]
 800abd2:	4298      	cmp	r0, r3
 800abd4:	4615      	mov	r5, r2
 800abd6:	d00f      	beq.n	800abf8 <ai_platform_get_activations_map+0x38>
 800abd8:	6a15      	ldr	r5, [r2, #32]
 800abda:	b15d      	cbz	r5, 800abf4 <ai_platform_get_activations_map+0x34>
 800abdc:	682e      	ldr	r6, [r5, #0]
 800abde:	429e      	cmp	r6, r3
 800abe0:	d02b      	beq.n	800ac3a <ai_platform_get_activations_map+0x7a>
 800abe2:	f1a1 0001 	sub.w	r0, r1, #1
 800abe6:	6025      	str	r5, [r4, #0]
 800abe8:	fab0 f080 	clz	r0, r0
 800abec:	0940      	lsrs	r0, r0, #5
 800abee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abf0:	42a7      	cmp	r7, r4
 800abf2:	d035      	beq.n	800ac60 <ai_platform_get_activations_map+0xa0>
 800abf4:	2000      	movs	r0, #0
 800abf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abf8:	f102 000c 	add.w	r0, r2, #12
 800abfc:	f7ff ff6e 	bl	800aadc <ai_buffer_array_sane>
 800ac00:	2800      	cmp	r0, #0
 800ac02:	d0f7      	beq.n	800abf4 <ai_platform_get_activations_map+0x34>
 800ac04:	89eb      	ldrh	r3, [r5, #14]
 800ac06:	429f      	cmp	r7, r3
 800ac08:	d1f4      	bne.n	800abf4 <ai_platform_get_activations_map+0x34>
 800ac0a:	f04f 0e00 	mov.w	lr, #0
 800ac0e:	1f23      	subs	r3, r4, #4
 800ac10:	4670      	mov	r0, lr
 800ac12:	692a      	ldr	r2, [r5, #16]
 800ac14:	eb02 0c0e 	add.w	ip, r2, lr
 800ac18:	f10e 0e1c 	add.w	lr, lr, #28
 800ac1c:	f8dc 4004 	ldr.w	r4, [ip, #4]
 800ac20:	b124      	cbz	r4, 800ac2c <ai_platform_get_activations_map+0x6c>
 800ac22:	3001      	adds	r0, #1
 800ac24:	4287      	cmp	r7, r0
 800ac26:	f843 4f04 	str.w	r4, [r3, #4]!
 800ac2a:	d1f2      	bne.n	800ac12 <ai_platform_get_activations_map+0x52>
 800ac2c:	1a38      	subs	r0, r7, r0
 800ac2e:	fab0 f080 	clz	r0, r0
 800ac32:	0940      	lsrs	r0, r0, #5
 800ac34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac36:	2000      	movs	r0, #0
 800ac38:	4770      	bx	lr
 800ac3a:	1f23      	subs	r3, r4, #4
 800ac3c:	4628      	mov	r0, r5
 800ac3e:	2400      	movs	r4, #0
 800ac40:	e000      	b.n	800ac44 <ai_platform_get_activations_map+0x84>
 800ac42:	4614      	mov	r4, r2
 800ac44:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800ac48:	42b2      	cmp	r2, r6
 800ac4a:	d0d1      	beq.n	800abf0 <ai_platform_get_activations_map+0x30>
 800ac4c:	f843 2f04 	str.w	r2, [r3, #4]!
 800ac50:	1c62      	adds	r2, r4, #1
 800ac52:	4297      	cmp	r7, r2
 800ac54:	d1f5      	bne.n	800ac42 <ai_platform_get_activations_map+0x82>
 800ac56:	3402      	adds	r4, #2
 800ac58:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800ac5c:	42b3      	cmp	r3, r6
 800ac5e:	d1c9      	bne.n	800abf4 <ai_platform_get_activations_map+0x34>
 800ac60:	2001      	movs	r0, #1
 800ac62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac64:	a1facade 	.word	0xa1facade

0800ac68 <ai_platform_bind_network_params>:
 800ac68:	b1a0      	cbz	r0, 800ac94 <ai_platform_bind_network_params+0x2c>
 800ac6a:	b1b1      	cbz	r1, 800ac9a <ai_platform_bind_network_params+0x32>
 800ac6c:	b1c2      	cbz	r2, 800aca0 <ai_platform_bind_network_params+0x38>
 800ac6e:	b410      	push	{r4}
 800ac70:	4603      	mov	r3, r0
 800ac72:	4c0d      	ldr	r4, [pc, #52]	; (800aca8 <ai_platform_bind_network_params+0x40>)
 800ac74:	f843 4b04 	str.w	r4, [r3], #4
 800ac78:	f100 0c0c 	add.w	ip, r0, #12
 800ac7c:	c903      	ldmia	r1, {r0, r1}
 800ac7e:	e883 0003 	stmia.w	r3, {r0, r1}
 800ac82:	e892 0003 	ldmia.w	r2, {r0, r1}
 800ac86:	e88c 0003 	stmia.w	ip, {r0, r1}
 800ac8a:	2301      	movs	r3, #1
 800ac8c:	4618      	mov	r0, r3
 800ac8e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ac92:	4770      	bx	lr
 800ac94:	4603      	mov	r3, r0
 800ac96:	4618      	mov	r0, r3
 800ac98:	4770      	bx	lr
 800ac9a:	460b      	mov	r3, r1
 800ac9c:	4618      	mov	r0, r3
 800ac9e:	4770      	bx	lr
 800aca0:	4613      	mov	r3, r2
 800aca2:	4618      	mov	r0, r3
 800aca4:	4770      	bx	lr
 800aca6:	bf00      	nop
 800aca8:	a1facade 	.word	0xa1facade

0800acac <ai_platform_network_get_error>:
 800acac:	b510      	push	{r4, lr}
 800acae:	b1f0      	cbz	r0, 800acee <ai_platform_network_get_error+0x42>
 800acb0:	4b2f      	ldr	r3, [pc, #188]	; (800ad70 <ai_platform_network_get_error+0xc4>)
 800acb2:	6802      	ldr	r2, [r0, #0]
 800acb4:	429a      	cmp	r2, r3
 800acb6:	4604      	mov	r4, r0
 800acb8:	d119      	bne.n	800acee <ai_platform_network_get_error+0x42>
 800acba:	f7ff ff29 	bl	800ab10 <_ai_platform_acquire_crc>
 800acbe:	4b2d      	ldr	r3, [pc, #180]	; (800ad74 <ai_platform_network_get_error+0xc8>)
 800acc0:	681b      	ldr	r3, [r3, #0]
 800acc2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800acc6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800acca:	d03c      	beq.n	800ad46 <ai_platform_network_get_error+0x9a>
 800accc:	4a2a      	ldr	r2, [pc, #168]	; (800ad78 <ai_platform_network_get_error+0xcc>)
 800acce:	2301      	movs	r3, #1
 800acd0:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800acd4:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800acd8:	2b00      	cmp	r3, #0
 800acda:	d1fb      	bne.n	800acd4 <ai_platform_network_get_error+0x28>
 800acdc:	4b27      	ldr	r3, [pc, #156]	; (800ad7c <ai_platform_network_get_error+0xd0>)
 800acde:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ace2:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ace6:	4b26      	ldr	r3, [pc, #152]	; (800ad80 <ai_platform_network_get_error+0xd4>)
 800ace8:	429a      	cmp	r2, r3
 800acea:	d038      	beq.n	800ad5e <ai_platform_network_get_error+0xb2>
 800acec:	e7fe      	b.n	800acec <ai_platform_network_get_error+0x40>
 800acee:	f7ff ff0f 	bl	800ab10 <_ai_platform_acquire_crc>
 800acf2:	4b20      	ldr	r3, [pc, #128]	; (800ad74 <ai_platform_network_get_error+0xc8>)
 800acf4:	681b      	ldr	r3, [r3, #0]
 800acf6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800acfa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800acfe:	d010      	beq.n	800ad22 <ai_platform_network_get_error+0x76>
 800ad00:	4a1d      	ldr	r2, [pc, #116]	; (800ad78 <ai_platform_network_get_error+0xcc>)
 800ad02:	2301      	movs	r3, #1
 800ad04:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800ad08:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800ad0c:	2b00      	cmp	r3, #0
 800ad0e:	d1fb      	bne.n	800ad08 <ai_platform_network_get_error+0x5c>
 800ad10:	4b1a      	ldr	r3, [pc, #104]	; (800ad7c <ai_platform_network_get_error+0xd0>)
 800ad12:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ad16:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ad1a:	4b19      	ldr	r3, [pc, #100]	; (800ad80 <ai_platform_network_get_error+0xd4>)
 800ad1c:	429a      	cmp	r2, r3
 800ad1e:	d00d      	beq.n	800ad3c <ai_platform_network_get_error+0x90>
 800ad20:	e7fe      	b.n	800ad20 <ai_platform_network_get_error+0x74>
 800ad22:	4a18      	ldr	r2, [pc, #96]	; (800ad84 <ai_platform_network_get_error+0xd8>)
 800ad24:	2301      	movs	r3, #1
 800ad26:	6093      	str	r3, [r2, #8]
 800ad28:	6893      	ldr	r3, [r2, #8]
 800ad2a:	2b00      	cmp	r3, #0
 800ad2c:	d1fc      	bne.n	800ad28 <ai_platform_network_get_error+0x7c>
 800ad2e:	4b13      	ldr	r3, [pc, #76]	; (800ad7c <ai_platform_network_get_error+0xd0>)
 800ad30:	6013      	str	r3, [r2, #0]
 800ad32:	6812      	ldr	r2, [r2, #0]
 800ad34:	4b12      	ldr	r3, [pc, #72]	; (800ad80 <ai_platform_network_get_error+0xd4>)
 800ad36:	429a      	cmp	r2, r3
 800ad38:	d000      	beq.n	800ad3c <ai_platform_network_get_error+0x90>
 800ad3a:	e7fe      	b.n	800ad3a <ai_platform_network_get_error+0x8e>
 800ad3c:	f7ff feea 	bl	800ab14 <_ai_platform_release_crc>
 800ad40:	f241 0010 	movw	r0, #4112	; 0x1010
 800ad44:	bd10      	pop	{r4, pc}
 800ad46:	4a0f      	ldr	r2, [pc, #60]	; (800ad84 <ai_platform_network_get_error+0xd8>)
 800ad48:	2301      	movs	r3, #1
 800ad4a:	6093      	str	r3, [r2, #8]
 800ad4c:	6893      	ldr	r3, [r2, #8]
 800ad4e:	2b00      	cmp	r3, #0
 800ad50:	d1fc      	bne.n	800ad4c <ai_platform_network_get_error+0xa0>
 800ad52:	4b0a      	ldr	r3, [pc, #40]	; (800ad7c <ai_platform_network_get_error+0xd0>)
 800ad54:	6013      	str	r3, [r2, #0]
 800ad56:	6812      	ldr	r2, [r2, #0]
 800ad58:	4b09      	ldr	r3, [pc, #36]	; (800ad80 <ai_platform_network_get_error+0xd4>)
 800ad5a:	429a      	cmp	r2, r3
 800ad5c:	d107      	bne.n	800ad6e <ai_platform_network_get_error+0xc2>
 800ad5e:	f7ff fed9 	bl	800ab14 <_ai_platform_release_crc>
 800ad62:	f104 0010 	add.w	r0, r4, #16
 800ad66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800ad6a:	f000 be8b 	b.w	800ba84 <core_get_error>
 800ad6e:	e7fe      	b.n	800ad6e <ai_platform_network_get_error+0xc2>
 800ad70:	a1c00100 	.word	0xa1c00100
 800ad74:	e0042000 	.word	0xe0042000
 800ad78:	58024000 	.word	0x58024000
 800ad7c:	f407a5c2 	.word	0xf407a5c2
 800ad80:	b5e8b5cd 	.word	0xb5e8b5cd
 800ad84:	40023000 	.word	0x40023000

0800ad88 <ai_platform_network_set_error>:
 800ad88:	b110      	cbz	r0, 800ad90 <ai_platform_network_set_error+0x8>
 800ad8a:	3010      	adds	r0, #16
 800ad8c:	f000 be80 	b.w	800ba90 <core_set_error>
 800ad90:	4770      	bx	lr
 800ad92:	bf00      	nop

0800ad94 <ai_platform_inputs_get>:
 800ad94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ad98:	b085      	sub	sp, #20
 800ad9a:	9102      	str	r1, [sp, #8]
 800ad9c:	b1f0      	cbz	r0, 800addc <ai_platform_inputs_get+0x48>
 800ad9e:	4b62      	ldr	r3, [pc, #392]	; (800af28 <ai_platform_inputs_get+0x194>)
 800ada0:	6802      	ldr	r2, [r0, #0]
 800ada2:	429a      	cmp	r2, r3
 800ada4:	4607      	mov	r7, r0
 800ada6:	d119      	bne.n	800addc <ai_platform_inputs_get+0x48>
 800ada8:	f7ff feb2 	bl	800ab10 <_ai_platform_acquire_crc>
 800adac:	4b5f      	ldr	r3, [pc, #380]	; (800af2c <ai_platform_inputs_get+0x198>)
 800adae:	681b      	ldr	r3, [r3, #0]
 800adb0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800adb4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800adb8:	d03d      	beq.n	800ae36 <ai_platform_inputs_get+0xa2>
 800adba:	4a5d      	ldr	r2, [pc, #372]	; (800af30 <ai_platform_inputs_get+0x19c>)
 800adbc:	2301      	movs	r3, #1
 800adbe:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800adc2:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800adc6:	2b00      	cmp	r3, #0
 800adc8:	d1fb      	bne.n	800adc2 <ai_platform_inputs_get+0x2e>
 800adca:	4b5a      	ldr	r3, [pc, #360]	; (800af34 <ai_platform_inputs_get+0x1a0>)
 800adcc:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800add0:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800add4:	4b58      	ldr	r3, [pc, #352]	; (800af38 <ai_platform_inputs_get+0x1a4>)
 800add6:	429a      	cmp	r2, r3
 800add8:	d039      	beq.n	800ae4e <ai_platform_inputs_get+0xba>
 800adda:	e7fe      	b.n	800adda <ai_platform_inputs_get+0x46>
 800addc:	f7ff fe98 	bl	800ab10 <_ai_platform_acquire_crc>
 800ade0:	4b52      	ldr	r3, [pc, #328]	; (800af2c <ai_platform_inputs_get+0x198>)
 800ade2:	681b      	ldr	r3, [r3, #0]
 800ade4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800ade8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800adec:	d010      	beq.n	800ae10 <ai_platform_inputs_get+0x7c>
 800adee:	4a50      	ldr	r2, [pc, #320]	; (800af30 <ai_platform_inputs_get+0x19c>)
 800adf0:	2301      	movs	r3, #1
 800adf2:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800adf6:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800adfa:	2b00      	cmp	r3, #0
 800adfc:	d1fb      	bne.n	800adf6 <ai_platform_inputs_get+0x62>
 800adfe:	4b4d      	ldr	r3, [pc, #308]	; (800af34 <ai_platform_inputs_get+0x1a0>)
 800ae00:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800ae04:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800ae08:	4b4b      	ldr	r3, [pc, #300]	; (800af38 <ai_platform_inputs_get+0x1a4>)
 800ae0a:	429a      	cmp	r2, r3
 800ae0c:	d00d      	beq.n	800ae2a <ai_platform_inputs_get+0x96>
 800ae0e:	e7fe      	b.n	800ae0e <ai_platform_inputs_get+0x7a>
 800ae10:	4a4a      	ldr	r2, [pc, #296]	; (800af3c <ai_platform_inputs_get+0x1a8>)
 800ae12:	2301      	movs	r3, #1
 800ae14:	6093      	str	r3, [r2, #8]
 800ae16:	6893      	ldr	r3, [r2, #8]
 800ae18:	2b00      	cmp	r3, #0
 800ae1a:	d1fc      	bne.n	800ae16 <ai_platform_inputs_get+0x82>
 800ae1c:	4b45      	ldr	r3, [pc, #276]	; (800af34 <ai_platform_inputs_get+0x1a0>)
 800ae1e:	6013      	str	r3, [r2, #0]
 800ae20:	6812      	ldr	r2, [r2, #0]
 800ae22:	4b45      	ldr	r3, [pc, #276]	; (800af38 <ai_platform_inputs_get+0x1a4>)
 800ae24:	429a      	cmp	r2, r3
 800ae26:	d000      	beq.n	800ae2a <ai_platform_inputs_get+0x96>
 800ae28:	e7fe      	b.n	800ae28 <ai_platform_inputs_get+0x94>
 800ae2a:	f7ff fe73 	bl	800ab14 <_ai_platform_release_crc>
 800ae2e:	2000      	movs	r0, #0
 800ae30:	b005      	add	sp, #20
 800ae32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ae36:	4a41      	ldr	r2, [pc, #260]	; (800af3c <ai_platform_inputs_get+0x1a8>)
 800ae38:	2301      	movs	r3, #1
 800ae3a:	6093      	str	r3, [r2, #8]
 800ae3c:	6893      	ldr	r3, [r2, #8]
 800ae3e:	2b00      	cmp	r3, #0
 800ae40:	d1fc      	bne.n	800ae3c <ai_platform_inputs_get+0xa8>
 800ae42:	4b3c      	ldr	r3, [pc, #240]	; (800af34 <ai_platform_inputs_get+0x1a0>)
 800ae44:	6013      	str	r3, [r2, #0]
 800ae46:	6812      	ldr	r2, [r2, #0]
 800ae48:	4b3b      	ldr	r3, [pc, #236]	; (800af38 <ai_platform_inputs_get+0x1a4>)
 800ae4a:	429a      	cmp	r2, r3
 800ae4c:	d155      	bne.n	800aefa <ai_platform_inputs_get+0x166>
 800ae4e:	f7ff fe61 	bl	800ab14 <_ai_platform_release_crc>
 800ae52:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800ae54:	2b00      	cmp	r3, #0
 800ae56:	d051      	beq.n	800aefc <ai_platform_inputs_get+0x168>
 800ae58:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
 800ae5c:	f1ba 0f00 	cmp.w	sl, #0
 800ae60:	d04c      	beq.n	800aefc <ai_platform_inputs_get+0x168>
 800ae62:	f04f 0b00 	mov.w	fp, #0
 800ae66:	465d      	mov	r5, fp
 800ae68:	9703      	str	r7, [sp, #12]
 800ae6a:	e016      	b.n	800ae9a <ai_platform_inputs_get+0x106>
 800ae6c:	9901      	ldr	r1, [sp, #4]
 800ae6e:	2301      	movs	r3, #1
 800ae70:	507b      	str	r3, [r7, r1]
 800ae72:	69b1      	ldr	r1, [r6, #24]
 800ae74:	6849      	ldr	r1, [r1, #4]
 800ae76:	6121      	str	r1, [r4, #16]
 800ae78:	f04f 0301 	mov.w	r3, #1
 800ae7c:	7523      	strb	r3, [r4, #20]
 800ae7e:	e9c4 c200 	strd	ip, r2, [r4]
 800ae82:	6962      	ldr	r2, [r4, #20]
 800ae84:	60a0      	str	r0, [r4, #8]
 800ae86:	2300      	movs	r3, #0
 800ae88:	f369 221f 	bfi	r2, r9, #8, #24
 800ae8c:	f8c4 8018 	str.w	r8, [r4, #24]
 800ae90:	60e3      	str	r3, [r4, #12]
 800ae92:	3501      	adds	r5, #1
 800ae94:	f10b 0b1c 	add.w	fp, fp, #28
 800ae98:	6162      	str	r2, [r4, #20]
 800ae9a:	f8ba 3000 	ldrh.w	r3, [sl]
 800ae9e:	42ab      	cmp	r3, r5
 800aea0:	b2aa      	uxth	r2, r5
 800aea2:	d93a      	bls.n	800af1a <ai_platform_inputs_get+0x186>
 800aea4:	f8da 3004 	ldr.w	r3, [sl, #4]
 800aea8:	00e9      	lsls	r1, r5, #3
 800aeaa:	9101      	str	r1, [sp, #4]
 800aeac:	2b00      	cmp	r3, #0
 800aeae:	d034      	beq.n	800af1a <ai_platform_inputs_get+0x186>
 800aeb0:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 800aeb4:	2e00      	cmp	r6, #0
 800aeb6:	d030      	beq.n	800af1a <ai_platform_inputs_get+0x186>
 800aeb8:	f8da 3008 	ldr.w	r3, [sl, #8]
 800aebc:	69b2      	ldr	r2, [r6, #24]
 800aebe:	f8d6 800c 	ldr.w	r8, [r6, #12]
 800aec2:	6810      	ldr	r0, [r2, #0]
 800aec4:	e9d3 4701 	ldrd	r4, r7, [r3, #4]
 800aec8:	68b3      	ldr	r3, [r6, #8]
 800aeca:	f3c3 2917 	ubfx	r9, r3, #8, #24
 800aece:	f001 ffc3 	bl	800ce58 <ai_array_to_buffer_fmt>
 800aed2:	69b1      	ldr	r1, [r6, #24]
 800aed4:	4684      	mov	ip, r0
 800aed6:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 800aeda:	688a      	ldr	r2, [r1, #8]
 800aedc:	445c      	add	r4, fp
 800aede:	2800      	cmp	r0, #0
 800aee0:	d0c8      	beq.n	800ae74 <ai_platform_inputs_get+0xe0>
 800aee2:	2100      	movs	r1, #0
 800aee4:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
 800aee8:	6831      	ldr	r1, [r6, #0]
 800aeea:	6041      	str	r1, [r0, #4]
 800aeec:	b111      	cbz	r1, 800aef4 <ai_platform_inputs_get+0x160>
 800aeee:	8849      	ldrh	r1, [r1, #2]
 800aef0:	2900      	cmp	r1, #0
 800aef2:	d1bb      	bne.n	800ae6c <ai_platform_inputs_get+0xd8>
 800aef4:	69b1      	ldr	r1, [r6, #24]
 800aef6:	2000      	movs	r0, #0
 800aef8:	e7bc      	b.n	800ae74 <ai_platform_inputs_get+0xe0>
 800aefa:	e7fe      	b.n	800aefa <ai_platform_inputs_get+0x166>
 800aefc:	2218      	movs	r2, #24
 800aefe:	2111      	movs	r1, #17
 800af00:	f107 0010 	add.w	r0, r7, #16
 800af04:	f000 fdc4 	bl	800ba90 <core_set_error>
 800af08:	2200      	movs	r2, #0
 800af0a:	4610      	mov	r0, r2
 800af0c:	9b02      	ldr	r3, [sp, #8]
 800af0e:	2b00      	cmp	r3, #0
 800af10:	d08e      	beq.n	800ae30 <ai_platform_inputs_get+0x9c>
 800af12:	801a      	strh	r2, [r3, #0]
 800af14:	b005      	add	sp, #20
 800af16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800af1a:	9f03      	ldr	r7, [sp, #12]
 800af1c:	2a00      	cmp	r2, #0
 800af1e:	d0ed      	beq.n	800aefc <ai_platform_inputs_get+0x168>
 800af20:	f8da 3008 	ldr.w	r3, [sl, #8]
 800af24:	6858      	ldr	r0, [r3, #4]
 800af26:	e7f1      	b.n	800af0c <ai_platform_inputs_get+0x178>
 800af28:	a1c00100 	.word	0xa1c00100
 800af2c:	e0042000 	.word	0xe0042000
 800af30:	58024000 	.word	0x58024000
 800af34:	f407a5c2 	.word	0xf407a5c2
 800af38:	b5e8b5cd 	.word	0xb5e8b5cd
 800af3c:	40023000 	.word	0x40023000

0800af40 <ai_platform_outputs_get>:
 800af40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800af44:	b085      	sub	sp, #20
 800af46:	9102      	str	r1, [sp, #8]
 800af48:	b1f0      	cbz	r0, 800af88 <ai_platform_outputs_get+0x48>
 800af4a:	4b5f      	ldr	r3, [pc, #380]	; (800b0c8 <ai_platform_outputs_get+0x188>)
 800af4c:	6802      	ldr	r2, [r0, #0]
 800af4e:	429a      	cmp	r2, r3
 800af50:	4607      	mov	r7, r0
 800af52:	d119      	bne.n	800af88 <ai_platform_outputs_get+0x48>
 800af54:	f7ff fddc 	bl	800ab10 <_ai_platform_acquire_crc>
 800af58:	4b5c      	ldr	r3, [pc, #368]	; (800b0cc <ai_platform_outputs_get+0x18c>)
 800af5a:	681b      	ldr	r3, [r3, #0]
 800af5c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800af60:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800af64:	d03d      	beq.n	800afe2 <ai_platform_outputs_get+0xa2>
 800af66:	4a5a      	ldr	r2, [pc, #360]	; (800b0d0 <ai_platform_outputs_get+0x190>)
 800af68:	2301      	movs	r3, #1
 800af6a:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800af6e:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800af72:	2b00      	cmp	r3, #0
 800af74:	d1fb      	bne.n	800af6e <ai_platform_outputs_get+0x2e>
 800af76:	4b57      	ldr	r3, [pc, #348]	; (800b0d4 <ai_platform_outputs_get+0x194>)
 800af78:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800af7c:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800af80:	4b55      	ldr	r3, [pc, #340]	; (800b0d8 <ai_platform_outputs_get+0x198>)
 800af82:	429a      	cmp	r2, r3
 800af84:	d039      	beq.n	800affa <ai_platform_outputs_get+0xba>
 800af86:	e7fe      	b.n	800af86 <ai_platform_outputs_get+0x46>
 800af88:	f7ff fdc2 	bl	800ab10 <_ai_platform_acquire_crc>
 800af8c:	4b4f      	ldr	r3, [pc, #316]	; (800b0cc <ai_platform_outputs_get+0x18c>)
 800af8e:	681b      	ldr	r3, [r3, #0]
 800af90:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800af94:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800af98:	d010      	beq.n	800afbc <ai_platform_outputs_get+0x7c>
 800af9a:	4a4d      	ldr	r2, [pc, #308]	; (800b0d0 <ai_platform_outputs_get+0x190>)
 800af9c:	2301      	movs	r3, #1
 800af9e:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800afa2:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800afa6:	2b00      	cmp	r3, #0
 800afa8:	d1fb      	bne.n	800afa2 <ai_platform_outputs_get+0x62>
 800afaa:	4b4a      	ldr	r3, [pc, #296]	; (800b0d4 <ai_platform_outputs_get+0x194>)
 800afac:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800afb0:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800afb4:	4b48      	ldr	r3, [pc, #288]	; (800b0d8 <ai_platform_outputs_get+0x198>)
 800afb6:	429a      	cmp	r2, r3
 800afb8:	d00d      	beq.n	800afd6 <ai_platform_outputs_get+0x96>
 800afba:	e7fe      	b.n	800afba <ai_platform_outputs_get+0x7a>
 800afbc:	4a47      	ldr	r2, [pc, #284]	; (800b0dc <ai_platform_outputs_get+0x19c>)
 800afbe:	2301      	movs	r3, #1
 800afc0:	6093      	str	r3, [r2, #8]
 800afc2:	6893      	ldr	r3, [r2, #8]
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	d1fc      	bne.n	800afc2 <ai_platform_outputs_get+0x82>
 800afc8:	4b42      	ldr	r3, [pc, #264]	; (800b0d4 <ai_platform_outputs_get+0x194>)
 800afca:	6013      	str	r3, [r2, #0]
 800afcc:	6812      	ldr	r2, [r2, #0]
 800afce:	4b42      	ldr	r3, [pc, #264]	; (800b0d8 <ai_platform_outputs_get+0x198>)
 800afd0:	429a      	cmp	r2, r3
 800afd2:	d000      	beq.n	800afd6 <ai_platform_outputs_get+0x96>
 800afd4:	e7fe      	b.n	800afd4 <ai_platform_outputs_get+0x94>
 800afd6:	f7ff fd9d 	bl	800ab14 <_ai_platform_release_crc>
 800afda:	2000      	movs	r0, #0
 800afdc:	b005      	add	sp, #20
 800afde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800afe2:	4a3e      	ldr	r2, [pc, #248]	; (800b0dc <ai_platform_outputs_get+0x19c>)
 800afe4:	2301      	movs	r3, #1
 800afe6:	6093      	str	r3, [r2, #8]
 800afe8:	6893      	ldr	r3, [r2, #8]
 800afea:	2b00      	cmp	r3, #0
 800afec:	d1fc      	bne.n	800afe8 <ai_platform_outputs_get+0xa8>
 800afee:	4b39      	ldr	r3, [pc, #228]	; (800b0d4 <ai_platform_outputs_get+0x194>)
 800aff0:	6013      	str	r3, [r2, #0]
 800aff2:	6812      	ldr	r2, [r2, #0]
 800aff4:	4b38      	ldr	r3, [pc, #224]	; (800b0d8 <ai_platform_outputs_get+0x198>)
 800aff6:	429a      	cmp	r2, r3
 800aff8:	d150      	bne.n	800b09c <ai_platform_outputs_get+0x15c>
 800affa:	f7ff fd8b 	bl	800ab14 <_ai_platform_release_crc>
 800affe:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800b000:	2b01      	cmp	r3, #1
 800b002:	d958      	bls.n	800b0b6 <ai_platform_outputs_get+0x176>
 800b004:	f04f 0b00 	mov.w	fp, #0
 800b008:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
 800b00c:	9703      	str	r7, [sp, #12]
 800b00e:	465d      	mov	r5, fp
 800b010:	e016      	b.n	800b040 <ai_platform_outputs_get+0x100>
 800b012:	9901      	ldr	r1, [sp, #4]
 800b014:	2301      	movs	r3, #1
 800b016:	507b      	str	r3, [r7, r1]
 800b018:	69b1      	ldr	r1, [r6, #24]
 800b01a:	6849      	ldr	r1, [r1, #4]
 800b01c:	6121      	str	r1, [r4, #16]
 800b01e:	f04f 0301 	mov.w	r3, #1
 800b022:	7523      	strb	r3, [r4, #20]
 800b024:	e9c4 c200 	strd	ip, r2, [r4]
 800b028:	6962      	ldr	r2, [r4, #20]
 800b02a:	60a0      	str	r0, [r4, #8]
 800b02c:	2300      	movs	r3, #0
 800b02e:	f369 221f 	bfi	r2, r9, #8, #24
 800b032:	f8c4 8018 	str.w	r8, [r4, #24]
 800b036:	60e3      	str	r3, [r4, #12]
 800b038:	3501      	adds	r5, #1
 800b03a:	f10b 0b1c 	add.w	fp, fp, #28
 800b03e:	6162      	str	r2, [r4, #20]
 800b040:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 800b044:	42ab      	cmp	r3, r5
 800b046:	b2aa      	uxth	r2, r5
 800b048:	d929      	bls.n	800b09e <ai_platform_outputs_get+0x15e>
 800b04a:	f8da 3010 	ldr.w	r3, [sl, #16]
 800b04e:	00e9      	lsls	r1, r5, #3
 800b050:	9101      	str	r1, [sp, #4]
 800b052:	b323      	cbz	r3, 800b09e <ai_platform_outputs_get+0x15e>
 800b054:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 800b058:	b30e      	cbz	r6, 800b09e <ai_platform_outputs_get+0x15e>
 800b05a:	f8da 3014 	ldr.w	r3, [sl, #20]
 800b05e:	69b2      	ldr	r2, [r6, #24]
 800b060:	f8d6 800c 	ldr.w	r8, [r6, #12]
 800b064:	6810      	ldr	r0, [r2, #0]
 800b066:	e9d3 4701 	ldrd	r4, r7, [r3, #4]
 800b06a:	68b3      	ldr	r3, [r6, #8]
 800b06c:	f3c3 2917 	ubfx	r9, r3, #8, #24
 800b070:	f001 fef2 	bl	800ce58 <ai_array_to_buffer_fmt>
 800b074:	69b1      	ldr	r1, [r6, #24]
 800b076:	4684      	mov	ip, r0
 800b078:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 800b07c:	688a      	ldr	r2, [r1, #8]
 800b07e:	445c      	add	r4, fp
 800b080:	2800      	cmp	r0, #0
 800b082:	d0ca      	beq.n	800b01a <ai_platform_outputs_get+0xda>
 800b084:	2100      	movs	r1, #0
 800b086:	f847 1035 	str.w	r1, [r7, r5, lsl #3]
 800b08a:	6831      	ldr	r1, [r6, #0]
 800b08c:	6041      	str	r1, [r0, #4]
 800b08e:	b111      	cbz	r1, 800b096 <ai_platform_outputs_get+0x156>
 800b090:	8849      	ldrh	r1, [r1, #2]
 800b092:	2900      	cmp	r1, #0
 800b094:	d1bd      	bne.n	800b012 <ai_platform_outputs_get+0xd2>
 800b096:	69b1      	ldr	r1, [r6, #24]
 800b098:	2000      	movs	r0, #0
 800b09a:	e7be      	b.n	800b01a <ai_platform_outputs_get+0xda>
 800b09c:	e7fe      	b.n	800b09c <ai_platform_outputs_get+0x15c>
 800b09e:	9f03      	ldr	r7, [sp, #12]
 800b0a0:	b14a      	cbz	r2, 800b0b6 <ai_platform_outputs_get+0x176>
 800b0a2:	f8da 3014 	ldr.w	r3, [sl, #20]
 800b0a6:	6858      	ldr	r0, [r3, #4]
 800b0a8:	9b02      	ldr	r3, [sp, #8]
 800b0aa:	2b00      	cmp	r3, #0
 800b0ac:	d096      	beq.n	800afdc <ai_platform_outputs_get+0x9c>
 800b0ae:	801a      	strh	r2, [r3, #0]
 800b0b0:	b005      	add	sp, #20
 800b0b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b0b6:	2218      	movs	r2, #24
 800b0b8:	2111      	movs	r1, #17
 800b0ba:	f107 0010 	add.w	r0, r7, #16
 800b0be:	f000 fce7 	bl	800ba90 <core_set_error>
 800b0c2:	2200      	movs	r2, #0
 800b0c4:	4610      	mov	r0, r2
 800b0c6:	e7ef      	b.n	800b0a8 <ai_platform_outputs_get+0x168>
 800b0c8:	a1c00100 	.word	0xa1c00100
 800b0cc:	e0042000 	.word	0xe0042000
 800b0d0:	58024000 	.word	0x58024000
 800b0d4:	f407a5c2 	.word	0xf407a5c2
 800b0d8:	b5e8b5cd 	.word	0xb5e8b5cd
 800b0dc:	40023000 	.word	0x40023000

0800b0e0 <ai_platform_network_create>:
 800b0e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b0e4:	b083      	sub	sp, #12
 800b0e6:	4606      	mov	r6, r0
 800b0e8:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
 800b0ec:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
 800b0f0:	4615      	mov	r5, r2
 800b0f2:	461f      	mov	r7, r3
 800b0f4:	f7ff fd0c 	bl	800ab10 <_ai_platform_acquire_crc>
 800b0f8:	b188      	cbz	r0, 800b11e <ai_platform_network_create+0x3e>
 800b0fa:	4a5d      	ldr	r2, [pc, #372]	; (800b270 <ai_platform_network_create+0x190>)
 800b0fc:	6812      	ldr	r2, [r2, #0]
 800b0fe:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800b102:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800b106:	4603      	mov	r3, r0
 800b108:	d00e      	beq.n	800b128 <ai_platform_network_create+0x48>
 800b10a:	4a5a      	ldr	r2, [pc, #360]	; (800b274 <ai_platform_network_create+0x194>)
 800b10c:	2118      	movs	r1, #24
 800b10e:	f8c2 1c08 	str.w	r1, [r2, #3080]	; 0xc08
 800b112:	f8d2 1c08 	ldr.w	r1, [r2, #3080]	; 0xc08
 800b116:	2918      	cmp	r1, #24
 800b118:	d018      	beq.n	800b14c <ai_platform_network_create+0x6c>
 800b11a:	f7ff fcfb 	bl	800ab14 <_ai_platform_release_crc>
 800b11e:	f244 1033 	movw	r0, #16691	; 0x4133
 800b122:	b003      	add	sp, #12
 800b124:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b128:	4a53      	ldr	r2, [pc, #332]	; (800b278 <ai_platform_network_create+0x198>)
 800b12a:	2101      	movs	r1, #1
 800b12c:	6091      	str	r1, [r2, #8]
 800b12e:	2114      	movs	r1, #20
 800b130:	e001      	b.n	800b136 <ai_platform_network_create+0x56>
 800b132:	3901      	subs	r1, #1
 800b134:	d002      	beq.n	800b13c <ai_platform_network_create+0x5c>
 800b136:	6894      	ldr	r4, [r2, #8]
 800b138:	2c00      	cmp	r4, #0
 800b13a:	d1fa      	bne.n	800b132 <ai_platform_network_create+0x52>
 800b13c:	4a4e      	ldr	r2, [pc, #312]	; (800b278 <ai_platform_network_create+0x198>)
 800b13e:	6891      	ldr	r1, [r2, #8]
 800b140:	b911      	cbnz	r1, 800b148 <ai_platform_network_create+0x68>
 800b142:	6812      	ldr	r2, [r2, #0]
 800b144:	3201      	adds	r2, #1
 800b146:	d008      	beq.n	800b15a <ai_platform_network_create+0x7a>
 800b148:	4618      	mov	r0, r3
 800b14a:	e7e6      	b.n	800b11a <ai_platform_network_create+0x3a>
 800b14c:	2101      	movs	r1, #1
 800b14e:	f8c2 1c08 	str.w	r1, [r2, #3080]	; 0xc08
 800b152:	f8d2 1c08 	ldr.w	r1, [r2, #3080]	; 0xc08
 800b156:	2900      	cmp	r1, #0
 800b158:	d1fb      	bne.n	800b152 <ai_platform_network_create+0x72>
 800b15a:	4618      	mov	r0, r3
 800b15c:	f7ff fcda 	bl	800ab14 <_ai_platform_release_crc>
 800b160:	f7ff fcd6 	bl	800ab10 <_ai_platform_acquire_crc>
 800b164:	4b42      	ldr	r3, [pc, #264]	; (800b270 <ai_platform_network_create+0x190>)
 800b166:	681b      	ldr	r3, [r3, #0]
 800b168:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b16c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b170:	d010      	beq.n	800b194 <ai_platform_network_create+0xb4>
 800b172:	4b40      	ldr	r3, [pc, #256]	; (800b274 <ai_platform_network_create+0x194>)
 800b174:	2201      	movs	r2, #1
 800b176:	f8c3 2c08 	str.w	r2, [r3, #3080]	; 0xc08
 800b17a:	f8d3 1c08 	ldr.w	r1, [r3, #3080]	; 0xc08
 800b17e:	2900      	cmp	r1, #0
 800b180:	d1fb      	bne.n	800b17a <ai_platform_network_create+0x9a>
 800b182:	4a3e      	ldr	r2, [pc, #248]	; (800b27c <ai_platform_network_create+0x19c>)
 800b184:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
 800b188:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
 800b18c:	4b3c      	ldr	r3, [pc, #240]	; (800b280 <ai_platform_network_create+0x1a0>)
 800b18e:	429a      	cmp	r2, r3
 800b190:	d00c      	beq.n	800b1ac <ai_platform_network_create+0xcc>
 800b192:	e7fe      	b.n	800b192 <ai_platform_network_create+0xb2>
 800b194:	4a38      	ldr	r2, [pc, #224]	; (800b278 <ai_platform_network_create+0x198>)
 800b196:	2301      	movs	r3, #1
 800b198:	6093      	str	r3, [r2, #8]
 800b19a:	6893      	ldr	r3, [r2, #8]
 800b19c:	2b00      	cmp	r3, #0
 800b19e:	d1fc      	bne.n	800b19a <ai_platform_network_create+0xba>
 800b1a0:	4b36      	ldr	r3, [pc, #216]	; (800b27c <ai_platform_network_create+0x19c>)
 800b1a2:	6013      	str	r3, [r2, #0]
 800b1a4:	6812      	ldr	r2, [r2, #0]
 800b1a6:	4b36      	ldr	r3, [pc, #216]	; (800b280 <ai_platform_network_create+0x1a0>)
 800b1a8:	429a      	cmp	r2, r3
 800b1aa:	d122      	bne.n	800b1f2 <ai_platform_network_create+0x112>
 800b1ac:	f7ff fcb2 	bl	800ab14 <_ai_platform_release_crc>
 800b1b0:	b38e      	cbz	r6, 800b216 <ai_platform_network_create+0x136>
 800b1b2:	4b34      	ldr	r3, [pc, #208]	; (800b284 <ai_platform_network_create+0x1a4>)
 800b1b4:	602b      	str	r3, [r5, #0]
 800b1b6:	6035      	str	r5, [r6, #0]
 800b1b8:	f000 fc62 	bl	800ba80 <core_init>
 800b1bc:	b1d0      	cbz	r0, 800b1f4 <ai_platform_network_create+0x114>
 800b1be:	f7ff fca7 	bl	800ab10 <_ai_platform_acquire_crc>
 800b1c2:	4b2b      	ldr	r3, [pc, #172]	; (800b270 <ai_platform_network_create+0x190>)
 800b1c4:	681b      	ldr	r3, [r3, #0]
 800b1c6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b1ca:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b1ce:	d025      	beq.n	800b21c <ai_platform_network_create+0x13c>
 800b1d0:	4a28      	ldr	r2, [pc, #160]	; (800b274 <ai_platform_network_create+0x194>)
 800b1d2:	2301      	movs	r3, #1
 800b1d4:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b1d8:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b1dc:	2b00      	cmp	r3, #0
 800b1de:	d1fb      	bne.n	800b1d8 <ai_platform_network_create+0xf8>
 800b1e0:	4b26      	ldr	r3, [pc, #152]	; (800b27c <ai_platform_network_create+0x19c>)
 800b1e2:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b1e6:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b1ea:	4b25      	ldr	r3, [pc, #148]	; (800b280 <ai_platform_network_create+0x1a0>)
 800b1ec:	429a      	cmp	r2, r3
 800b1ee:	d022      	beq.n	800b236 <ai_platform_network_create+0x156>
 800b1f0:	e7fe      	b.n	800b1f0 <ai_platform_network_create+0x110>
 800b1f2:	e7fe      	b.n	800b1f2 <ai_platform_network_create+0x112>
 800b1f4:	2430      	movs	r4, #48	; 0x30
 800b1f6:	2300      	movs	r3, #0
 800b1f8:	6033      	str	r3, [r6, #0]
 800b1fa:	2610      	movs	r6, #16
 800b1fc:	464a      	mov	r2, r9
 800b1fe:	4641      	mov	r1, r8
 800b200:	4638      	mov	r0, r7
 800b202:	f001 fecf 	bl	800cfa4 <ai_version_get>
 800b206:	4603      	mov	r3, r0
 800b208:	2000      	movs	r0, #0
 800b20a:	f364 0007 	bfi	r0, r4, #0, #8
 800b20e:	64ab      	str	r3, [r5, #72]	; 0x48
 800b210:	f366 201f 	bfi	r0, r6, #8, #24
 800b214:	e785      	b.n	800b122 <ai_platform_network_create+0x42>
 800b216:	f241 0010 	movw	r0, #4112	; 0x1010
 800b21a:	e782      	b.n	800b122 <ai_platform_network_create+0x42>
 800b21c:	4a16      	ldr	r2, [pc, #88]	; (800b278 <ai_platform_network_create+0x198>)
 800b21e:	2301      	movs	r3, #1
 800b220:	6093      	str	r3, [r2, #8]
 800b222:	6893      	ldr	r3, [r2, #8]
 800b224:	2b00      	cmp	r3, #0
 800b226:	d1fc      	bne.n	800b222 <ai_platform_network_create+0x142>
 800b228:	4b14      	ldr	r3, [pc, #80]	; (800b27c <ai_platform_network_create+0x19c>)
 800b22a:	6013      	str	r3, [r2, #0]
 800b22c:	6812      	ldr	r2, [r2, #0]
 800b22e:	4b14      	ldr	r3, [pc, #80]	; (800b280 <ai_platform_network_create+0x1a0>)
 800b230:	429a      	cmp	r2, r3
 800b232:	d000      	beq.n	800b236 <ai_platform_network_create+0x156>
 800b234:	e7fe      	b.n	800b234 <ai_platform_network_create+0x154>
 800b236:	f7ff fc6d 	bl	800ab14 <_ai_platform_release_crc>
 800b23a:	2200      	movs	r2, #0
 800b23c:	4641      	mov	r1, r8
 800b23e:	4638      	mov	r0, r7
 800b240:	f001 feb0 	bl	800cfa4 <ai_version_get>
 800b244:	2200      	movs	r2, #0
 800b246:	4604      	mov	r4, r0
 800b248:	2105      	movs	r1, #5
 800b24a:	2001      	movs	r0, #1
 800b24c:	f001 feaa 	bl	800cfa4 <ai_version_get>
 800b250:	4284      	cmp	r4, r0
 800b252:	d001      	beq.n	800b258 <ai_platform_network_create+0x178>
 800b254:	2401      	movs	r4, #1
 800b256:	e7ce      	b.n	800b1f6 <ai_platform_network_create+0x116>
 800b258:	4b0b      	ldr	r3, [pc, #44]	; (800b288 <ai_platform_network_create+0x1a8>)
 800b25a:	9301      	str	r3, [sp, #4]
 800b25c:	a801      	add	r0, sp, #4
 800b25e:	f000 fc23 	bl	800baa8 <ai_check_custom_types>
 800b262:	b110      	cbz	r0, 800b26a <ai_platform_network_create+0x18a>
 800b264:	2600      	movs	r6, #0
 800b266:	4634      	mov	r4, r6
 800b268:	e7c8      	b.n	800b1fc <ai_platform_network_create+0x11c>
 800b26a:	2402      	movs	r4, #2
 800b26c:	e7c3      	b.n	800b1f6 <ai_platform_network_create+0x116>
 800b26e:	bf00      	nop
 800b270:	e0042000 	.word	0xe0042000
 800b274:	58024000 	.word	0x58024000
 800b278:	40023000 	.word	0x40023000
 800b27c:	f407a5c2 	.word	0xf407a5c2
 800b280:	b5e8b5cd 	.word	0xb5e8b5cd
 800b284:	a1c00100 	.word	0xa1c00100
 800b288:	84048403 	.word	0x84048403

0800b28c <ai_platform_network_init>:
 800b28c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b290:	b1f8      	cbz	r0, 800b2d2 <ai_platform_network_init+0x46>
 800b292:	4b6e      	ldr	r3, [pc, #440]	; (800b44c <ai_platform_network_init+0x1c0>)
 800b294:	6802      	ldr	r2, [r0, #0]
 800b296:	429a      	cmp	r2, r3
 800b298:	4604      	mov	r4, r0
 800b29a:	d11a      	bne.n	800b2d2 <ai_platform_network_init+0x46>
 800b29c:	460e      	mov	r6, r1
 800b29e:	f7ff fc37 	bl	800ab10 <_ai_platform_acquire_crc>
 800b2a2:	4b6b      	ldr	r3, [pc, #428]	; (800b450 <ai_platform_network_init+0x1c4>)
 800b2a4:	681b      	ldr	r3, [r3, #0]
 800b2a6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b2aa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b2ae:	d03d      	beq.n	800b32c <ai_platform_network_init+0xa0>
 800b2b0:	4a68      	ldr	r2, [pc, #416]	; (800b454 <ai_platform_network_init+0x1c8>)
 800b2b2:	2301      	movs	r3, #1
 800b2b4:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b2b8:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b2bc:	2b00      	cmp	r3, #0
 800b2be:	d1fb      	bne.n	800b2b8 <ai_platform_network_init+0x2c>
 800b2c0:	4b65      	ldr	r3, [pc, #404]	; (800b458 <ai_platform_network_init+0x1cc>)
 800b2c2:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b2c6:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b2ca:	4b64      	ldr	r3, [pc, #400]	; (800b45c <ai_platform_network_init+0x1d0>)
 800b2cc:	429a      	cmp	r2, r3
 800b2ce:	d039      	beq.n	800b344 <ai_platform_network_init+0xb8>
 800b2d0:	e7fe      	b.n	800b2d0 <ai_platform_network_init+0x44>
 800b2d2:	f7ff fc1d 	bl	800ab10 <_ai_platform_acquire_crc>
 800b2d6:	4b5e      	ldr	r3, [pc, #376]	; (800b450 <ai_platform_network_init+0x1c4>)
 800b2d8:	681b      	ldr	r3, [r3, #0]
 800b2da:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b2de:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b2e2:	d010      	beq.n	800b306 <ai_platform_network_init+0x7a>
 800b2e4:	4a5b      	ldr	r2, [pc, #364]	; (800b454 <ai_platform_network_init+0x1c8>)
 800b2e6:	2301      	movs	r3, #1
 800b2e8:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b2ec:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b2f0:	2b00      	cmp	r3, #0
 800b2f2:	d1fb      	bne.n	800b2ec <ai_platform_network_init+0x60>
 800b2f4:	4b58      	ldr	r3, [pc, #352]	; (800b458 <ai_platform_network_init+0x1cc>)
 800b2f6:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b2fa:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b2fe:	4b57      	ldr	r3, [pc, #348]	; (800b45c <ai_platform_network_init+0x1d0>)
 800b300:	429a      	cmp	r2, r3
 800b302:	d00d      	beq.n	800b320 <ai_platform_network_init+0x94>
 800b304:	e7fe      	b.n	800b304 <ai_platform_network_init+0x78>
 800b306:	4a56      	ldr	r2, [pc, #344]	; (800b460 <ai_platform_network_init+0x1d4>)
 800b308:	2301      	movs	r3, #1
 800b30a:	6093      	str	r3, [r2, #8]
 800b30c:	6893      	ldr	r3, [r2, #8]
 800b30e:	2b00      	cmp	r3, #0
 800b310:	d1fc      	bne.n	800b30c <ai_platform_network_init+0x80>
 800b312:	4b51      	ldr	r3, [pc, #324]	; (800b458 <ai_platform_network_init+0x1cc>)
 800b314:	6013      	str	r3, [r2, #0]
 800b316:	6812      	ldr	r2, [r2, #0]
 800b318:	4b50      	ldr	r3, [pc, #320]	; (800b45c <ai_platform_network_init+0x1d0>)
 800b31a:	429a      	cmp	r2, r3
 800b31c:	d000      	beq.n	800b320 <ai_platform_network_init+0x94>
 800b31e:	e7fe      	b.n	800b31e <ai_platform_network_init+0x92>
 800b320:	f7ff fbf8 	bl	800ab14 <_ai_platform_release_crc>
 800b324:	2600      	movs	r6, #0
 800b326:	4630      	mov	r0, r6
 800b328:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b32c:	4a4c      	ldr	r2, [pc, #304]	; (800b460 <ai_platform_network_init+0x1d4>)
 800b32e:	2301      	movs	r3, #1
 800b330:	6093      	str	r3, [r2, #8]
 800b332:	6893      	ldr	r3, [r2, #8]
 800b334:	2b00      	cmp	r3, #0
 800b336:	d1fc      	bne.n	800b332 <ai_platform_network_init+0xa6>
 800b338:	4b47      	ldr	r3, [pc, #284]	; (800b458 <ai_platform_network_init+0x1cc>)
 800b33a:	6013      	str	r3, [r2, #0]
 800b33c:	6812      	ldr	r2, [r2, #0]
 800b33e:	4b47      	ldr	r3, [pc, #284]	; (800b45c <ai_platform_network_init+0x1d0>)
 800b340:	429a      	cmp	r2, r3
 800b342:	d11c      	bne.n	800b37e <ai_platform_network_init+0xf2>
 800b344:	f7ff fbe6 	bl	800ab14 <_ai_platform_release_crc>
 800b348:	2e00      	cmp	r6, #0
 800b34a:	d06f      	beq.n	800b42c <ai_platform_network_init+0x1a0>
 800b34c:	4b45      	ldr	r3, [pc, #276]	; (800b464 <ai_platform_network_init+0x1d8>)
 800b34e:	6832      	ldr	r2, [r6, #0]
 800b350:	429a      	cmp	r2, r3
 800b352:	d115      	bne.n	800b380 <ai_platform_network_init+0xf4>
 800b354:	e9d6 2101 	ldrd	r2, r1, [r6, #4]
 800b358:	6933      	ldr	r3, [r6, #16]
 800b35a:	f8b6 e00c 	ldrh.w	lr, [r6, #12]
 800b35e:	89f7      	ldrh	r7, [r6, #14]
 800b360:	62a3      	str	r3, [r4, #40]	; 0x28
 800b362:	e9c4 2107 	strd	r2, r1, [r4, #28]
 800b366:	2303      	movs	r3, #3
 800b368:	84e7      	strh	r7, [r4, #38]	; 0x26
 800b36a:	f8a4 e024 	strh.w	lr, [r4, #36]	; 0x24
 800b36e:	60e3      	str	r3, [r4, #12]
 800b370:	4620      	mov	r0, r4
 800b372:	4626      	mov	r6, r4
 800b374:	f000 fbc2 	bl	800bafc <ai_layers_init_all>
 800b378:	4630      	mov	r0, r6
 800b37a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b37e:	e7fe      	b.n	800b37e <ai_platform_network_init+0xf2>
 800b380:	2101      	movs	r1, #1
 800b382:	4630      	mov	r0, r6
 800b384:	4635      	mov	r5, r6
 800b386:	6876      	ldr	r6, [r6, #4]
 800b388:	f7ff fb74 	bl	800aa74 <ai_buffer_get_size>
 800b38c:	f105 081c 	add.w	r8, r5, #28
 800b390:	4681      	mov	r9, r0
 800b392:	2101      	movs	r1, #1
 800b394:	4640      	mov	r0, r8
 800b396:	6a2f      	ldr	r7, [r5, #32]
 800b398:	f7ff fb6c 	bl	800aa74 <ai_buffer_get_size>
 800b39c:	f1b9 0f00 	cmp.w	r9, #0
 800b3a0:	d025      	beq.n	800b3ee <ai_platform_network_init+0x162>
 800b3a2:	2201      	movs	r2, #1
 800b3a4:	4696      	mov	lr, r2
 800b3a6:	bb30      	cbnz	r0, 800b3f6 <ai_platform_network_init+0x16a>
 800b3a8:	4680      	mov	r8, r0
 800b3aa:	4607      	mov	r7, r0
 800b3ac:	b376      	cbz	r6, 800b40c <ai_platform_network_init+0x180>
 800b3ae:	8be3      	ldrh	r3, [r4, #30]
 800b3b0:	4573      	cmp	r3, lr
 800b3b2:	d323      	bcc.n	800b3fc <ai_platform_network_init+0x170>
 800b3b4:	b142      	cbz	r2, 800b3c8 <ai_platform_network_init+0x13c>
 800b3b6:	46ac      	mov	ip, r5
 800b3b8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b3bc:	6a25      	ldr	r5, [r4, #32]
 800b3be:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b3c0:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800b3c4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 800b3c8:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800b3ca:	f8a4 e01e 	strh.w	lr, [r4, #30]
 800b3ce:	2600      	movs	r6, #0
 800b3d0:	42bb      	cmp	r3, r7
 800b3d2:	83a6      	strh	r6, [r4, #28]
 800b3d4:	d323      	bcc.n	800b41e <ai_platform_network_init+0x192>
 800b3d6:	b37f      	cbz	r7, 800b438 <ai_platform_network_init+0x1ac>
 800b3d8:	46c4      	mov	ip, r8
 800b3da:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b3de:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 800b3e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800b3e2:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
 800b3e6:	46b6      	mov	lr, r6
 800b3e8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 800b3ec:	e7bb      	b.n	800b366 <ai_platform_network_init+0xda>
 800b3ee:	464a      	mov	r2, r9
 800b3f0:	46ce      	mov	lr, r9
 800b3f2:	464d      	mov	r5, r9
 800b3f4:	e7d7      	b.n	800b3a6 <ai_platform_network_init+0x11a>
 800b3f6:	b30f      	cbz	r7, 800b43c <ai_platform_network_init+0x1b0>
 800b3f8:	2701      	movs	r7, #1
 800b3fa:	e7d7      	b.n	800b3ac <ai_platform_network_init+0x120>
 800b3fc:	2212      	movs	r2, #18
 800b3fe:	2116      	movs	r1, #22
 800b400:	f104 0010 	add.w	r0, r4, #16
 800b404:	f000 fb44 	bl	800ba90 <core_set_error>
 800b408:	2600      	movs	r6, #0
 800b40a:	e78c      	b.n	800b326 <ai_platform_network_init+0x9a>
 800b40c:	f1b9 0f00 	cmp.w	r9, #0
 800b410:	d0cd      	beq.n	800b3ae <ai_platform_network_init+0x122>
 800b412:	2110      	movs	r1, #16
 800b414:	2212      	movs	r2, #18
 800b416:	1860      	adds	r0, r4, r1
 800b418:	f000 fb3a 	bl	800ba90 <core_set_error>
 800b41c:	e783      	b.n	800b326 <ai_platform_network_init+0x9a>
 800b41e:	2213      	movs	r2, #19
 800b420:	2116      	movs	r1, #22
 800b422:	f104 0010 	add.w	r0, r4, #16
 800b426:	f000 fb33 	bl	800ba90 <core_set_error>
 800b42a:	e77c      	b.n	800b326 <ai_platform_network_init+0x9a>
 800b42c:	2110      	movs	r1, #16
 800b42e:	2211      	movs	r2, #17
 800b430:	1860      	adds	r0, r4, r1
 800b432:	f000 fb2d 	bl	800ba90 <core_set_error>
 800b436:	e776      	b.n	800b326 <ai_platform_network_init+0x9a>
 800b438:	46be      	mov	lr, r7
 800b43a:	e794      	b.n	800b366 <ai_platform_network_init+0xda>
 800b43c:	2110      	movs	r1, #16
 800b43e:	2213      	movs	r2, #19
 800b440:	1860      	adds	r0, r4, r1
 800b442:	f000 fb25 	bl	800ba90 <core_set_error>
 800b446:	463e      	mov	r6, r7
 800b448:	e76d      	b.n	800b326 <ai_platform_network_init+0x9a>
 800b44a:	bf00      	nop
 800b44c:	a1c00100 	.word	0xa1c00100
 800b450:	e0042000 	.word	0xe0042000
 800b454:	58024000 	.word	0x58024000
 800b458:	f407a5c2 	.word	0xf407a5c2
 800b45c:	b5e8b5cd 	.word	0xb5e8b5cd
 800b460:	40023000 	.word	0x40023000
 800b464:	a1facade 	.word	0xa1facade

0800b468 <ai_platform_network_post_init>:
 800b468:	b538      	push	{r3, r4, r5, lr}
 800b46a:	b1f0      	cbz	r0, 800b4aa <ai_platform_network_post_init+0x42>
 800b46c:	4b3c      	ldr	r3, [pc, #240]	; (800b560 <ai_platform_network_post_init+0xf8>)
 800b46e:	6802      	ldr	r2, [r0, #0]
 800b470:	429a      	cmp	r2, r3
 800b472:	4604      	mov	r4, r0
 800b474:	d119      	bne.n	800b4aa <ai_platform_network_post_init+0x42>
 800b476:	f7ff fb4b 	bl	800ab10 <_ai_platform_acquire_crc>
 800b47a:	4b3a      	ldr	r3, [pc, #232]	; (800b564 <ai_platform_network_post_init+0xfc>)
 800b47c:	681b      	ldr	r3, [r3, #0]
 800b47e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b482:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b486:	d03b      	beq.n	800b500 <ai_platform_network_post_init+0x98>
 800b488:	4a37      	ldr	r2, [pc, #220]	; (800b568 <ai_platform_network_post_init+0x100>)
 800b48a:	2301      	movs	r3, #1
 800b48c:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b490:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b494:	2b00      	cmp	r3, #0
 800b496:	d1fb      	bne.n	800b490 <ai_platform_network_post_init+0x28>
 800b498:	4b34      	ldr	r3, [pc, #208]	; (800b56c <ai_platform_network_post_init+0x104>)
 800b49a:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b49e:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b4a2:	4b33      	ldr	r3, [pc, #204]	; (800b570 <ai_platform_network_post_init+0x108>)
 800b4a4:	429a      	cmp	r2, r3
 800b4a6:	d037      	beq.n	800b518 <ai_platform_network_post_init+0xb0>
 800b4a8:	e7fe      	b.n	800b4a8 <ai_platform_network_post_init+0x40>
 800b4aa:	f7ff fb31 	bl	800ab10 <_ai_platform_acquire_crc>
 800b4ae:	4b2d      	ldr	r3, [pc, #180]	; (800b564 <ai_platform_network_post_init+0xfc>)
 800b4b0:	681b      	ldr	r3, [r3, #0]
 800b4b2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b4b6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b4ba:	d010      	beq.n	800b4de <ai_platform_network_post_init+0x76>
 800b4bc:	4a2a      	ldr	r2, [pc, #168]	; (800b568 <ai_platform_network_post_init+0x100>)
 800b4be:	2301      	movs	r3, #1
 800b4c0:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b4c4:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b4c8:	2b00      	cmp	r3, #0
 800b4ca:	d1fb      	bne.n	800b4c4 <ai_platform_network_post_init+0x5c>
 800b4cc:	4b27      	ldr	r3, [pc, #156]	; (800b56c <ai_platform_network_post_init+0x104>)
 800b4ce:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b4d2:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b4d6:	4b26      	ldr	r3, [pc, #152]	; (800b570 <ai_platform_network_post_init+0x108>)
 800b4d8:	429a      	cmp	r2, r3
 800b4da:	d00d      	beq.n	800b4f8 <ai_platform_network_post_init+0x90>
 800b4dc:	e7fe      	b.n	800b4dc <ai_platform_network_post_init+0x74>
 800b4de:	4a25      	ldr	r2, [pc, #148]	; (800b574 <ai_platform_network_post_init+0x10c>)
 800b4e0:	2301      	movs	r3, #1
 800b4e2:	6093      	str	r3, [r2, #8]
 800b4e4:	6893      	ldr	r3, [r2, #8]
 800b4e6:	2b00      	cmp	r3, #0
 800b4e8:	d1fc      	bne.n	800b4e4 <ai_platform_network_post_init+0x7c>
 800b4ea:	4b20      	ldr	r3, [pc, #128]	; (800b56c <ai_platform_network_post_init+0x104>)
 800b4ec:	6013      	str	r3, [r2, #0]
 800b4ee:	6812      	ldr	r2, [r2, #0]
 800b4f0:	4b1f      	ldr	r3, [pc, #124]	; (800b570 <ai_platform_network_post_init+0x108>)
 800b4f2:	429a      	cmp	r2, r3
 800b4f4:	d000      	beq.n	800b4f8 <ai_platform_network_post_init+0x90>
 800b4f6:	e7fe      	b.n	800b4f6 <ai_platform_network_post_init+0x8e>
 800b4f8:	f7ff fb0c 	bl	800ab14 <_ai_platform_release_crc>
 800b4fc:	2000      	movs	r0, #0
 800b4fe:	bd38      	pop	{r3, r4, r5, pc}
 800b500:	4a1c      	ldr	r2, [pc, #112]	; (800b574 <ai_platform_network_post_init+0x10c>)
 800b502:	2301      	movs	r3, #1
 800b504:	6093      	str	r3, [r2, #8]
 800b506:	6893      	ldr	r3, [r2, #8]
 800b508:	2b00      	cmp	r3, #0
 800b50a:	d1fc      	bne.n	800b506 <ai_platform_network_post_init+0x9e>
 800b50c:	4b17      	ldr	r3, [pc, #92]	; (800b56c <ai_platform_network_post_init+0x104>)
 800b50e:	6013      	str	r3, [r2, #0]
 800b510:	6812      	ldr	r2, [r2, #0]
 800b512:	4b17      	ldr	r3, [pc, #92]	; (800b570 <ai_platform_network_post_init+0x108>)
 800b514:	429a      	cmp	r2, r3
 800b516:	d11a      	bne.n	800b54e <ai_platform_network_post_init+0xe6>
 800b518:	f7ff fafc 	bl	800ab14 <_ai_platform_release_crc>
 800b51c:	68e3      	ldr	r3, [r4, #12]
 800b51e:	f013 0502 	ands.w	r5, r3, #2
 800b522:	d015      	beq.n	800b550 <ai_platform_network_post_init+0xe8>
 800b524:	4620      	mov	r0, r4
 800b526:	f000 faf7 	bl	800bb18 <ai_layers_post_init_all>
 800b52a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b52c:	b16b      	cbz	r3, 800b54a <ai_platform_network_post_init+0xe2>
 800b52e:	6b65      	ldr	r5, [r4, #52]	; 0x34
 800b530:	e007      	b.n	800b542 <ai_platform_network_post_init+0xda>
 800b532:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
 800b536:	4798      	blx	r3
 800b538:	692b      	ldr	r3, [r5, #16]
 800b53a:	42ab      	cmp	r3, r5
 800b53c:	d005      	beq.n	800b54a <ai_platform_network_post_init+0xe2>
 800b53e:	b123      	cbz	r3, 800b54a <ai_platform_network_post_init+0xe2>
 800b540:	461d      	mov	r5, r3
 800b542:	4629      	mov	r1, r5
 800b544:	2000      	movs	r0, #0
 800b546:	2d00      	cmp	r5, #0
 800b548:	d1f3      	bne.n	800b532 <ai_platform_network_post_init+0xca>
 800b54a:	2001      	movs	r0, #1
 800b54c:	bd38      	pop	{r3, r4, r5, pc}
 800b54e:	e7fe      	b.n	800b54e <ai_platform_network_post_init+0xe6>
 800b550:	2210      	movs	r2, #16
 800b552:	2111      	movs	r1, #17
 800b554:	18a0      	adds	r0, r4, r2
 800b556:	f000 fa9b 	bl	800ba90 <core_set_error>
 800b55a:	4628      	mov	r0, r5
 800b55c:	bd38      	pop	{r3, r4, r5, pc}
 800b55e:	bf00      	nop
 800b560:	a1c00100 	.word	0xa1c00100
 800b564:	e0042000 	.word	0xe0042000
 800b568:	58024000 	.word	0x58024000
 800b56c:	f407a5c2 	.word	0xf407a5c2
 800b570:	b5e8b5cd 	.word	0xb5e8b5cd
 800b574:	40023000 	.word	0x40023000

0800b578 <ai_platform_network_process>:
 800b578:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b57c:	460e      	mov	r6, r1
 800b57e:	b085      	sub	sp, #20
 800b580:	4693      	mov	fp, r2
 800b582:	4605      	mov	r5, r0
 800b584:	b120      	cbz	r0, 800b590 <ai_platform_network_process+0x18>
 800b586:	4bb8      	ldr	r3, [pc, #736]	; (800b868 <ai_platform_network_process+0x2f0>)
 800b588:	6802      	ldr	r2, [r0, #0]
 800b58a:	429a      	cmp	r2, r3
 800b58c:	bf18      	it	ne
 800b58e:	2500      	movne	r5, #0
 800b590:	f7ff fabe 	bl	800ab10 <_ai_platform_acquire_crc>
 800b594:	4bb5      	ldr	r3, [pc, #724]	; (800b86c <ai_platform_network_process+0x2f4>)
 800b596:	681b      	ldr	r3, [r3, #0]
 800b598:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b59c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800b5a0:	d010      	beq.n	800b5c4 <ai_platform_network_process+0x4c>
 800b5a2:	4ab3      	ldr	r2, [pc, #716]	; (800b870 <ai_platform_network_process+0x2f8>)
 800b5a4:	2301      	movs	r3, #1
 800b5a6:	f8c2 3c08 	str.w	r3, [r2, #3080]	; 0xc08
 800b5aa:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	; 0xc08
 800b5ae:	2b00      	cmp	r3, #0
 800b5b0:	d1fb      	bne.n	800b5aa <ai_platform_network_process+0x32>
 800b5b2:	4bb0      	ldr	r3, [pc, #704]	; (800b874 <ai_platform_network_process+0x2fc>)
 800b5b4:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800b5b8:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	; 0xc00
 800b5bc:	4bae      	ldr	r3, [pc, #696]	; (800b878 <ai_platform_network_process+0x300>)
 800b5be:	429a      	cmp	r2, r3
 800b5c0:	d00d      	beq.n	800b5de <ai_platform_network_process+0x66>
 800b5c2:	e7fe      	b.n	800b5c2 <ai_platform_network_process+0x4a>
 800b5c4:	4aad      	ldr	r2, [pc, #692]	; (800b87c <ai_platform_network_process+0x304>)
 800b5c6:	2301      	movs	r3, #1
 800b5c8:	6093      	str	r3, [r2, #8]
 800b5ca:	6893      	ldr	r3, [r2, #8]
 800b5cc:	2b00      	cmp	r3, #0
 800b5ce:	d1fc      	bne.n	800b5ca <ai_platform_network_process+0x52>
 800b5d0:	4ba8      	ldr	r3, [pc, #672]	; (800b874 <ai_platform_network_process+0x2fc>)
 800b5d2:	6013      	str	r3, [r2, #0]
 800b5d4:	6812      	ldr	r2, [r2, #0]
 800b5d6:	4ba8      	ldr	r3, [pc, #672]	; (800b878 <ai_platform_network_process+0x300>)
 800b5d8:	429a      	cmp	r2, r3
 800b5da:	f040 812c 	bne.w	800b836 <ai_platform_network_process+0x2be>
 800b5de:	f7ff fa99 	bl	800ab14 <_ai_platform_release_crc>
 800b5e2:	2d00      	cmp	r5, #0
 800b5e4:	f000 8154 	beq.w	800b890 <ai_platform_network_process+0x318>
 800b5e8:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
 800b5ea:	2b00      	cmp	r3, #0
 800b5ec:	f000 8124 	beq.w	800b838 <ai_platform_network_process+0x2c0>
 800b5f0:	68eb      	ldr	r3, [r5, #12]
 800b5f2:	f8d5 a030 	ldr.w	sl, [r5, #48]	; 0x30
 800b5f6:	f003 0303 	and.w	r3, r3, #3
 800b5fa:	2700      	movs	r7, #0
 800b5fc:	2b03      	cmp	r3, #3
 800b5fe:	616f      	str	r7, [r5, #20]
 800b600:	f040 813e 	bne.w	800b880 <ai_platform_network_process+0x308>
 800b604:	2e00      	cmp	r6, #0
 800b606:	f000 811d 	beq.w	800b844 <ai_platform_network_process+0x2cc>
 800b60a:	f1ba 0f00 	cmp.w	sl, #0
 800b60e:	f000 8119 	beq.w	800b844 <ai_platform_network_process+0x2cc>
 800b612:	f8ba 3000 	ldrh.w	r3, [sl]
 800b616:	2b00      	cmp	r3, #0
 800b618:	f000 8114 	beq.w	800b844 <ai_platform_network_process+0x2cc>
 800b61c:	69b3      	ldr	r3, [r6, #24]
 800b61e:	f8cd b00c 	str.w	fp, [sp, #12]
 800b622:	681b      	ldr	r3, [r3, #0]
 800b624:	e9cd 3501 	strd	r3, r5, [sp, #4]
 800b628:	f8da 3004 	ldr.w	r3, [sl, #4]
 800b62c:	2b00      	cmp	r3, #0
 800b62e:	d072      	beq.n	800b716 <ai_platform_network_process+0x19e>
 800b630:	f853 4027 	ldr.w	r4, [r3, r7, lsl #2]
 800b634:	2c00      	cmp	r4, #0
 800b636:	d06e      	beq.n	800b716 <ai_platform_network_process+0x19e>
 800b638:	f8da 3008 	ldr.w	r3, [sl, #8]
 800b63c:	f8d3 9000 	ldr.w	r9, [r3]
 800b640:	eb19 1807 	adds.w	r8, r9, r7, lsl #4
 800b644:	ea4f 1b07 	mov.w	fp, r7, lsl #4
 800b648:	f000 81de 	beq.w	800ba08 <ai_platform_network_process+0x490>
 800b64c:	69a3      	ldr	r3, [r4, #24]
 800b64e:	2101      	movs	r1, #1
 800b650:	4630      	mov	r0, r6
 800b652:	685d      	ldr	r5, [r3, #4]
 800b654:	f7ff fa0e 	bl	800aa74 <ai_buffer_get_size>
 800b658:	4285      	cmp	r5, r0
 800b65a:	f0c0 811b 	bcc.w	800b894 <ai_platform_network_process+0x31c>
 800b65e:	68e0      	ldr	r0, [r4, #12]
 800b660:	69b1      	ldr	r1, [r6, #24]
 800b662:	68c2      	ldr	r2, [r0, #12]
 800b664:	68cb      	ldr	r3, [r1, #12]
 800b666:	429a      	cmp	r2, r3
 800b668:	f040 8114 	bne.w	800b894 <ai_platform_network_process+0x31c>
 800b66c:	6882      	ldr	r2, [r0, #8]
 800b66e:	688b      	ldr	r3, [r1, #8]
 800b670:	429a      	cmp	r2, r3
 800b672:	f040 810f 	bne.w	800b894 <ai_platform_network_process+0x31c>
 800b676:	6842      	ldr	r2, [r0, #4]
 800b678:	684b      	ldr	r3, [r1, #4]
 800b67a:	429a      	cmp	r2, r3
 800b67c:	f040 810a 	bne.w	800b894 <ai_platform_network_process+0x31c>
 800b680:	69a3      	ldr	r3, [r4, #24]
 800b682:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b686:	f001 fc7b 	bl	800cf80 <ai_array_get_data_byte_size>
 800b68a:	4605      	mov	r5, r0
 800b68c:	4620      	mov	r0, r4
 800b68e:	f001 fc8f 	bl	800cfb0 <get_tensor_byte_size>
 800b692:	4285      	cmp	r5, r0
 800b694:	f0c0 80fe 	bcc.w	800b894 <ai_platform_network_process+0x31c>
 800b698:	69a3      	ldr	r3, [r4, #24]
 800b69a:	6818      	ldr	r0, [r3, #0]
 800b69c:	f001 fbdc 	bl	800ce58 <ai_array_to_buffer_fmt>
 800b6a0:	6833      	ldr	r3, [r6, #0]
 800b6a2:	4058      	eors	r0, r3
 800b6a4:	f030 407e 	bics.w	r0, r0, #4261412864	; 0xfe000000
 800b6a8:	f040 81b9 	bne.w	800ba1e <ai_platform_network_process+0x4a6>
 800b6ac:	6873      	ldr	r3, [r6, #4]
 800b6ae:	2b00      	cmp	r3, #0
 800b6b0:	f000 81ac 	beq.w	800ba0c <ai_platform_network_process+0x494>
 800b6b4:	69b3      	ldr	r3, [r6, #24]
 800b6b6:	681b      	ldr	r3, [r3, #0]
 800b6b8:	2b00      	cmp	r3, #0
 800b6ba:	f000 819c 	beq.w	800b9f6 <ai_platform_network_process+0x47e>
 800b6be:	9a01      	ldr	r2, [sp, #4]
 800b6c0:	429a      	cmp	r2, r3
 800b6c2:	bf38      	it	cc
 800b6c4:	461a      	movcc	r2, r3
 800b6c6:	4620      	mov	r0, r4
 800b6c8:	9201      	str	r2, [sp, #4]
 800b6ca:	f001 fc71 	bl	800cfb0 <get_tensor_byte_size>
 800b6ce:	f8c8 0008 	str.w	r0, [r8, #8]
 800b6d2:	69b3      	ldr	r3, [r6, #24]
 800b6d4:	681b      	ldr	r3, [r3, #0]
 800b6d6:	fb00 f303 	mul.w	r3, r0, r3
 800b6da:	f8c8 300c 	str.w	r3, [r8, #12]
 800b6de:	6871      	ldr	r1, [r6, #4]
 800b6e0:	f8c8 1004 	str.w	r1, [r8, #4]
 800b6e4:	440b      	add	r3, r1
 800b6e6:	f849 300b 	str.w	r3, [r9, fp]
 800b6ea:	69a0      	ldr	r0, [r4, #24]
 800b6ec:	6803      	ldr	r3, [r0, #0]
 800b6ee:	009a      	lsls	r2, r3, #2
 800b6f0:	f107 0701 	add.w	r7, r7, #1
 800b6f4:	f106 061c 	add.w	r6, r6, #28
 800b6f8:	f100 80af 	bmi.w	800b85a <ai_platform_network_process+0x2e2>
 800b6fc:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 800b700:	1a9b      	subs	r3, r3, r2
 800b702:	4419      	add	r1, r3
 800b704:	6081      	str	r1, [r0, #8]
 800b706:	69a3      	ldr	r3, [r4, #24]
 800b708:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800b70c:	60da      	str	r2, [r3, #12]
 800b70e:	f8ba 3000 	ldrh.w	r3, [sl]
 800b712:	42bb      	cmp	r3, r7
 800b714:	d888      	bhi.n	800b628 <ai_platform_network_process+0xb0>
 800b716:	e9dd 5b02 	ldrd	r5, fp, [sp, #8]
 800b71a:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
 800b71c:	f1bb 0f00 	cmp.w	fp, #0
 800b720:	f000 8186 	beq.w	800ba30 <ai_platform_network_process+0x4b8>
 800b724:	2a01      	cmp	r2, #1
 800b726:	f240 815e 	bls.w	800b9e6 <ai_platform_network_process+0x46e>
 800b72a:	f8d5 9030 	ldr.w	r9, [r5, #48]	; 0x30
 800b72e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b732:	2b00      	cmp	r3, #0
 800b734:	f000 8157 	beq.w	800b9e6 <ai_platform_network_process+0x46e>
 800b738:	465e      	mov	r6, fp
 800b73a:	2700      	movs	r7, #0
 800b73c:	462c      	mov	r4, r5
 800b73e:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800b742:	2b00      	cmp	r3, #0
 800b744:	f000 80b4 	beq.w	800b8b0 <ai_platform_network_process+0x338>
 800b748:	f853 5027 	ldr.w	r5, [r3, r7, lsl #2]
 800b74c:	2d00      	cmp	r5, #0
 800b74e:	f000 80af 	beq.w	800b8b0 <ai_platform_network_process+0x338>
 800b752:	f8d9 3014 	ldr.w	r3, [r9, #20]
 800b756:	f8d3 8000 	ldr.w	r8, [r3]
 800b75a:	eb18 1a07 	adds.w	sl, r8, r7, lsl #4
 800b75e:	ea4f 1b07 	mov.w	fp, r7, lsl #4
 800b762:	f000 8171 	beq.w	800ba48 <ai_platform_network_process+0x4d0>
 800b766:	69ab      	ldr	r3, [r5, #24]
 800b768:	2101      	movs	r1, #1
 800b76a:	685b      	ldr	r3, [r3, #4]
 800b76c:	9302      	str	r3, [sp, #8]
 800b76e:	4630      	mov	r0, r6
 800b770:	f7ff f980 	bl	800aa74 <ai_buffer_get_size>
 800b774:	9b02      	ldr	r3, [sp, #8]
 800b776:	4283      	cmp	r3, r0
 800b778:	f0c0 8134 	bcc.w	800b9e4 <ai_platform_network_process+0x46c>
 800b77c:	68e8      	ldr	r0, [r5, #12]
 800b77e:	69b1      	ldr	r1, [r6, #24]
 800b780:	68c2      	ldr	r2, [r0, #12]
 800b782:	68cb      	ldr	r3, [r1, #12]
 800b784:	429a      	cmp	r2, r3
 800b786:	f040 812d 	bne.w	800b9e4 <ai_platform_network_process+0x46c>
 800b78a:	6882      	ldr	r2, [r0, #8]
 800b78c:	688b      	ldr	r3, [r1, #8]
 800b78e:	429a      	cmp	r2, r3
 800b790:	f040 8128 	bne.w	800b9e4 <ai_platform_network_process+0x46c>
 800b794:	6842      	ldr	r2, [r0, #4]
 800b796:	684b      	ldr	r3, [r1, #4]
 800b798:	429a      	cmp	r2, r3
 800b79a:	f040 8123 	bne.w	800b9e4 <ai_platform_network_process+0x46c>
 800b79e:	69ab      	ldr	r3, [r5, #24]
 800b7a0:	e9d3 0100 	ldrd	r0, r1, [r3]
 800b7a4:	f001 fbec 	bl	800cf80 <ai_array_get_data_byte_size>
 800b7a8:	9002      	str	r0, [sp, #8]
 800b7aa:	4628      	mov	r0, r5
 800b7ac:	f001 fc00 	bl	800cfb0 <get_tensor_byte_size>
 800b7b0:	9b02      	ldr	r3, [sp, #8]
 800b7b2:	4283      	cmp	r3, r0
 800b7b4:	f0c0 8116 	bcc.w	800b9e4 <ai_platform_network_process+0x46c>
 800b7b8:	69ab      	ldr	r3, [r5, #24]
 800b7ba:	6818      	ldr	r0, [r3, #0]
 800b7bc:	f001 fb4c 	bl	800ce58 <ai_array_to_buffer_fmt>
 800b7c0:	6833      	ldr	r3, [r6, #0]
 800b7c2:	4058      	eors	r0, r3
 800b7c4:	f030 407e 	bics.w	r0, r0, #4261412864	; 0xfe000000
 800b7c8:	f040 8136 	bne.w	800ba38 <ai_platform_network_process+0x4c0>
 800b7cc:	6873      	ldr	r3, [r6, #4]
 800b7ce:	2b00      	cmp	r3, #0
 800b7d0:	f000 814d 	beq.w	800ba6e <ai_platform_network_process+0x4f6>
 800b7d4:	69b3      	ldr	r3, [r6, #24]
 800b7d6:	681b      	ldr	r3, [r3, #0]
 800b7d8:	2b00      	cmp	r3, #0
 800b7da:	f000 813f 	beq.w	800ba5c <ai_platform_network_process+0x4e4>
 800b7de:	9a01      	ldr	r2, [sp, #4]
 800b7e0:	429a      	cmp	r2, r3
 800b7e2:	bf38      	it	cc
 800b7e4:	461a      	movcc	r2, r3
 800b7e6:	4628      	mov	r0, r5
 800b7e8:	9201      	str	r2, [sp, #4]
 800b7ea:	f001 fbe1 	bl	800cfb0 <get_tensor_byte_size>
 800b7ee:	f8ca 0008 	str.w	r0, [sl, #8]
 800b7f2:	69b3      	ldr	r3, [r6, #24]
 800b7f4:	681b      	ldr	r3, [r3, #0]
 800b7f6:	fb00 f303 	mul.w	r3, r0, r3
 800b7fa:	f8ca 300c 	str.w	r3, [sl, #12]
 800b7fe:	6871      	ldr	r1, [r6, #4]
 800b800:	f8ca 1004 	str.w	r1, [sl, #4]
 800b804:	440b      	add	r3, r1
 800b806:	f848 300b 	str.w	r3, [r8, fp]
 800b80a:	69a8      	ldr	r0, [r5, #24]
 800b80c:	6803      	ldr	r3, [r0, #0]
 800b80e:	009b      	lsls	r3, r3, #2
 800b810:	f107 0701 	add.w	r7, r7, #1
 800b814:	f106 061c 	add.w	r6, r6, #28
 800b818:	d445      	bmi.n	800b8a6 <ai_platform_network_process+0x32e>
 800b81a:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 800b81e:	1a9b      	subs	r3, r3, r2
 800b820:	4419      	add	r1, r3
 800b822:	6081      	str	r1, [r0, #8]
 800b824:	69ab      	ldr	r3, [r5, #24]
 800b826:	f8da 2004 	ldr.w	r2, [sl, #4]
 800b82a:	60da      	str	r2, [r3, #12]
 800b82c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b830:	429f      	cmp	r7, r3
 800b832:	d384      	bcc.n	800b73e <ai_platform_network_process+0x1c6>
 800b834:	e03c      	b.n	800b8b0 <ai_platform_network_process+0x338>
 800b836:	e7fe      	b.n	800b836 <ai_platform_network_process+0x2be>
 800b838:	68ea      	ldr	r2, [r5, #12]
 800b83a:	616b      	str	r3, [r5, #20]
 800b83c:	f002 0203 	and.w	r2, r2, #3
 800b840:	2a03      	cmp	r2, #3
 800b842:	d11d      	bne.n	800b880 <ai_platform_network_process+0x308>
 800b844:	2217      	movs	r2, #23
 800b846:	2112      	movs	r1, #18
 800b848:	f105 0010 	add.w	r0, r5, #16
 800b84c:	f000 f920 	bl	800ba90 <core_set_error>
 800b850:	2400      	movs	r4, #0
 800b852:	4620      	mov	r0, r4
 800b854:	b005      	add	sp, #20
 800b856:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b85a:	f8ba 3000 	ldrh.w	r3, [sl]
 800b85e:	429f      	cmp	r7, r3
 800b860:	f4ff aee2 	bcc.w	800b628 <ai_platform_network_process+0xb0>
 800b864:	e757      	b.n	800b716 <ai_platform_network_process+0x19e>
 800b866:	bf00      	nop
 800b868:	a1c00100 	.word	0xa1c00100
 800b86c:	e0042000 	.word	0xe0042000
 800b870:	58024000 	.word	0x58024000
 800b874:	f407a5c2 	.word	0xf407a5c2
 800b878:	b5e8b5cd 	.word	0xb5e8b5cd
 800b87c:	40023000 	.word	0x40023000
 800b880:	2230      	movs	r2, #48	; 0x30
 800b882:	2111      	movs	r1, #17
 800b884:	f105 0010 	add.w	r0, r5, #16
 800b888:	f000 f902 	bl	800ba90 <core_set_error>
 800b88c:	2400      	movs	r4, #0
 800b88e:	e7e0      	b.n	800b852 <ai_platform_network_process+0x2da>
 800b890:	462c      	mov	r4, r5
 800b892:	e7de      	b.n	800b852 <ai_platform_network_process+0x2da>
 800b894:	9d02      	ldr	r5, [sp, #8]
 800b896:	2218      	movs	r2, #24
 800b898:	2112      	movs	r1, #18
 800b89a:	f105 0010 	add.w	r0, r5, #16
 800b89e:	f000 f8f7 	bl	800ba90 <core_set_error>
 800b8a2:	2400      	movs	r4, #0
 800b8a4:	e7d5      	b.n	800b852 <ai_platform_network_process+0x2da>
 800b8a6:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800b8aa:	429f      	cmp	r7, r3
 800b8ac:	f4ff af47 	bcc.w	800b73e <ai_platform_network_process+0x1c6>
 800b8b0:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800b8b4:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 800b8b6:	82a3      	strh	r3, [r4, #20]
 800b8b8:	4625      	mov	r5, r4
 800b8ba:	2a00      	cmp	r2, #0
 800b8bc:	f040 808c 	bne.w	800b9d8 <ai_platform_network_process+0x460>
 800b8c0:	4616      	mov	r6, r2
 800b8c2:	4617      	mov	r7, r2
 800b8c4:	8aec      	ldrh	r4, [r5, #22]
 800b8c6:	429c      	cmp	r4, r3
 800b8c8:	bf38      	it	cc
 800b8ca:	46ab      	movcc	fp, r5
 800b8cc:	d2c1      	bcs.n	800b852 <ai_platform_network_process+0x2da>
 800b8ce:	2e00      	cmp	r6, #0
 800b8d0:	d030      	beq.n	800b934 <ai_platform_network_process+0x3bc>
 800b8d2:	f04f 0800 	mov.w	r8, #0
 800b8d6:	e014      	b.n	800b902 <ai_platform_network_process+0x38a>
 800b8d8:	6882      	ldr	r2, [r0, #8]
 800b8da:	68c5      	ldr	r5, [r0, #12]
 800b8dc:	6863      	ldr	r3, [r4, #4]
 800b8de:	1b52      	subs	r2, r2, r5
 800b8e0:	4413      	add	r3, r2
 800b8e2:	6083      	str	r3, [r0, #8]
 800b8e4:	698b      	ldr	r3, [r1, #24]
 800b8e6:	6862      	ldr	r2, [r4, #4]
 800b8e8:	60da      	str	r2, [r3, #12]
 800b8ea:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 800b8ee:	f859 200a 	ldr.w	r2, [r9, sl]
 800b8f2:	440b      	add	r3, r1
 800b8f4:	4293      	cmp	r3, r2
 800b8f6:	bf24      	itt	cs
 800b8f8:	68e3      	ldrcs	r3, [r4, #12]
 800b8fa:	1ad3      	subcs	r3, r2, r3
 800b8fc:	6063      	str	r3, [r4, #4]
 800b8fe:	f108 0801 	add.w	r8, r8, #1
 800b902:	8833      	ldrh	r3, [r6, #0]
 800b904:	4543      	cmp	r3, r8
 800b906:	ea4f 1a08 	mov.w	sl, r8, lsl #4
 800b90a:	d913      	bls.n	800b934 <ai_platform_network_process+0x3bc>
 800b90c:	6873      	ldr	r3, [r6, #4]
 800b90e:	b18b      	cbz	r3, 800b934 <ai_platform_network_process+0x3bc>
 800b910:	f853 1028 	ldr.w	r1, [r3, r8, lsl #2]
 800b914:	b171      	cbz	r1, 800b934 <ai_platform_network_process+0x3bc>
 800b916:	6988      	ldr	r0, [r1, #24]
 800b918:	68b2      	ldr	r2, [r6, #8]
 800b91a:	6803      	ldr	r3, [r0, #0]
 800b91c:	f8d2 9000 	ldr.w	r9, [r2]
 800b920:	009d      	lsls	r5, r3, #2
 800b922:	eb09 1408 	add.w	r4, r9, r8, lsl #4
 800b926:	d5d7      	bpl.n	800b8d8 <ai_platform_network_process+0x360>
 800b928:	6881      	ldr	r1, [r0, #8]
 800b92a:	68a2      	ldr	r2, [r4, #8]
 800b92c:	6860      	ldr	r0, [r4, #4]
 800b92e:	f001 f9a5 	bl	800cc7c <st_int8_copy>
 800b932:	e7da      	b.n	800b8ea <ai_platform_network_process+0x372>
 800b934:	4658      	mov	r0, fp
 800b936:	f000 f903 	bl	800bb40 <ai_layers_forward_all>
 800b93a:	2f00      	cmp	r7, #0
 800b93c:	d03d      	beq.n	800b9ba <ai_platform_network_process+0x442>
 800b93e:	2400      	movs	r4, #0
 800b940:	e016      	b.n	800b970 <ai_platform_network_process+0x3f8>
 800b942:	e9d8 3201 	ldrd	r3, r2, [r8, #4]
 800b946:	f859 100a 	ldr.w	r1, [r9, sl]
 800b94a:	4413      	add	r3, r2
 800b94c:	428b      	cmp	r3, r1
 800b94e:	bf24      	itt	cs
 800b950:	f8d8 300c 	ldrcs.w	r3, [r8, #12]
 800b954:	1acb      	subcs	r3, r1, r3
 800b956:	f8c8 3004 	str.w	r3, [r8, #4]
 800b95a:	6981      	ldr	r1, [r0, #24]
 800b95c:	e9d1 2502 	ldrd	r2, r5, [r1, #8]
 800b960:	1b52      	subs	r2, r2, r5
 800b962:	4413      	add	r3, r2
 800b964:	608b      	str	r3, [r1, #8]
 800b966:	6983      	ldr	r3, [r0, #24]
 800b968:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800b96c:	60da      	str	r2, [r3, #12]
 800b96e:	3401      	adds	r4, #1
 800b970:	883b      	ldrh	r3, [r7, #0]
 800b972:	42a3      	cmp	r3, r4
 800b974:	d921      	bls.n	800b9ba <ai_platform_network_process+0x442>
 800b976:	687b      	ldr	r3, [r7, #4]
 800b978:	b1fb      	cbz	r3, 800b9ba <ai_platform_network_process+0x442>
 800b97a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800b97e:	b1e0      	cbz	r0, 800b9ba <ai_platform_network_process+0x442>
 800b980:	68ba      	ldr	r2, [r7, #8]
 800b982:	6983      	ldr	r3, [r0, #24]
 800b984:	f8d2 9000 	ldr.w	r9, [r2]
 800b988:	681a      	ldr	r2, [r3, #0]
 800b98a:	0092      	lsls	r2, r2, #2
 800b98c:	ea4f 1a04 	mov.w	sl, r4, lsl #4
 800b990:	eb09 1804 	add.w	r8, r9, r4, lsl #4
 800b994:	d5d5      	bpl.n	800b942 <ai_platform_network_process+0x3ca>
 800b996:	e9d8 1201 	ldrd	r1, r2, [r8, #4]
 800b99a:	6898      	ldr	r0, [r3, #8]
 800b99c:	f001 f96e 	bl	800cc7c <st_int8_copy>
 800b9a0:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 800b9a4:	f859 200a 	ldr.w	r2, [r9, sl]
 800b9a8:	440b      	add	r3, r1
 800b9aa:	4293      	cmp	r3, r2
 800b9ac:	bf24      	itt	cs
 800b9ae:	f8d8 300c 	ldrcs.w	r3, [r8, #12]
 800b9b2:	1ad3      	subcs	r3, r2, r3
 800b9b4:	f8c8 3004 	str.w	r3, [r8, #4]
 800b9b8:	e7d9      	b.n	800b96e <ai_platform_network_process+0x3f6>
 800b9ba:	f8bb 4016 	ldrh.w	r4, [fp, #22]
 800b9be:	f8bb 3014 	ldrh.w	r3, [fp, #20]
 800b9c2:	3401      	adds	r4, #1
 800b9c4:	b2a4      	uxth	r4, r4
 800b9c6:	42a3      	cmp	r3, r4
 800b9c8:	f8ab 4016 	strh.w	r4, [fp, #22]
 800b9cc:	f63f af7f 	bhi.w	800b8ce <ai_platform_network_process+0x356>
 800b9d0:	4620      	mov	r0, r4
 800b9d2:	b005      	add	sp, #20
 800b9d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b9d8:	2a01      	cmp	r2, #1
 800b9da:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800b9dc:	d03c      	beq.n	800ba58 <ai_platform_network_process+0x4e0>
 800b9de:	f106 070c 	add.w	r7, r6, #12
 800b9e2:	e76f      	b.n	800b8c4 <ai_platform_network_process+0x34c>
 800b9e4:	4625      	mov	r5, r4
 800b9e6:	2218      	movs	r2, #24
 800b9e8:	2113      	movs	r1, #19
 800b9ea:	f105 0010 	add.w	r0, r5, #16
 800b9ee:	f000 f84f 	bl	800ba90 <core_set_error>
 800b9f2:	2400      	movs	r4, #0
 800b9f4:	e72d      	b.n	800b852 <ai_platform_network_process+0x2da>
 800b9f6:	9d02      	ldr	r5, [sp, #8]
 800b9f8:	4604      	mov	r4, r0
 800b9fa:	2221      	movs	r2, #33	; 0x21
 800b9fc:	2112      	movs	r1, #18
 800b9fe:	f105 0010 	add.w	r0, r5, #16
 800ba02:	f000 f845 	bl	800ba90 <core_set_error>
 800ba06:	e724      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba08:	9d02      	ldr	r5, [sp, #8]
 800ba0a:	e71b      	b.n	800b844 <ai_platform_network_process+0x2cc>
 800ba0c:	9d02      	ldr	r5, [sp, #8]
 800ba0e:	4604      	mov	r4, r0
 800ba10:	2217      	movs	r2, #23
 800ba12:	2112      	movs	r1, #18
 800ba14:	f105 0010 	add.w	r0, r5, #16
 800ba18:	f000 f83a 	bl	800ba90 <core_set_error>
 800ba1c:	e719      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba1e:	9d02      	ldr	r5, [sp, #8]
 800ba20:	2219      	movs	r2, #25
 800ba22:	2112      	movs	r1, #18
 800ba24:	f105 0010 	add.w	r0, r5, #16
 800ba28:	f000 f832 	bl	800ba90 <core_set_error>
 800ba2c:	2400      	movs	r4, #0
 800ba2e:	e710      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba30:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800ba34:	82ab      	strh	r3, [r5, #20]
 800ba36:	e740      	b.n	800b8ba <ai_platform_network_process+0x342>
 800ba38:	f104 0010 	add.w	r0, r4, #16
 800ba3c:	2219      	movs	r2, #25
 800ba3e:	2113      	movs	r1, #19
 800ba40:	f000 f826 	bl	800ba90 <core_set_error>
 800ba44:	2400      	movs	r4, #0
 800ba46:	e704      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba48:	f104 0010 	add.w	r0, r4, #16
 800ba4c:	2217      	movs	r2, #23
 800ba4e:	2113      	movs	r1, #19
 800ba50:	f000 f81e 	bl	800ba90 <core_set_error>
 800ba54:	4654      	mov	r4, sl
 800ba56:	e6fc      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba58:	2700      	movs	r7, #0
 800ba5a:	e733      	b.n	800b8c4 <ai_platform_network_process+0x34c>
 800ba5c:	4625      	mov	r5, r4
 800ba5e:	2221      	movs	r2, #33	; 0x21
 800ba60:	4604      	mov	r4, r0
 800ba62:	2113      	movs	r1, #19
 800ba64:	f105 0010 	add.w	r0, r5, #16
 800ba68:	f000 f812 	bl	800ba90 <core_set_error>
 800ba6c:	e6f1      	b.n	800b852 <ai_platform_network_process+0x2da>
 800ba6e:	4625      	mov	r5, r4
 800ba70:	2217      	movs	r2, #23
 800ba72:	4604      	mov	r4, r0
 800ba74:	2113      	movs	r1, #19
 800ba76:	f105 0010 	add.w	r0, r5, #16
 800ba7a:	f000 f809 	bl	800ba90 <core_set_error>
 800ba7e:	e6e8      	b.n	800b852 <ai_platform_network_process+0x2da>

0800ba80 <core_init>:
 800ba80:	2001      	movs	r0, #1
 800ba82:	4770      	bx	lr

0800ba84 <core_get_error>:
 800ba84:	4603      	mov	r3, r0
 800ba86:	2200      	movs	r2, #0
 800ba88:	6800      	ldr	r0, [r0, #0]
 800ba8a:	601a      	str	r2, [r3, #0]
 800ba8c:	4770      	bx	lr
 800ba8e:	bf00      	nop

0800ba90 <core_set_error>:
 800ba90:	4603      	mov	r3, r0
 800ba92:	7800      	ldrb	r0, [r0, #0]
 800ba94:	b108      	cbz	r0, 800ba9a <core_set_error+0xa>
 800ba96:	2000      	movs	r0, #0
 800ba98:	4770      	bx	lr
 800ba9a:	7019      	strb	r1, [r3, #0]
 800ba9c:	6819      	ldr	r1, [r3, #0]
 800ba9e:	f362 211f 	bfi	r1, r2, #8, #24
 800baa2:	2001      	movs	r0, #1
 800baa4:	6019      	str	r1, [r3, #0]
 800baa6:	4770      	bx	lr

0800baa8 <ai_check_custom_types>:
 800baa8:	b082      	sub	sp, #8
 800baaa:	4b13      	ldr	r3, [pc, #76]	; (800baf8 <ai_check_custom_types+0x50>)
 800baac:	9301      	str	r3, [sp, #4]
 800baae:	b118      	cbz	r0, 800bab8 <ai_check_custom_types+0x10>
 800bab0:	7803      	ldrb	r3, [r0, #0]
 800bab2:	2b03      	cmp	r3, #3
 800bab4:	d002      	beq.n	800babc <ai_check_custom_types+0x14>
 800bab6:	2000      	movs	r0, #0
 800bab8:	b002      	add	sp, #8
 800baba:	4770      	bx	lr
 800babc:	f89d 2004 	ldrb.w	r2, [sp, #4]
 800bac0:	4293      	cmp	r3, r2
 800bac2:	d004      	beq.n	800bace <ai_check_custom_types+0x26>
 800bac4:	2001      	movs	r0, #1
 800bac6:	f080 0001 	eor.w	r0, r0, #1
 800baca:	b002      	add	sp, #8
 800bacc:	4770      	bx	lr
 800bace:	7842      	ldrb	r2, [r0, #1]
 800bad0:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800bad4:	429a      	cmp	r2, r3
 800bad6:	f100 0001 	add.w	r0, r0, #1
 800bada:	d1f3      	bne.n	800bac4 <ai_check_custom_types+0x1c>
 800badc:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 800bae0:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800bae4:	429a      	cmp	r2, r3
 800bae6:	d1ed      	bne.n	800bac4 <ai_check_custom_types+0x1c>
 800bae8:	7842      	ldrb	r2, [r0, #1]
 800baea:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800baee:	429a      	cmp	r2, r3
 800baf0:	d1e8      	bne.n	800bac4 <ai_check_custom_types+0x1c>
 800baf2:	2000      	movs	r0, #0
 800baf4:	e7e7      	b.n	800bac6 <ai_check_custom_types+0x1e>
 800baf6:	bf00      	nop
 800baf8:	84048403 	.word	0x84048403

0800bafc <ai_layers_init_all>:
 800bafc:	4601      	mov	r1, r0
 800bafe:	2000      	movs	r0, #0
 800bb00:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800bb02:	b143      	cbz	r3, 800bb16 <ai_layers_init_all+0x1a>
 800bb04:	691a      	ldr	r2, [r3, #16]
 800bb06:	60d9      	str	r1, [r3, #12]
 800bb08:	429a      	cmp	r2, r3
 800bb0a:	f100 0001 	add.w	r0, r0, #1
 800bb0e:	d002      	beq.n	800bb16 <ai_layers_init_all+0x1a>
 800bb10:	b10a      	cbz	r2, 800bb16 <ai_layers_init_all+0x1a>
 800bb12:	4613      	mov	r3, r2
 800bb14:	e7f5      	b.n	800bb02 <ai_layers_init_all+0x6>
 800bb16:	4770      	bx	lr

0800bb18 <ai_layers_post_init_all>:
 800bb18:	b538      	push	{r3, r4, r5, lr}
 800bb1a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800bb1c:	2500      	movs	r5, #0
 800bb1e:	b16c      	cbz	r4, 800bb3c <ai_layers_post_init_all+0x24>
 800bb20:	6863      	ldr	r3, [r4, #4]
 800bb22:	07db      	lsls	r3, r3, #31
 800bb24:	d504      	bpl.n	800bb30 <ai_layers_post_init_all+0x18>
 800bb26:	6a23      	ldr	r3, [r4, #32]
 800bb28:	4620      	mov	r0, r4
 800bb2a:	b10b      	cbz	r3, 800bb30 <ai_layers_post_init_all+0x18>
 800bb2c:	4798      	blx	r3
 800bb2e:	3501      	adds	r5, #1
 800bb30:	6923      	ldr	r3, [r4, #16]
 800bb32:	42a3      	cmp	r3, r4
 800bb34:	d002      	beq.n	800bb3c <ai_layers_post_init_all+0x24>
 800bb36:	b10b      	cbz	r3, 800bb3c <ai_layers_post_init_all+0x24>
 800bb38:	461c      	mov	r4, r3
 800bb3a:	e7f0      	b.n	800bb1e <ai_layers_post_init_all+0x6>
 800bb3c:	4628      	mov	r0, r5
 800bb3e:	bd38      	pop	{r3, r4, r5, pc}

0800bb40 <ai_layers_forward_all>:
 800bb40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bb44:	f8d0 803c 	ldr.w	r8, [r0, #60]	; 0x3c
 800bb48:	4604      	mov	r4, r0
 800bb4a:	f1b8 0f00 	cmp.w	r8, #0
 800bb4e:	d02b      	beq.n	800bba8 <ai_layers_forward_all+0x68>
 800bb50:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800bb52:	6381      	str	r1, [r0, #56]	; 0x38
 800bb54:	b321      	cbz	r1, 800bba0 <ai_layers_forward_all+0x60>
 800bb56:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800bb58:	2001      	movs	r0, #1
 800bb5a:	47c0      	blx	r8
 800bb5c:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800bb5e:	b1fe      	cbz	r6, 800bba0 <ai_layers_forward_all+0x60>
 800bb60:	2700      	movs	r7, #0
 800bb62:	4631      	mov	r1, r6
 800bb64:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800bb66:	2002      	movs	r0, #2
 800bb68:	47c0      	blx	r8
 800bb6a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 800bb6c:	4628      	mov	r0, r5
 800bb6e:	696b      	ldr	r3, [r5, #20]
 800bb70:	4798      	blx	r3
 800bb72:	692e      	ldr	r6, [r5, #16]
 800bb74:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800bb76:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800bb78:	42b5      	cmp	r5, r6
 800bb7a:	f04f 0003 	mov.w	r0, #3
 800bb7e:	d007      	beq.n	800bb90 <ai_layers_forward_all+0x50>
 800bb80:	47c0      	blx	r8
 800bb82:	3701      	adds	r7, #1
 800bb84:	63a6      	str	r6, [r4, #56]	; 0x38
 800bb86:	2e00      	cmp	r6, #0
 800bb88:	d1eb      	bne.n	800bb62 <ai_layers_forward_all+0x22>
 800bb8a:	4638      	mov	r0, r7
 800bb8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bb90:	2003      	movs	r0, #3
 800bb92:	47c0      	blx	r8
 800bb94:	2300      	movs	r3, #0
 800bb96:	3701      	adds	r7, #1
 800bb98:	63a3      	str	r3, [r4, #56]	; 0x38
 800bb9a:	4638      	mov	r0, r7
 800bb9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bba0:	2700      	movs	r7, #0
 800bba2:	4638      	mov	r0, r7
 800bba4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bba8:	6b45      	ldr	r5, [r0, #52]	; 0x34
 800bbaa:	6385      	str	r5, [r0, #56]	; 0x38
 800bbac:	2d00      	cmp	r5, #0
 800bbae:	d0f7      	beq.n	800bba0 <ai_layers_forward_all+0x60>
 800bbb0:	4647      	mov	r7, r8
 800bbb2:	696b      	ldr	r3, [r5, #20]
 800bbb4:	4628      	mov	r0, r5
 800bbb6:	4798      	blx	r3
 800bbb8:	462b      	mov	r3, r5
 800bbba:	692d      	ldr	r5, [r5, #16]
 800bbbc:	429d      	cmp	r5, r3
 800bbbe:	d004      	beq.n	800bbca <ai_layers_forward_all+0x8a>
 800bbc0:	63a5      	str	r5, [r4, #56]	; 0x38
 800bbc2:	3701      	adds	r7, #1
 800bbc4:	2d00      	cmp	r5, #0
 800bbc6:	d1f4      	bne.n	800bbb2 <ai_layers_forward_all+0x72>
 800bbc8:	e7df      	b.n	800bb8a <ai_layers_forward_all+0x4a>
 800bbca:	2300      	movs	r3, #0
 800bbcc:	63a3      	str	r3, [r4, #56]	; 0x38
 800bbce:	3701      	adds	r7, #1
 800bbd0:	e7db      	b.n	800bb8a <ai_layers_forward_all+0x4a>
 800bbd2:	bf00      	nop

0800bbd4 <forward_dense>:
 800bbd4:	6983      	ldr	r3, [r0, #24]
 800bbd6:	881a      	ldrh	r2, [r3, #0]
 800bbd8:	2a00      	cmp	r2, #0
 800bbda:	f000 8181 	beq.w	800bee0 <forward_dense+0x30c>
 800bbde:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bbe2:	ed2d 8b02 	vpush	{d8}
 800bbe6:	f8d3 c004 	ldr.w	ip, [r3, #4]
 800bbea:	f8dc 5004 	ldr.w	r5, [ip, #4]
 800bbee:	b095      	sub	sp, #84	; 0x54
 800bbf0:	b105      	cbz	r5, 800bbf4 <forward_dense+0x20>
 800bbf2:	682d      	ldr	r5, [r5, #0]
 800bbf4:	2a01      	cmp	r2, #1
 800bbf6:	f000 828f 	beq.w	800c118 <forward_dense+0x544>
 800bbfa:	f8dc 6010 	ldr.w	r6, [ip, #16]
 800bbfe:	b106      	cbz	r6, 800bc02 <forward_dense+0x2e>
 800bc00:	6836      	ldr	r6, [r6, #0]
 800bc02:	2a02      	cmp	r2, #2
 800bc04:	f000 816e 	beq.w	800bee4 <forward_dense+0x310>
 800bc08:	f8dc 301c 	ldr.w	r3, [ip, #28]
 800bc0c:	930b      	str	r3, [sp, #44]	; 0x2c
 800bc0e:	2b00      	cmp	r3, #0
 800bc10:	f000 8274 	beq.w	800c0fc <forward_dense+0x528>
 800bc14:	4619      	mov	r1, r3
 800bc16:	f8bc 3018 	ldrh.w	r3, [ip, #24]
 800bc1a:	6809      	ldr	r1, [r1, #0]
 800bc1c:	910d      	str	r1, [sp, #52]	; 0x34
 800bc1e:	2b01      	cmp	r3, #1
 800bc20:	f240 826e 	bls.w	800c100 <forward_dense+0x52c>
 800bc24:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800bc26:	685b      	ldr	r3, [r3, #4]
 800bc28:	930b      	str	r3, [sp, #44]	; 0x2c
 800bc2a:	460b      	mov	r3, r1
 800bc2c:	68e8      	ldr	r0, [r5, #12]
 800bc2e:	68f7      	ldr	r7, [r6, #12]
 800bc30:	6840      	ldr	r0, [r0, #4]
 800bc32:	6999      	ldr	r1, [r3, #24]
 800bc34:	9013      	str	r0, [sp, #76]	; 0x4c
 800bc36:	6878      	ldr	r0, [r7, #4]
 800bc38:	680b      	ldr	r3, [r1, #0]
 800bc3a:	9012      	str	r0, [sp, #72]	; 0x48
 800bc3c:	e9d7 4702 	ldrd	r4, r7, [r7, #8]
 800bc40:	f3c3 1ec6 	ubfx	lr, r3, #7, #7
 800bc44:	fb00 f404 	mul.w	r4, r0, r4
 800bc48:	f3c3 5041 	ubfx	r0, r3, #21, #2
 800bc4c:	fa4e f000 	asr.w	r0, lr, r0
 800bc50:	2a03      	cmp	r2, #3
 800bc52:	9010      	str	r0, [sp, #64]	; 0x40
 800bc54:	f000 825d 	beq.w	800c112 <forward_dense+0x53e>
 800bc58:	f8dc 2028 	ldr.w	r2, [ip, #40]	; 0x28
 800bc5c:	f3c3 4343 	ubfx	r3, r3, #17, #4
 800bc60:	2a00      	cmp	r2, #0
 800bc62:	f000 8246 	beq.w	800c0f2 <forward_dense+0x51e>
 800bc66:	6812      	ldr	r2, [r2, #0]
 800bc68:	2a00      	cmp	r2, #0
 800bc6a:	f000 8242 	beq.w	800c0f2 <forward_dense+0x51e>
 800bc6e:	2b04      	cmp	r3, #4
 800bc70:	f8d2 9018 	ldr.w	r9, [r2, #24]
 800bc74:	f000 822c 	beq.w	800c0d0 <forward_dense+0x4fc>
 800bc78:	2b08      	cmp	r3, #8
 800bc7a:	f000 8229 	beq.w	800c0d0 <forward_dense+0x4fc>
 800bc7e:	f04f 0b00 	mov.w	fp, #0
 800bc82:	69b2      	ldr	r2, [r6, #24]
 800bc84:	69ab      	ldr	r3, [r5, #24]
 800bc86:	6891      	ldr	r1, [r2, #8]
 800bc88:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800bc8a:	689b      	ldr	r3, [r3, #8]
 800bc8c:	6952      	ldr	r2, [r2, #20]
 800bc8e:	9106      	str	r1, [sp, #24]
 800bc90:	fb07 f404 	mul.w	r4, r7, r4
 800bc94:	f8d2 9004 	ldr.w	r9, [r2, #4]
 800bc98:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800bc9a:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 800bc9e:	4281      	cmp	r1, r0
 800bca0:	ea4f 0482 	mov.w	r4, r2, lsl #2
 800bca4:	900e      	str	r0, [sp, #56]	; 0x38
 800bca6:	940c      	str	r4, [sp, #48]	; 0x30
 800bca8:	eb01 0882 	add.w	r8, r1, r2, lsl #2
 800bcac:	f080 8113 	bcs.w	800bed6 <forward_dense+0x302>
 800bcb0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800bcb2:	ed9f 8a93 	vldr	s16, [pc, #588]	; 800bf00 <forward_dense+0x32c>
 800bcb6:	f021 0201 	bic.w	r2, r1, #1
 800bcba:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800bcbe:	9204      	str	r2, [sp, #16]
 800bcc0:	f001 0201 	and.w	r2, r1, #1
 800bcc4:	08c8      	lsrs	r0, r1, #3
 800bcc6:	9208      	str	r2, [sp, #32]
 800bcc8:	008a      	lsls	r2, r1, #2
 800bcca:	f001 0a07 	and.w	sl, r1, #7
 800bcce:	920f      	str	r2, [sp, #60]	; 0x3c
 800bcd0:	eb03 1240 	add.w	r2, r3, r0, lsl #5
 800bcd4:	3320      	adds	r3, #32
 800bcd6:	465c      	mov	r4, fp
 800bcd8:	9007      	str	r0, [sp, #28]
 800bcda:	46cb      	mov	fp, r9
 800bcdc:	9205      	str	r2, [sp, #20]
 800bcde:	9302      	str	r3, [sp, #8]
 800bce0:	46c1      	mov	r9, r8
 800bce2:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
 800bce6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800bce8:	699b      	ldr	r3, [r3, #24]
 800bcea:	689a      	ldr	r2, [r3, #8]
 800bcec:	9b02      	ldr	r3, [sp, #8]
 800bcee:	3b20      	subs	r3, #32
 800bcf0:	930a      	str	r3, [sp, #40]	; 0x28
 800bcf2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800bcf4:	b10b      	cbz	r3, 800bcfa <forward_dense+0x126>
 800bcf6:	699b      	ldr	r3, [r3, #24]
 800bcf8:	689b      	ldr	r3, [r3, #8]
 800bcfa:	2c00      	cmp	r4, #0
 800bcfc:	f000 81da 	beq.w	800c0b4 <forward_dense+0x4e0>
 800bd00:	9910      	ldr	r1, [sp, #64]	; 0x40
 800bd02:	2904      	cmp	r1, #4
 800bd04:	9906      	ldr	r1, [sp, #24]
 800bd06:	f000 80fd 	beq.w	800bf04 <forward_dense+0x330>
 800bd0a:	4549      	cmp	r1, r9
 800bd0c:	f080 80d2 	bcs.w	800beb4 <forward_dense+0x2e0>
 800bd10:	460f      	mov	r7, r1
 800bd12:	9907      	ldr	r1, [sp, #28]
 800bd14:	f8dd 8008 	ldr.w	r8, [sp, #8]
 800bd18:	f8dd a014 	ldr.w	sl, [sp, #20]
 800bd1c:	1c4e      	adds	r6, r1, #1
 800bd1e:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 800bd22:	4694      	mov	ip, r2
 800bd24:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800bd26:	468e      	mov	lr, r1
 800bd28:	2b00      	cmp	r3, #0
 800bd2a:	f000 80de 	beq.w	800beea <forward_dense+0x316>
 800bd2e:	ecf3 2a01 	vldmia	r3!, {s5}
 800bd32:	ed9f 7a73 	vldr	s14, [pc, #460]	; 800bf00 <forward_dense+0x32c>
 800bd36:	f1be 0f00 	cmp.w	lr, #0
 800bd3a:	f000 80de 	beq.w	800befa <forward_dense+0x326>
 800bd3e:	f10c 0108 	add.w	r1, ip, #8
 800bd42:	4640      	mov	r0, r8
 800bd44:	f811 5c07 	ldrb.w	r5, [r1, #-7]
 800bd48:	ed10 3a07 	vldr	s6, [r0, #-28]	; 0xffffffe4
 800bd4c:	ed50 3a08 	vldr	s7, [r0, #-32]	; 0xffffffe0
 800bd50:	ed10 4a06 	vldr	s8, [r0, #-24]	; 0xffffffe8
 800bd54:	ed50 4a05 	vldr	s9, [r0, #-20]	; 0xffffffec
 800bd58:	ed10 5a04 	vldr	s10, [r0, #-16]
 800bd5c:	ed50 5a03 	vldr	s11, [r0, #-12]
 800bd60:	ed10 6a02 	vldr	s12, [r0, #-8]
 800bd64:	ed50 6a01 	vldr	s13, [r0, #-4]
 800bd68:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bd6c:	edd5 7a00 	vldr	s15, [r5]
 800bd70:	f811 5c08 	ldrb.w	r5, [r1, #-8]
 800bd74:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bd78:	ee67 7a83 	vmul.f32	s15, s15, s6
 800bd7c:	ed95 3a00 	vldr	s6, [r5]
 800bd80:	f811 5c06 	ldrb.w	r5, [r1, #-6]
 800bd84:	eee3 7a23 	vfma.f32	s15, s6, s7
 800bd88:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bd8c:	3108      	adds	r1, #8
 800bd8e:	edd5 3a00 	vldr	s7, [r5]
 800bd92:	f811 5c0d 	ldrb.w	r5, [r1, #-13]
 800bd96:	eee3 7a84 	vfma.f32	s15, s7, s8
 800bd9a:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bd9e:	3020      	adds	r0, #32
 800bda0:	ed95 4a00 	vldr	s8, [r5]
 800bda4:	f811 5c0c 	ldrb.w	r5, [r1, #-12]
 800bda8:	eee4 7a24 	vfma.f32	s15, s8, s9
 800bdac:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdb0:	edd5 4a00 	vldr	s9, [r5]
 800bdb4:	f811 5c0b 	ldrb.w	r5, [r1, #-11]
 800bdb8:	eee4 7a85 	vfma.f32	s15, s9, s10
 800bdbc:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdc0:	ed95 5a00 	vldr	s10, [r5]
 800bdc4:	f811 5c0a 	ldrb.w	r5, [r1, #-10]
 800bdc8:	eee5 7a25 	vfma.f32	s15, s10, s11
 800bdcc:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bdd0:	edd5 5a00 	vldr	s11, [r5]
 800bdd4:	f811 5c09 	ldrb.w	r5, [r1, #-9]
 800bdd8:	eee5 7a86 	vfma.f32	s15, s11, s12
 800bddc:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bde0:	428e      	cmp	r6, r1
 800bde2:	ed95 6a00 	vldr	s12, [r5]
 800bde6:	eee6 7a26 	vfma.f32	s15, s12, s13
 800bdea:	ee37 7a27 	vadd.f32	s14, s14, s15
 800bdee:	d1a9      	bne.n	800bd44 <forward_dense+0x170>
 800bdf0:	f1a6 0108 	sub.w	r1, r6, #8
 800bdf4:	4650      	mov	r0, sl
 800bdf6:	2a00      	cmp	r2, #0
 800bdf8:	d04a      	beq.n	800be90 <forward_dense+0x2bc>
 800bdfa:	780d      	ldrb	r5, [r1, #0]
 800bdfc:	edd0 6a00 	vldr	s13, [r0]
 800be00:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be04:	edd5 7a00 	vldr	s15, [r5]
 800be08:	2a01      	cmp	r2, #1
 800be0a:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be0e:	d03f      	beq.n	800be90 <forward_dense+0x2bc>
 800be10:	784d      	ldrb	r5, [r1, #1]
 800be12:	edd0 6a01 	vldr	s13, [r0, #4]
 800be16:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be1a:	edd5 7a00 	vldr	s15, [r5]
 800be1e:	2a02      	cmp	r2, #2
 800be20:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be24:	d034      	beq.n	800be90 <forward_dense+0x2bc>
 800be26:	788d      	ldrb	r5, [r1, #2]
 800be28:	edd0 6a02 	vldr	s13, [r0, #8]
 800be2c:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be30:	edd5 7a00 	vldr	s15, [r5]
 800be34:	2a03      	cmp	r2, #3
 800be36:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be3a:	d029      	beq.n	800be90 <forward_dense+0x2bc>
 800be3c:	78cd      	ldrb	r5, [r1, #3]
 800be3e:	edd0 6a03 	vldr	s13, [r0, #12]
 800be42:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be46:	edd5 7a00 	vldr	s15, [r5]
 800be4a:	2a04      	cmp	r2, #4
 800be4c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be50:	d01e      	beq.n	800be90 <forward_dense+0x2bc>
 800be52:	790d      	ldrb	r5, [r1, #4]
 800be54:	edd0 6a04 	vldr	s13, [r0, #16]
 800be58:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be5c:	edd5 7a00 	vldr	s15, [r5]
 800be60:	2a05      	cmp	r2, #5
 800be62:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be66:	d013      	beq.n	800be90 <forward_dense+0x2bc>
 800be68:	794d      	ldrb	r5, [r1, #5]
 800be6a:	edd0 6a05 	vldr	s13, [r0, #20]
 800be6e:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800be72:	edd5 7a00 	vldr	s15, [r5]
 800be76:	2a06      	cmp	r2, #6
 800be78:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be7c:	d008      	beq.n	800be90 <forward_dense+0x2bc>
 800be7e:	7989      	ldrb	r1, [r1, #6]
 800be80:	edd0 7a06 	vldr	s15, [r0, #24]
 800be84:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800be88:	edd1 6a00 	vldr	s13, [r1]
 800be8c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800be90:	44dc      	add	ip, fp
 800be92:	445e      	add	r6, fp
 800be94:	ee32 7a87 	vadd.f32	s14, s5, s14
 800be98:	eca7 7a01 	vstmia	r7!, {s14}
 800be9c:	454f      	cmp	r7, r9
 800be9e:	f4ff af43 	bcc.w	800bd28 <forward_dense+0x154>
 800bea2:	9a06      	ldr	r2, [sp, #24]
 800bea4:	eba9 0302 	sub.w	r3, r9, r2
 800bea8:	3b01      	subs	r3, #1
 800beaa:	f023 0303 	bic.w	r3, r3, #3
 800beae:	3304      	adds	r3, #4
 800beb0:	18d3      	adds	r3, r2, r3
 800beb2:	9306      	str	r3, [sp, #24]
 800beb4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800beb6:	9a05      	ldr	r2, [sp, #20]
 800beb8:	4499      	add	r9, r3
 800beba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800bebc:	441a      	add	r2, r3
 800bebe:	9205      	str	r2, [sp, #20]
 800bec0:	9a02      	ldr	r2, [sp, #8]
 800bec2:	441a      	add	r2, r3
 800bec4:	9202      	str	r2, [sp, #8]
 800bec6:	9a04      	ldr	r2, [sp, #16]
 800bec8:	441a      	add	r2, r3
 800beca:	9204      	str	r2, [sp, #16]
 800becc:	9b06      	ldr	r3, [sp, #24]
 800bece:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800bed0:	4293      	cmp	r3, r2
 800bed2:	f4ff af08 	bcc.w	800bce6 <forward_dense+0x112>
 800bed6:	b015      	add	sp, #84	; 0x54
 800bed8:	ecbd 8b02 	vpop	{d8}
 800bedc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bee0:	6853      	ldr	r3, [r2, #4]
 800bee2:	deff      	udf	#255	; 0xff
 800bee4:	2300      	movs	r3, #0
 800bee6:	685b      	ldr	r3, [r3, #4]
 800bee8:	deff      	udf	#255	; 0xff
 800beea:	ed9f 7a05 	vldr	s14, [pc, #20]	; 800bf00 <forward_dense+0x32c>
 800beee:	eef0 2a48 	vmov.f32	s5, s16
 800bef2:	f1be 0f00 	cmp.w	lr, #0
 800bef6:	f47f af22 	bne.w	800bd3e <forward_dense+0x16a>
 800befa:	980a      	ldr	r0, [sp, #40]	; 0x28
 800befc:	4661      	mov	r1, ip
 800befe:	e77a      	b.n	800bdf6 <forward_dense+0x222>
 800bf00:	00000000 	.word	0x00000000
 800bf04:	4549      	cmp	r1, r9
 800bf06:	d2d5      	bcs.n	800beb4 <forward_dense+0x2e0>
 800bf08:	9807      	ldr	r0, [sp, #28]
 800bf0a:	9103      	str	r1, [sp, #12]
 800bf0c:	9904      	ldr	r1, [sp, #16]
 800bf0e:	f100 0c01 	add.w	ip, r0, #1
 800bf12:	3901      	subs	r1, #1
 800bf14:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 800bf18:	9109      	str	r1, [sp, #36]	; 0x24
 800bf1a:	2b00      	cmp	r3, #0
 800bf1c:	f000 80b2 	beq.w	800c084 <forward_dense+0x4b0>
 800bf20:	9907      	ldr	r1, [sp, #28]
 800bf22:	ecf3 2a01 	vldmia	r3!, {s5}
 800bf26:	ed1f 7a0a 	vldr	s14, [pc, #-40]	; 800bf00 <forward_dense+0x32c>
 800bf2a:	2900      	cmp	r1, #0
 800bf2c:	f000 80b2 	beq.w	800c094 <forward_dense+0x4c0>
 800bf30:	9902      	ldr	r1, [sp, #8]
 800bf32:	1d10      	adds	r0, r2, #4
 800bf34:	f810 6c04 	ldrb.w	r6, [r0, #-4]
 800bf38:	ed11 2a07 	vldr	s4, [r1, #-28]	; 0xffffffe4
 800bf3c:	f810 5c03 	ldrb.w	r5, [r0, #-3]
 800bf40:	ed51 3a08 	vldr	s7, [r1, #-32]	; 0xffffffe0
 800bf44:	ed11 4a06 	vldr	s8, [r1, #-24]	; 0xffffffe8
 800bf48:	ed51 4a05 	vldr	s9, [r1, #-20]	; 0xffffffec
 800bf4c:	ed11 5a04 	vldr	s10, [r1, #-16]
 800bf50:	ed51 5a03 	vldr	s11, [r1, #-12]
 800bf54:	ed11 6a02 	vldr	s12, [r1, #-8]
 800bf58:	ed51 6a01 	vldr	s13, [r1, #-4]
 800bf5c:	f006 070f 	and.w	r7, r6, #15
 800bf60:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 800bf64:	edd7 7a00 	vldr	s15, [r7]
 800bf68:	0936      	lsrs	r6, r6, #4
 800bf6a:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bf6e:	ed96 3a00 	vldr	s6, [r6]
 800bf72:	ee67 7a82 	vmul.f32	s15, s15, s4
 800bf76:	092e      	lsrs	r6, r5, #4
 800bf78:	eee3 7a23 	vfma.f32	s15, s6, s7
 800bf7c:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bf80:	f005 050f 	and.w	r5, r5, #15
 800bf84:	edd6 3a00 	vldr	s7, [r6]
 800bf88:	f810 6c02 	ldrb.w	r6, [r0, #-2]
 800bf8c:	eee3 7a84 	vfma.f32	s15, s7, s8
 800bf90:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bf94:	0937      	lsrs	r7, r6, #4
 800bf96:	ed95 4a00 	vldr	s8, [r5]
 800bf9a:	f810 5c01 	ldrb.w	r5, [r0, #-1]
 800bf9e:	eee4 7a24 	vfma.f32	s15, s8, s9
 800bfa2:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 800bfa6:	f006 060f 	and.w	r6, r6, #15
 800bfaa:	edd7 4a00 	vldr	s9, [r7]
 800bfae:	eee4 7a85 	vfma.f32	s15, s9, s10
 800bfb2:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bfb6:	3004      	adds	r0, #4
 800bfb8:	ed96 5a00 	vldr	s10, [r6]
 800bfbc:	092e      	lsrs	r6, r5, #4
 800bfbe:	eee5 7a25 	vfma.f32	s15, s10, s11
 800bfc2:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 800bfc6:	f005 050f 	and.w	r5, r5, #15
 800bfca:	edd6 5a00 	vldr	s11, [r6]
 800bfce:	eee5 7a86 	vfma.f32	s15, s11, s12
 800bfd2:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800bfd6:	4584      	cmp	ip, r0
 800bfd8:	ed95 6a00 	vldr	s12, [r5]
 800bfdc:	eee6 7a26 	vfma.f32	s15, s12, s13
 800bfe0:	f101 0120 	add.w	r1, r1, #32
 800bfe4:	ee37 7a27 	vadd.f32	s14, s14, s15
 800bfe8:	d1a4      	bne.n	800bf34 <forward_dense+0x360>
 800bfea:	f8dd e014 	ldr.w	lr, [sp, #20]
 800bfee:	f1ac 0804 	sub.w	r8, ip, #4
 800bff2:	9904      	ldr	r1, [sp, #16]
 800bff4:	458e      	cmp	lr, r1
 800bff6:	d22a      	bcs.n	800c04e <forward_dense+0x47a>
 800bff8:	9909      	ldr	r1, [sp, #36]	; 0x24
 800bffa:	eba1 070e 	sub.w	r7, r1, lr
 800bffe:	ea4f 0ad7 	mov.w	sl, r7, lsr #3
 800c002:	f10e 0008 	add.w	r0, lr, #8
 800c006:	f108 36ff 	add.w	r6, r8, #4294967295
 800c00a:	eb08 07d7 	add.w	r7, r8, r7, lsr #3
 800c00e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800c012:	ed50 5a01 	vldr	s11, [r0, #-4]
 800c016:	ed50 6a02 	vldr	s13, [r0, #-8]
 800c01a:	f001 050f 	and.w	r5, r1, #15
 800c01e:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800c022:	edd5 7a00 	vldr	s15, [r5]
 800c026:	0909      	lsrs	r1, r1, #4
 800c028:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800c02c:	ed91 6a00 	vldr	s12, [r1]
 800c030:	ee67 7aa5 	vmul.f32	s15, s15, s11
 800c034:	42b7      	cmp	r7, r6
 800c036:	eee6 7a26 	vfma.f32	s15, s12, s13
 800c03a:	f100 0008 	add.w	r0, r0, #8
 800c03e:	ee37 7a27 	vadd.f32	s14, s14, s15
 800c042:	d1e4      	bne.n	800c00e <forward_dense+0x43a>
 800c044:	f10a 0a01 	add.w	sl, sl, #1
 800c048:	44d0      	add	r8, sl
 800c04a:	eb0e 0eca 	add.w	lr, lr, sl, lsl #3
 800c04e:	9908      	ldr	r1, [sp, #32]
 800c050:	b321      	cbz	r1, 800c09c <forward_dense+0x4c8>
 800c052:	f898 1000 	ldrb.w	r1, [r8]
 800c056:	edde 7a00 	vldr	s15, [lr]
 800c05a:	0909      	lsrs	r1, r1, #4
 800c05c:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800c060:	edd1 6a00 	vldr	s13, [r1]
 800c064:	9903      	ldr	r1, [sp, #12]
 800c066:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800c06a:	445a      	add	r2, fp
 800c06c:	44dc      	add	ip, fp
 800c06e:	ee72 2a87 	vadd.f32	s5, s5, s14
 800c072:	ece1 2a01 	vstmia	r1!, {s5}
 800c076:	4589      	cmp	r9, r1
 800c078:	9103      	str	r1, [sp, #12]
 800c07a:	f67f af12 	bls.w	800bea2 <forward_dense+0x2ce>
 800c07e:	2b00      	cmp	r3, #0
 800c080:	f47f af4e 	bne.w	800bf20 <forward_dense+0x34c>
 800c084:	9907      	ldr	r1, [sp, #28]
 800c086:	ed1f 7a62 	vldr	s14, [pc, #-392]	; 800bf00 <forward_dense+0x32c>
 800c08a:	eef0 2a48 	vmov.f32	s5, s16
 800c08e:	2900      	cmp	r1, #0
 800c090:	f47f af4e 	bne.w	800bf30 <forward_dense+0x35c>
 800c094:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
 800c098:	4690      	mov	r8, r2
 800c09a:	e7aa      	b.n	800bff2 <forward_dense+0x41e>
 800c09c:	9903      	ldr	r1, [sp, #12]
 800c09e:	ee32 7a87 	vadd.f32	s14, s5, s14
 800c0a2:	445a      	add	r2, fp
 800c0a4:	eca1 7a01 	vstmia	r1!, {s14}
 800c0a8:	4549      	cmp	r1, r9
 800c0aa:	9103      	str	r1, [sp, #12]
 800c0ac:	44dc      	add	ip, fp
 800c0ae:	f4ff af34 	bcc.w	800bf1a <forward_dense+0x346>
 800c0b2:	e6f6      	b.n	800bea2 <forward_dense+0x2ce>
 800c0b4:	9912      	ldr	r1, [sp, #72]	; 0x48
 800c0b6:	9d06      	ldr	r5, [sp, #24]
 800c0b8:	9101      	str	r1, [sp, #4]
 800c0ba:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800c0bc:	9100      	str	r1, [sp, #0]
 800c0be:	4628      	mov	r0, r5
 800c0c0:	990a      	ldr	r1, [sp, #40]	; 0x28
 800c0c2:	f000 fcb7 	bl	800ca34 <forward_lite_dense_if32of32wf32>
 800c0c6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c0c8:	462b      	mov	r3, r5
 800c0ca:	4413      	add	r3, r2
 800c0cc:	9306      	str	r3, [sp, #24]
 800c0ce:	e6f1      	b.n	800beb4 <forward_dense+0x2e0>
 800c0d0:	f8d1 800c 	ldr.w	r8, [r1, #12]
 800c0d4:	f1b9 0f00 	cmp.w	r9, #0
 800c0d8:	d016      	beq.n	800c108 <forward_dense+0x534>
 800c0da:	e9d9 0100 	ldrd	r0, r1, [r9]
 800c0de:	f000 ff27 	bl	800cf30 <ai_array_get_byte_size>
 800c0e2:	f8d9 b00c 	ldr.w	fp, [r9, #12]
 800c0e6:	4602      	mov	r2, r0
 800c0e8:	4659      	mov	r1, fp
 800c0ea:	4640      	mov	r0, r8
 800c0ec:	f000 fdc6 	bl	800cc7c <st_int8_copy>
 800c0f0:	e5c7      	b.n	800bc82 <forward_dense+0xae>
 800c0f2:	2b04      	cmp	r3, #4
 800c0f4:	d00a      	beq.n	800c10c <forward_dense+0x538>
 800c0f6:	f04f 0900 	mov.w	r9, #0
 800c0fa:	e5bd      	b.n	800bc78 <forward_dense+0xa4>
 800c0fc:	930d      	str	r3, [sp, #52]	; 0x34
 800c0fe:	e595      	b.n	800bc2c <forward_dense+0x58>
 800c100:	2300      	movs	r3, #0
 800c102:	930b      	str	r3, [sp, #44]	; 0x2c
 800c104:	460b      	mov	r3, r1
 800c106:	e591      	b.n	800bc2c <forward_dense+0x58>
 800c108:	46c3      	mov	fp, r8
 800c10a:	e5ba      	b.n	800bc82 <forward_dense+0xae>
 800c10c:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 800c110:	e5b7      	b.n	800bc82 <forward_dense+0xae>
 800c112:	2300      	movs	r3, #0
 800c114:	685b      	ldr	r3, [r3, #4]
 800c116:	deff      	udf	#255	; 0xff
 800c118:	2300      	movs	r3, #0
 800c11a:	685b      	ldr	r3, [r3, #4]
 800c11c:	deff      	udf	#255	; 0xff
 800c11e:	bf00      	nop

0800c120 <forward_concat>:
 800c120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c124:	ed2d 8b06 	vpush	{d8-d10}
 800c128:	6982      	ldr	r2, [r0, #24]
 800c12a:	b085      	sub	sp, #20
 800c12c:	8813      	ldrh	r3, [r2, #0]
 800c12e:	9002      	str	r0, [sp, #8]
 800c130:	b90b      	cbnz	r3, 800c136 <forward_concat+0x16>
 800c132:	685b      	ldr	r3, [r3, #4]
 800c134:	deff      	udf	#255	; 0xff
 800c136:	2b01      	cmp	r3, #1
 800c138:	6856      	ldr	r6, [r2, #4]
 800c13a:	f000 8293 	beq.w	800c664 <forward_concat+0x544>
 800c13e:	6933      	ldr	r3, [r6, #16]
 800c140:	9301      	str	r3, [sp, #4]
 800c142:	b10b      	cbz	r3, 800c148 <forward_concat+0x28>
 800c144:	681b      	ldr	r3, [r3, #0]
 800c146:	9301      	str	r3, [sp, #4]
 800c148:	8834      	ldrh	r4, [r6, #0]
 800c14a:	2300      	movs	r3, #0
 800c14c:	4621      	mov	r1, r4
 800c14e:	4618      	mov	r0, r3
 800c150:	e00c      	b.n	800c16c <forward_concat+0x4c>
 800c152:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c156:	b172      	cbz	r2, 800c176 <forward_concat+0x56>
 800c158:	6992      	ldr	r2, [r2, #24]
 800c15a:	6812      	ldr	r2, [r2, #0]
 800c15c:	f3c2 4243 	ubfx	r2, r2, #17, #4
 800c160:	2a01      	cmp	r2, #1
 800c162:	bf0c      	ite	eq
 800c164:	2201      	moveq	r2, #1
 800c166:	2202      	movne	r2, #2
 800c168:	3301      	adds	r3, #1
 800c16a:	4310      	orrs	r0, r2
 800c16c:	429c      	cmp	r4, r3
 800c16e:	d002      	beq.n	800c176 <forward_concat+0x56>
 800c170:	6872      	ldr	r2, [r6, #4]
 800c172:	2a00      	cmp	r2, #0
 800c174:	d1ed      	bne.n	800c152 <forward_concat+0x32>
 800c176:	9b01      	ldr	r3, [sp, #4]
 800c178:	699a      	ldr	r2, [r3, #24]
 800c17a:	6813      	ldr	r3, [r2, #0]
 800c17c:	f8d2 b008 	ldr.w	fp, [r2, #8]
 800c180:	f3c3 4243 	ubfx	r2, r3, #17, #4
 800c184:	2a01      	cmp	r2, #1
 800c186:	d006      	beq.n	800c196 <forward_concat+0x76>
 800c188:	2801      	cmp	r0, #1
 800c18a:	d146      	bne.n	800c21a <forward_concat+0xfa>
 800c18c:	b005      	add	sp, #20
 800c18e:	ecbd 8b06 	vpop	{d8-d10}
 800c192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c196:	2801      	cmp	r0, #1
 800c198:	d134      	bne.n	800c204 <forward_concat+0xe4>
 800c19a:	f04f 0800 	mov.w	r8, #0
 800c19e:	4541      	cmp	r1, r8
 800c1a0:	d9f4      	bls.n	800c18c <forward_concat+0x6c>
 800c1a2:	6873      	ldr	r3, [r6, #4]
 800c1a4:	2b00      	cmp	r3, #0
 800c1a6:	d0f1      	beq.n	800c18c <forward_concat+0x6c>
 800c1a8:	f853 5028 	ldr.w	r5, [r3, r8, lsl #2]
 800c1ac:	2d00      	cmp	r5, #0
 800c1ae:	d0ed      	beq.n	800c18c <forward_concat+0x6c>
 800c1b0:	69ab      	ldr	r3, [r5, #24]
 800c1b2:	e9d3 0100 	ldrd	r0, r1, [r3]
 800c1b6:	f000 febb 	bl	800cf30 <ai_array_get_byte_size>
 800c1ba:	69ab      	ldr	r3, [r5, #24]
 800c1bc:	6969      	ldr	r1, [r5, #20]
 800c1be:	689c      	ldr	r4, [r3, #8]
 800c1c0:	9b02      	ldr	r3, [sp, #8]
 800c1c2:	68ea      	ldr	r2, [r5, #12]
 800c1c4:	69db      	ldr	r3, [r3, #28]
 800c1c6:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 800c1ca:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800c1ce:	fb02 f905 	mul.w	r9, r2, r5
 800c1d2:	9a01      	ldr	r2, [sp, #4]
 800c1d4:	68d1      	ldr	r1, [r2, #12]
 800c1d6:	1827      	adds	r7, r4, r0
 800c1d8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800c1dc:	42bc      	cmp	r4, r7
 800c1de:	fb03 f505 	mul.w	r5, r3, r5
 800c1e2:	bf38      	it	cc
 800c1e4:	46da      	movcc	sl, fp
 800c1e6:	d208      	bcs.n	800c1fa <forward_concat+0xda>
 800c1e8:	4651      	mov	r1, sl
 800c1ea:	4620      	mov	r0, r4
 800c1ec:	464a      	mov	r2, r9
 800c1ee:	444c      	add	r4, r9
 800c1f0:	f000 fd44 	bl	800cc7c <st_int8_copy>
 800c1f4:	42a7      	cmp	r7, r4
 800c1f6:	44aa      	add	sl, r5
 800c1f8:	d8f6      	bhi.n	800c1e8 <forward_concat+0xc8>
 800c1fa:	8831      	ldrh	r1, [r6, #0]
 800c1fc:	44cb      	add	fp, r9
 800c1fe:	f108 0801 	add.w	r8, r8, #1
 800c202:	e7cc      	b.n	800c19e <forward_concat+0x7e>
 800c204:	0782      	lsls	r2, r0, #30
 800c206:	d4c1      	bmi.n	800c18c <forward_concat+0x6c>
 800c208:	9a01      	ldr	r2, [sp, #4]
 800c20a:	f8d2 8000 	ldr.w	r8, [r2]
 800c20e:	f1b8 0f00 	cmp.w	r8, #0
 800c212:	d109      	bne.n	800c228 <forward_concat+0x108>
 800c214:	ed9f 8aba 	vldr	s16, [pc, #744]	; 800c500 <forward_concat+0x3e0>
 800c218:	e011      	b.n	800c23e <forward_concat+0x11e>
 800c21a:	9a01      	ldr	r2, [sp, #4]
 800c21c:	f8d2 8000 	ldr.w	r8, [r2]
 800c220:	f1b8 0f00 	cmp.w	r8, #0
 800c224:	f000 8216 	beq.w	800c654 <forward_concat+0x534>
 800c228:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800c22c:	2a00      	cmp	r2, #0
 800c22e:	d0f1      	beq.n	800c214 <forward_concat+0xf4>
 800c230:	f8b8 1002 	ldrh.w	r1, [r8, #2]
 800c234:	2900      	cmp	r1, #0
 800c236:	d0ed      	beq.n	800c214 <forward_concat+0xf4>
 800c238:	6812      	ldr	r2, [r2, #0]
 800c23a:	ed92 8a00 	vldr	s16, [r2]
 800c23e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800c242:	ee87 9a88 	vdiv.f32	s18, s15, s16
 800c246:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 800c24a:	9303      	str	r3, [sp, #12]
 800c24c:	4621      	mov	r1, r4
 800c24e:	4633      	mov	r3, r6
 800c250:	2700      	movs	r7, #0
 800c252:	4646      	mov	r6, r8
 800c254:	4698      	mov	r8, r3
 800c256:	ed9f aaa8 	vldr	s20, [pc, #672]	; 800c4f8 <forward_concat+0x3d8>
 800c25a:	eddf 8aa9 	vldr	s17, [pc, #676]	; 800c500 <forward_concat+0x3e0>
 800c25e:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
 800c262:	42b9      	cmp	r1, r7
 800c264:	d992      	bls.n	800c18c <forward_concat+0x6c>
 800c266:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800c26a:	2b00      	cmp	r3, #0
 800c26c:	d08e      	beq.n	800c18c <forward_concat+0x6c>
 800c26e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 800c272:	2b00      	cmp	r3, #0
 800c274:	d08a      	beq.n	800c18c <forward_concat+0x6c>
 800c276:	9a02      	ldr	r2, [sp, #8]
 800c278:	68d9      	ldr	r1, [r3, #12]
 800c27a:	69d4      	ldr	r4, [r2, #28]
 800c27c:	9a01      	ldr	r2, [sp, #4]
 800c27e:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 800c282:	68d2      	ldr	r2, [r2, #12]
 800c284:	6958      	ldr	r0, [r3, #20]
 800c286:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 800c28a:	699a      	ldr	r2, [r3, #24]
 800c28c:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 800c290:	f8d2 9000 	ldr.w	r9, [r2]
 800c294:	9300      	str	r3, [sp, #0]
 800c296:	fb01 fa00 	mul.w	sl, r1, r0
 800c29a:	fb00 f505 	mul.w	r5, r0, r5
 800c29e:	e9d2 1401 	ldrd	r1, r4, [r2, #4]
 800c2a2:	4648      	mov	r0, r9
 800c2a4:	f000 fe44 	bl	800cf30 <ai_array_get_byte_size>
 800c2a8:	f3c9 4243 	ubfx	r2, r9, #17, #4
 800c2ac:	2a01      	cmp	r2, #1
 800c2ae:	9b00      	ldr	r3, [sp, #0]
 800c2b0:	eb04 0900 	add.w	r9, r4, r0
 800c2b4:	d079      	beq.n	800c3aa <forward_concat+0x28a>
 800c2b6:	6818      	ldr	r0, [r3, #0]
 800c2b8:	2800      	cmp	r0, #0
 800c2ba:	f000 8118 	beq.w	800c4ee <forward_concat+0x3ce>
 800c2be:	6841      	ldr	r1, [r0, #4]
 800c2c0:	2900      	cmp	r1, #0
 800c2c2:	f000 8166 	beq.w	800c592 <forward_concat+0x472>
 800c2c6:	8842      	ldrh	r2, [r0, #2]
 800c2c8:	2a00      	cmp	r2, #0
 800c2ca:	f000 815f 	beq.w	800c58c <forward_concat+0x46c>
 800c2ce:	680b      	ldr	r3, [r1, #0]
 800c2d0:	edd3 6a00 	vldr	s13, [r3]
 800c2d4:	684b      	ldr	r3, [r1, #4]
 800c2d6:	f993 2000 	ldrsb.w	r2, [r3]
 800c2da:	2e00      	cmp	r6, #0
 800c2dc:	f000 8105 	beq.w	800c4ea <forward_concat+0x3ca>
 800c2e0:	6871      	ldr	r1, [r6, #4]
 800c2e2:	2900      	cmp	r1, #0
 800c2e4:	f000 8159 	beq.w	800c59a <forward_concat+0x47a>
 800c2e8:	8873      	ldrh	r3, [r6, #2]
 800c2ea:	b113      	cbz	r3, 800c2f2 <forward_concat+0x1d2>
 800c2ec:	684b      	ldr	r3, [r1, #4]
 800c2ee:	f993 3000 	ldrsb.w	r3, [r3]
 800c2f2:	eeb4 8a66 	vcmp.f32	s16, s13
 800c2f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c2fa:	d102      	bne.n	800c302 <forward_concat+0x1e2>
 800c2fc:	429a      	cmp	r2, r3
 800c2fe:	f000 818b 	beq.w	800c618 <forward_concat+0x4f8>
 800c302:	9b03      	ldr	r3, [sp, #12]
 800c304:	2b00      	cmp	r3, #0
 800c306:	f040 809a 	bne.w	800c43e <forward_concat+0x31e>
 800c30a:	2800      	cmp	r0, #0
 800c30c:	f000 8150 	beq.w	800c5b0 <forward_concat+0x490>
 800c310:	6843      	ldr	r3, [r0, #4]
 800c312:	2b00      	cmp	r3, #0
 800c314:	f000 8143 	beq.w	800c59e <forward_concat+0x47e>
 800c318:	8842      	ldrh	r2, [r0, #2]
 800c31a:	2a00      	cmp	r2, #0
 800c31c:	f000 813f 	beq.w	800c59e <forward_concat+0x47e>
 800c320:	685b      	ldr	r3, [r3, #4]
 800c322:	7819      	ldrb	r1, [r3, #0]
 800c324:	2e00      	cmp	r6, #0
 800c326:	f000 813e 	beq.w	800c5a6 <forward_concat+0x486>
 800c32a:	6872      	ldr	r2, [r6, #4]
 800c32c:	2a00      	cmp	r2, #0
 800c32e:	f000 816d 	beq.w	800c60c <forward_concat+0x4ec>
 800c332:	8873      	ldrh	r3, [r6, #2]
 800c334:	b10b      	cbz	r3, 800c33a <forward_concat+0x21a>
 800c336:	6853      	ldr	r3, [r2, #4]
 800c338:	781b      	ldrb	r3, [r3, #0]
 800c33a:	eeb4 8a66 	vcmp.f32	s16, s13
 800c33e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c342:	d102      	bne.n	800c34a <forward_concat+0x22a>
 800c344:	4299      	cmp	r1, r3
 800c346:	f000 814c 	beq.w	800c5e2 <forward_concat+0x4c2>
 800c34a:	454c      	cmp	r4, r9
 800c34c:	ee66 6a89 	vmul.f32	s13, s13, s18
 800c350:	f080 80c7 	bcs.w	800c4e2 <forward_concat+0x3c2>
 800c354:	2d00      	cmp	r5, #0
 800c356:	f340 80c4 	ble.w	800c4e2 <forward_concat+0x3c2>
 800c35a:	ee07 3a90 	vmov	s15, r3
 800c35e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 800c362:	1960      	adds	r0, r4, r5
 800c364:	ee36 6a29 	vadd.f32	s12, s12, s19
 800c368:	4602      	mov	r2, r0
 800c36a:	46dc      	mov	ip, fp
 800c36c:	46e6      	mov	lr, ip
 800c36e:	f814 3b01 	ldrb.w	r3, [r4], #1
 800c372:	1a5b      	subs	r3, r3, r1
 800c374:	ee07 3a90 	vmov	s15, r3
 800c378:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c37c:	eeb0 7a46 	vmov.f32	s14, s12
 800c380:	eea7 7aa6 	vfma.f32	s14, s15, s13
 800c384:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 800c388:	ee17 3a90 	vmov	r3, s15
 800c38c:	f383 0308 	usat	r3, #8, r3
 800c390:	4294      	cmp	r4, r2
 800c392:	f80e 3b01 	strb.w	r3, [lr], #1
 800c396:	d1ea      	bne.n	800c36e <forward_concat+0x24e>
 800c398:	4548      	cmp	r0, r9
 800c39a:	eb04 0205 	add.w	r2, r4, r5
 800c39e:	44d4      	add	ip, sl
 800c3a0:	4604      	mov	r4, r0
 800c3a2:	f080 809e 	bcs.w	800c4e2 <forward_concat+0x3c2>
 800c3a6:	4428      	add	r0, r5
 800c3a8:	e7e0      	b.n	800c36c <forward_concat+0x24c>
 800c3aa:	2d00      	cmp	r5, #0
 800c3ac:	9b03      	ldr	r3, [sp, #12]
 800c3ae:	4629      	mov	r1, r5
 800c3b0:	bfb8      	it	lt
 800c3b2:	1ce9      	addlt	r1, r5, #3
 800c3b4:	1089      	asrs	r1, r1, #2
 800c3b6:	2b00      	cmp	r3, #0
 800c3b8:	f040 80a4 	bne.w	800c504 <forward_concat+0x3e4>
 800c3bc:	2e00      	cmp	r6, #0
 800c3be:	f000 80f4 	beq.w	800c5aa <forward_concat+0x48a>
 800c3c2:	6873      	ldr	r3, [r6, #4]
 800c3c4:	2b00      	cmp	r3, #0
 800c3c6:	f000 80f0 	beq.w	800c5aa <forward_concat+0x48a>
 800c3ca:	8872      	ldrh	r2, [r6, #2]
 800c3cc:	2a00      	cmp	r2, #0
 800c3ce:	f000 80ec 	beq.w	800c5aa <forward_concat+0x48a>
 800c3d2:	685b      	ldr	r3, [r3, #4]
 800c3d4:	781b      	ldrb	r3, [r3, #0]
 800c3d6:	ee06 3a90 	vmov	s13, r3
 800c3da:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c3de:	ee76 6aa9 	vadd.f32	s13, s13, s19
 800c3e2:	454c      	cmp	r4, r9
 800c3e4:	d226      	bcs.n	800c434 <forward_concat+0x314>
 800c3e6:	2d03      	cmp	r5, #3
 800c3e8:	ebaa 0a01 	sub.w	sl, sl, r1
 800c3ec:	bfc8      	it	gt
 800c3ee:	46de      	movgt	lr, fp
 800c3f0:	dd20      	ble.n	800c434 <forward_concat+0x314>
 800c3f2:	46f4      	mov	ip, lr
 800c3f4:	4620      	mov	r0, r4
 800c3f6:	2200      	movs	r2, #0
 800c3f8:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c3fc:	ee07 3a10 	vmov	s14, r3
 800c400:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c404:	eef0 7a66 	vmov.f32	s15, s13
 800c408:	eee7 7a09 	vfma.f32	s15, s14, s18
 800c40c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c410:	ee17 3a90 	vmov	r3, s15
 800c414:	f383 0308 	usat	r3, #8, r3
 800c418:	3201      	adds	r2, #1
 800c41a:	4291      	cmp	r1, r2
 800c41c:	f80c 3b01 	strb.w	r3, [ip], #1
 800c420:	dcea      	bgt.n	800c3f8 <forward_concat+0x2d8>
 800c422:	2d03      	cmp	r5, #3
 800c424:	bfcc      	ite	gt
 800c426:	460b      	movgt	r3, r1
 800c428:	2301      	movle	r3, #1
 800c42a:	441c      	add	r4, r3
 800c42c:	45a1      	cmp	r9, r4
 800c42e:	4453      	add	r3, sl
 800c430:	449e      	add	lr, r3
 800c432:	d8de      	bhi.n	800c3f2 <forward_concat+0x2d2>
 800c434:	448b      	add	fp, r1
 800c436:	f8b8 1000 	ldrh.w	r1, [r8]
 800c43a:	3701      	adds	r7, #1
 800c43c:	e711      	b.n	800c262 <forward_concat+0x142>
 800c43e:	b140      	cbz	r0, 800c452 <forward_concat+0x332>
 800c440:	6843      	ldr	r3, [r0, #4]
 800c442:	2b00      	cmp	r3, #0
 800c444:	f000 80e4 	beq.w	800c610 <forward_concat+0x4f0>
 800c448:	8840      	ldrh	r0, [r0, #2]
 800c44a:	b110      	cbz	r0, 800c452 <forward_concat+0x332>
 800c44c:	685b      	ldr	r3, [r3, #4]
 800c44e:	f993 0000 	ldrsb.w	r0, [r3]
 800c452:	2e00      	cmp	r6, #0
 800c454:	f000 80ae 	beq.w	800c5b4 <forward_concat+0x494>
 800c458:	6872      	ldr	r2, [r6, #4]
 800c45a:	2a00      	cmp	r2, #0
 800c45c:	f000 80da 	beq.w	800c614 <forward_concat+0x4f4>
 800c460:	8873      	ldrh	r3, [r6, #2]
 800c462:	b113      	cbz	r3, 800c46a <forward_concat+0x34a>
 800c464:	6853      	ldr	r3, [r2, #4]
 800c466:	f993 3000 	ldrsb.w	r3, [r3]
 800c46a:	eeb4 8a66 	vcmp.f32	s16, s13
 800c46e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c472:	d102      	bne.n	800c47a <forward_concat+0x35a>
 800c474:	4298      	cmp	r0, r3
 800c476:	f000 809f 	beq.w	800c5b8 <forward_concat+0x498>
 800c47a:	454c      	cmp	r4, r9
 800c47c:	ee66 6a89 	vmul.f32	s13, s13, s18
 800c480:	d22f      	bcs.n	800c4e2 <forward_concat+0x3c2>
 800c482:	2d00      	cmp	r5, #0
 800c484:	dd2d      	ble.n	800c4e2 <forward_concat+0x3c2>
 800c486:	ee07 3a90 	vmov	s15, r3
 800c48a:	eb0b 0e05 	add.w	lr, fp, r5
 800c48e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 800c492:	46f4      	mov	ip, lr
 800c494:	465a      	mov	r2, fp
 800c496:	4621      	mov	r1, r4
 800c498:	f911 3b01 	ldrsb.w	r3, [r1], #1
 800c49c:	1a1b      	subs	r3, r3, r0
 800c49e:	ee07 3a90 	vmov	s15, r3
 800c4a2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800c4a6:	eef0 7a46 	vmov.f32	s15, s12
 800c4aa:	eee7 7a26 	vfma.f32	s15, s14, s13
 800c4ae:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c4b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c4b6:	bf4c      	ite	mi
 800c4b8:	ee77 7aca 	vsubmi.f32	s15, s15, s20
 800c4bc:	ee77 7aa9 	vaddpl.f32	s15, s15, s19
 800c4c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c4c4:	ee17 3a90 	vmov	r3, s15
 800c4c8:	f303 0307 	ssat	r3, #8, r3
 800c4cc:	f802 3b01 	strb.w	r3, [r2], #1
 800c4d0:	4562      	cmp	r2, ip
 800c4d2:	d1e1      	bne.n	800c498 <forward_concat+0x378>
 800c4d4:	442c      	add	r4, r5
 800c4d6:	454c      	cmp	r4, r9
 800c4d8:	44d3      	add	fp, sl
 800c4da:	44d4      	add	ip, sl
 800c4dc:	d3da      	bcc.n	800c494 <forward_concat+0x374>
 800c4de:	46f3      	mov	fp, lr
 800c4e0:	e7a9      	b.n	800c436 <forward_concat+0x316>
 800c4e2:	eb0b 0e05 	add.w	lr, fp, r5
 800c4e6:	46f3      	mov	fp, lr
 800c4e8:	e7a5      	b.n	800c436 <forward_concat+0x316>
 800c4ea:	4633      	mov	r3, r6
 800c4ec:	e701      	b.n	800c2f2 <forward_concat+0x1d2>
 800c4ee:	eef0 6a68 	vmov.f32	s13, s17
 800c4f2:	4602      	mov	r2, r0
 800c4f4:	e6f1      	b.n	800c2da <forward_concat+0x1ba>
 800c4f6:	bf00      	nop
 800c4f8:	3efffffc 	.word	0x3efffffc
 800c4fc:	7f800000 	.word	0x7f800000
 800c500:	00000000 	.word	0x00000000
 800c504:	2e00      	cmp	r6, #0
 800c506:	f000 809c 	beq.w	800c642 <forward_concat+0x522>
 800c50a:	6873      	ldr	r3, [r6, #4]
 800c50c:	2b00      	cmp	r3, #0
 800c50e:	f000 809e 	beq.w	800c64e <forward_concat+0x52e>
 800c512:	8872      	ldrh	r2, [r6, #2]
 800c514:	2a00      	cmp	r2, #0
 800c516:	f000 8097 	beq.w	800c648 <forward_concat+0x528>
 800c51a:	685b      	ldr	r3, [r3, #4]
 800c51c:	f993 3000 	ldrsb.w	r3, [r3]
 800c520:	ee06 3a90 	vmov	s13, r3
 800c524:	454c      	cmp	r4, r9
 800c526:	d285      	bcs.n	800c434 <forward_concat+0x314>
 800c528:	2d03      	cmp	r5, #3
 800c52a:	ebaa 0a01 	sub.w	sl, sl, r1
 800c52e:	dd81      	ble.n	800c434 <forward_concat+0x314>
 800c530:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800c534:	46de      	mov	lr, fp
 800c536:	46f4      	mov	ip, lr
 800c538:	4620      	mov	r0, r4
 800c53a:	2200      	movs	r2, #0
 800c53c:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c540:	ee07 3a10 	vmov	s14, r3
 800c544:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800c548:	eef0 7a66 	vmov.f32	s15, s13
 800c54c:	eee7 7a09 	vfma.f32	s15, s14, s18
 800c550:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c554:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c558:	bf4c      	ite	mi
 800c55a:	ee77 7aca 	vsubmi.f32	s15, s15, s20
 800c55e:	ee77 7aa9 	vaddpl.f32	s15, s15, s19
 800c562:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c566:	ee17 3a90 	vmov	r3, s15
 800c56a:	f303 0307 	ssat	r3, #8, r3
 800c56e:	3201      	adds	r2, #1
 800c570:	4291      	cmp	r1, r2
 800c572:	f80c 3b01 	strb.w	r3, [ip], #1
 800c576:	dce1      	bgt.n	800c53c <forward_concat+0x41c>
 800c578:	2d03      	cmp	r5, #3
 800c57a:	bfcc      	ite	gt
 800c57c:	460b      	movgt	r3, r1
 800c57e:	2301      	movle	r3, #1
 800c580:	441c      	add	r4, r3
 800c582:	45a1      	cmp	r9, r4
 800c584:	4453      	add	r3, sl
 800c586:	449e      	add	lr, r3
 800c588:	d8d5      	bhi.n	800c536 <forward_concat+0x416>
 800c58a:	e753      	b.n	800c434 <forward_concat+0x314>
 800c58c:	eef0 6a68 	vmov.f32	s13, s17
 800c590:	e6a3      	b.n	800c2da <forward_concat+0x1ba>
 800c592:	eef0 6a68 	vmov.f32	s13, s17
 800c596:	460a      	mov	r2, r1
 800c598:	e69f      	b.n	800c2da <forward_concat+0x1ba>
 800c59a:	460b      	mov	r3, r1
 800c59c:	e6a9      	b.n	800c2f2 <forward_concat+0x1d2>
 800c59e:	9903      	ldr	r1, [sp, #12]
 800c5a0:	2e00      	cmp	r6, #0
 800c5a2:	f47f aec2 	bne.w	800c32a <forward_concat+0x20a>
 800c5a6:	4633      	mov	r3, r6
 800c5a8:	e6c7      	b.n	800c33a <forward_concat+0x21a>
 800c5aa:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 800c5ae:	e718      	b.n	800c3e2 <forward_concat+0x2c2>
 800c5b0:	4619      	mov	r1, r3
 800c5b2:	e6b7      	b.n	800c324 <forward_concat+0x204>
 800c5b4:	4633      	mov	r3, r6
 800c5b6:	e758      	b.n	800c46a <forward_concat+0x34a>
 800c5b8:	454c      	cmp	r4, r9
 800c5ba:	d292      	bcs.n	800c4e2 <forward_concat+0x3c2>
 800c5bc:	9600      	str	r6, [sp, #0]
 800c5be:	462e      	mov	r6, r5
 800c5c0:	464d      	mov	r5, r9
 800c5c2:	46d9      	mov	r9, fp
 800c5c4:	4649      	mov	r1, r9
 800c5c6:	4620      	mov	r0, r4
 800c5c8:	4632      	mov	r2, r6
 800c5ca:	4434      	add	r4, r6
 800c5cc:	f000 fb56 	bl	800cc7c <st_int8_copy>
 800c5d0:	42a5      	cmp	r5, r4
 800c5d2:	44d1      	add	r9, sl
 800c5d4:	d8f6      	bhi.n	800c5c4 <forward_concat+0x4a4>
 800c5d6:	4635      	mov	r5, r6
 800c5d8:	9e00      	ldr	r6, [sp, #0]
 800c5da:	eb0b 0e05 	add.w	lr, fp, r5
 800c5de:	46f3      	mov	fp, lr
 800c5e0:	e729      	b.n	800c436 <forward_concat+0x316>
 800c5e2:	454c      	cmp	r4, r9
 800c5e4:	f4bf af7d 	bcs.w	800c4e2 <forward_concat+0x3c2>
 800c5e8:	9600      	str	r6, [sp, #0]
 800c5ea:	462e      	mov	r6, r5
 800c5ec:	464d      	mov	r5, r9
 800c5ee:	46d9      	mov	r9, fp
 800c5f0:	4649      	mov	r1, r9
 800c5f2:	4620      	mov	r0, r4
 800c5f4:	4632      	mov	r2, r6
 800c5f6:	4434      	add	r4, r6
 800c5f8:	f000 fb40 	bl	800cc7c <st_int8_copy>
 800c5fc:	42a5      	cmp	r5, r4
 800c5fe:	44d1      	add	r9, sl
 800c600:	d8f6      	bhi.n	800c5f0 <forward_concat+0x4d0>
 800c602:	4635      	mov	r5, r6
 800c604:	eb0b 0e05 	add.w	lr, fp, r5
 800c608:	9e00      	ldr	r6, [sp, #0]
 800c60a:	e7e8      	b.n	800c5de <forward_concat+0x4be>
 800c60c:	4613      	mov	r3, r2
 800c60e:	e694      	b.n	800c33a <forward_concat+0x21a>
 800c610:	4618      	mov	r0, r3
 800c612:	e71e      	b.n	800c452 <forward_concat+0x332>
 800c614:	4613      	mov	r3, r2
 800c616:	e728      	b.n	800c46a <forward_concat+0x34a>
 800c618:	454c      	cmp	r4, r9
 800c61a:	f4bf af62 	bcs.w	800c4e2 <forward_concat+0x3c2>
 800c61e:	9600      	str	r6, [sp, #0]
 800c620:	462e      	mov	r6, r5
 800c622:	464d      	mov	r5, r9
 800c624:	46d9      	mov	r9, fp
 800c626:	4649      	mov	r1, r9
 800c628:	4620      	mov	r0, r4
 800c62a:	4632      	mov	r2, r6
 800c62c:	4434      	add	r4, r6
 800c62e:	f000 fb25 	bl	800cc7c <st_int8_copy>
 800c632:	42a5      	cmp	r5, r4
 800c634:	44d1      	add	r9, sl
 800c636:	d8f6      	bhi.n	800c626 <forward_concat+0x506>
 800c638:	4635      	mov	r5, r6
 800c63a:	eb0b 0e05 	add.w	lr, fp, r5
 800c63e:	9e00      	ldr	r6, [sp, #0]
 800c640:	e7cd      	b.n	800c5de <forward_concat+0x4be>
 800c642:	ee06 6a90 	vmov	s13, r6
 800c646:	e76d      	b.n	800c524 <forward_concat+0x404>
 800c648:	ee06 2a90 	vmov	s13, r2
 800c64c:	e76a      	b.n	800c524 <forward_concat+0x404>
 800c64e:	ee06 3a90 	vmov	s13, r3
 800c652:	e767      	b.n	800c524 <forward_concat+0x404>
 800c654:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 800c658:	ed1f 9a58 	vldr	s18, [pc, #-352]	; 800c4fc <forward_concat+0x3dc>
 800c65c:	ed1f 8a58 	vldr	s16, [pc, #-352]	; 800c500 <forward_concat+0x3e0>
 800c660:	9303      	str	r3, [sp, #12]
 800c662:	e5f4      	b.n	800c24e <forward_concat+0x12e>
 800c664:	2300      	movs	r3, #0
 800c666:	e564      	b.n	800c132 <forward_concat+0x12>

0800c668 <forward_eltwise>:
 800c668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c66c:	6982      	ldr	r2, [r0, #24]
 800c66e:	b09d      	sub	sp, #116	; 0x74
 800c670:	8811      	ldrh	r1, [r2, #0]
 800c672:	9003      	str	r0, [sp, #12]
 800c674:	2900      	cmp	r1, #0
 800c676:	f000 80c7 	beq.w	800c808 <forward_eltwise+0x1a0>
 800c67a:	6853      	ldr	r3, [r2, #4]
 800c67c:	2b00      	cmp	r3, #0
 800c67e:	f000 810f 	beq.w	800c8a0 <forward_eltwise+0x238>
 800c682:	881d      	ldrh	r5, [r3, #0]
 800c684:	f8d3 8004 	ldr.w	r8, [r3, #4]
 800c688:	f1b8 0f00 	cmp.w	r8, #0
 800c68c:	d001      	beq.n	800c692 <forward_eltwise+0x2a>
 800c68e:	f8d8 8000 	ldr.w	r8, [r8]
 800c692:	2901      	cmp	r1, #1
 800c694:	f000 8108 	beq.w	800c8a8 <forward_eltwise+0x240>
 800c698:	691b      	ldr	r3, [r3, #16]
 800c69a:	9300      	str	r3, [sp, #0]
 800c69c:	b10b      	cbz	r3, 800c6a2 <forward_eltwise+0x3a>
 800c69e:	681b      	ldr	r3, [r3, #0]
 800c6a0:	9300      	str	r3, [sp, #0]
 800c6a2:	2300      	movs	r3, #0
 800c6a4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 800c6a8:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
 800c6ac:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 800c6b0:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
 800c6b4:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 800c6b8:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
 800c6bc:	e9cd 3319 	strd	r3, r3, [sp, #100]	; 0x64
 800c6c0:	931b      	str	r3, [sp, #108]	; 0x6c
 800c6c2:	f240 5302 	movw	r3, #1282	; 0x502
 800c6c6:	9307      	str	r3, [sp, #28]
 800c6c8:	9309      	str	r3, [sp, #36]	; 0x24
 800c6ca:	f240 5301 	movw	r3, #1281	; 0x501
 800c6ce:	930b      	str	r3, [sp, #44]	; 0x2c
 800c6d0:	9b03      	ldr	r3, [sp, #12]
 800c6d2:	e9d3 7307 	ldrd	r7, r3, [r3, #28]
 800c6d6:	ac0d      	add	r4, sp, #52	; 0x34
 800c6d8:	a812      	add	r0, sp, #72	; 0x48
 800c6da:	a917      	add	r1, sp, #92	; 0x5c
 800c6dc:	2d01      	cmp	r5, #1
 800c6de:	9408      	str	r4, [sp, #32]
 800c6e0:	900a      	str	r0, [sp, #40]	; 0x28
 800c6e2:	910c      	str	r1, [sp, #48]	; 0x30
 800c6e4:	9304      	str	r3, [sp, #16]
 800c6e6:	f240 80d8 	bls.w	800c89a <forward_eltwise+0x232>
 800c6ea:	00ab      	lsls	r3, r5, #2
 800c6ec:	9305      	str	r3, [sp, #20]
 800c6ee:	2304      	movs	r3, #4
 800c6f0:	9301      	str	r3, [sp, #4]
 800c6f2:	8813      	ldrh	r3, [r2, #0]
 800c6f4:	2b00      	cmp	r3, #0
 800c6f6:	f000 80da 	beq.w	800c8ae <forward_eltwise+0x246>
 800c6fa:	6853      	ldr	r3, [r2, #4]
 800c6fc:	685b      	ldr	r3, [r3, #4]
 800c6fe:	2b00      	cmp	r3, #0
 800c700:	f000 80d0 	beq.w	800c8a4 <forward_eltwise+0x23c>
 800c704:	9a01      	ldr	r2, [sp, #4]
 800c706:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800c70a:	f853 a002 	ldr.w	sl, [r3, r2]
 800c70e:	f8da 3008 	ldr.w	r3, [sl, #8]
 800c712:	4043      	eors	r3, r0
 800c714:	f033 03ff 	bics.w	r3, r3, #255	; 0xff
 800c718:	f108 0108 	add.w	r1, r8, #8
 800c71c:	f10a 0908 	add.w	r9, sl, #8
 800c720:	d10f      	bne.n	800c742 <forward_eltwise+0xda>
 800c722:	f3c0 2017 	ubfx	r0, r0, #8, #24
 800c726:	2800      	cmp	r0, #0
 800c728:	f000 8095 	beq.w	800c856 <forward_eltwise+0x1ee>
 800c72c:	3801      	subs	r0, #1
 800c72e:	f8d8 200c 	ldr.w	r2, [r8, #12]
 800c732:	f8da 300c 	ldr.w	r3, [sl, #12]
 800c736:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 800c73a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800c73e:	429a      	cmp	r2, r3
 800c740:	d0f1      	beq.n	800c726 <forward_eltwise+0xbe>
 800c742:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800c746:	9102      	str	r1, [sp, #8]
 800c748:	689d      	ldr	r5, [r3, #8]
 800c74a:	f8da 3018 	ldr.w	r3, [sl, #24]
 800c74e:	689c      	ldr	r4, [r3, #8]
 800c750:	9b00      	ldr	r3, [sp, #0]
 800c752:	699b      	ldr	r3, [r3, #24]
 800c754:	464a      	mov	r2, r9
 800c756:	a80b      	add	r0, sp, #44	; 0x2c
 800c758:	689e      	ldr	r6, [r3, #8]
 800c75a:	f000 fc41 	bl	800cfe0 <core_get_broadcasted_shape>
 800c75e:	f8da 2014 	ldr.w	r2, [sl, #20]
 800c762:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800c766:	f8d2 a004 	ldr.w	sl, [r2, #4]
 800c76a:	9a00      	ldr	r2, [sp, #0]
 800c76c:	685b      	ldr	r3, [r3, #4]
 800c76e:	6952      	ldr	r2, [r2, #20]
 800c770:	9902      	ldr	r1, [sp, #8]
 800c772:	f8d2 8004 	ldr.w	r8, [r2, #4]
 800c776:	a807      	add	r0, sp, #28
 800c778:	aa0b      	add	r2, sp, #44	; 0x2c
 800c77a:	f000 fc5d 	bl	800d038 <core_compute_offsets>
 800c77e:	4653      	mov	r3, sl
 800c780:	aa0b      	add	r2, sp, #44	; 0x2c
 800c782:	4649      	mov	r1, r9
 800c784:	a809      	add	r0, sp, #36	; 0x24
 800c786:	f000 fc57 	bl	800d038 <core_compute_offsets>
 800c78a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c78c:	68d3      	ldr	r3, [r2, #12]
 800c78e:	2b00      	cmp	r3, #0
 800c790:	d056      	beq.n	800c840 <forward_eltwise+0x1d8>
 800c792:	2300      	movs	r3, #0
 800c794:	6890      	ldr	r0, [r2, #8]
 800c796:	9302      	str	r3, [sp, #8]
 800c798:	2800      	cmp	r0, #0
 800c79a:	d051      	beq.n	800c840 <forward_eltwise+0x1d8>
 800c79c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800c79e:	f04f 0b00 	mov.w	fp, #0
 800c7a2:	f3c1 2117 	ubfx	r1, r1, #8, #24
 800c7a6:	f04f 0a00 	mov.w	sl, #0
 800c7aa:	2904      	cmp	r1, #4
 800c7ac:	bf8c      	ite	hi
 800c7ae:	6913      	ldrhi	r3, [r2, #16]
 800c7b0:	2301      	movls	r3, #1
 800c7b2:	459a      	cmp	sl, r3
 800c7b4:	d22a      	bcs.n	800c80c <forward_eltwise+0x1a4>
 800c7b6:	6850      	ldr	r0, [r2, #4]
 800c7b8:	f04f 0900 	mov.w	r9, #0
 800c7bc:	b198      	cbz	r0, 800c7e6 <forward_eltwise+0x17e>
 800c7be:	4622      	mov	r2, r4
 800c7c0:	4629      	mov	r1, r5
 800c7c2:	4630      	mov	r0, r6
 800c7c4:	47b8      	blx	r7
 800c7c6:	9b08      	ldr	r3, [sp, #32]
 800c7c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c7ca:	685b      	ldr	r3, [r3, #4]
 800c7cc:	441d      	add	r5, r3
 800c7ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c7d0:	685b      	ldr	r3, [r3, #4]
 800c7d2:	441c      	add	r4, r3
 800c7d4:	6853      	ldr	r3, [r2, #4]
 800c7d6:	f109 0901 	add.w	r9, r9, #1
 800c7da:	454b      	cmp	r3, r9
 800c7dc:	4446      	add	r6, r8
 800c7de:	d8ee      	bhi.n	800c7be <forward_eltwise+0x156>
 800c7e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c7e2:	f3c3 2117 	ubfx	r1, r3, #8, #24
 800c7e6:	9807      	ldr	r0, [sp, #28]
 800c7e8:	f5b0 6fa0 	cmp.w	r0, #1280	; 0x500
 800c7ec:	d302      	bcc.n	800c7f4 <forward_eltwise+0x18c>
 800c7ee:	9808      	ldr	r0, [sp, #32]
 800c7f0:	6903      	ldr	r3, [r0, #16]
 800c7f2:	441d      	add	r5, r3
 800c7f4:	9809      	ldr	r0, [sp, #36]	; 0x24
 800c7f6:	f5b0 6fa0 	cmp.w	r0, #1280	; 0x500
 800c7fa:	d302      	bcc.n	800c802 <forward_eltwise+0x19a>
 800c7fc:	980a      	ldr	r0, [sp, #40]	; 0x28
 800c7fe:	6903      	ldr	r3, [r0, #16]
 800c800:	441c      	add	r4, r3
 800c802:	f10a 0a01 	add.w	sl, sl, #1
 800c806:	e7d0      	b.n	800c7aa <forward_eltwise+0x142>
 800c808:	684b      	ldr	r3, [r1, #4]
 800c80a:	deff      	udf	#255	; 0xff
 800c80c:	9b08      	ldr	r3, [sp, #32]
 800c80e:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 800c812:	6898      	ldr	r0, [r3, #8]
 800c814:	4405      	add	r5, r0
 800c816:	f8dc 0008 	ldr.w	r0, [ip, #8]
 800c81a:	4404      	add	r4, r0
 800c81c:	6890      	ldr	r0, [r2, #8]
 800c81e:	f10b 0b01 	add.w	fp, fp, #1
 800c822:	4558      	cmp	r0, fp
 800c824:	d8bf      	bhi.n	800c7a6 <forward_eltwise+0x13e>
 800c826:	68d9      	ldr	r1, [r3, #12]
 800c828:	469e      	mov	lr, r3
 800c82a:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800c82e:	441c      	add	r4, r3
 800c830:	9b02      	ldr	r3, [sp, #8]
 800c832:	3301      	adds	r3, #1
 800c834:	440d      	add	r5, r1
 800c836:	9302      	str	r3, [sp, #8]
 800c838:	4619      	mov	r1, r3
 800c83a:	68d3      	ldr	r3, [r2, #12]
 800c83c:	428b      	cmp	r3, r1
 800c83e:	d8ab      	bhi.n	800c798 <forward_eltwise+0x130>
 800c840:	9b01      	ldr	r3, [sp, #4]
 800c842:	9a05      	ldr	r2, [sp, #20]
 800c844:	3304      	adds	r3, #4
 800c846:	4293      	cmp	r3, r2
 800c848:	9301      	str	r3, [sp, #4]
 800c84a:	d026      	beq.n	800c89a <forward_eltwise+0x232>
 800c84c:	9b03      	ldr	r3, [sp, #12]
 800c84e:	f8dd 8000 	ldr.w	r8, [sp]
 800c852:	699a      	ldr	r2, [r3, #24]
 800c854:	e74d      	b.n	800c6f2 <forward_eltwise+0x8a>
 800c856:	9b00      	ldr	r3, [sp, #0]
 800c858:	f8da 0018 	ldr.w	r0, [sl, #24]
 800c85c:	699b      	ldr	r3, [r3, #24]
 800c85e:	f8d8 4018 	ldr.w	r4, [r8, #24]
 800c862:	6885      	ldr	r5, [r0, #8]
 800c864:	689e      	ldr	r6, [r3, #8]
 800c866:	68a4      	ldr	r4, [r4, #8]
 800c868:	464a      	mov	r2, r9
 800c86a:	a80b      	add	r0, sp, #44	; 0x2c
 800c86c:	f000 fbb8 	bl	800cfe0 <core_get_broadcasted_shape>
 800c870:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800c872:	0a1b      	lsrs	r3, r3, #8
 800c874:	bf08      	it	eq
 800c876:	2301      	moveq	r3, #1
 800c878:	d009      	beq.n	800c88e <forward_eltwise+0x226>
 800c87a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800c87c:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 800c880:	2301      	movs	r3, #1
 800c882:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 800c886:	4290      	cmp	r0, r2
 800c888:	fb01 f303 	mul.w	r3, r1, r3
 800c88c:	d1f9      	bne.n	800c882 <forward_eltwise+0x21a>
 800c88e:	4621      	mov	r1, r4
 800c890:	462a      	mov	r2, r5
 800c892:	9c04      	ldr	r4, [sp, #16]
 800c894:	4630      	mov	r0, r6
 800c896:	47a0      	blx	r4
 800c898:	e7d2      	b.n	800c840 <forward_eltwise+0x1d8>
 800c89a:	b01d      	add	sp, #116	; 0x74
 800c89c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c8a0:	461d      	mov	r5, r3
 800c8a2:	e6ef      	b.n	800c684 <forward_eltwise+0x1c>
 800c8a4:	689b      	ldr	r3, [r3, #8]
 800c8a6:	deff      	udf	#255	; 0xff
 800c8a8:	2300      	movs	r3, #0
 800c8aa:	685b      	ldr	r3, [r3, #4]
 800c8ac:	deff      	udf	#255	; 0xff
 800c8ae:	685b      	ldr	r3, [r3, #4]
 800c8b0:	deff      	udf	#255	; 0xff
 800c8b2:	bf00      	nop

0800c8b4 <forward_elu>:
 800c8b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c8b6:	ed2d 8b04 	vpush	{d8-d9}
 800c8ba:	6982      	ldr	r2, [r0, #24]
 800c8bc:	8813      	ldrh	r3, [r2, #0]
 800c8be:	2b00      	cmp	r3, #0
 800c8c0:	d051      	beq.n	800c966 <forward_elu+0xb2>
 800c8c2:	6851      	ldr	r1, [r2, #4]
 800c8c4:	684a      	ldr	r2, [r1, #4]
 800c8c6:	b102      	cbz	r2, 800c8ca <forward_elu+0x16>
 800c8c8:	6812      	ldr	r2, [r2, #0]
 800c8ca:	2b01      	cmp	r3, #1
 800c8cc:	d04a      	beq.n	800c964 <forward_elu+0xb0>
 800c8ce:	690b      	ldr	r3, [r1, #16]
 800c8d0:	2b00      	cmp	r3, #0
 800c8d2:	d050      	beq.n	800c976 <forward_elu+0xc2>
 800c8d4:	681b      	ldr	r3, [r3, #0]
 800c8d6:	6991      	ldr	r1, [r2, #24]
 800c8d8:	699c      	ldr	r4, [r3, #24]
 800c8da:	6893      	ldr	r3, [r2, #8]
 800c8dc:	68a7      	ldr	r7, [r4, #8]
 800c8de:	688e      	ldr	r6, [r1, #8]
 800c8e0:	0a1b      	lsrs	r3, r3, #8
 800c8e2:	d042      	beq.n	800c96a <forward_elu+0xb6>
 800c8e4:	68d4      	ldr	r4, [r2, #12]
 800c8e6:	2201      	movs	r2, #1
 800c8e8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800c8ec:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800c8f0:	429c      	cmp	r4, r3
 800c8f2:	fb01 f202 	mul.w	r2, r1, r2
 800c8f6:	d1f9      	bne.n	800c8ec <forward_elu+0x38>
 800c8f8:	69c3      	ldr	r3, [r0, #28]
 800c8fa:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800c8fe:	3a01      	subs	r2, #1
 800c900:	689b      	ldr	r3, [r3, #8]
 800c902:	eb06 0582 	add.w	r5, r6, r2, lsl #2
 800c906:	42ae      	cmp	r6, r5
 800c908:	ed93 9a00 	vldr	s18, [r3]
 800c90c:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 800c910:	d825      	bhi.n	800c95e <forward_elu+0xaa>
 800c912:	eddf 8a1a 	vldr	s17, [pc, #104]	; 800c97c <forward_elu+0xc8>
 800c916:	3504      	adds	r5, #4
 800c918:	3704      	adds	r7, #4
 800c91a:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
 800c91e:	462c      	mov	r4, r5
 800c920:	ed35 8a01 	vldmdb	r5!, {s16}
 800c924:	eeb0 0a48 	vmov.f32	s0, s16
 800c928:	f001 fbb8 	bl	800e09c <expf>
 800c92c:	ee30 0a69 	vsub.f32	s0, s0, s19
 800c930:	3c08      	subs	r4, #8
 800c932:	ee60 7a09 	vmul.f32	s15, s0, s18
 800c936:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800c93a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c93e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800c942:	bf88      	it	hi
 800c944:	eef0 7a68 	vmovhi.f32	s15, s17
 800c948:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c94c:	bfb8      	it	lt
 800c94e:	eeb0 8a68 	vmovlt.f32	s16, s17
 800c952:	ee77 7a88 	vadd.f32	s15, s15, s16
 800c956:	42a6      	cmp	r6, r4
 800c958:	ed67 7a01 	vstmdb	r7!, {s15}
 800c95c:	d9df      	bls.n	800c91e <forward_elu+0x6a>
 800c95e:	ecbd 8b04 	vpop	{d8-d9}
 800c962:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c964:	2300      	movs	r3, #0
 800c966:	685b      	ldr	r3, [r3, #4]
 800c968:	deff      	udf	#255	; 0xff
 800c96a:	69c3      	ldr	r3, [r0, #28]
 800c96c:	689b      	ldr	r3, [r3, #8]
 800c96e:	4635      	mov	r5, r6
 800c970:	ed93 9a00 	vldr	s18, [r3]
 800c974:	e7cd      	b.n	800c912 <forward_elu+0x5e>
 800c976:	699b      	ldr	r3, [r3, #24]
 800c978:	deff      	udf	#255	; 0xff
 800c97a:	bf00      	nop
 800c97c:	00000000 	.word	0x00000000

0800c980 <forward_clip>:
 800c980:	6982      	ldr	r2, [r0, #24]
 800c982:	8813      	ldrh	r3, [r2, #0]
 800c984:	2b00      	cmp	r3, #0
 800c986:	d045      	beq.n	800ca14 <forward_clip+0x94>
 800c988:	6851      	ldr	r1, [r2, #4]
 800c98a:	684a      	ldr	r2, [r1, #4]
 800c98c:	b102      	cbz	r2, 800c990 <forward_clip+0x10>
 800c98e:	6812      	ldr	r2, [r2, #0]
 800c990:	2b01      	cmp	r3, #1
 800c992:	d049      	beq.n	800ca28 <forward_clip+0xa8>
 800c994:	690b      	ldr	r3, [r1, #16]
 800c996:	2b00      	cmp	r3, #0
 800c998:	d049      	beq.n	800ca2e <forward_clip+0xae>
 800c99a:	b470      	push	{r4, r5, r6}
 800c99c:	681b      	ldr	r3, [r3, #0]
 800c99e:	6994      	ldr	r4, [r2, #24]
 800c9a0:	6999      	ldr	r1, [r3, #24]
 800c9a2:	6893      	ldr	r3, [r2, #8]
 800c9a4:	6889      	ldr	r1, [r1, #8]
 800c9a6:	68a5      	ldr	r5, [r4, #8]
 800c9a8:	0a1b      	lsrs	r3, r3, #8
 800c9aa:	d035      	beq.n	800ca18 <forward_clip+0x98>
 800c9ac:	68d6      	ldr	r6, [r2, #12]
 800c9ae:	2201      	movs	r2, #1
 800c9b0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800c9b4:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800c9b8:	429e      	cmp	r6, r3
 800c9ba:	fb04 f202 	mul.w	r2, r4, r2
 800c9be:	d1f9      	bne.n	800c9b4 <forward_clip+0x34>
 800c9c0:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
 800c9c4:	69c0      	ldr	r0, [r0, #28]
 800c9c6:	3b01      	subs	r3, #1
 800c9c8:	6880      	ldr	r0, [r0, #8]
 800c9ca:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 800c9ce:	4295      	cmp	r5, r2
 800c9d0:	edd0 6a00 	vldr	s13, [r0]
 800c9d4:	ed90 7a01 	vldr	s14, [r0, #4]
 800c9d8:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800c9dc:	d818      	bhi.n	800ca10 <forward_clip+0x90>
 800c9de:	3204      	adds	r2, #4
 800c9e0:	3104      	adds	r1, #4
 800c9e2:	4613      	mov	r3, r2
 800c9e4:	ed72 7a01 	vldmdb	r2!, {s15}
 800c9e8:	eef4 7ae6 	vcmpe.f32	s15, s13
 800c9ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c9f0:	bfb8      	it	lt
 800c9f2:	eef0 7a66 	vmovlt.f32	s15, s13
 800c9f6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c9fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c9fe:	f1a3 0308 	sub.w	r3, r3, #8
 800ca02:	bf88      	it	hi
 800ca04:	eef0 7a47 	vmovhi.f32	s15, s14
 800ca08:	429d      	cmp	r5, r3
 800ca0a:	ed61 7a01 	vstmdb	r1!, {s15}
 800ca0e:	d9e8      	bls.n	800c9e2 <forward_clip+0x62>
 800ca10:	bc70      	pop	{r4, r5, r6}
 800ca12:	4770      	bx	lr
 800ca14:	685b      	ldr	r3, [r3, #4]
 800ca16:	deff      	udf	#255	; 0xff
 800ca18:	69c3      	ldr	r3, [r0, #28]
 800ca1a:	689b      	ldr	r3, [r3, #8]
 800ca1c:	462a      	mov	r2, r5
 800ca1e:	edd3 6a00 	vldr	s13, [r3]
 800ca22:	ed93 7a01 	vldr	s14, [r3, #4]
 800ca26:	e7da      	b.n	800c9de <forward_clip+0x5e>
 800ca28:	2300      	movs	r3, #0
 800ca2a:	685b      	ldr	r3, [r3, #4]
 800ca2c:	deff      	udf	#255	; 0xff
 800ca2e:	699b      	ldr	r3, [r3, #24]
 800ca30:	deff      	udf	#255	; 0xff
 800ca32:	bf00      	nop

0800ca34 <forward_lite_dense_if32of32wf32>:
 800ca34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ca38:	e9dd 6409 	ldrd	r6, r4, [sp, #36]	; 0x24
 800ca3c:	eb00 0784 	add.w	r7, r0, r4, lsl #2
 800ca40:	4287      	cmp	r7, r0
 800ca42:	f240 8106 	bls.w	800cc52 <forward_lite_dense_if32of32wf32+0x21e>
 800ca46:	f1a6 0810 	sub.w	r8, r6, #16
 800ca4a:	ea4f 1818 	mov.w	r8, r8, lsr #4
 800ca4e:	f108 0801 	add.w	r8, r8, #1
 800ca52:	ea4f 1b88 	mov.w	fp, r8, lsl #6
 800ca56:	ea4f 0986 	mov.w	r9, r6, lsl #2
 800ca5a:	eb01 1888 	add.w	r8, r1, r8, lsl #6
 800ca5e:	4605      	mov	r5, r0
 800ca60:	f006 0a0f 	and.w	sl, r6, #15
 800ca64:	2e0f      	cmp	r6, #15
 800ca66:	ed9f 7a84 	vldr	s14, [pc, #528]	; 800cc78 <forward_lite_dense_if32of32wf32+0x244>
 800ca6a:	f240 8101 	bls.w	800cc70 <forward_lite_dense_if32of32wf32+0x23c>
 800ca6e:	f101 0c40 	add.w	ip, r1, #64	; 0x40
 800ca72:	f102 0440 	add.w	r4, r2, #64	; 0x40
 800ca76:	46b6      	mov	lr, r6
 800ca78:	ed54 5a0f 	vldr	s11, [r4, #-60]	; 0xffffffc4
 800ca7c:	ed5c 7a0f 	vldr	s15, [ip, #-60]	; 0xffffffc4
 800ca80:	ed1c 6a10 	vldr	s12, [ip, #-64]	; 0xffffffc0
 800ca84:	ed54 6a10 	vldr	s13, [r4, #-64]	; 0xffffffc0
 800ca88:	ed5c 4a0d 	vldr	s9, [ip, #-52]	; 0xffffffcc
 800ca8c:	ed1c 5a0c 	vldr	s10, [ip, #-48]	; 0xffffffd0
 800ca90:	ed1c 3a0a 	vldr	s6, [ip, #-40]	; 0xffffffd8
 800ca94:	ed54 3a0a 	vldr	s7, [r4, #-40]	; 0xffffffd8
 800ca98:	ed1c 4a09 	vldr	s8, [ip, #-36]	; 0xffffffdc
 800ca9c:	ed1c 1a06 	vldr	s2, [ip, #-24]	; 0xffffffe8
 800caa0:	ed54 1a06 	vldr	s3, [r4, #-24]	; 0xffffffe8
 800caa4:	ed1c 2a05 	vldr	s4, [ip, #-20]	; 0xffffffec
 800caa8:	ed54 2a05 	vldr	s5, [r4, #-20]	; 0xffffffec
 800caac:	ee67 7aa5 	vmul.f32	s15, s15, s11
 800cab0:	ed5c 5a0e 	vldr	s11, [ip, #-56]	; 0xffffffc8
 800cab4:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cab8:	f1ae 0e10 	sub.w	lr, lr, #16
 800cabc:	f1be 0f0f 	cmp.w	lr, #15
 800cac0:	ed14 6a0e 	vldr	s12, [r4, #-56]	; 0xffffffc8
 800cac4:	ed54 6a0d 	vldr	s13, [r4, #-52]	; 0xffffffcc
 800cac8:	eee5 7a86 	vfma.f32	s15, s11, s12
 800cacc:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
 800cad0:	f104 0440 	add.w	r4, r4, #64	; 0x40
 800cad4:	ed54 5a1c 	vldr	s11, [r4, #-112]	; 0xffffff90
 800cad8:	ed1c 6a1b 	vldr	s12, [ip, #-108]	; 0xffffff94
 800cadc:	eee4 7aa6 	vfma.f32	s15, s9, s13
 800cae0:	ed54 6a1b 	vldr	s13, [r4, #-108]	; 0xffffff94
 800cae4:	ed54 4a19 	vldr	s9, [r4, #-100]	; 0xffffff9c
 800cae8:	eee5 7a25 	vfma.f32	s15, s10, s11
 800caec:	ed1c 5a18 	vldr	s10, [ip, #-96]	; 0xffffffa0
 800caf0:	ed54 5a18 	vldr	s11, [r4, #-96]	; 0xffffffa0
 800caf4:	eee6 7a26 	vfma.f32	s15, s12, s13
 800caf8:	ed1c 6a17 	vldr	s12, [ip, #-92]	; 0xffffffa4
 800cafc:	ed54 6a17 	vldr	s13, [r4, #-92]	; 0xffffffa4
 800cb00:	eee3 7a23 	vfma.f32	s15, s6, s7
 800cb04:	ed1c 3a14 	vldr	s6, [ip, #-80]	; 0xffffffb0
 800cb08:	ed54 3a14 	vldr	s7, [r4, #-80]	; 0xffffffb0
 800cb0c:	eee4 7a24 	vfma.f32	s15, s8, s9
 800cb10:	ed1c 4a13 	vldr	s8, [ip, #-76]	; 0xffffffb4
 800cb14:	ed54 4a13 	vldr	s9, [r4, #-76]	; 0xffffffb4
 800cb18:	eee5 7a25 	vfma.f32	s15, s10, s11
 800cb1c:	ed1c 5a12 	vldr	s10, [ip, #-72]	; 0xffffffb8
 800cb20:	ed54 5a12 	vldr	s11, [r4, #-72]	; 0xffffffb8
 800cb24:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb28:	ed1c 6a11 	vldr	s12, [ip, #-68]	; 0xffffffbc
 800cb2c:	ed54 6a11 	vldr	s13, [r4, #-68]	; 0xffffffbc
 800cb30:	eee1 7a21 	vfma.f32	s15, s2, s3
 800cb34:	eee2 7a22 	vfma.f32	s15, s4, s5
 800cb38:	eee3 7a23 	vfma.f32	s15, s6, s7
 800cb3c:	eee4 7a24 	vfma.f32	s15, s8, s9
 800cb40:	eee5 7a25 	vfma.f32	s15, s10, s11
 800cb44:	eee6 7a26 	vfma.f32	s15, s12, s13
 800cb48:	ee37 7a27 	vadd.f32	s14, s14, s15
 800cb4c:	d894      	bhi.n	800ca78 <forward_lite_dense_if32of32wf32+0x44>
 800cb4e:	eb02 0e0b 	add.w	lr, r2, fp
 800cb52:	4654      	mov	r4, sl
 800cb54:	46c4      	mov	ip, r8
 800cb56:	2c00      	cmp	r4, #0
 800cb58:	d075      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cb5a:	eddc 6a00 	vldr	s13, [ip]
 800cb5e:	edde 7a00 	vldr	s15, [lr]
 800cb62:	2c01      	cmp	r4, #1
 800cb64:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cb68:	d06d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cb6a:	eddc 6a01 	vldr	s13, [ip, #4]
 800cb6e:	edde 7a01 	vldr	s15, [lr, #4]
 800cb72:	2c02      	cmp	r4, #2
 800cb74:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cb78:	d065      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cb7a:	eddc 6a02 	vldr	s13, [ip, #8]
 800cb7e:	edde 7a02 	vldr	s15, [lr, #8]
 800cb82:	2c03      	cmp	r4, #3
 800cb84:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cb88:	d05d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cb8a:	eddc 6a03 	vldr	s13, [ip, #12]
 800cb8e:	edde 7a03 	vldr	s15, [lr, #12]
 800cb92:	2c04      	cmp	r4, #4
 800cb94:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cb98:	d055      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cb9a:	eddc 6a04 	vldr	s13, [ip, #16]
 800cb9e:	edde 7a04 	vldr	s15, [lr, #16]
 800cba2:	2c05      	cmp	r4, #5
 800cba4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cba8:	d04d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbaa:	eddc 6a05 	vldr	s13, [ip, #20]
 800cbae:	edde 7a05 	vldr	s15, [lr, #20]
 800cbb2:	2c06      	cmp	r4, #6
 800cbb4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbb8:	d045      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbba:	eddc 6a06 	vldr	s13, [ip, #24]
 800cbbe:	edde 7a06 	vldr	s15, [lr, #24]
 800cbc2:	2c07      	cmp	r4, #7
 800cbc4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbc8:	d03d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbca:	eddc 6a07 	vldr	s13, [ip, #28]
 800cbce:	edde 7a07 	vldr	s15, [lr, #28]
 800cbd2:	2c08      	cmp	r4, #8
 800cbd4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbd8:	d035      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbda:	eddc 6a08 	vldr	s13, [ip, #32]
 800cbde:	edde 7a08 	vldr	s15, [lr, #32]
 800cbe2:	2c09      	cmp	r4, #9
 800cbe4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbe8:	d02d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbea:	eddc 6a09 	vldr	s13, [ip, #36]	; 0x24
 800cbee:	edde 7a09 	vldr	s15, [lr, #36]	; 0x24
 800cbf2:	2c0a      	cmp	r4, #10
 800cbf4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cbf8:	d025      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cbfa:	eddc 6a0a 	vldr	s13, [ip, #40]	; 0x28
 800cbfe:	edde 7a0a 	vldr	s15, [lr, #40]	; 0x28
 800cc02:	2c0b      	cmp	r4, #11
 800cc04:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc08:	d01d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cc0a:	eddc 6a0b 	vldr	s13, [ip, #44]	; 0x2c
 800cc0e:	edde 7a0b 	vldr	s15, [lr, #44]	; 0x2c
 800cc12:	2c0c      	cmp	r4, #12
 800cc14:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc18:	d015      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cc1a:	eddc 6a0c 	vldr	s13, [ip, #48]	; 0x30
 800cc1e:	edde 7a0c 	vldr	s15, [lr, #48]	; 0x30
 800cc22:	3c0d      	subs	r4, #13
 800cc24:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc28:	d00d      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cc2a:	eddc 6a0d 	vldr	s13, [ip, #52]	; 0x34
 800cc2e:	edde 7a0d 	vldr	s15, [lr, #52]	; 0x34
 800cc32:	2c01      	cmp	r4, #1
 800cc34:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc38:	d005      	beq.n	800cc46 <forward_lite_dense_if32of32wf32+0x212>
 800cc3a:	edde 6a0e 	vldr	s13, [lr, #56]	; 0x38
 800cc3e:	eddc 7a0e 	vldr	s15, [ip, #56]	; 0x38
 800cc42:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800cc46:	444a      	add	r2, r9
 800cc48:	eca5 7a01 	vstmia	r5!, {s14}
 800cc4c:	42af      	cmp	r7, r5
 800cc4e:	f63f af09 	bhi.w	800ca64 <forward_lite_dense_if32of32wf32+0x30>
 800cc52:	b15b      	cbz	r3, 800cc6c <forward_lite_dense_if32of32wf32+0x238>
 800cc54:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cc56:	b14a      	cbz	r2, 800cc6c <forward_lite_dense_if32of32wf32+0x238>
 800cc58:	edd0 7a00 	vldr	s15, [r0]
 800cc5c:	ecb3 7a01 	vldmia	r3!, {s14}
 800cc60:	ee77 7a87 	vadd.f32	s15, s15, s14
 800cc64:	ece0 7a01 	vstmia	r0!, {s15}
 800cc68:	4287      	cmp	r7, r0
 800cc6a:	d1f5      	bne.n	800cc58 <forward_lite_dense_if32of32wf32+0x224>
 800cc6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cc70:	4634      	mov	r4, r6
 800cc72:	4696      	mov	lr, r2
 800cc74:	468c      	mov	ip, r1
 800cc76:	e76e      	b.n	800cb56 <forward_lite_dense_if32of32wf32+0x122>
 800cc78:	00000000 	.word	0x00000000

0800cc7c <st_int8_copy>:
 800cc7c:	4288      	cmp	r0, r1
 800cc7e:	d057      	beq.n	800cd30 <st_int8_copy+0xb4>
 800cc80:	2a00      	cmp	r2, #0
 800cc82:	d055      	beq.n	800cd30 <st_int8_copy+0xb4>
 800cc84:	4288      	cmp	r0, r1
 800cc86:	d354      	bcc.n	800cd32 <st_int8_copy+0xb6>
 800cc88:	078b      	lsls	r3, r1, #30
 800cc8a:	d102      	bne.n	800cc92 <st_int8_copy+0x16>
 800cc8c:	e009      	b.n	800cca2 <st_int8_copy+0x26>
 800cc8e:	2a00      	cmp	r2, #0
 800cc90:	d05c      	beq.n	800cd4c <st_int8_copy+0xd0>
 800cc92:	f910 3b01 	ldrsb.w	r3, [r0], #1
 800cc96:	f801 3b01 	strb.w	r3, [r1], #1
 800cc9a:	078b      	lsls	r3, r1, #30
 800cc9c:	f102 32ff 	add.w	r2, r2, #4294967295
 800cca0:	d1f5      	bne.n	800cc8e <st_int8_copy+0x12>
 800cca2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cca6:	ea5f 1e12 	movs.w	lr, r2, lsr #4
 800ccaa:	d069      	beq.n	800cd80 <st_int8_copy+0x104>
 800ccac:	ea41 0300 	orr.w	r3, r1, r0
 800ccb0:	075b      	lsls	r3, r3, #29
 800ccb2:	d14c      	bne.n	800cd4e <st_int8_copy+0xd2>
 800ccb4:	f10e 33ff 	add.w	r3, lr, #4294967295
 800ccb8:	2b01      	cmp	r3, #1
 800ccba:	d948      	bls.n	800cd4e <st_int8_copy+0xd2>
 800ccbc:	f100 0310 	add.w	r3, r0, #16
 800ccc0:	ea4f 140e 	mov.w	r4, lr, lsl #4
 800ccc4:	f101 0c10 	add.w	ip, r1, #16
 800ccc8:	eb03 1e0e 	add.w	lr, r3, lr, lsl #4
 800cccc:	ed13 6b04 	vldr	d6, [r3, #-16]
 800ccd0:	ed13 7b02 	vldr	d7, [r3, #-8]
 800ccd4:	3310      	adds	r3, #16
 800ccd6:	4573      	cmp	r3, lr
 800ccd8:	ed0c 6b04 	vstr	d6, [ip, #-16]
 800ccdc:	ed0c 7b02 	vstr	d7, [ip, #-8]
 800cce0:	f10c 0c10 	add.w	ip, ip, #16
 800cce4:	d1f2      	bne.n	800cccc <st_int8_copy+0x50>
 800cce6:	f3c2 0381 	ubfx	r3, r2, #2, #2
 800ccea:	4421      	add	r1, r4
 800ccec:	4420      	add	r0, r4
 800ccee:	f002 0203 	and.w	r2, r2, #3
 800ccf2:	b16b      	cbz	r3, 800cd10 <st_int8_copy+0x94>
 800ccf4:	6804      	ldr	r4, [r0, #0]
 800ccf6:	600c      	str	r4, [r1, #0]
 800ccf8:	1e5c      	subs	r4, r3, #1
 800ccfa:	d005      	beq.n	800cd08 <st_int8_copy+0x8c>
 800ccfc:	6845      	ldr	r5, [r0, #4]
 800ccfe:	604d      	str	r5, [r1, #4]
 800cd00:	2c01      	cmp	r4, #1
 800cd02:	bf1c      	itt	ne
 800cd04:	6884      	ldrne	r4, [r0, #8]
 800cd06:	608c      	strne	r4, [r1, #8]
 800cd08:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800cd0c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800cd10:	b162      	cbz	r2, 800cd2c <st_int8_copy+0xb0>
 800cd12:	f990 3000 	ldrsb.w	r3, [r0]
 800cd16:	700b      	strb	r3, [r1, #0]
 800cd18:	3a01      	subs	r2, #1
 800cd1a:	d007      	beq.n	800cd2c <st_int8_copy+0xb0>
 800cd1c:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800cd20:	704b      	strb	r3, [r1, #1]
 800cd22:	2a01      	cmp	r2, #1
 800cd24:	bf1c      	itt	ne
 800cd26:	f990 3002 	ldrsbne.w	r3, [r0, #2]
 800cd2a:	708b      	strbne	r3, [r1, #2]
 800cd2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cd30:	4770      	bx	lr
 800cd32:	1883      	adds	r3, r0, r2
 800cd34:	428b      	cmp	r3, r1
 800cd36:	d9a7      	bls.n	800cc88 <st_int8_copy+0xc>
 800cd38:	4283      	cmp	r3, r0
 800cd3a:	440a      	add	r2, r1
 800cd3c:	d9f8      	bls.n	800cd30 <st_int8_copy+0xb4>
 800cd3e:	f913 1d01 	ldrsb.w	r1, [r3, #-1]!
 800cd42:	f802 1d01 	strb.w	r1, [r2, #-1]!
 800cd46:	4283      	cmp	r3, r0
 800cd48:	d1f9      	bne.n	800cd3e <st_int8_copy+0xc2>
 800cd4a:	4770      	bx	lr
 800cd4c:	4770      	bx	lr
 800cd4e:	ea4f 140e 	mov.w	r4, lr, lsl #4
 800cd52:	460b      	mov	r3, r1
 800cd54:	eb01 1e0e 	add.w	lr, r1, lr, lsl #4
 800cd58:	4684      	mov	ip, r0
 800cd5a:	f8dc 7000 	ldr.w	r7, [ip]
 800cd5e:	f8dc 6004 	ldr.w	r6, [ip, #4]
 800cd62:	f8dc 5008 	ldr.w	r5, [ip, #8]
 800cd66:	f8dc 800c 	ldr.w	r8, [ip, #12]
 800cd6a:	f8c3 800c 	str.w	r8, [r3, #12]
 800cd6e:	601f      	str	r7, [r3, #0]
 800cd70:	605e      	str	r6, [r3, #4]
 800cd72:	609d      	str	r5, [r3, #8]
 800cd74:	3310      	adds	r3, #16
 800cd76:	459e      	cmp	lr, r3
 800cd78:	f10c 0c10 	add.w	ip, ip, #16
 800cd7c:	d1ed      	bne.n	800cd5a <st_int8_copy+0xde>
 800cd7e:	e7b2      	b.n	800cce6 <st_int8_copy+0x6a>
 800cd80:	0893      	lsrs	r3, r2, #2
 800cd82:	f002 0203 	and.w	r2, r2, #3
 800cd86:	e7b4      	b.n	800ccf2 <st_int8_copy+0x76>

0800cd88 <ai_sum_f32>:
 800cd88:	edd1 7a00 	vldr	s15, [r1]
 800cd8c:	ed92 7a00 	vldr	s14, [r2]
 800cd90:	ee77 7a87 	vadd.f32	s15, s15, s14
 800cd94:	edc0 7a00 	vstr	s15, [r0]
 800cd98:	4770      	bx	lr
 800cd9a:	bf00      	nop

0800cd9c <ai_sum_buffer_f32>:
 800cd9c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800cda0:	4298      	cmp	r0, r3
 800cda2:	d209      	bcs.n	800cdb8 <ai_sum_buffer_f32+0x1c>
 800cda4:	ecf1 7a01 	vldmia	r1!, {s15}
 800cda8:	ecb2 7a01 	vldmia	r2!, {s14}
 800cdac:	ee77 7a87 	vadd.f32	s15, s15, s14
 800cdb0:	ece0 7a01 	vstmia	r0!, {s15}
 800cdb4:	4283      	cmp	r3, r0
 800cdb6:	d8f5      	bhi.n	800cda4 <ai_sum_buffer_f32+0x8>
 800cdb8:	4770      	bx	lr
 800cdba:	bf00      	nop

0800cdbc <ai_sub_f32>:
 800cdbc:	edd1 7a00 	vldr	s15, [r1]
 800cdc0:	ed92 7a00 	vldr	s14, [r2]
 800cdc4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800cdc8:	edc0 7a00 	vstr	s15, [r0]
 800cdcc:	4770      	bx	lr
 800cdce:	bf00      	nop

0800cdd0 <ai_sub_buffer_f32>:
 800cdd0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800cdd4:	4298      	cmp	r0, r3
 800cdd6:	d209      	bcs.n	800cdec <ai_sub_buffer_f32+0x1c>
 800cdd8:	ecf1 7a01 	vldmia	r1!, {s15}
 800cddc:	ecb2 7a01 	vldmia	r2!, {s14}
 800cde0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800cde4:	ece0 7a01 	vstmia	r0!, {s15}
 800cde8:	4283      	cmp	r3, r0
 800cdea:	d8f5      	bhi.n	800cdd8 <ai_sub_buffer_f32+0x8>
 800cdec:	4770      	bx	lr
 800cdee:	bf00      	nop

0800cdf0 <ai_mul_f32>:
 800cdf0:	edd1 7a00 	vldr	s15, [r1]
 800cdf4:	ed92 7a00 	vldr	s14, [r2]
 800cdf8:	ee67 7a87 	vmul.f32	s15, s15, s14
 800cdfc:	edc0 7a00 	vstr	s15, [r0]
 800ce00:	4770      	bx	lr
 800ce02:	bf00      	nop

0800ce04 <ai_mul_buffer_f32>:
 800ce04:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ce08:	4298      	cmp	r0, r3
 800ce0a:	d209      	bcs.n	800ce20 <ai_mul_buffer_f32+0x1c>
 800ce0c:	ecf1 7a01 	vldmia	r1!, {s15}
 800ce10:	ecb2 7a01 	vldmia	r2!, {s14}
 800ce14:	ee67 7a87 	vmul.f32	s15, s15, s14
 800ce18:	ece0 7a01 	vstmia	r0!, {s15}
 800ce1c:	4283      	cmp	r3, r0
 800ce1e:	d8f5      	bhi.n	800ce0c <ai_mul_buffer_f32+0x8>
 800ce20:	4770      	bx	lr
 800ce22:	bf00      	nop

0800ce24 <ai_div_f32>:
 800ce24:	edd1 6a00 	vldr	s13, [r1]
 800ce28:	ed92 7a00 	vldr	s14, [r2]
 800ce2c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ce30:	edc0 7a00 	vstr	s15, [r0]
 800ce34:	4770      	bx	lr
 800ce36:	bf00      	nop

0800ce38 <ai_div_buffer_f32>:
 800ce38:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800ce3c:	4298      	cmp	r0, r3
 800ce3e:	d209      	bcs.n	800ce54 <ai_div_buffer_f32+0x1c>
 800ce40:	ecf1 6a01 	vldmia	r1!, {s13}
 800ce44:	ecb2 7a01 	vldmia	r2!, {s14}
 800ce48:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ce4c:	ece0 7a01 	vstmia	r0!, {s15}
 800ce50:	4283      	cmp	r3, r0
 800ce52:	d8f5      	bhi.n	800ce40 <ai_div_buffer_f32+0x8>
 800ce54:	4770      	bx	lr
 800ce56:	bf00      	nop

0800ce58 <ai_array_to_buffer_fmt>:
 800ce58:	f3c0 4343 	ubfx	r3, r0, #17, #4
 800ce5c:	2b02      	cmp	r3, #2
 800ce5e:	d050      	beq.n	800cf02 <ai_array_to_buffer_fmt+0xaa>
 800ce60:	4b2a      	ldr	r3, [pc, #168]	; (800cf0c <ai_array_to_buffer_fmt+0xb4>)
 800ce62:	f020 427e 	bic.w	r2, r0, #4261412864	; 0xfe000000
 800ce66:	429a      	cmp	r2, r3
 800ce68:	d00b      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ce6a:	dc1c      	bgt.n	800cea6 <ai_array_to_buffer_fmt+0x4e>
 800ce6c:	4b28      	ldr	r3, [pc, #160]	; (800cf10 <ai_array_to_buffer_fmt+0xb8>)
 800ce6e:	429a      	cmp	r2, r3
 800ce70:	d007      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ce72:	dd0b      	ble.n	800ce8c <ai_array_to_buffer_fmt+0x34>
 800ce74:	4b27      	ldr	r3, [pc, #156]	; (800cf14 <ai_array_to_buffer_fmt+0xbc>)
 800ce76:	429a      	cmp	r2, r3
 800ce78:	d003      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ce7a:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 800ce7e:	429a      	cmp	r2, r3
 800ce80:	d131      	bne.n	800cee6 <ai_array_to_buffer_fmt+0x8e>
 800ce82:	4613      	mov	r3, r2
 800ce84:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800ce88:	4318      	orrs	r0, r3
 800ce8a:	4770      	bx	lr
 800ce8c:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800ce90:	429a      	cmp	r2, r3
 800ce92:	d0f6      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ce94:	dd2c      	ble.n	800cef0 <ai_array_to_buffer_fmt+0x98>
 800ce96:	4b20      	ldr	r3, [pc, #128]	; (800cf18 <ai_array_to_buffer_fmt+0xc0>)
 800ce98:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800ce9c:	429a      	cmp	r2, r3
 800ce9e:	bf18      	it	ne
 800cea0:	2340      	movne	r3, #64	; 0x40
 800cea2:	4318      	orrs	r0, r3
 800cea4:	4770      	bx	lr
 800cea6:	4b1d      	ldr	r3, [pc, #116]	; (800cf1c <ai_array_to_buffer_fmt+0xc4>)
 800cea8:	429a      	cmp	r2, r3
 800ceaa:	d0ea      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ceac:	dd0e      	ble.n	800cecc <ai_array_to_buffer_fmt+0x74>
 800ceae:	4b1c      	ldr	r3, [pc, #112]	; (800cf20 <ai_array_to_buffer_fmt+0xc8>)
 800ceb0:	429a      	cmp	r2, r3
 800ceb2:	d0e6      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ceb4:	f503 037e 	add.w	r3, r3, #16646144	; 0xfe0000
 800ceb8:	429a      	cmp	r2, r3
 800ceba:	d0e2      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800cebc:	4b19      	ldr	r3, [pc, #100]	; (800cf24 <ai_array_to_buffer_fmt+0xcc>)
 800cebe:	f000 40d0 	and.w	r0, r0, #1744830464	; 0x68000000
 800cec2:	429a      	cmp	r2, r3
 800cec4:	bf18      	it	ne
 800cec6:	2340      	movne	r3, #64	; 0x40
 800cec8:	4318      	orrs	r0, r3
 800ceca:	4770      	bx	lr
 800cecc:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800ced0:	429a      	cmp	r2, r3
 800ced2:	d0d6      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ced4:	3307      	adds	r3, #7
 800ced6:	429a      	cmp	r2, r3
 800ced8:	d0d3      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800ceda:	f2a3 3387 	subw	r3, r3, #903	; 0x387
 800cede:	429a      	cmp	r2, r3
 800cee0:	bf18      	it	ne
 800cee2:	2340      	movne	r3, #64	; 0x40
 800cee4:	e7ce      	b.n	800ce84 <ai_array_to_buffer_fmt+0x2c>
 800cee6:	4b10      	ldr	r3, [pc, #64]	; (800cf28 <ai_array_to_buffer_fmt+0xd0>)
 800cee8:	429a      	cmp	r2, r3
 800ceea:	bf18      	it	ne
 800ceec:	2340      	movne	r3, #64	; 0x40
 800ceee:	e7c9      	b.n	800ce84 <ai_array_to_buffer_fmt+0x2c>
 800cef0:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800cef4:	429a      	cmp	r2, r3
 800cef6:	d0c4      	beq.n	800ce82 <ai_array_to_buffer_fmt+0x2a>
 800cef8:	3380      	adds	r3, #128	; 0x80
 800cefa:	429a      	cmp	r2, r3
 800cefc:	bf18      	it	ne
 800cefe:	2340      	movne	r3, #64	; 0x40
 800cf00:	e7c0      	b.n	800ce84 <ai_array_to_buffer_fmt+0x2c>
 800cf02:	4b0a      	ldr	r3, [pc, #40]	; (800cf2c <ai_array_to_buffer_fmt+0xd4>)
 800cf04:	4003      	ands	r3, r0
 800cf06:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800cf0a:	e7bb      	b.n	800ce84 <ai_array_to_buffer_fmt+0x2c>
 800cf0c:	00840040 	.word	0x00840040
 800cf10:	00040840 	.word	0x00040840
 800cf14:	00041040 	.word	0x00041040
 800cf18:	00040447 	.word	0x00040447
 800cf1c:	00840840 	.word	0x00840840
 800cf20:	00841040 	.word	0x00841040
 800cf24:	0084084f 	.word	0x0084084f
 800cf28:	0004084f 	.word	0x0004084f
 800cf2c:	00803fff 	.word	0x00803fff

0800cf30 <ai_array_get_byte_size>:
 800cf30:	b319      	cbz	r1, 800cf7a <ai_array_get_byte_size+0x4a>
 800cf32:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 800cf36:	fb03 f101 	mul.w	r1, r3, r1
 800cf3a:	3107      	adds	r1, #7
 800cf3c:	f3c0 4243 	ubfx	r2, r0, #17, #4
 800cf40:	f021 0307 	bic.w	r3, r1, #7
 800cf44:	2a04      	cmp	r2, #4
 800cf46:	f3c0 5141 	ubfx	r1, r0, #21, #2
 800cf4a:	fa23 f101 	lsr.w	r1, r3, r1
 800cf4e:	ea4f 10e0 	mov.w	r0, r0, asr #7
 800cf52:	d00b      	beq.n	800cf6c <ai_array_get_byte_size+0x3c>
 800cf54:	2a08      	cmp	r2, #8
 800cf56:	d002      	beq.n	800cf5e <ai_array_get_byte_size+0x2e>
 800cf58:	3107      	adds	r1, #7
 800cf5a:	08c8      	lsrs	r0, r1, #3
 800cf5c:	4770      	bx	lr
 800cf5e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800cf62:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 800cf66:	3107      	adds	r1, #7
 800cf68:	08c8      	lsrs	r0, r1, #3
 800cf6a:	4770      	bx	lr
 800cf6c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800cf70:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 800cf74:	3107      	adds	r1, #7
 800cf76:	08c8      	lsrs	r0, r1, #3
 800cf78:	4770      	bx	lr
 800cf7a:	4608      	mov	r0, r1
 800cf7c:	4770      	bx	lr
 800cf7e:	bf00      	nop

0800cf80 <ai_array_get_data_byte_size>:
 800cf80:	b169      	cbz	r1, 800cf9e <ai_array_get_data_byte_size+0x1e>
 800cf82:	f3c0 12c6 	ubfx	r2, r0, #7, #7
 800cf86:	fb02 f101 	mul.w	r1, r2, r1
 800cf8a:	1dcb      	adds	r3, r1, #7
 800cf8c:	f023 0307 	bic.w	r3, r3, #7
 800cf90:	f3c0 5041 	ubfx	r0, r0, #21, #2
 800cf94:	fa23 f000 	lsr.w	r0, r3, r0
 800cf98:	3007      	adds	r0, #7
 800cf9a:	08c0      	lsrs	r0, r0, #3
 800cf9c:	4770      	bx	lr
 800cf9e:	4608      	mov	r0, r1
 800cfa0:	4770      	bx	lr
 800cfa2:	bf00      	nop

0800cfa4 <ai_version_get>:
 800cfa4:	0212      	lsls	r2, r2, #8
 800cfa6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800cfaa:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 800cfae:	4770      	bx	lr

0800cfb0 <get_tensor_byte_size>:
 800cfb0:	b410      	push	{r4}
 800cfb2:	6983      	ldr	r3, [r0, #24]
 800cfb4:	68c4      	ldr	r4, [r0, #12]
 800cfb6:	6941      	ldr	r1, [r0, #20]
 800cfb8:	681b      	ldr	r3, [r3, #0]
 800cfba:	68e0      	ldr	r0, [r4, #12]
 800cfbc:	4a07      	ldr	r2, [pc, #28]	; (800cfdc <get_tensor_byte_size+0x2c>)
 800cfbe:	68c9      	ldr	r1, [r1, #12]
 800cfc0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800cfc4:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
 800cfc8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800cfcc:	fb01 f000 	mul.w	r0, r1, r0
 800cfd0:	4293      	cmp	r3, r2
 800cfd2:	bf04      	itt	eq
 800cfd4:	3007      	addeq	r0, #7
 800cfd6:	08c0      	lsreq	r0, r0, #3
 800cfd8:	4770      	bx	lr
 800cfda:	bf00      	nop
 800cfdc:	000400c0 	.word	0x000400c0

0800cfe0 <core_get_broadcasted_shape>:
 800cfe0:	b470      	push	{r4, r5, r6}
 800cfe2:	6804      	ldr	r4, [r0, #0]
 800cfe4:	f3c4 2417 	ubfx	r4, r4, #8, #24
 800cfe8:	b324      	cbz	r4, 800d034 <core_get_broadcasted_shape+0x54>
 800cfea:	4623      	mov	r3, r4
 800cfec:	3b01      	subs	r3, #1
 800cfee:	429c      	cmp	r4, r3
 800cff0:	d91b      	bls.n	800d02a <core_get_broadcasted_shape+0x4a>
 800cff2:	6814      	ldr	r4, [r2, #0]
 800cff4:	680e      	ldr	r6, [r1, #0]
 800cff6:	ebb3 2f14 	cmp.w	r3, r4, lsr #8
 800cffa:	bf36      	itet	cc
 800cffc:	6854      	ldrcc	r4, [r2, #4]
 800cffe:	2401      	movcs	r4, #1
 800d000:	f854 4023 	ldrcc.w	r4, [r4, r3, lsl #2]
 800d004:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 800d008:	bf38      	it	cc
 800d00a:	ea4f 0c83 	movcc.w	ip, r3, lsl #2
 800d00e:	ebb3 2f16 	cmp.w	r3, r6, lsr #8
 800d012:	f04f 0501 	mov.w	r5, #1
 800d016:	bf3c      	itt	cc
 800d018:	684d      	ldrcc	r5, [r1, #4]
 800d01a:	f855 500c 	ldrcc.w	r5, [r5, ip]
 800d01e:	42ac      	cmp	r4, r5
 800d020:	bf38      	it	cc
 800d022:	462c      	movcc	r4, r5
 800d024:	6845      	ldr	r5, [r0, #4]
 800d026:	f845 400c 	str.w	r4, [r5, ip]
 800d02a:	b11b      	cbz	r3, 800d034 <core_get_broadcasted_shape+0x54>
 800d02c:	6804      	ldr	r4, [r0, #0]
 800d02e:	f3c4 2417 	ubfx	r4, r4, #8, #24
 800d032:	e7db      	b.n	800cfec <core_get_broadcasted_shape+0xc>
 800d034:	bc70      	pop	{r4, r5, r6}
 800d036:	4770      	bx	lr

0800d038 <core_compute_offsets>:
 800d038:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d03c:	e9d1 4600 	ldrd	r4, r6, [r1]
 800d040:	f5b4 6fa0 	cmp.w	r4, #1280	; 0x500
 800d044:	f8d2 9004 	ldr.w	r9, [r2, #4]
 800d048:	6871      	ldr	r1, [r6, #4]
 800d04a:	6812      	ldr	r2, [r2, #0]
 800d04c:	bf28      	it	cs
 800d04e:	6935      	ldrcs	r5, [r6, #16]
 800d050:	f8d9 c004 	ldr.w	ip, [r9, #4]
 800d054:	f8d0 b000 	ldr.w	fp, [r0]
 800d058:	bf2e      	itee	cs
 800d05a:	fb05 fe01 	mulcs.w	lr, r5, r1
 800d05e:	468e      	movcc	lr, r1
 800d060:	2501      	movcc	r5, #1
 800d062:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800d066:	bf28      	it	cs
 800d068:	f8d9 2010 	ldrcs.w	r2, [r9, #16]
 800d06c:	e9d6 4802 	ldrd	r4, r8, [r6, #8]
 800d070:	e9d9 6902 	ldrd	r6, r9, [r9, #8]
 800d074:	bf38      	it	cc
 800d076:	2201      	movcc	r2, #1
 800d078:	b083      	sub	sp, #12
 800d07a:	ebb4 0a06 	subs.w	sl, r4, r6
 800d07e:	bf18      	it	ne
 800d080:	f04f 0a01 	movne.w	sl, #1
 800d084:	f5bb 7f00 	cmp.w	fp, #512	; 0x200
 800d088:	9201      	str	r2, [sp, #4]
 800d08a:	f3cb 2217 	ubfx	r2, fp, #8, #24
 800d08e:	d308      	bcc.n	800d0a2 <core_compute_offsets+0x6a>
 800d090:	6847      	ldr	r7, [r0, #4]
 800d092:	4561      	cmp	r1, ip
 800d094:	bf0c      	ite	eq
 800d096:	461a      	moveq	r2, r3
 800d098:	2200      	movne	r2, #0
 800d09a:	607a      	str	r2, [r7, #4]
 800d09c:	6802      	ldr	r2, [r0, #0]
 800d09e:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d0a2:	9f01      	ldr	r7, [sp, #4]
 800d0a4:	42bd      	cmp	r5, r7
 800d0a6:	d03f      	beq.n	800d128 <core_compute_offsets+0xf0>
 800d0a8:	eba1 0b0c 	sub.w	fp, r1, ip
 800d0ac:	fabb fb8b 	clz	fp, fp
 800d0b0:	ea4f 1b5b 	mov.w	fp, fp, lsr #5
 800d0b4:	fb01 fb0b 	mul.w	fp, r1, fp
 800d0b8:	f1cb 0b00 	rsb	fp, fp, #0
 800d0bc:	2a04      	cmp	r2, #4
 800d0be:	d906      	bls.n	800d0ce <core_compute_offsets+0x96>
 800d0c0:	6847      	ldr	r7, [r0, #4]
 800d0c2:	fb0b f203 	mul.w	r2, fp, r3
 800d0c6:	613a      	str	r2, [r7, #16]
 800d0c8:	6802      	ldr	r2, [r0, #0]
 800d0ca:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d0ce:	42b4      	cmp	r4, r6
 800d0d0:	d03a      	beq.n	800d148 <core_compute_offsets+0x110>
 800d0d2:	f04f 0b00 	mov.w	fp, #0
 800d0d6:	2a02      	cmp	r2, #2
 800d0d8:	fb0e fa0a 	mul.w	sl, lr, sl
 800d0dc:	d90e      	bls.n	800d0fc <core_compute_offsets+0xc4>
 800d0de:	9a01      	ldr	r2, [sp, #4]
 800d0e0:	6847      	ldr	r7, [r0, #4]
 800d0e2:	1aaa      	subs	r2, r5, r2
 800d0e4:	bf18      	it	ne
 800d0e6:	2201      	movne	r2, #1
 800d0e8:	ebab 0b0a 	sub.w	fp, fp, sl
 800d0ec:	fb01 bb02 	mla	fp, r1, r2, fp
 800d0f0:	fb03 f20b 	mul.w	r2, r3, fp
 800d0f4:	60ba      	str	r2, [r7, #8]
 800d0f6:	6802      	ldr	r2, [r0, #0]
 800d0f8:	f3c2 2217 	ubfx	r2, r2, #8, #24
 800d0fc:	45c8      	cmp	r8, r9
 800d0fe:	d019      	beq.n	800d134 <core_compute_offsets+0xfc>
 800d100:	2100      	movs	r1, #0
 800d102:	2a03      	cmp	r2, #3
 800d104:	d90d      	bls.n	800d122 <core_compute_offsets+0xea>
 800d106:	ebb8 0809 	subs.w	r8, r8, r9
 800d10a:	fb0e f404 	mul.w	r4, lr, r4
 800d10e:	bf18      	it	ne
 800d110:	f04f 0801 	movne.w	r8, #1
 800d114:	fb08 1114 	mls	r1, r8, r4, r1
 800d118:	6842      	ldr	r2, [r0, #4]
 800d11a:	448a      	add	sl, r1
 800d11c:	fb03 f30a 	mul.w	r3, r3, sl
 800d120:	60d3      	str	r3, [r2, #12]
 800d122:	b003      	add	sp, #12
 800d124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d128:	ebb1 0b0c 	subs.w	fp, r1, ip
 800d12c:	bf18      	it	ne
 800d12e:	f04f 0b01 	movne.w	fp, #1
 800d132:	e7c3      	b.n	800d0bc <core_compute_offsets+0x84>
 800d134:	42b4      	cmp	r4, r6
 800d136:	d0e3      	beq.n	800d100 <core_compute_offsets+0xc8>
 800d138:	9e01      	ldr	r6, [sp, #4]
 800d13a:	42b5      	cmp	r5, r6
 800d13c:	d0e0      	beq.n	800d100 <core_compute_offsets+0xc8>
 800d13e:	ebb1 010c 	subs.w	r1, r1, ip
 800d142:	bf18      	it	ne
 800d144:	2101      	movne	r1, #1
 800d146:	e7dc      	b.n	800d102 <core_compute_offsets+0xca>
 800d148:	9f01      	ldr	r7, [sp, #4]
 800d14a:	42bd      	cmp	r5, r7
 800d14c:	d0c1      	beq.n	800d0d2 <core_compute_offsets+0x9a>
 800d14e:	ebb1 0b0c 	subs.w	fp, r1, ip
 800d152:	bf18      	it	ne
 800d154:	f04f 0b01 	movne.w	fp, #1
 800d158:	e7bd      	b.n	800d0d6 <core_compute_offsets+0x9e>
 800d15a:	bf00      	nop

0800d15c <sbrk_aligned>:
 800d15c:	b570      	push	{r4, r5, r6, lr}
 800d15e:	4e0e      	ldr	r6, [pc, #56]	; (800d198 <sbrk_aligned+0x3c>)
 800d160:	460c      	mov	r4, r1
 800d162:	6831      	ldr	r1, [r6, #0]
 800d164:	4605      	mov	r5, r0
 800d166:	b911      	cbnz	r1, 800d16e <sbrk_aligned+0x12>
 800d168:	f000 fae8 	bl	800d73c <_sbrk_r>
 800d16c:	6030      	str	r0, [r6, #0]
 800d16e:	4621      	mov	r1, r4
 800d170:	4628      	mov	r0, r5
 800d172:	f000 fae3 	bl	800d73c <_sbrk_r>
 800d176:	1c43      	adds	r3, r0, #1
 800d178:	d00a      	beq.n	800d190 <sbrk_aligned+0x34>
 800d17a:	1cc4      	adds	r4, r0, #3
 800d17c:	f024 0403 	bic.w	r4, r4, #3
 800d180:	42a0      	cmp	r0, r4
 800d182:	d007      	beq.n	800d194 <sbrk_aligned+0x38>
 800d184:	1a21      	subs	r1, r4, r0
 800d186:	4628      	mov	r0, r5
 800d188:	f000 fad8 	bl	800d73c <_sbrk_r>
 800d18c:	3001      	adds	r0, #1
 800d18e:	d101      	bne.n	800d194 <sbrk_aligned+0x38>
 800d190:	f04f 34ff 	mov.w	r4, #4294967295
 800d194:	4620      	mov	r0, r4
 800d196:	bd70      	pop	{r4, r5, r6, pc}
 800d198:	200030b0 	.word	0x200030b0

0800d19c <_malloc_r>:
 800d19c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d1a0:	1ccd      	adds	r5, r1, #3
 800d1a2:	f025 0503 	bic.w	r5, r5, #3
 800d1a6:	3508      	adds	r5, #8
 800d1a8:	2d0c      	cmp	r5, #12
 800d1aa:	bf38      	it	cc
 800d1ac:	250c      	movcc	r5, #12
 800d1ae:	2d00      	cmp	r5, #0
 800d1b0:	4607      	mov	r7, r0
 800d1b2:	db01      	blt.n	800d1b8 <_malloc_r+0x1c>
 800d1b4:	42a9      	cmp	r1, r5
 800d1b6:	d905      	bls.n	800d1c4 <_malloc_r+0x28>
 800d1b8:	230c      	movs	r3, #12
 800d1ba:	603b      	str	r3, [r7, #0]
 800d1bc:	2600      	movs	r6, #0
 800d1be:	4630      	mov	r0, r6
 800d1c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d1c4:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800d298 <_malloc_r+0xfc>
 800d1c8:	f000 f868 	bl	800d29c <__malloc_lock>
 800d1cc:	f8d8 3000 	ldr.w	r3, [r8]
 800d1d0:	461c      	mov	r4, r3
 800d1d2:	bb5c      	cbnz	r4, 800d22c <_malloc_r+0x90>
 800d1d4:	4629      	mov	r1, r5
 800d1d6:	4638      	mov	r0, r7
 800d1d8:	f7ff ffc0 	bl	800d15c <sbrk_aligned>
 800d1dc:	1c43      	adds	r3, r0, #1
 800d1de:	4604      	mov	r4, r0
 800d1e0:	d155      	bne.n	800d28e <_malloc_r+0xf2>
 800d1e2:	f8d8 4000 	ldr.w	r4, [r8]
 800d1e6:	4626      	mov	r6, r4
 800d1e8:	2e00      	cmp	r6, #0
 800d1ea:	d145      	bne.n	800d278 <_malloc_r+0xdc>
 800d1ec:	2c00      	cmp	r4, #0
 800d1ee:	d048      	beq.n	800d282 <_malloc_r+0xe6>
 800d1f0:	6823      	ldr	r3, [r4, #0]
 800d1f2:	4631      	mov	r1, r6
 800d1f4:	4638      	mov	r0, r7
 800d1f6:	eb04 0903 	add.w	r9, r4, r3
 800d1fa:	f000 fa9f 	bl	800d73c <_sbrk_r>
 800d1fe:	4581      	cmp	r9, r0
 800d200:	d13f      	bne.n	800d282 <_malloc_r+0xe6>
 800d202:	6821      	ldr	r1, [r4, #0]
 800d204:	1a6d      	subs	r5, r5, r1
 800d206:	4629      	mov	r1, r5
 800d208:	4638      	mov	r0, r7
 800d20a:	f7ff ffa7 	bl	800d15c <sbrk_aligned>
 800d20e:	3001      	adds	r0, #1
 800d210:	d037      	beq.n	800d282 <_malloc_r+0xe6>
 800d212:	6823      	ldr	r3, [r4, #0]
 800d214:	442b      	add	r3, r5
 800d216:	6023      	str	r3, [r4, #0]
 800d218:	f8d8 3000 	ldr.w	r3, [r8]
 800d21c:	2b00      	cmp	r3, #0
 800d21e:	d038      	beq.n	800d292 <_malloc_r+0xf6>
 800d220:	685a      	ldr	r2, [r3, #4]
 800d222:	42a2      	cmp	r2, r4
 800d224:	d12b      	bne.n	800d27e <_malloc_r+0xe2>
 800d226:	2200      	movs	r2, #0
 800d228:	605a      	str	r2, [r3, #4]
 800d22a:	e00f      	b.n	800d24c <_malloc_r+0xb0>
 800d22c:	6822      	ldr	r2, [r4, #0]
 800d22e:	1b52      	subs	r2, r2, r5
 800d230:	d41f      	bmi.n	800d272 <_malloc_r+0xd6>
 800d232:	2a0b      	cmp	r2, #11
 800d234:	d917      	bls.n	800d266 <_malloc_r+0xca>
 800d236:	1961      	adds	r1, r4, r5
 800d238:	42a3      	cmp	r3, r4
 800d23a:	6025      	str	r5, [r4, #0]
 800d23c:	bf18      	it	ne
 800d23e:	6059      	strne	r1, [r3, #4]
 800d240:	6863      	ldr	r3, [r4, #4]
 800d242:	bf08      	it	eq
 800d244:	f8c8 1000 	streq.w	r1, [r8]
 800d248:	5162      	str	r2, [r4, r5]
 800d24a:	604b      	str	r3, [r1, #4]
 800d24c:	4638      	mov	r0, r7
 800d24e:	f104 060b 	add.w	r6, r4, #11
 800d252:	f000 f829 	bl	800d2a8 <__malloc_unlock>
 800d256:	f026 0607 	bic.w	r6, r6, #7
 800d25a:	1d23      	adds	r3, r4, #4
 800d25c:	1af2      	subs	r2, r6, r3
 800d25e:	d0ae      	beq.n	800d1be <_malloc_r+0x22>
 800d260:	1b9b      	subs	r3, r3, r6
 800d262:	50a3      	str	r3, [r4, r2]
 800d264:	e7ab      	b.n	800d1be <_malloc_r+0x22>
 800d266:	42a3      	cmp	r3, r4
 800d268:	6862      	ldr	r2, [r4, #4]
 800d26a:	d1dd      	bne.n	800d228 <_malloc_r+0x8c>
 800d26c:	f8c8 2000 	str.w	r2, [r8]
 800d270:	e7ec      	b.n	800d24c <_malloc_r+0xb0>
 800d272:	4623      	mov	r3, r4
 800d274:	6864      	ldr	r4, [r4, #4]
 800d276:	e7ac      	b.n	800d1d2 <_malloc_r+0x36>
 800d278:	4634      	mov	r4, r6
 800d27a:	6876      	ldr	r6, [r6, #4]
 800d27c:	e7b4      	b.n	800d1e8 <_malloc_r+0x4c>
 800d27e:	4613      	mov	r3, r2
 800d280:	e7cc      	b.n	800d21c <_malloc_r+0x80>
 800d282:	230c      	movs	r3, #12
 800d284:	603b      	str	r3, [r7, #0]
 800d286:	4638      	mov	r0, r7
 800d288:	f000 f80e 	bl	800d2a8 <__malloc_unlock>
 800d28c:	e797      	b.n	800d1be <_malloc_r+0x22>
 800d28e:	6025      	str	r5, [r4, #0]
 800d290:	e7dc      	b.n	800d24c <_malloc_r+0xb0>
 800d292:	605b      	str	r3, [r3, #4]
 800d294:	deff      	udf	#255	; 0xff
 800d296:	bf00      	nop
 800d298:	200030ac 	.word	0x200030ac

0800d29c <__malloc_lock>:
 800d29c:	4801      	ldr	r0, [pc, #4]	; (800d2a4 <__malloc_lock+0x8>)
 800d29e:	f000 ba9a 	b.w	800d7d6 <__retarget_lock_acquire_recursive>
 800d2a2:	bf00      	nop
 800d2a4:	200031f4 	.word	0x200031f4

0800d2a8 <__malloc_unlock>:
 800d2a8:	4801      	ldr	r0, [pc, #4]	; (800d2b0 <__malloc_unlock+0x8>)
 800d2aa:	f000 ba95 	b.w	800d7d8 <__retarget_lock_release_recursive>
 800d2ae:	bf00      	nop
 800d2b0:	200031f4 	.word	0x200031f4

0800d2b4 <std>:
 800d2b4:	2300      	movs	r3, #0
 800d2b6:	b510      	push	{r4, lr}
 800d2b8:	4604      	mov	r4, r0
 800d2ba:	e9c0 3300 	strd	r3, r3, [r0]
 800d2be:	e9c0 3304 	strd	r3, r3, [r0, #16]
 800d2c2:	6083      	str	r3, [r0, #8]
 800d2c4:	8181      	strh	r1, [r0, #12]
 800d2c6:	6643      	str	r3, [r0, #100]	; 0x64
 800d2c8:	81c2      	strh	r2, [r0, #14]
 800d2ca:	6183      	str	r3, [r0, #24]
 800d2cc:	4619      	mov	r1, r3
 800d2ce:	2208      	movs	r2, #8
 800d2d0:	305c      	adds	r0, #92	; 0x5c
 800d2d2:	f000 f9f7 	bl	800d6c4 <memset>
 800d2d6:	4b0d      	ldr	r3, [pc, #52]	; (800d30c <std+0x58>)
 800d2d8:	6263      	str	r3, [r4, #36]	; 0x24
 800d2da:	4b0d      	ldr	r3, [pc, #52]	; (800d310 <std+0x5c>)
 800d2dc:	62a3      	str	r3, [r4, #40]	; 0x28
 800d2de:	4b0d      	ldr	r3, [pc, #52]	; (800d314 <std+0x60>)
 800d2e0:	62e3      	str	r3, [r4, #44]	; 0x2c
 800d2e2:	4b0d      	ldr	r3, [pc, #52]	; (800d318 <std+0x64>)
 800d2e4:	6323      	str	r3, [r4, #48]	; 0x30
 800d2e6:	4b0d      	ldr	r3, [pc, #52]	; (800d31c <std+0x68>)
 800d2e8:	6224      	str	r4, [r4, #32]
 800d2ea:	429c      	cmp	r4, r3
 800d2ec:	d006      	beq.n	800d2fc <std+0x48>
 800d2ee:	f103 0268 	add.w	r2, r3, #104	; 0x68
 800d2f2:	4294      	cmp	r4, r2
 800d2f4:	d002      	beq.n	800d2fc <std+0x48>
 800d2f6:	33d0      	adds	r3, #208	; 0xd0
 800d2f8:	429c      	cmp	r4, r3
 800d2fa:	d105      	bne.n	800d308 <std+0x54>
 800d2fc:	f104 0058 	add.w	r0, r4, #88	; 0x58
 800d300:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d304:	f000 ba66 	b.w	800d7d4 <__retarget_lock_init_recursive>
 800d308:	bd10      	pop	{r4, pc}
 800d30a:	bf00      	nop
 800d30c:	0800d515 	.word	0x0800d515
 800d310:	0800d537 	.word	0x0800d537
 800d314:	0800d56f 	.word	0x0800d56f
 800d318:	0800d593 	.word	0x0800d593
 800d31c:	200030b4 	.word	0x200030b4

0800d320 <stdio_exit_handler>:
 800d320:	4a02      	ldr	r2, [pc, #8]	; (800d32c <stdio_exit_handler+0xc>)
 800d322:	4903      	ldr	r1, [pc, #12]	; (800d330 <stdio_exit_handler+0x10>)
 800d324:	4803      	ldr	r0, [pc, #12]	; (800d334 <stdio_exit_handler+0x14>)
 800d326:	f000 b869 	b.w	800d3fc <_fwalk_sglue>
 800d32a:	bf00      	nop
 800d32c:	200014b0 	.word	0x200014b0
 800d330:	0800df45 	.word	0x0800df45
 800d334:	200014bc 	.word	0x200014bc

0800d338 <cleanup_stdio>:
 800d338:	6841      	ldr	r1, [r0, #4]
 800d33a:	4b0c      	ldr	r3, [pc, #48]	; (800d36c <cleanup_stdio+0x34>)
 800d33c:	4299      	cmp	r1, r3
 800d33e:	b510      	push	{r4, lr}
 800d340:	4604      	mov	r4, r0
 800d342:	d001      	beq.n	800d348 <cleanup_stdio+0x10>
 800d344:	f000 fdfe 	bl	800df44 <_fflush_r>
 800d348:	68a1      	ldr	r1, [r4, #8]
 800d34a:	4b09      	ldr	r3, [pc, #36]	; (800d370 <cleanup_stdio+0x38>)
 800d34c:	4299      	cmp	r1, r3
 800d34e:	d002      	beq.n	800d356 <cleanup_stdio+0x1e>
 800d350:	4620      	mov	r0, r4
 800d352:	f000 fdf7 	bl	800df44 <_fflush_r>
 800d356:	68e1      	ldr	r1, [r4, #12]
 800d358:	4b06      	ldr	r3, [pc, #24]	; (800d374 <cleanup_stdio+0x3c>)
 800d35a:	4299      	cmp	r1, r3
 800d35c:	d004      	beq.n	800d368 <cleanup_stdio+0x30>
 800d35e:	4620      	mov	r0, r4
 800d360:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d364:	f000 bdee 	b.w	800df44 <_fflush_r>
 800d368:	bd10      	pop	{r4, pc}
 800d36a:	bf00      	nop
 800d36c:	200030b4 	.word	0x200030b4
 800d370:	2000311c 	.word	0x2000311c
 800d374:	20003184 	.word	0x20003184

0800d378 <global_stdio_init.part.0>:
 800d378:	b510      	push	{r4, lr}
 800d37a:	4b0b      	ldr	r3, [pc, #44]	; (800d3a8 <global_stdio_init.part.0+0x30>)
 800d37c:	4c0b      	ldr	r4, [pc, #44]	; (800d3ac <global_stdio_init.part.0+0x34>)
 800d37e:	4a0c      	ldr	r2, [pc, #48]	; (800d3b0 <global_stdio_init.part.0+0x38>)
 800d380:	601a      	str	r2, [r3, #0]
 800d382:	4620      	mov	r0, r4
 800d384:	2200      	movs	r2, #0
 800d386:	2104      	movs	r1, #4
 800d388:	f7ff ff94 	bl	800d2b4 <std>
 800d38c:	f104 0068 	add.w	r0, r4, #104	; 0x68
 800d390:	2201      	movs	r2, #1
 800d392:	2109      	movs	r1, #9
 800d394:	f7ff ff8e 	bl	800d2b4 <std>
 800d398:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 800d39c:	2202      	movs	r2, #2
 800d39e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3a2:	2112      	movs	r1, #18
 800d3a4:	f7ff bf86 	b.w	800d2b4 <std>
 800d3a8:	200031ec 	.word	0x200031ec
 800d3ac:	200030b4 	.word	0x200030b4
 800d3b0:	0800d321 	.word	0x0800d321

0800d3b4 <__sfp_lock_acquire>:
 800d3b4:	4801      	ldr	r0, [pc, #4]	; (800d3bc <__sfp_lock_acquire+0x8>)
 800d3b6:	f000 ba0e 	b.w	800d7d6 <__retarget_lock_acquire_recursive>
 800d3ba:	bf00      	nop
 800d3bc:	200031f5 	.word	0x200031f5

0800d3c0 <__sfp_lock_release>:
 800d3c0:	4801      	ldr	r0, [pc, #4]	; (800d3c8 <__sfp_lock_release+0x8>)
 800d3c2:	f000 ba09 	b.w	800d7d8 <__retarget_lock_release_recursive>
 800d3c6:	bf00      	nop
 800d3c8:	200031f5 	.word	0x200031f5

0800d3cc <__sinit>:
 800d3cc:	b510      	push	{r4, lr}
 800d3ce:	4604      	mov	r4, r0
 800d3d0:	f7ff fff0 	bl	800d3b4 <__sfp_lock_acquire>
 800d3d4:	6a23      	ldr	r3, [r4, #32]
 800d3d6:	b11b      	cbz	r3, 800d3e0 <__sinit+0x14>
 800d3d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3dc:	f7ff bff0 	b.w	800d3c0 <__sfp_lock_release>
 800d3e0:	4b04      	ldr	r3, [pc, #16]	; (800d3f4 <__sinit+0x28>)
 800d3e2:	6223      	str	r3, [r4, #32]
 800d3e4:	4b04      	ldr	r3, [pc, #16]	; (800d3f8 <__sinit+0x2c>)
 800d3e6:	681b      	ldr	r3, [r3, #0]
 800d3e8:	2b00      	cmp	r3, #0
 800d3ea:	d1f5      	bne.n	800d3d8 <__sinit+0xc>
 800d3ec:	f7ff ffc4 	bl	800d378 <global_stdio_init.part.0>
 800d3f0:	e7f2      	b.n	800d3d8 <__sinit+0xc>
 800d3f2:	bf00      	nop
 800d3f4:	0800d339 	.word	0x0800d339
 800d3f8:	200031ec 	.word	0x200031ec

0800d3fc <_fwalk_sglue>:
 800d3fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d400:	4607      	mov	r7, r0
 800d402:	4688      	mov	r8, r1
 800d404:	4614      	mov	r4, r2
 800d406:	2600      	movs	r6, #0
 800d408:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 800d40c:	f1b9 0901 	subs.w	r9, r9, #1
 800d410:	d505      	bpl.n	800d41e <_fwalk_sglue+0x22>
 800d412:	6824      	ldr	r4, [r4, #0]
 800d414:	2c00      	cmp	r4, #0
 800d416:	d1f7      	bne.n	800d408 <_fwalk_sglue+0xc>
 800d418:	4630      	mov	r0, r6
 800d41a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d41e:	89ab      	ldrh	r3, [r5, #12]
 800d420:	2b01      	cmp	r3, #1
 800d422:	d907      	bls.n	800d434 <_fwalk_sglue+0x38>
 800d424:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800d428:	3301      	adds	r3, #1
 800d42a:	d003      	beq.n	800d434 <_fwalk_sglue+0x38>
 800d42c:	4629      	mov	r1, r5
 800d42e:	4638      	mov	r0, r7
 800d430:	47c0      	blx	r8
 800d432:	4306      	orrs	r6, r0
 800d434:	3568      	adds	r5, #104	; 0x68
 800d436:	e7e9      	b.n	800d40c <_fwalk_sglue+0x10>

0800d438 <iprintf>:
 800d438:	b40f      	push	{r0, r1, r2, r3}
 800d43a:	b507      	push	{r0, r1, r2, lr}
 800d43c:	4906      	ldr	r1, [pc, #24]	; (800d458 <iprintf+0x20>)
 800d43e:	ab04      	add	r3, sp, #16
 800d440:	6808      	ldr	r0, [r1, #0]
 800d442:	f853 2b04 	ldr.w	r2, [r3], #4
 800d446:	6881      	ldr	r1, [r0, #8]
 800d448:	9301      	str	r3, [sp, #4]
 800d44a:	f000 fa4b 	bl	800d8e4 <_vfiprintf_r>
 800d44e:	b003      	add	sp, #12
 800d450:	f85d eb04 	ldr.w	lr, [sp], #4
 800d454:	b004      	add	sp, #16
 800d456:	4770      	bx	lr
 800d458:	20001508 	.word	0x20001508

0800d45c <_puts_r>:
 800d45c:	6a03      	ldr	r3, [r0, #32]
 800d45e:	b570      	push	{r4, r5, r6, lr}
 800d460:	6884      	ldr	r4, [r0, #8]
 800d462:	4605      	mov	r5, r0
 800d464:	460e      	mov	r6, r1
 800d466:	b90b      	cbnz	r3, 800d46c <_puts_r+0x10>
 800d468:	f7ff ffb0 	bl	800d3cc <__sinit>
 800d46c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d46e:	07db      	lsls	r3, r3, #31
 800d470:	d405      	bmi.n	800d47e <_puts_r+0x22>
 800d472:	89a3      	ldrh	r3, [r4, #12]
 800d474:	0598      	lsls	r0, r3, #22
 800d476:	d402      	bmi.n	800d47e <_puts_r+0x22>
 800d478:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800d47a:	f000 f9ac 	bl	800d7d6 <__retarget_lock_acquire_recursive>
 800d47e:	89a3      	ldrh	r3, [r4, #12]
 800d480:	0719      	lsls	r1, r3, #28
 800d482:	d513      	bpl.n	800d4ac <_puts_r+0x50>
 800d484:	6923      	ldr	r3, [r4, #16]
 800d486:	b18b      	cbz	r3, 800d4ac <_puts_r+0x50>
 800d488:	3e01      	subs	r6, #1
 800d48a:	68a3      	ldr	r3, [r4, #8]
 800d48c:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800d490:	3b01      	subs	r3, #1
 800d492:	60a3      	str	r3, [r4, #8]
 800d494:	b9e9      	cbnz	r1, 800d4d2 <_puts_r+0x76>
 800d496:	2b00      	cmp	r3, #0
 800d498:	da2e      	bge.n	800d4f8 <_puts_r+0x9c>
 800d49a:	4622      	mov	r2, r4
 800d49c:	210a      	movs	r1, #10
 800d49e:	4628      	mov	r0, r5
 800d4a0:	f000 f87b 	bl	800d59a <__swbuf_r>
 800d4a4:	3001      	adds	r0, #1
 800d4a6:	d007      	beq.n	800d4b8 <_puts_r+0x5c>
 800d4a8:	250a      	movs	r5, #10
 800d4aa:	e007      	b.n	800d4bc <_puts_r+0x60>
 800d4ac:	4621      	mov	r1, r4
 800d4ae:	4628      	mov	r0, r5
 800d4b0:	f000 f8b0 	bl	800d614 <__swsetup_r>
 800d4b4:	2800      	cmp	r0, #0
 800d4b6:	d0e7      	beq.n	800d488 <_puts_r+0x2c>
 800d4b8:	f04f 35ff 	mov.w	r5, #4294967295
 800d4bc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d4be:	07da      	lsls	r2, r3, #31
 800d4c0:	d405      	bmi.n	800d4ce <_puts_r+0x72>
 800d4c2:	89a3      	ldrh	r3, [r4, #12]
 800d4c4:	059b      	lsls	r3, r3, #22
 800d4c6:	d402      	bmi.n	800d4ce <_puts_r+0x72>
 800d4c8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800d4ca:	f000 f985 	bl	800d7d8 <__retarget_lock_release_recursive>
 800d4ce:	4628      	mov	r0, r5
 800d4d0:	bd70      	pop	{r4, r5, r6, pc}
 800d4d2:	2b00      	cmp	r3, #0
 800d4d4:	da04      	bge.n	800d4e0 <_puts_r+0x84>
 800d4d6:	69a2      	ldr	r2, [r4, #24]
 800d4d8:	429a      	cmp	r2, r3
 800d4da:	dc06      	bgt.n	800d4ea <_puts_r+0x8e>
 800d4dc:	290a      	cmp	r1, #10
 800d4de:	d004      	beq.n	800d4ea <_puts_r+0x8e>
 800d4e0:	6823      	ldr	r3, [r4, #0]
 800d4e2:	1c5a      	adds	r2, r3, #1
 800d4e4:	6022      	str	r2, [r4, #0]
 800d4e6:	7019      	strb	r1, [r3, #0]
 800d4e8:	e7cf      	b.n	800d48a <_puts_r+0x2e>
 800d4ea:	4622      	mov	r2, r4
 800d4ec:	4628      	mov	r0, r5
 800d4ee:	f000 f854 	bl	800d59a <__swbuf_r>
 800d4f2:	3001      	adds	r0, #1
 800d4f4:	d1c9      	bne.n	800d48a <_puts_r+0x2e>
 800d4f6:	e7df      	b.n	800d4b8 <_puts_r+0x5c>
 800d4f8:	6823      	ldr	r3, [r4, #0]
 800d4fa:	250a      	movs	r5, #10
 800d4fc:	1c5a      	adds	r2, r3, #1
 800d4fe:	6022      	str	r2, [r4, #0]
 800d500:	701d      	strb	r5, [r3, #0]
 800d502:	e7db      	b.n	800d4bc <_puts_r+0x60>

0800d504 <puts>:
 800d504:	4b02      	ldr	r3, [pc, #8]	; (800d510 <puts+0xc>)
 800d506:	4601      	mov	r1, r0
 800d508:	6818      	ldr	r0, [r3, #0]
 800d50a:	f7ff bfa7 	b.w	800d45c <_puts_r>
 800d50e:	bf00      	nop
 800d510:	20001508 	.word	0x20001508

0800d514 <__sread>:
 800d514:	b510      	push	{r4, lr}
 800d516:	460c      	mov	r4, r1
 800d518:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d51c:	f000 f8fc 	bl	800d718 <_read_r>
 800d520:	2800      	cmp	r0, #0
 800d522:	bfab      	itete	ge
 800d524:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800d526:	89a3      	ldrhlt	r3, [r4, #12]
 800d528:	181b      	addge	r3, r3, r0
 800d52a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800d52e:	bfac      	ite	ge
 800d530:	6563      	strge	r3, [r4, #84]	; 0x54
 800d532:	81a3      	strhlt	r3, [r4, #12]
 800d534:	bd10      	pop	{r4, pc}

0800d536 <__swrite>:
 800d536:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d53a:	461f      	mov	r7, r3
 800d53c:	898b      	ldrh	r3, [r1, #12]
 800d53e:	05db      	lsls	r3, r3, #23
 800d540:	4605      	mov	r5, r0
 800d542:	460c      	mov	r4, r1
 800d544:	4616      	mov	r6, r2
 800d546:	d505      	bpl.n	800d554 <__swrite+0x1e>
 800d548:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d54c:	2302      	movs	r3, #2
 800d54e:	2200      	movs	r2, #0
 800d550:	f000 f8d0 	bl	800d6f4 <_lseek_r>
 800d554:	89a3      	ldrh	r3, [r4, #12]
 800d556:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d55a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800d55e:	81a3      	strh	r3, [r4, #12]
 800d560:	4632      	mov	r2, r6
 800d562:	463b      	mov	r3, r7
 800d564:	4628      	mov	r0, r5
 800d566:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800d56a:	f000 b8f7 	b.w	800d75c <_write_r>

0800d56e <__sseek>:
 800d56e:	b510      	push	{r4, lr}
 800d570:	460c      	mov	r4, r1
 800d572:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d576:	f000 f8bd 	bl	800d6f4 <_lseek_r>
 800d57a:	1c43      	adds	r3, r0, #1
 800d57c:	89a3      	ldrh	r3, [r4, #12]
 800d57e:	bf15      	itete	ne
 800d580:	6560      	strne	r0, [r4, #84]	; 0x54
 800d582:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800d586:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800d58a:	81a3      	strheq	r3, [r4, #12]
 800d58c:	bf18      	it	ne
 800d58e:	81a3      	strhne	r3, [r4, #12]
 800d590:	bd10      	pop	{r4, pc}

0800d592 <__sclose>:
 800d592:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d596:	f000 b89d 	b.w	800d6d4 <_close_r>

0800d59a <__swbuf_r>:
 800d59a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d59c:	460e      	mov	r6, r1
 800d59e:	4614      	mov	r4, r2
 800d5a0:	4605      	mov	r5, r0
 800d5a2:	b118      	cbz	r0, 800d5ac <__swbuf_r+0x12>
 800d5a4:	6a03      	ldr	r3, [r0, #32]
 800d5a6:	b90b      	cbnz	r3, 800d5ac <__swbuf_r+0x12>
 800d5a8:	f7ff ff10 	bl	800d3cc <__sinit>
 800d5ac:	69a3      	ldr	r3, [r4, #24]
 800d5ae:	60a3      	str	r3, [r4, #8]
 800d5b0:	89a3      	ldrh	r3, [r4, #12]
 800d5b2:	071a      	lsls	r2, r3, #28
 800d5b4:	d525      	bpl.n	800d602 <__swbuf_r+0x68>
 800d5b6:	6923      	ldr	r3, [r4, #16]
 800d5b8:	b31b      	cbz	r3, 800d602 <__swbuf_r+0x68>
 800d5ba:	6823      	ldr	r3, [r4, #0]
 800d5bc:	6922      	ldr	r2, [r4, #16]
 800d5be:	1a98      	subs	r0, r3, r2
 800d5c0:	6963      	ldr	r3, [r4, #20]
 800d5c2:	b2f6      	uxtb	r6, r6
 800d5c4:	4283      	cmp	r3, r0
 800d5c6:	4637      	mov	r7, r6
 800d5c8:	dc04      	bgt.n	800d5d4 <__swbuf_r+0x3a>
 800d5ca:	4621      	mov	r1, r4
 800d5cc:	4628      	mov	r0, r5
 800d5ce:	f000 fcb9 	bl	800df44 <_fflush_r>
 800d5d2:	b9e0      	cbnz	r0, 800d60e <__swbuf_r+0x74>
 800d5d4:	68a3      	ldr	r3, [r4, #8]
 800d5d6:	3b01      	subs	r3, #1
 800d5d8:	60a3      	str	r3, [r4, #8]
 800d5da:	6823      	ldr	r3, [r4, #0]
 800d5dc:	1c5a      	adds	r2, r3, #1
 800d5de:	6022      	str	r2, [r4, #0]
 800d5e0:	701e      	strb	r6, [r3, #0]
 800d5e2:	6962      	ldr	r2, [r4, #20]
 800d5e4:	1c43      	adds	r3, r0, #1
 800d5e6:	429a      	cmp	r2, r3
 800d5e8:	d004      	beq.n	800d5f4 <__swbuf_r+0x5a>
 800d5ea:	89a3      	ldrh	r3, [r4, #12]
 800d5ec:	07db      	lsls	r3, r3, #31
 800d5ee:	d506      	bpl.n	800d5fe <__swbuf_r+0x64>
 800d5f0:	2e0a      	cmp	r6, #10
 800d5f2:	d104      	bne.n	800d5fe <__swbuf_r+0x64>
 800d5f4:	4621      	mov	r1, r4
 800d5f6:	4628      	mov	r0, r5
 800d5f8:	f000 fca4 	bl	800df44 <_fflush_r>
 800d5fc:	b938      	cbnz	r0, 800d60e <__swbuf_r+0x74>
 800d5fe:	4638      	mov	r0, r7
 800d600:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d602:	4621      	mov	r1, r4
 800d604:	4628      	mov	r0, r5
 800d606:	f000 f805 	bl	800d614 <__swsetup_r>
 800d60a:	2800      	cmp	r0, #0
 800d60c:	d0d5      	beq.n	800d5ba <__swbuf_r+0x20>
 800d60e:	f04f 37ff 	mov.w	r7, #4294967295
 800d612:	e7f4      	b.n	800d5fe <__swbuf_r+0x64>

0800d614 <__swsetup_r>:
 800d614:	b538      	push	{r3, r4, r5, lr}
 800d616:	4b2a      	ldr	r3, [pc, #168]	; (800d6c0 <__swsetup_r+0xac>)
 800d618:	4605      	mov	r5, r0
 800d61a:	6818      	ldr	r0, [r3, #0]
 800d61c:	460c      	mov	r4, r1
 800d61e:	b118      	cbz	r0, 800d628 <__swsetup_r+0x14>
 800d620:	6a03      	ldr	r3, [r0, #32]
 800d622:	b90b      	cbnz	r3, 800d628 <__swsetup_r+0x14>
 800d624:	f7ff fed2 	bl	800d3cc <__sinit>
 800d628:	89a3      	ldrh	r3, [r4, #12]
 800d62a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800d62e:	0718      	lsls	r0, r3, #28
 800d630:	d422      	bmi.n	800d678 <__swsetup_r+0x64>
 800d632:	06d9      	lsls	r1, r3, #27
 800d634:	d407      	bmi.n	800d646 <__swsetup_r+0x32>
 800d636:	2309      	movs	r3, #9
 800d638:	602b      	str	r3, [r5, #0]
 800d63a:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 800d63e:	81a3      	strh	r3, [r4, #12]
 800d640:	f04f 30ff 	mov.w	r0, #4294967295
 800d644:	e034      	b.n	800d6b0 <__swsetup_r+0x9c>
 800d646:	0758      	lsls	r0, r3, #29
 800d648:	d512      	bpl.n	800d670 <__swsetup_r+0x5c>
 800d64a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d64c:	b141      	cbz	r1, 800d660 <__swsetup_r+0x4c>
 800d64e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800d652:	4299      	cmp	r1, r3
 800d654:	d002      	beq.n	800d65c <__swsetup_r+0x48>
 800d656:	4628      	mov	r0, r5
 800d658:	f000 f8ce 	bl	800d7f8 <_free_r>
 800d65c:	2300      	movs	r3, #0
 800d65e:	6363      	str	r3, [r4, #52]	; 0x34
 800d660:	89a3      	ldrh	r3, [r4, #12]
 800d662:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800d666:	81a3      	strh	r3, [r4, #12]
 800d668:	2300      	movs	r3, #0
 800d66a:	6063      	str	r3, [r4, #4]
 800d66c:	6923      	ldr	r3, [r4, #16]
 800d66e:	6023      	str	r3, [r4, #0]
 800d670:	89a3      	ldrh	r3, [r4, #12]
 800d672:	f043 0308 	orr.w	r3, r3, #8
 800d676:	81a3      	strh	r3, [r4, #12]
 800d678:	6923      	ldr	r3, [r4, #16]
 800d67a:	b94b      	cbnz	r3, 800d690 <__swsetup_r+0x7c>
 800d67c:	89a3      	ldrh	r3, [r4, #12]
 800d67e:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800d682:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800d686:	d003      	beq.n	800d690 <__swsetup_r+0x7c>
 800d688:	4621      	mov	r1, r4
 800d68a:	4628      	mov	r0, r5
 800d68c:	f000 fca8 	bl	800dfe0 <__smakebuf_r>
 800d690:	89a0      	ldrh	r0, [r4, #12]
 800d692:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800d696:	f010 0301 	ands.w	r3, r0, #1
 800d69a:	d00a      	beq.n	800d6b2 <__swsetup_r+0x9e>
 800d69c:	2300      	movs	r3, #0
 800d69e:	60a3      	str	r3, [r4, #8]
 800d6a0:	6963      	ldr	r3, [r4, #20]
 800d6a2:	425b      	negs	r3, r3
 800d6a4:	61a3      	str	r3, [r4, #24]
 800d6a6:	6923      	ldr	r3, [r4, #16]
 800d6a8:	b943      	cbnz	r3, 800d6bc <__swsetup_r+0xa8>
 800d6aa:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800d6ae:	d1c4      	bne.n	800d63a <__swsetup_r+0x26>
 800d6b0:	bd38      	pop	{r3, r4, r5, pc}
 800d6b2:	0781      	lsls	r1, r0, #30
 800d6b4:	bf58      	it	pl
 800d6b6:	6963      	ldrpl	r3, [r4, #20]
 800d6b8:	60a3      	str	r3, [r4, #8]
 800d6ba:	e7f4      	b.n	800d6a6 <__swsetup_r+0x92>
 800d6bc:	2000      	movs	r0, #0
 800d6be:	e7f7      	b.n	800d6b0 <__swsetup_r+0x9c>
 800d6c0:	20001508 	.word	0x20001508

0800d6c4 <memset>:
 800d6c4:	4402      	add	r2, r0
 800d6c6:	4603      	mov	r3, r0
 800d6c8:	4293      	cmp	r3, r2
 800d6ca:	d100      	bne.n	800d6ce <memset+0xa>
 800d6cc:	4770      	bx	lr
 800d6ce:	f803 1b01 	strb.w	r1, [r3], #1
 800d6d2:	e7f9      	b.n	800d6c8 <memset+0x4>

0800d6d4 <_close_r>:
 800d6d4:	b538      	push	{r3, r4, r5, lr}
 800d6d6:	4d06      	ldr	r5, [pc, #24]	; (800d6f0 <_close_r+0x1c>)
 800d6d8:	2300      	movs	r3, #0
 800d6da:	4604      	mov	r4, r0
 800d6dc:	4608      	mov	r0, r1
 800d6de:	602b      	str	r3, [r5, #0]
 800d6e0:	f001 fb8e 	bl	800ee00 <_close>
 800d6e4:	1c43      	adds	r3, r0, #1
 800d6e6:	d102      	bne.n	800d6ee <_close_r+0x1a>
 800d6e8:	682b      	ldr	r3, [r5, #0]
 800d6ea:	b103      	cbz	r3, 800d6ee <_close_r+0x1a>
 800d6ec:	6023      	str	r3, [r4, #0]
 800d6ee:	bd38      	pop	{r3, r4, r5, pc}
 800d6f0:	200031f0 	.word	0x200031f0

0800d6f4 <_lseek_r>:
 800d6f4:	b538      	push	{r3, r4, r5, lr}
 800d6f6:	4d07      	ldr	r5, [pc, #28]	; (800d714 <_lseek_r+0x20>)
 800d6f8:	4604      	mov	r4, r0
 800d6fa:	4608      	mov	r0, r1
 800d6fc:	4611      	mov	r1, r2
 800d6fe:	2200      	movs	r2, #0
 800d700:	602a      	str	r2, [r5, #0]
 800d702:	461a      	mov	r2, r3
 800d704:	f001 fb94 	bl	800ee30 <_lseek>
 800d708:	1c43      	adds	r3, r0, #1
 800d70a:	d102      	bne.n	800d712 <_lseek_r+0x1e>
 800d70c:	682b      	ldr	r3, [r5, #0]
 800d70e:	b103      	cbz	r3, 800d712 <_lseek_r+0x1e>
 800d710:	6023      	str	r3, [r4, #0]
 800d712:	bd38      	pop	{r3, r4, r5, pc}
 800d714:	200031f0 	.word	0x200031f0

0800d718 <_read_r>:
 800d718:	b538      	push	{r3, r4, r5, lr}
 800d71a:	4d07      	ldr	r5, [pc, #28]	; (800d738 <_read_r+0x20>)
 800d71c:	4604      	mov	r4, r0
 800d71e:	4608      	mov	r0, r1
 800d720:	4611      	mov	r1, r2
 800d722:	2200      	movs	r2, #0
 800d724:	602a      	str	r2, [r5, #0]
 800d726:	461a      	mov	r2, r3
 800d728:	f001 fb8a 	bl	800ee40 <_read>
 800d72c:	1c43      	adds	r3, r0, #1
 800d72e:	d102      	bne.n	800d736 <_read_r+0x1e>
 800d730:	682b      	ldr	r3, [r5, #0]
 800d732:	b103      	cbz	r3, 800d736 <_read_r+0x1e>
 800d734:	6023      	str	r3, [r4, #0]
 800d736:	bd38      	pop	{r3, r4, r5, pc}
 800d738:	200031f0 	.word	0x200031f0

0800d73c <_sbrk_r>:
 800d73c:	b538      	push	{r3, r4, r5, lr}
 800d73e:	4d06      	ldr	r5, [pc, #24]	; (800d758 <_sbrk_r+0x1c>)
 800d740:	2300      	movs	r3, #0
 800d742:	4604      	mov	r4, r0
 800d744:	4608      	mov	r0, r1
 800d746:	602b      	str	r3, [r5, #0]
 800d748:	f7f7 fa62 	bl	8004c10 <_sbrk>
 800d74c:	1c43      	adds	r3, r0, #1
 800d74e:	d102      	bne.n	800d756 <_sbrk_r+0x1a>
 800d750:	682b      	ldr	r3, [r5, #0]
 800d752:	b103      	cbz	r3, 800d756 <_sbrk_r+0x1a>
 800d754:	6023      	str	r3, [r4, #0]
 800d756:	bd38      	pop	{r3, r4, r5, pc}
 800d758:	200031f0 	.word	0x200031f0

0800d75c <_write_r>:
 800d75c:	b538      	push	{r3, r4, r5, lr}
 800d75e:	4d07      	ldr	r5, [pc, #28]	; (800d77c <_write_r+0x20>)
 800d760:	4604      	mov	r4, r0
 800d762:	4608      	mov	r0, r1
 800d764:	4611      	mov	r1, r2
 800d766:	2200      	movs	r2, #0
 800d768:	602a      	str	r2, [r5, #0]
 800d76a:	461a      	mov	r2, r3
 800d76c:	f001 fb70 	bl	800ee50 <_write>
 800d770:	1c43      	adds	r3, r0, #1
 800d772:	d102      	bne.n	800d77a <_write_r+0x1e>
 800d774:	682b      	ldr	r3, [r5, #0]
 800d776:	b103      	cbz	r3, 800d77a <_write_r+0x1e>
 800d778:	6023      	str	r3, [r4, #0]
 800d77a:	bd38      	pop	{r3, r4, r5, pc}
 800d77c:	200031f0 	.word	0x200031f0

0800d780 <__errno>:
 800d780:	4b01      	ldr	r3, [pc, #4]	; (800d788 <__errno+0x8>)
 800d782:	6818      	ldr	r0, [r3, #0]
 800d784:	4770      	bx	lr
 800d786:	bf00      	nop
 800d788:	20001508 	.word	0x20001508

0800d78c <__libc_init_array>:
 800d78c:	b570      	push	{r4, r5, r6, lr}
 800d78e:	4d0d      	ldr	r5, [pc, #52]	; (800d7c4 <__libc_init_array+0x38>)
 800d790:	4c0d      	ldr	r4, [pc, #52]	; (800d7c8 <__libc_init_array+0x3c>)
 800d792:	1b64      	subs	r4, r4, r5
 800d794:	10a4      	asrs	r4, r4, #2
 800d796:	2600      	movs	r6, #0
 800d798:	42a6      	cmp	r6, r4
 800d79a:	d109      	bne.n	800d7b0 <__libc_init_array+0x24>
 800d79c:	4d0b      	ldr	r5, [pc, #44]	; (800d7cc <__libc_init_array+0x40>)
 800d79e:	4c0c      	ldr	r4, [pc, #48]	; (800d7d0 <__libc_init_array+0x44>)
 800d7a0:	f001 fb5e 	bl	800ee60 <_init>
 800d7a4:	1b64      	subs	r4, r4, r5
 800d7a6:	10a4      	asrs	r4, r4, #2
 800d7a8:	2600      	movs	r6, #0
 800d7aa:	42a6      	cmp	r6, r4
 800d7ac:	d105      	bne.n	800d7ba <__libc_init_array+0x2e>
 800d7ae:	bd70      	pop	{r4, r5, r6, pc}
 800d7b0:	f855 3b04 	ldr.w	r3, [r5], #4
 800d7b4:	4798      	blx	r3
 800d7b6:	3601      	adds	r6, #1
 800d7b8:	e7ee      	b.n	800d798 <__libc_init_array+0xc>
 800d7ba:	f855 3b04 	ldr.w	r3, [r5], #4
 800d7be:	4798      	blx	r3
 800d7c0:	3601      	adds	r6, #1
 800d7c2:	e7f2      	b.n	800d7aa <__libc_init_array+0x1e>
 800d7c4:	0801a5fc 	.word	0x0801a5fc
 800d7c8:	0801a5fc 	.word	0x0801a5fc
 800d7cc:	0801a5fc 	.word	0x0801a5fc
 800d7d0:	0801a600 	.word	0x0801a600

0800d7d4 <__retarget_lock_init_recursive>:
 800d7d4:	4770      	bx	lr

0800d7d6 <__retarget_lock_acquire_recursive>:
 800d7d6:	4770      	bx	lr

0800d7d8 <__retarget_lock_release_recursive>:
 800d7d8:	4770      	bx	lr

0800d7da <memcpy>:
 800d7da:	440a      	add	r2, r1
 800d7dc:	4291      	cmp	r1, r2
 800d7de:	f100 33ff 	add.w	r3, r0, #4294967295
 800d7e2:	d100      	bne.n	800d7e6 <memcpy+0xc>
 800d7e4:	4770      	bx	lr
 800d7e6:	b510      	push	{r4, lr}
 800d7e8:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d7ec:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d7f0:	4291      	cmp	r1, r2
 800d7f2:	d1f9      	bne.n	800d7e8 <memcpy+0xe>
 800d7f4:	bd10      	pop	{r4, pc}
	...

0800d7f8 <_free_r>:
 800d7f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800d7fa:	2900      	cmp	r1, #0
 800d7fc:	d044      	beq.n	800d888 <_free_r+0x90>
 800d7fe:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d802:	9001      	str	r0, [sp, #4]
 800d804:	2b00      	cmp	r3, #0
 800d806:	f1a1 0404 	sub.w	r4, r1, #4
 800d80a:	bfb8      	it	lt
 800d80c:	18e4      	addlt	r4, r4, r3
 800d80e:	f7ff fd45 	bl	800d29c <__malloc_lock>
 800d812:	4a1e      	ldr	r2, [pc, #120]	; (800d88c <_free_r+0x94>)
 800d814:	9801      	ldr	r0, [sp, #4]
 800d816:	6813      	ldr	r3, [r2, #0]
 800d818:	b933      	cbnz	r3, 800d828 <_free_r+0x30>
 800d81a:	6063      	str	r3, [r4, #4]
 800d81c:	6014      	str	r4, [r2, #0]
 800d81e:	b003      	add	sp, #12
 800d820:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800d824:	f7ff bd40 	b.w	800d2a8 <__malloc_unlock>
 800d828:	42a3      	cmp	r3, r4
 800d82a:	d908      	bls.n	800d83e <_free_r+0x46>
 800d82c:	6825      	ldr	r5, [r4, #0]
 800d82e:	1961      	adds	r1, r4, r5
 800d830:	428b      	cmp	r3, r1
 800d832:	bf01      	itttt	eq
 800d834:	6819      	ldreq	r1, [r3, #0]
 800d836:	685b      	ldreq	r3, [r3, #4]
 800d838:	1949      	addeq	r1, r1, r5
 800d83a:	6021      	streq	r1, [r4, #0]
 800d83c:	e7ed      	b.n	800d81a <_free_r+0x22>
 800d83e:	461a      	mov	r2, r3
 800d840:	685b      	ldr	r3, [r3, #4]
 800d842:	b10b      	cbz	r3, 800d848 <_free_r+0x50>
 800d844:	42a3      	cmp	r3, r4
 800d846:	d9fa      	bls.n	800d83e <_free_r+0x46>
 800d848:	6811      	ldr	r1, [r2, #0]
 800d84a:	1855      	adds	r5, r2, r1
 800d84c:	42a5      	cmp	r5, r4
 800d84e:	d10b      	bne.n	800d868 <_free_r+0x70>
 800d850:	6824      	ldr	r4, [r4, #0]
 800d852:	4421      	add	r1, r4
 800d854:	1854      	adds	r4, r2, r1
 800d856:	42a3      	cmp	r3, r4
 800d858:	6011      	str	r1, [r2, #0]
 800d85a:	d1e0      	bne.n	800d81e <_free_r+0x26>
 800d85c:	681c      	ldr	r4, [r3, #0]
 800d85e:	685b      	ldr	r3, [r3, #4]
 800d860:	6053      	str	r3, [r2, #4]
 800d862:	440c      	add	r4, r1
 800d864:	6014      	str	r4, [r2, #0]
 800d866:	e7da      	b.n	800d81e <_free_r+0x26>
 800d868:	d902      	bls.n	800d870 <_free_r+0x78>
 800d86a:	230c      	movs	r3, #12
 800d86c:	6003      	str	r3, [r0, #0]
 800d86e:	e7d6      	b.n	800d81e <_free_r+0x26>
 800d870:	6825      	ldr	r5, [r4, #0]
 800d872:	1961      	adds	r1, r4, r5
 800d874:	428b      	cmp	r3, r1
 800d876:	bf04      	itt	eq
 800d878:	6819      	ldreq	r1, [r3, #0]
 800d87a:	685b      	ldreq	r3, [r3, #4]
 800d87c:	6063      	str	r3, [r4, #4]
 800d87e:	bf04      	itt	eq
 800d880:	1949      	addeq	r1, r1, r5
 800d882:	6021      	streq	r1, [r4, #0]
 800d884:	6054      	str	r4, [r2, #4]
 800d886:	e7ca      	b.n	800d81e <_free_r+0x26>
 800d888:	b003      	add	sp, #12
 800d88a:	bd30      	pop	{r4, r5, pc}
 800d88c:	200030ac 	.word	0x200030ac

0800d890 <__sfputc_r>:
 800d890:	6893      	ldr	r3, [r2, #8]
 800d892:	3b01      	subs	r3, #1
 800d894:	2b00      	cmp	r3, #0
 800d896:	b410      	push	{r4}
 800d898:	6093      	str	r3, [r2, #8]
 800d89a:	da08      	bge.n	800d8ae <__sfputc_r+0x1e>
 800d89c:	6994      	ldr	r4, [r2, #24]
 800d89e:	42a3      	cmp	r3, r4
 800d8a0:	db01      	blt.n	800d8a6 <__sfputc_r+0x16>
 800d8a2:	290a      	cmp	r1, #10
 800d8a4:	d103      	bne.n	800d8ae <__sfputc_r+0x1e>
 800d8a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d8aa:	f7ff be76 	b.w	800d59a <__swbuf_r>
 800d8ae:	6813      	ldr	r3, [r2, #0]
 800d8b0:	1c58      	adds	r0, r3, #1
 800d8b2:	6010      	str	r0, [r2, #0]
 800d8b4:	7019      	strb	r1, [r3, #0]
 800d8b6:	4608      	mov	r0, r1
 800d8b8:	f85d 4b04 	ldr.w	r4, [sp], #4
 800d8bc:	4770      	bx	lr

0800d8be <__sfputs_r>:
 800d8be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d8c0:	4606      	mov	r6, r0
 800d8c2:	460f      	mov	r7, r1
 800d8c4:	4614      	mov	r4, r2
 800d8c6:	18d5      	adds	r5, r2, r3
 800d8c8:	42ac      	cmp	r4, r5
 800d8ca:	d101      	bne.n	800d8d0 <__sfputs_r+0x12>
 800d8cc:	2000      	movs	r0, #0
 800d8ce:	e007      	b.n	800d8e0 <__sfputs_r+0x22>
 800d8d0:	f814 1b01 	ldrb.w	r1, [r4], #1
 800d8d4:	463a      	mov	r2, r7
 800d8d6:	4630      	mov	r0, r6
 800d8d8:	f7ff ffda 	bl	800d890 <__sfputc_r>
 800d8dc:	1c43      	adds	r3, r0, #1
 800d8de:	d1f3      	bne.n	800d8c8 <__sfputs_r+0xa>
 800d8e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800d8e4 <_vfiprintf_r>:
 800d8e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d8e8:	460d      	mov	r5, r1
 800d8ea:	b09d      	sub	sp, #116	; 0x74
 800d8ec:	4614      	mov	r4, r2
 800d8ee:	4698      	mov	r8, r3
 800d8f0:	4606      	mov	r6, r0
 800d8f2:	b118      	cbz	r0, 800d8fc <_vfiprintf_r+0x18>
 800d8f4:	6a03      	ldr	r3, [r0, #32]
 800d8f6:	b90b      	cbnz	r3, 800d8fc <_vfiprintf_r+0x18>
 800d8f8:	f7ff fd68 	bl	800d3cc <__sinit>
 800d8fc:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d8fe:	07d9      	lsls	r1, r3, #31
 800d900:	d405      	bmi.n	800d90e <_vfiprintf_r+0x2a>
 800d902:	89ab      	ldrh	r3, [r5, #12]
 800d904:	059a      	lsls	r2, r3, #22
 800d906:	d402      	bmi.n	800d90e <_vfiprintf_r+0x2a>
 800d908:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800d90a:	f7ff ff64 	bl	800d7d6 <__retarget_lock_acquire_recursive>
 800d90e:	89ab      	ldrh	r3, [r5, #12]
 800d910:	071b      	lsls	r3, r3, #28
 800d912:	d501      	bpl.n	800d918 <_vfiprintf_r+0x34>
 800d914:	692b      	ldr	r3, [r5, #16]
 800d916:	b99b      	cbnz	r3, 800d940 <_vfiprintf_r+0x5c>
 800d918:	4629      	mov	r1, r5
 800d91a:	4630      	mov	r0, r6
 800d91c:	f7ff fe7a 	bl	800d614 <__swsetup_r>
 800d920:	b170      	cbz	r0, 800d940 <_vfiprintf_r+0x5c>
 800d922:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d924:	07dc      	lsls	r4, r3, #31
 800d926:	d504      	bpl.n	800d932 <_vfiprintf_r+0x4e>
 800d928:	f04f 30ff 	mov.w	r0, #4294967295
 800d92c:	b01d      	add	sp, #116	; 0x74
 800d92e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d932:	89ab      	ldrh	r3, [r5, #12]
 800d934:	0598      	lsls	r0, r3, #22
 800d936:	d4f7      	bmi.n	800d928 <_vfiprintf_r+0x44>
 800d938:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800d93a:	f7ff ff4d 	bl	800d7d8 <__retarget_lock_release_recursive>
 800d93e:	e7f3      	b.n	800d928 <_vfiprintf_r+0x44>
 800d940:	2300      	movs	r3, #0
 800d942:	9309      	str	r3, [sp, #36]	; 0x24
 800d944:	2320      	movs	r3, #32
 800d946:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800d94a:	f8cd 800c 	str.w	r8, [sp, #12]
 800d94e:	2330      	movs	r3, #48	; 0x30
 800d950:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 800db04 <_vfiprintf_r+0x220>
 800d954:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800d958:	f04f 0901 	mov.w	r9, #1
 800d95c:	4623      	mov	r3, r4
 800d95e:	469a      	mov	sl, r3
 800d960:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d964:	b10a      	cbz	r2, 800d96a <_vfiprintf_r+0x86>
 800d966:	2a25      	cmp	r2, #37	; 0x25
 800d968:	d1f9      	bne.n	800d95e <_vfiprintf_r+0x7a>
 800d96a:	ebba 0b04 	subs.w	fp, sl, r4
 800d96e:	d00b      	beq.n	800d988 <_vfiprintf_r+0xa4>
 800d970:	465b      	mov	r3, fp
 800d972:	4622      	mov	r2, r4
 800d974:	4629      	mov	r1, r5
 800d976:	4630      	mov	r0, r6
 800d978:	f7ff ffa1 	bl	800d8be <__sfputs_r>
 800d97c:	3001      	adds	r0, #1
 800d97e:	f000 80a9 	beq.w	800dad4 <_vfiprintf_r+0x1f0>
 800d982:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d984:	445a      	add	r2, fp
 800d986:	9209      	str	r2, [sp, #36]	; 0x24
 800d988:	f89a 3000 	ldrb.w	r3, [sl]
 800d98c:	2b00      	cmp	r3, #0
 800d98e:	f000 80a1 	beq.w	800dad4 <_vfiprintf_r+0x1f0>
 800d992:	2300      	movs	r3, #0
 800d994:	f04f 32ff 	mov.w	r2, #4294967295
 800d998:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800d99c:	f10a 0a01 	add.w	sl, sl, #1
 800d9a0:	9304      	str	r3, [sp, #16]
 800d9a2:	9307      	str	r3, [sp, #28]
 800d9a4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800d9a8:	931a      	str	r3, [sp, #104]	; 0x68
 800d9aa:	4654      	mov	r4, sl
 800d9ac:	2205      	movs	r2, #5
 800d9ae:	f814 1b01 	ldrb.w	r1, [r4], #1
 800d9b2:	4854      	ldr	r0, [pc, #336]	; (800db04 <_vfiprintf_r+0x220>)
 800d9b4:	f7f2 fc34 	bl	8000220 <memchr>
 800d9b8:	9a04      	ldr	r2, [sp, #16]
 800d9ba:	b9d8      	cbnz	r0, 800d9f4 <_vfiprintf_r+0x110>
 800d9bc:	06d1      	lsls	r1, r2, #27
 800d9be:	bf44      	itt	mi
 800d9c0:	2320      	movmi	r3, #32
 800d9c2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800d9c6:	0713      	lsls	r3, r2, #28
 800d9c8:	bf44      	itt	mi
 800d9ca:	232b      	movmi	r3, #43	; 0x2b
 800d9cc:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800d9d0:	f89a 3000 	ldrb.w	r3, [sl]
 800d9d4:	2b2a      	cmp	r3, #42	; 0x2a
 800d9d6:	d015      	beq.n	800da04 <_vfiprintf_r+0x120>
 800d9d8:	9a07      	ldr	r2, [sp, #28]
 800d9da:	4654      	mov	r4, sl
 800d9dc:	2000      	movs	r0, #0
 800d9de:	f04f 0c0a 	mov.w	ip, #10
 800d9e2:	4621      	mov	r1, r4
 800d9e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 800d9e8:	3b30      	subs	r3, #48	; 0x30
 800d9ea:	2b09      	cmp	r3, #9
 800d9ec:	d94d      	bls.n	800da8a <_vfiprintf_r+0x1a6>
 800d9ee:	b1b0      	cbz	r0, 800da1e <_vfiprintf_r+0x13a>
 800d9f0:	9207      	str	r2, [sp, #28]
 800d9f2:	e014      	b.n	800da1e <_vfiprintf_r+0x13a>
 800d9f4:	eba0 0308 	sub.w	r3, r0, r8
 800d9f8:	fa09 f303 	lsl.w	r3, r9, r3
 800d9fc:	4313      	orrs	r3, r2
 800d9fe:	9304      	str	r3, [sp, #16]
 800da00:	46a2      	mov	sl, r4
 800da02:	e7d2      	b.n	800d9aa <_vfiprintf_r+0xc6>
 800da04:	9b03      	ldr	r3, [sp, #12]
 800da06:	1d19      	adds	r1, r3, #4
 800da08:	681b      	ldr	r3, [r3, #0]
 800da0a:	9103      	str	r1, [sp, #12]
 800da0c:	2b00      	cmp	r3, #0
 800da0e:	bfbb      	ittet	lt
 800da10:	425b      	neglt	r3, r3
 800da12:	f042 0202 	orrlt.w	r2, r2, #2
 800da16:	9307      	strge	r3, [sp, #28]
 800da18:	9307      	strlt	r3, [sp, #28]
 800da1a:	bfb8      	it	lt
 800da1c:	9204      	strlt	r2, [sp, #16]
 800da1e:	7823      	ldrb	r3, [r4, #0]
 800da20:	2b2e      	cmp	r3, #46	; 0x2e
 800da22:	d10c      	bne.n	800da3e <_vfiprintf_r+0x15a>
 800da24:	7863      	ldrb	r3, [r4, #1]
 800da26:	2b2a      	cmp	r3, #42	; 0x2a
 800da28:	d134      	bne.n	800da94 <_vfiprintf_r+0x1b0>
 800da2a:	9b03      	ldr	r3, [sp, #12]
 800da2c:	1d1a      	adds	r2, r3, #4
 800da2e:	681b      	ldr	r3, [r3, #0]
 800da30:	9203      	str	r2, [sp, #12]
 800da32:	2b00      	cmp	r3, #0
 800da34:	bfb8      	it	lt
 800da36:	f04f 33ff 	movlt.w	r3, #4294967295
 800da3a:	3402      	adds	r4, #2
 800da3c:	9305      	str	r3, [sp, #20]
 800da3e:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 800db14 <_vfiprintf_r+0x230>
 800da42:	7821      	ldrb	r1, [r4, #0]
 800da44:	2203      	movs	r2, #3
 800da46:	4650      	mov	r0, sl
 800da48:	f7f2 fbea 	bl	8000220 <memchr>
 800da4c:	b138      	cbz	r0, 800da5e <_vfiprintf_r+0x17a>
 800da4e:	9b04      	ldr	r3, [sp, #16]
 800da50:	eba0 000a 	sub.w	r0, r0, sl
 800da54:	2240      	movs	r2, #64	; 0x40
 800da56:	4082      	lsls	r2, r0
 800da58:	4313      	orrs	r3, r2
 800da5a:	3401      	adds	r4, #1
 800da5c:	9304      	str	r3, [sp, #16]
 800da5e:	f814 1b01 	ldrb.w	r1, [r4], #1
 800da62:	4829      	ldr	r0, [pc, #164]	; (800db08 <_vfiprintf_r+0x224>)
 800da64:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800da68:	2206      	movs	r2, #6
 800da6a:	f7f2 fbd9 	bl	8000220 <memchr>
 800da6e:	2800      	cmp	r0, #0
 800da70:	d03f      	beq.n	800daf2 <_vfiprintf_r+0x20e>
 800da72:	4b26      	ldr	r3, [pc, #152]	; (800db0c <_vfiprintf_r+0x228>)
 800da74:	bb1b      	cbnz	r3, 800dabe <_vfiprintf_r+0x1da>
 800da76:	9b03      	ldr	r3, [sp, #12]
 800da78:	3307      	adds	r3, #7
 800da7a:	f023 0307 	bic.w	r3, r3, #7
 800da7e:	3308      	adds	r3, #8
 800da80:	9303      	str	r3, [sp, #12]
 800da82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800da84:	443b      	add	r3, r7
 800da86:	9309      	str	r3, [sp, #36]	; 0x24
 800da88:	e768      	b.n	800d95c <_vfiprintf_r+0x78>
 800da8a:	fb0c 3202 	mla	r2, ip, r2, r3
 800da8e:	460c      	mov	r4, r1
 800da90:	2001      	movs	r0, #1
 800da92:	e7a6      	b.n	800d9e2 <_vfiprintf_r+0xfe>
 800da94:	2300      	movs	r3, #0
 800da96:	3401      	adds	r4, #1
 800da98:	9305      	str	r3, [sp, #20]
 800da9a:	4619      	mov	r1, r3
 800da9c:	f04f 0c0a 	mov.w	ip, #10
 800daa0:	4620      	mov	r0, r4
 800daa2:	f810 2b01 	ldrb.w	r2, [r0], #1
 800daa6:	3a30      	subs	r2, #48	; 0x30
 800daa8:	2a09      	cmp	r2, #9
 800daaa:	d903      	bls.n	800dab4 <_vfiprintf_r+0x1d0>
 800daac:	2b00      	cmp	r3, #0
 800daae:	d0c6      	beq.n	800da3e <_vfiprintf_r+0x15a>
 800dab0:	9105      	str	r1, [sp, #20]
 800dab2:	e7c4      	b.n	800da3e <_vfiprintf_r+0x15a>
 800dab4:	fb0c 2101 	mla	r1, ip, r1, r2
 800dab8:	4604      	mov	r4, r0
 800daba:	2301      	movs	r3, #1
 800dabc:	e7f0      	b.n	800daa0 <_vfiprintf_r+0x1bc>
 800dabe:	ab03      	add	r3, sp, #12
 800dac0:	9300      	str	r3, [sp, #0]
 800dac2:	462a      	mov	r2, r5
 800dac4:	4b12      	ldr	r3, [pc, #72]	; (800db10 <_vfiprintf_r+0x22c>)
 800dac6:	a904      	add	r1, sp, #16
 800dac8:	4630      	mov	r0, r6
 800daca:	f3af 8000 	nop.w
 800dace:	4607      	mov	r7, r0
 800dad0:	1c78      	adds	r0, r7, #1
 800dad2:	d1d6      	bne.n	800da82 <_vfiprintf_r+0x19e>
 800dad4:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800dad6:	07d9      	lsls	r1, r3, #31
 800dad8:	d405      	bmi.n	800dae6 <_vfiprintf_r+0x202>
 800dada:	89ab      	ldrh	r3, [r5, #12]
 800dadc:	059a      	lsls	r2, r3, #22
 800dade:	d402      	bmi.n	800dae6 <_vfiprintf_r+0x202>
 800dae0:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800dae2:	f7ff fe79 	bl	800d7d8 <__retarget_lock_release_recursive>
 800dae6:	89ab      	ldrh	r3, [r5, #12]
 800dae8:	065b      	lsls	r3, r3, #25
 800daea:	f53f af1d 	bmi.w	800d928 <_vfiprintf_r+0x44>
 800daee:	9809      	ldr	r0, [sp, #36]	; 0x24
 800daf0:	e71c      	b.n	800d92c <_vfiprintf_r+0x48>
 800daf2:	ab03      	add	r3, sp, #12
 800daf4:	9300      	str	r3, [sp, #0]
 800daf6:	462a      	mov	r2, r5
 800daf8:	4b05      	ldr	r3, [pc, #20]	; (800db10 <_vfiprintf_r+0x22c>)
 800dafa:	a904      	add	r1, sp, #16
 800dafc:	4630      	mov	r0, r6
 800dafe:	f000 f879 	bl	800dbf4 <_printf_i>
 800db02:	e7e4      	b.n	800dace <_vfiprintf_r+0x1ea>
 800db04:	0801a1d8 	.word	0x0801a1d8
 800db08:	0801a1e2 	.word	0x0801a1e2
 800db0c:	00000000 	.word	0x00000000
 800db10:	0800d8bf 	.word	0x0800d8bf
 800db14:	0801a1de 	.word	0x0801a1de

0800db18 <_printf_common>:
 800db18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800db1c:	4616      	mov	r6, r2
 800db1e:	4699      	mov	r9, r3
 800db20:	688a      	ldr	r2, [r1, #8]
 800db22:	690b      	ldr	r3, [r1, #16]
 800db24:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800db28:	4293      	cmp	r3, r2
 800db2a:	bfb8      	it	lt
 800db2c:	4613      	movlt	r3, r2
 800db2e:	6033      	str	r3, [r6, #0]
 800db30:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800db34:	4607      	mov	r7, r0
 800db36:	460c      	mov	r4, r1
 800db38:	b10a      	cbz	r2, 800db3e <_printf_common+0x26>
 800db3a:	3301      	adds	r3, #1
 800db3c:	6033      	str	r3, [r6, #0]
 800db3e:	6823      	ldr	r3, [r4, #0]
 800db40:	0699      	lsls	r1, r3, #26
 800db42:	bf42      	ittt	mi
 800db44:	6833      	ldrmi	r3, [r6, #0]
 800db46:	3302      	addmi	r3, #2
 800db48:	6033      	strmi	r3, [r6, #0]
 800db4a:	6825      	ldr	r5, [r4, #0]
 800db4c:	f015 0506 	ands.w	r5, r5, #6
 800db50:	d106      	bne.n	800db60 <_printf_common+0x48>
 800db52:	f104 0a19 	add.w	sl, r4, #25
 800db56:	68e3      	ldr	r3, [r4, #12]
 800db58:	6832      	ldr	r2, [r6, #0]
 800db5a:	1a9b      	subs	r3, r3, r2
 800db5c:	42ab      	cmp	r3, r5
 800db5e:	dc26      	bgt.n	800dbae <_printf_common+0x96>
 800db60:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800db64:	1e13      	subs	r3, r2, #0
 800db66:	6822      	ldr	r2, [r4, #0]
 800db68:	bf18      	it	ne
 800db6a:	2301      	movne	r3, #1
 800db6c:	0692      	lsls	r2, r2, #26
 800db6e:	d42b      	bmi.n	800dbc8 <_printf_common+0xb0>
 800db70:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800db74:	4649      	mov	r1, r9
 800db76:	4638      	mov	r0, r7
 800db78:	47c0      	blx	r8
 800db7a:	3001      	adds	r0, #1
 800db7c:	d01e      	beq.n	800dbbc <_printf_common+0xa4>
 800db7e:	6823      	ldr	r3, [r4, #0]
 800db80:	6922      	ldr	r2, [r4, #16]
 800db82:	f003 0306 	and.w	r3, r3, #6
 800db86:	2b04      	cmp	r3, #4
 800db88:	bf02      	ittt	eq
 800db8a:	68e5      	ldreq	r5, [r4, #12]
 800db8c:	6833      	ldreq	r3, [r6, #0]
 800db8e:	1aed      	subeq	r5, r5, r3
 800db90:	68a3      	ldr	r3, [r4, #8]
 800db92:	bf0c      	ite	eq
 800db94:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800db98:	2500      	movne	r5, #0
 800db9a:	4293      	cmp	r3, r2
 800db9c:	bfc4      	itt	gt
 800db9e:	1a9b      	subgt	r3, r3, r2
 800dba0:	18ed      	addgt	r5, r5, r3
 800dba2:	2600      	movs	r6, #0
 800dba4:	341a      	adds	r4, #26
 800dba6:	42b5      	cmp	r5, r6
 800dba8:	d11a      	bne.n	800dbe0 <_printf_common+0xc8>
 800dbaa:	2000      	movs	r0, #0
 800dbac:	e008      	b.n	800dbc0 <_printf_common+0xa8>
 800dbae:	2301      	movs	r3, #1
 800dbb0:	4652      	mov	r2, sl
 800dbb2:	4649      	mov	r1, r9
 800dbb4:	4638      	mov	r0, r7
 800dbb6:	47c0      	blx	r8
 800dbb8:	3001      	adds	r0, #1
 800dbba:	d103      	bne.n	800dbc4 <_printf_common+0xac>
 800dbbc:	f04f 30ff 	mov.w	r0, #4294967295
 800dbc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dbc4:	3501      	adds	r5, #1
 800dbc6:	e7c6      	b.n	800db56 <_printf_common+0x3e>
 800dbc8:	18e1      	adds	r1, r4, r3
 800dbca:	1c5a      	adds	r2, r3, #1
 800dbcc:	2030      	movs	r0, #48	; 0x30
 800dbce:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800dbd2:	4422      	add	r2, r4
 800dbd4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800dbd8:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800dbdc:	3302      	adds	r3, #2
 800dbde:	e7c7      	b.n	800db70 <_printf_common+0x58>
 800dbe0:	2301      	movs	r3, #1
 800dbe2:	4622      	mov	r2, r4
 800dbe4:	4649      	mov	r1, r9
 800dbe6:	4638      	mov	r0, r7
 800dbe8:	47c0      	blx	r8
 800dbea:	3001      	adds	r0, #1
 800dbec:	d0e6      	beq.n	800dbbc <_printf_common+0xa4>
 800dbee:	3601      	adds	r6, #1
 800dbf0:	e7d9      	b.n	800dba6 <_printf_common+0x8e>
	...

0800dbf4 <_printf_i>:
 800dbf4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800dbf8:	7e0f      	ldrb	r7, [r1, #24]
 800dbfa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800dbfc:	2f78      	cmp	r7, #120	; 0x78
 800dbfe:	4691      	mov	r9, r2
 800dc00:	4680      	mov	r8, r0
 800dc02:	460c      	mov	r4, r1
 800dc04:	469a      	mov	sl, r3
 800dc06:	f101 0243 	add.w	r2, r1, #67	; 0x43
 800dc0a:	d807      	bhi.n	800dc1c <_printf_i+0x28>
 800dc0c:	2f62      	cmp	r7, #98	; 0x62
 800dc0e:	d80a      	bhi.n	800dc26 <_printf_i+0x32>
 800dc10:	2f00      	cmp	r7, #0
 800dc12:	f000 80d4 	beq.w	800ddbe <_printf_i+0x1ca>
 800dc16:	2f58      	cmp	r7, #88	; 0x58
 800dc18:	f000 80c0 	beq.w	800dd9c <_printf_i+0x1a8>
 800dc1c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800dc20:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 800dc24:	e03a      	b.n	800dc9c <_printf_i+0xa8>
 800dc26:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 800dc2a:	2b15      	cmp	r3, #21
 800dc2c:	d8f6      	bhi.n	800dc1c <_printf_i+0x28>
 800dc2e:	a101      	add	r1, pc, #4	; (adr r1, 800dc34 <_printf_i+0x40>)
 800dc30:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800dc34:	0800dc8d 	.word	0x0800dc8d
 800dc38:	0800dca1 	.word	0x0800dca1
 800dc3c:	0800dc1d 	.word	0x0800dc1d
 800dc40:	0800dc1d 	.word	0x0800dc1d
 800dc44:	0800dc1d 	.word	0x0800dc1d
 800dc48:	0800dc1d 	.word	0x0800dc1d
 800dc4c:	0800dca1 	.word	0x0800dca1
 800dc50:	0800dc1d 	.word	0x0800dc1d
 800dc54:	0800dc1d 	.word	0x0800dc1d
 800dc58:	0800dc1d 	.word	0x0800dc1d
 800dc5c:	0800dc1d 	.word	0x0800dc1d
 800dc60:	0800dda5 	.word	0x0800dda5
 800dc64:	0800dccd 	.word	0x0800dccd
 800dc68:	0800dd5f 	.word	0x0800dd5f
 800dc6c:	0800dc1d 	.word	0x0800dc1d
 800dc70:	0800dc1d 	.word	0x0800dc1d
 800dc74:	0800ddc7 	.word	0x0800ddc7
 800dc78:	0800dc1d 	.word	0x0800dc1d
 800dc7c:	0800dccd 	.word	0x0800dccd
 800dc80:	0800dc1d 	.word	0x0800dc1d
 800dc84:	0800dc1d 	.word	0x0800dc1d
 800dc88:	0800dd67 	.word	0x0800dd67
 800dc8c:	682b      	ldr	r3, [r5, #0]
 800dc8e:	1d1a      	adds	r2, r3, #4
 800dc90:	681b      	ldr	r3, [r3, #0]
 800dc92:	602a      	str	r2, [r5, #0]
 800dc94:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800dc98:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800dc9c:	2301      	movs	r3, #1
 800dc9e:	e09f      	b.n	800dde0 <_printf_i+0x1ec>
 800dca0:	6820      	ldr	r0, [r4, #0]
 800dca2:	682b      	ldr	r3, [r5, #0]
 800dca4:	0607      	lsls	r7, r0, #24
 800dca6:	f103 0104 	add.w	r1, r3, #4
 800dcaa:	6029      	str	r1, [r5, #0]
 800dcac:	d501      	bpl.n	800dcb2 <_printf_i+0xbe>
 800dcae:	681e      	ldr	r6, [r3, #0]
 800dcb0:	e003      	b.n	800dcba <_printf_i+0xc6>
 800dcb2:	0646      	lsls	r6, r0, #25
 800dcb4:	d5fb      	bpl.n	800dcae <_printf_i+0xba>
 800dcb6:	f9b3 6000 	ldrsh.w	r6, [r3]
 800dcba:	2e00      	cmp	r6, #0
 800dcbc:	da03      	bge.n	800dcc6 <_printf_i+0xd2>
 800dcbe:	232d      	movs	r3, #45	; 0x2d
 800dcc0:	4276      	negs	r6, r6
 800dcc2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800dcc6:	485a      	ldr	r0, [pc, #360]	; (800de30 <_printf_i+0x23c>)
 800dcc8:	230a      	movs	r3, #10
 800dcca:	e012      	b.n	800dcf2 <_printf_i+0xfe>
 800dccc:	682b      	ldr	r3, [r5, #0]
 800dcce:	6820      	ldr	r0, [r4, #0]
 800dcd0:	1d19      	adds	r1, r3, #4
 800dcd2:	6029      	str	r1, [r5, #0]
 800dcd4:	0605      	lsls	r5, r0, #24
 800dcd6:	d501      	bpl.n	800dcdc <_printf_i+0xe8>
 800dcd8:	681e      	ldr	r6, [r3, #0]
 800dcda:	e002      	b.n	800dce2 <_printf_i+0xee>
 800dcdc:	0641      	lsls	r1, r0, #25
 800dcde:	d5fb      	bpl.n	800dcd8 <_printf_i+0xe4>
 800dce0:	881e      	ldrh	r6, [r3, #0]
 800dce2:	4853      	ldr	r0, [pc, #332]	; (800de30 <_printf_i+0x23c>)
 800dce4:	2f6f      	cmp	r7, #111	; 0x6f
 800dce6:	bf0c      	ite	eq
 800dce8:	2308      	moveq	r3, #8
 800dcea:	230a      	movne	r3, #10
 800dcec:	2100      	movs	r1, #0
 800dcee:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800dcf2:	6865      	ldr	r5, [r4, #4]
 800dcf4:	60a5      	str	r5, [r4, #8]
 800dcf6:	2d00      	cmp	r5, #0
 800dcf8:	bfa2      	ittt	ge
 800dcfa:	6821      	ldrge	r1, [r4, #0]
 800dcfc:	f021 0104 	bicge.w	r1, r1, #4
 800dd00:	6021      	strge	r1, [r4, #0]
 800dd02:	b90e      	cbnz	r6, 800dd08 <_printf_i+0x114>
 800dd04:	2d00      	cmp	r5, #0
 800dd06:	d04b      	beq.n	800dda0 <_printf_i+0x1ac>
 800dd08:	4615      	mov	r5, r2
 800dd0a:	fbb6 f1f3 	udiv	r1, r6, r3
 800dd0e:	fb03 6711 	mls	r7, r3, r1, r6
 800dd12:	5dc7      	ldrb	r7, [r0, r7]
 800dd14:	f805 7d01 	strb.w	r7, [r5, #-1]!
 800dd18:	4637      	mov	r7, r6
 800dd1a:	42bb      	cmp	r3, r7
 800dd1c:	460e      	mov	r6, r1
 800dd1e:	d9f4      	bls.n	800dd0a <_printf_i+0x116>
 800dd20:	2b08      	cmp	r3, #8
 800dd22:	d10b      	bne.n	800dd3c <_printf_i+0x148>
 800dd24:	6823      	ldr	r3, [r4, #0]
 800dd26:	07de      	lsls	r6, r3, #31
 800dd28:	d508      	bpl.n	800dd3c <_printf_i+0x148>
 800dd2a:	6923      	ldr	r3, [r4, #16]
 800dd2c:	6861      	ldr	r1, [r4, #4]
 800dd2e:	4299      	cmp	r1, r3
 800dd30:	bfde      	ittt	le
 800dd32:	2330      	movle	r3, #48	; 0x30
 800dd34:	f805 3c01 	strble.w	r3, [r5, #-1]
 800dd38:	f105 35ff 	addle.w	r5, r5, #4294967295
 800dd3c:	1b52      	subs	r2, r2, r5
 800dd3e:	6122      	str	r2, [r4, #16]
 800dd40:	f8cd a000 	str.w	sl, [sp]
 800dd44:	464b      	mov	r3, r9
 800dd46:	aa03      	add	r2, sp, #12
 800dd48:	4621      	mov	r1, r4
 800dd4a:	4640      	mov	r0, r8
 800dd4c:	f7ff fee4 	bl	800db18 <_printf_common>
 800dd50:	3001      	adds	r0, #1
 800dd52:	d14a      	bne.n	800ddea <_printf_i+0x1f6>
 800dd54:	f04f 30ff 	mov.w	r0, #4294967295
 800dd58:	b004      	add	sp, #16
 800dd5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dd5e:	6823      	ldr	r3, [r4, #0]
 800dd60:	f043 0320 	orr.w	r3, r3, #32
 800dd64:	6023      	str	r3, [r4, #0]
 800dd66:	4833      	ldr	r0, [pc, #204]	; (800de34 <_printf_i+0x240>)
 800dd68:	2778      	movs	r7, #120	; 0x78
 800dd6a:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800dd6e:	6823      	ldr	r3, [r4, #0]
 800dd70:	6829      	ldr	r1, [r5, #0]
 800dd72:	061f      	lsls	r7, r3, #24
 800dd74:	f851 6b04 	ldr.w	r6, [r1], #4
 800dd78:	d402      	bmi.n	800dd80 <_printf_i+0x18c>
 800dd7a:	065f      	lsls	r7, r3, #25
 800dd7c:	bf48      	it	mi
 800dd7e:	b2b6      	uxthmi	r6, r6
 800dd80:	07df      	lsls	r7, r3, #31
 800dd82:	bf48      	it	mi
 800dd84:	f043 0320 	orrmi.w	r3, r3, #32
 800dd88:	6029      	str	r1, [r5, #0]
 800dd8a:	bf48      	it	mi
 800dd8c:	6023      	strmi	r3, [r4, #0]
 800dd8e:	b91e      	cbnz	r6, 800dd98 <_printf_i+0x1a4>
 800dd90:	6823      	ldr	r3, [r4, #0]
 800dd92:	f023 0320 	bic.w	r3, r3, #32
 800dd96:	6023      	str	r3, [r4, #0]
 800dd98:	2310      	movs	r3, #16
 800dd9a:	e7a7      	b.n	800dcec <_printf_i+0xf8>
 800dd9c:	4824      	ldr	r0, [pc, #144]	; (800de30 <_printf_i+0x23c>)
 800dd9e:	e7e4      	b.n	800dd6a <_printf_i+0x176>
 800dda0:	4615      	mov	r5, r2
 800dda2:	e7bd      	b.n	800dd20 <_printf_i+0x12c>
 800dda4:	682b      	ldr	r3, [r5, #0]
 800dda6:	6826      	ldr	r6, [r4, #0]
 800dda8:	6961      	ldr	r1, [r4, #20]
 800ddaa:	1d18      	adds	r0, r3, #4
 800ddac:	6028      	str	r0, [r5, #0]
 800ddae:	0635      	lsls	r5, r6, #24
 800ddb0:	681b      	ldr	r3, [r3, #0]
 800ddb2:	d501      	bpl.n	800ddb8 <_printf_i+0x1c4>
 800ddb4:	6019      	str	r1, [r3, #0]
 800ddb6:	e002      	b.n	800ddbe <_printf_i+0x1ca>
 800ddb8:	0670      	lsls	r0, r6, #25
 800ddba:	d5fb      	bpl.n	800ddb4 <_printf_i+0x1c0>
 800ddbc:	8019      	strh	r1, [r3, #0]
 800ddbe:	2300      	movs	r3, #0
 800ddc0:	6123      	str	r3, [r4, #16]
 800ddc2:	4615      	mov	r5, r2
 800ddc4:	e7bc      	b.n	800dd40 <_printf_i+0x14c>
 800ddc6:	682b      	ldr	r3, [r5, #0]
 800ddc8:	1d1a      	adds	r2, r3, #4
 800ddca:	602a      	str	r2, [r5, #0]
 800ddcc:	681d      	ldr	r5, [r3, #0]
 800ddce:	6862      	ldr	r2, [r4, #4]
 800ddd0:	2100      	movs	r1, #0
 800ddd2:	4628      	mov	r0, r5
 800ddd4:	f7f2 fa24 	bl	8000220 <memchr>
 800ddd8:	b108      	cbz	r0, 800ddde <_printf_i+0x1ea>
 800ddda:	1b40      	subs	r0, r0, r5
 800dddc:	6060      	str	r0, [r4, #4]
 800ddde:	6863      	ldr	r3, [r4, #4]
 800dde0:	6123      	str	r3, [r4, #16]
 800dde2:	2300      	movs	r3, #0
 800dde4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800dde8:	e7aa      	b.n	800dd40 <_printf_i+0x14c>
 800ddea:	6923      	ldr	r3, [r4, #16]
 800ddec:	462a      	mov	r2, r5
 800ddee:	4649      	mov	r1, r9
 800ddf0:	4640      	mov	r0, r8
 800ddf2:	47d0      	blx	sl
 800ddf4:	3001      	adds	r0, #1
 800ddf6:	d0ad      	beq.n	800dd54 <_printf_i+0x160>
 800ddf8:	6823      	ldr	r3, [r4, #0]
 800ddfa:	079b      	lsls	r3, r3, #30
 800ddfc:	d413      	bmi.n	800de26 <_printf_i+0x232>
 800ddfe:	68e0      	ldr	r0, [r4, #12]
 800de00:	9b03      	ldr	r3, [sp, #12]
 800de02:	4298      	cmp	r0, r3
 800de04:	bfb8      	it	lt
 800de06:	4618      	movlt	r0, r3
 800de08:	e7a6      	b.n	800dd58 <_printf_i+0x164>
 800de0a:	2301      	movs	r3, #1
 800de0c:	4632      	mov	r2, r6
 800de0e:	4649      	mov	r1, r9
 800de10:	4640      	mov	r0, r8
 800de12:	47d0      	blx	sl
 800de14:	3001      	adds	r0, #1
 800de16:	d09d      	beq.n	800dd54 <_printf_i+0x160>
 800de18:	3501      	adds	r5, #1
 800de1a:	68e3      	ldr	r3, [r4, #12]
 800de1c:	9903      	ldr	r1, [sp, #12]
 800de1e:	1a5b      	subs	r3, r3, r1
 800de20:	42ab      	cmp	r3, r5
 800de22:	dcf2      	bgt.n	800de0a <_printf_i+0x216>
 800de24:	e7eb      	b.n	800ddfe <_printf_i+0x20a>
 800de26:	2500      	movs	r5, #0
 800de28:	f104 0619 	add.w	r6, r4, #25
 800de2c:	e7f5      	b.n	800de1a <_printf_i+0x226>
 800de2e:	bf00      	nop
 800de30:	0801a1e9 	.word	0x0801a1e9
 800de34:	0801a1fa 	.word	0x0801a1fa

0800de38 <__sflush_r>:
 800de38:	898a      	ldrh	r2, [r1, #12]
 800de3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800de3e:	4605      	mov	r5, r0
 800de40:	0710      	lsls	r0, r2, #28
 800de42:	460c      	mov	r4, r1
 800de44:	d458      	bmi.n	800def8 <__sflush_r+0xc0>
 800de46:	684b      	ldr	r3, [r1, #4]
 800de48:	2b00      	cmp	r3, #0
 800de4a:	dc05      	bgt.n	800de58 <__sflush_r+0x20>
 800de4c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800de4e:	2b00      	cmp	r3, #0
 800de50:	dc02      	bgt.n	800de58 <__sflush_r+0x20>
 800de52:	2000      	movs	r0, #0
 800de54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800de58:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800de5a:	2e00      	cmp	r6, #0
 800de5c:	d0f9      	beq.n	800de52 <__sflush_r+0x1a>
 800de5e:	2300      	movs	r3, #0
 800de60:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800de64:	682f      	ldr	r7, [r5, #0]
 800de66:	6a21      	ldr	r1, [r4, #32]
 800de68:	602b      	str	r3, [r5, #0]
 800de6a:	d032      	beq.n	800ded2 <__sflush_r+0x9a>
 800de6c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800de6e:	89a3      	ldrh	r3, [r4, #12]
 800de70:	075a      	lsls	r2, r3, #29
 800de72:	d505      	bpl.n	800de80 <__sflush_r+0x48>
 800de74:	6863      	ldr	r3, [r4, #4]
 800de76:	1ac0      	subs	r0, r0, r3
 800de78:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800de7a:	b10b      	cbz	r3, 800de80 <__sflush_r+0x48>
 800de7c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800de7e:	1ac0      	subs	r0, r0, r3
 800de80:	2300      	movs	r3, #0
 800de82:	4602      	mov	r2, r0
 800de84:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800de86:	6a21      	ldr	r1, [r4, #32]
 800de88:	4628      	mov	r0, r5
 800de8a:	47b0      	blx	r6
 800de8c:	1c43      	adds	r3, r0, #1
 800de8e:	89a3      	ldrh	r3, [r4, #12]
 800de90:	d106      	bne.n	800dea0 <__sflush_r+0x68>
 800de92:	6829      	ldr	r1, [r5, #0]
 800de94:	291d      	cmp	r1, #29
 800de96:	d82b      	bhi.n	800def0 <__sflush_r+0xb8>
 800de98:	4a29      	ldr	r2, [pc, #164]	; (800df40 <__sflush_r+0x108>)
 800de9a:	410a      	asrs	r2, r1
 800de9c:	07d6      	lsls	r6, r2, #31
 800de9e:	d427      	bmi.n	800def0 <__sflush_r+0xb8>
 800dea0:	2200      	movs	r2, #0
 800dea2:	6062      	str	r2, [r4, #4]
 800dea4:	04d9      	lsls	r1, r3, #19
 800dea6:	6922      	ldr	r2, [r4, #16]
 800dea8:	6022      	str	r2, [r4, #0]
 800deaa:	d504      	bpl.n	800deb6 <__sflush_r+0x7e>
 800deac:	1c42      	adds	r2, r0, #1
 800deae:	d101      	bne.n	800deb4 <__sflush_r+0x7c>
 800deb0:	682b      	ldr	r3, [r5, #0]
 800deb2:	b903      	cbnz	r3, 800deb6 <__sflush_r+0x7e>
 800deb4:	6560      	str	r0, [r4, #84]	; 0x54
 800deb6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800deb8:	602f      	str	r7, [r5, #0]
 800deba:	2900      	cmp	r1, #0
 800debc:	d0c9      	beq.n	800de52 <__sflush_r+0x1a>
 800debe:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800dec2:	4299      	cmp	r1, r3
 800dec4:	d002      	beq.n	800decc <__sflush_r+0x94>
 800dec6:	4628      	mov	r0, r5
 800dec8:	f7ff fc96 	bl	800d7f8 <_free_r>
 800decc:	2000      	movs	r0, #0
 800dece:	6360      	str	r0, [r4, #52]	; 0x34
 800ded0:	e7c0      	b.n	800de54 <__sflush_r+0x1c>
 800ded2:	2301      	movs	r3, #1
 800ded4:	4628      	mov	r0, r5
 800ded6:	47b0      	blx	r6
 800ded8:	1c41      	adds	r1, r0, #1
 800deda:	d1c8      	bne.n	800de6e <__sflush_r+0x36>
 800dedc:	682b      	ldr	r3, [r5, #0]
 800dede:	2b00      	cmp	r3, #0
 800dee0:	d0c5      	beq.n	800de6e <__sflush_r+0x36>
 800dee2:	2b1d      	cmp	r3, #29
 800dee4:	d001      	beq.n	800deea <__sflush_r+0xb2>
 800dee6:	2b16      	cmp	r3, #22
 800dee8:	d101      	bne.n	800deee <__sflush_r+0xb6>
 800deea:	602f      	str	r7, [r5, #0]
 800deec:	e7b1      	b.n	800de52 <__sflush_r+0x1a>
 800deee:	89a3      	ldrh	r3, [r4, #12]
 800def0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800def4:	81a3      	strh	r3, [r4, #12]
 800def6:	e7ad      	b.n	800de54 <__sflush_r+0x1c>
 800def8:	690f      	ldr	r7, [r1, #16]
 800defa:	2f00      	cmp	r7, #0
 800defc:	d0a9      	beq.n	800de52 <__sflush_r+0x1a>
 800defe:	0793      	lsls	r3, r2, #30
 800df00:	680e      	ldr	r6, [r1, #0]
 800df02:	bf08      	it	eq
 800df04:	694b      	ldreq	r3, [r1, #20]
 800df06:	600f      	str	r7, [r1, #0]
 800df08:	bf18      	it	ne
 800df0a:	2300      	movne	r3, #0
 800df0c:	eba6 0807 	sub.w	r8, r6, r7
 800df10:	608b      	str	r3, [r1, #8]
 800df12:	f1b8 0f00 	cmp.w	r8, #0
 800df16:	dd9c      	ble.n	800de52 <__sflush_r+0x1a>
 800df18:	6a21      	ldr	r1, [r4, #32]
 800df1a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800df1c:	4643      	mov	r3, r8
 800df1e:	463a      	mov	r2, r7
 800df20:	4628      	mov	r0, r5
 800df22:	47b0      	blx	r6
 800df24:	2800      	cmp	r0, #0
 800df26:	dc06      	bgt.n	800df36 <__sflush_r+0xfe>
 800df28:	89a3      	ldrh	r3, [r4, #12]
 800df2a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800df2e:	81a3      	strh	r3, [r4, #12]
 800df30:	f04f 30ff 	mov.w	r0, #4294967295
 800df34:	e78e      	b.n	800de54 <__sflush_r+0x1c>
 800df36:	4407      	add	r7, r0
 800df38:	eba8 0800 	sub.w	r8, r8, r0
 800df3c:	e7e9      	b.n	800df12 <__sflush_r+0xda>
 800df3e:	bf00      	nop
 800df40:	dfbffffe 	.word	0xdfbffffe

0800df44 <_fflush_r>:
 800df44:	b538      	push	{r3, r4, r5, lr}
 800df46:	690b      	ldr	r3, [r1, #16]
 800df48:	4605      	mov	r5, r0
 800df4a:	460c      	mov	r4, r1
 800df4c:	b913      	cbnz	r3, 800df54 <_fflush_r+0x10>
 800df4e:	2500      	movs	r5, #0
 800df50:	4628      	mov	r0, r5
 800df52:	bd38      	pop	{r3, r4, r5, pc}
 800df54:	b118      	cbz	r0, 800df5e <_fflush_r+0x1a>
 800df56:	6a03      	ldr	r3, [r0, #32]
 800df58:	b90b      	cbnz	r3, 800df5e <_fflush_r+0x1a>
 800df5a:	f7ff fa37 	bl	800d3cc <__sinit>
 800df5e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800df62:	2b00      	cmp	r3, #0
 800df64:	d0f3      	beq.n	800df4e <_fflush_r+0xa>
 800df66:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800df68:	07d0      	lsls	r0, r2, #31
 800df6a:	d404      	bmi.n	800df76 <_fflush_r+0x32>
 800df6c:	0599      	lsls	r1, r3, #22
 800df6e:	d402      	bmi.n	800df76 <_fflush_r+0x32>
 800df70:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800df72:	f7ff fc30 	bl	800d7d6 <__retarget_lock_acquire_recursive>
 800df76:	4628      	mov	r0, r5
 800df78:	4621      	mov	r1, r4
 800df7a:	f7ff ff5d 	bl	800de38 <__sflush_r>
 800df7e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800df80:	07da      	lsls	r2, r3, #31
 800df82:	4605      	mov	r5, r0
 800df84:	d4e4      	bmi.n	800df50 <_fflush_r+0xc>
 800df86:	89a3      	ldrh	r3, [r4, #12]
 800df88:	059b      	lsls	r3, r3, #22
 800df8a:	d4e1      	bmi.n	800df50 <_fflush_r+0xc>
 800df8c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800df8e:	f7ff fc23 	bl	800d7d8 <__retarget_lock_release_recursive>
 800df92:	e7dd      	b.n	800df50 <_fflush_r+0xc>

0800df94 <__swhatbuf_r>:
 800df94:	b570      	push	{r4, r5, r6, lr}
 800df96:	460c      	mov	r4, r1
 800df98:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800df9c:	2900      	cmp	r1, #0
 800df9e:	b096      	sub	sp, #88	; 0x58
 800dfa0:	4615      	mov	r5, r2
 800dfa2:	461e      	mov	r6, r3
 800dfa4:	da0d      	bge.n	800dfc2 <__swhatbuf_r+0x2e>
 800dfa6:	89a3      	ldrh	r3, [r4, #12]
 800dfa8:	f013 0f80 	tst.w	r3, #128	; 0x80
 800dfac:	f04f 0100 	mov.w	r1, #0
 800dfb0:	bf0c      	ite	eq
 800dfb2:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 800dfb6:	2340      	movne	r3, #64	; 0x40
 800dfb8:	2000      	movs	r0, #0
 800dfba:	6031      	str	r1, [r6, #0]
 800dfbc:	602b      	str	r3, [r5, #0]
 800dfbe:	b016      	add	sp, #88	; 0x58
 800dfc0:	bd70      	pop	{r4, r5, r6, pc}
 800dfc2:	466a      	mov	r2, sp
 800dfc4:	f000 f848 	bl	800e058 <_fstat_r>
 800dfc8:	2800      	cmp	r0, #0
 800dfca:	dbec      	blt.n	800dfa6 <__swhatbuf_r+0x12>
 800dfcc:	9901      	ldr	r1, [sp, #4]
 800dfce:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 800dfd2:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 800dfd6:	4259      	negs	r1, r3
 800dfd8:	4159      	adcs	r1, r3
 800dfda:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800dfde:	e7eb      	b.n	800dfb8 <__swhatbuf_r+0x24>

0800dfe0 <__smakebuf_r>:
 800dfe0:	898b      	ldrh	r3, [r1, #12]
 800dfe2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800dfe4:	079d      	lsls	r5, r3, #30
 800dfe6:	4606      	mov	r6, r0
 800dfe8:	460c      	mov	r4, r1
 800dfea:	d507      	bpl.n	800dffc <__smakebuf_r+0x1c>
 800dfec:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800dff0:	6023      	str	r3, [r4, #0]
 800dff2:	6123      	str	r3, [r4, #16]
 800dff4:	2301      	movs	r3, #1
 800dff6:	6163      	str	r3, [r4, #20]
 800dff8:	b002      	add	sp, #8
 800dffa:	bd70      	pop	{r4, r5, r6, pc}
 800dffc:	ab01      	add	r3, sp, #4
 800dffe:	466a      	mov	r2, sp
 800e000:	f7ff ffc8 	bl	800df94 <__swhatbuf_r>
 800e004:	9900      	ldr	r1, [sp, #0]
 800e006:	4605      	mov	r5, r0
 800e008:	4630      	mov	r0, r6
 800e00a:	f7ff f8c7 	bl	800d19c <_malloc_r>
 800e00e:	b948      	cbnz	r0, 800e024 <__smakebuf_r+0x44>
 800e010:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e014:	059a      	lsls	r2, r3, #22
 800e016:	d4ef      	bmi.n	800dff8 <__smakebuf_r+0x18>
 800e018:	f023 0303 	bic.w	r3, r3, #3
 800e01c:	f043 0302 	orr.w	r3, r3, #2
 800e020:	81a3      	strh	r3, [r4, #12]
 800e022:	e7e3      	b.n	800dfec <__smakebuf_r+0xc>
 800e024:	89a3      	ldrh	r3, [r4, #12]
 800e026:	6020      	str	r0, [r4, #0]
 800e028:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e02c:	81a3      	strh	r3, [r4, #12]
 800e02e:	9b00      	ldr	r3, [sp, #0]
 800e030:	6163      	str	r3, [r4, #20]
 800e032:	9b01      	ldr	r3, [sp, #4]
 800e034:	6120      	str	r0, [r4, #16]
 800e036:	b15b      	cbz	r3, 800e050 <__smakebuf_r+0x70>
 800e038:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800e03c:	4630      	mov	r0, r6
 800e03e:	f000 f81d 	bl	800e07c <_isatty_r>
 800e042:	b128      	cbz	r0, 800e050 <__smakebuf_r+0x70>
 800e044:	89a3      	ldrh	r3, [r4, #12]
 800e046:	f023 0303 	bic.w	r3, r3, #3
 800e04a:	f043 0301 	orr.w	r3, r3, #1
 800e04e:	81a3      	strh	r3, [r4, #12]
 800e050:	89a3      	ldrh	r3, [r4, #12]
 800e052:	431d      	orrs	r5, r3
 800e054:	81a5      	strh	r5, [r4, #12]
 800e056:	e7cf      	b.n	800dff8 <__smakebuf_r+0x18>

0800e058 <_fstat_r>:
 800e058:	b538      	push	{r3, r4, r5, lr}
 800e05a:	4d07      	ldr	r5, [pc, #28]	; (800e078 <_fstat_r+0x20>)
 800e05c:	2300      	movs	r3, #0
 800e05e:	4604      	mov	r4, r0
 800e060:	4608      	mov	r0, r1
 800e062:	4611      	mov	r1, r2
 800e064:	602b      	str	r3, [r5, #0]
 800e066:	f000 fed3 	bl	800ee10 <_fstat>
 800e06a:	1c43      	adds	r3, r0, #1
 800e06c:	d102      	bne.n	800e074 <_fstat_r+0x1c>
 800e06e:	682b      	ldr	r3, [r5, #0]
 800e070:	b103      	cbz	r3, 800e074 <_fstat_r+0x1c>
 800e072:	6023      	str	r3, [r4, #0]
 800e074:	bd38      	pop	{r3, r4, r5, pc}
 800e076:	bf00      	nop
 800e078:	200031f0 	.word	0x200031f0

0800e07c <_isatty_r>:
 800e07c:	b538      	push	{r3, r4, r5, lr}
 800e07e:	4d06      	ldr	r5, [pc, #24]	; (800e098 <_isatty_r+0x1c>)
 800e080:	2300      	movs	r3, #0
 800e082:	4604      	mov	r4, r0
 800e084:	4608      	mov	r0, r1
 800e086:	602b      	str	r3, [r5, #0]
 800e088:	f000 feca 	bl	800ee20 <_isatty>
 800e08c:	1c43      	adds	r3, r0, #1
 800e08e:	d102      	bne.n	800e096 <_isatty_r+0x1a>
 800e090:	682b      	ldr	r3, [r5, #0]
 800e092:	b103      	cbz	r3, 800e096 <_isatty_r+0x1a>
 800e094:	6023      	str	r3, [r4, #0]
 800e096:	bd38      	pop	{r3, r4, r5, pc}
 800e098:	200031f0 	.word	0x200031f0

0800e09c <expf>:
 800e09c:	b508      	push	{r3, lr}
 800e09e:	ed2d 8b02 	vpush	{d8}
 800e0a2:	eef0 8a40 	vmov.f32	s17, s0
 800e0a6:	f000 f9d9 	bl	800e45c <__ieee754_expf>
 800e0aa:	eeb0 8a40 	vmov.f32	s16, s0
 800e0ae:	eeb0 0a68 	vmov.f32	s0, s17
 800e0b2:	f000 f8bb 	bl	800e22c <finitef>
 800e0b6:	b160      	cbz	r0, 800e0d2 <expf+0x36>
 800e0b8:	eddf 7a0f 	vldr	s15, [pc, #60]	; 800e0f8 <expf+0x5c>
 800e0bc:	eef4 8ae7 	vcmpe.f32	s17, s15
 800e0c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e0c4:	dd0a      	ble.n	800e0dc <expf+0x40>
 800e0c6:	f7ff fb5b 	bl	800d780 <__errno>
 800e0ca:	ed9f 8a0c 	vldr	s16, [pc, #48]	; 800e0fc <expf+0x60>
 800e0ce:	2322      	movs	r3, #34	; 0x22
 800e0d0:	6003      	str	r3, [r0, #0]
 800e0d2:	eeb0 0a48 	vmov.f32	s0, s16
 800e0d6:	ecbd 8b02 	vpop	{d8}
 800e0da:	bd08      	pop	{r3, pc}
 800e0dc:	eddf 7a08 	vldr	s15, [pc, #32]	; 800e100 <expf+0x64>
 800e0e0:	eef4 8ae7 	vcmpe.f32	s17, s15
 800e0e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e0e8:	d5f3      	bpl.n	800e0d2 <expf+0x36>
 800e0ea:	f7ff fb49 	bl	800d780 <__errno>
 800e0ee:	2322      	movs	r3, #34	; 0x22
 800e0f0:	ed9f 8a04 	vldr	s16, [pc, #16]	; 800e104 <expf+0x68>
 800e0f4:	6003      	str	r3, [r0, #0]
 800e0f6:	e7ec      	b.n	800e0d2 <expf+0x36>
 800e0f8:	42b17217 	.word	0x42b17217
 800e0fc:	7f800000 	.word	0x7f800000
 800e100:	c2cff1b5 	.word	0xc2cff1b5
 800e104:	00000000 	.word	0x00000000

0800e108 <cosf>:
 800e108:	ee10 3a10 	vmov	r3, s0
 800e10c:	b507      	push	{r0, r1, r2, lr}
 800e10e:	4a1e      	ldr	r2, [pc, #120]	; (800e188 <cosf+0x80>)
 800e110:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e114:	4293      	cmp	r3, r2
 800e116:	dc06      	bgt.n	800e126 <cosf+0x1e>
 800e118:	eddf 0a1c 	vldr	s1, [pc, #112]	; 800e18c <cosf+0x84>
 800e11c:	b003      	add	sp, #12
 800e11e:	f85d eb04 	ldr.w	lr, [sp], #4
 800e122:	f000 b8f5 	b.w	800e310 <__kernel_cosf>
 800e126:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e12a:	db04      	blt.n	800e136 <cosf+0x2e>
 800e12c:	ee30 0a40 	vsub.f32	s0, s0, s0
 800e130:	b003      	add	sp, #12
 800e132:	f85d fb04 	ldr.w	pc, [sp], #4
 800e136:	4668      	mov	r0, sp
 800e138:	f000 fa5e 	bl	800e5f8 <__ieee754_rem_pio2f>
 800e13c:	f000 0003 	and.w	r0, r0, #3
 800e140:	2801      	cmp	r0, #1
 800e142:	d009      	beq.n	800e158 <cosf+0x50>
 800e144:	2802      	cmp	r0, #2
 800e146:	d010      	beq.n	800e16a <cosf+0x62>
 800e148:	b9b0      	cbnz	r0, 800e178 <cosf+0x70>
 800e14a:	eddd 0a01 	vldr	s1, [sp, #4]
 800e14e:	ed9d 0a00 	vldr	s0, [sp]
 800e152:	f000 f8dd 	bl	800e310 <__kernel_cosf>
 800e156:	e7eb      	b.n	800e130 <cosf+0x28>
 800e158:	eddd 0a01 	vldr	s1, [sp, #4]
 800e15c:	ed9d 0a00 	vldr	s0, [sp]
 800e160:	f000 f934 	bl	800e3cc <__kernel_sinf>
 800e164:	eeb1 0a40 	vneg.f32	s0, s0
 800e168:	e7e2      	b.n	800e130 <cosf+0x28>
 800e16a:	eddd 0a01 	vldr	s1, [sp, #4]
 800e16e:	ed9d 0a00 	vldr	s0, [sp]
 800e172:	f000 f8cd 	bl	800e310 <__kernel_cosf>
 800e176:	e7f5      	b.n	800e164 <cosf+0x5c>
 800e178:	eddd 0a01 	vldr	s1, [sp, #4]
 800e17c:	ed9d 0a00 	vldr	s0, [sp]
 800e180:	2001      	movs	r0, #1
 800e182:	f000 f923 	bl	800e3cc <__kernel_sinf>
 800e186:	e7d3      	b.n	800e130 <cosf+0x28>
 800e188:	3f490fd8 	.word	0x3f490fd8
 800e18c:	00000000 	.word	0x00000000

0800e190 <fabsf>:
 800e190:	ee10 3a10 	vmov	r3, s0
 800e194:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e198:	ee00 3a10 	vmov	s0, r3
 800e19c:	4770      	bx	lr
	...

0800e1a0 <sinf>:
 800e1a0:	ee10 3a10 	vmov	r3, s0
 800e1a4:	b507      	push	{r0, r1, r2, lr}
 800e1a6:	4a1f      	ldr	r2, [pc, #124]	; (800e224 <sinf+0x84>)
 800e1a8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e1ac:	4293      	cmp	r3, r2
 800e1ae:	dc07      	bgt.n	800e1c0 <sinf+0x20>
 800e1b0:	eddf 0a1d 	vldr	s1, [pc, #116]	; 800e228 <sinf+0x88>
 800e1b4:	2000      	movs	r0, #0
 800e1b6:	b003      	add	sp, #12
 800e1b8:	f85d eb04 	ldr.w	lr, [sp], #4
 800e1bc:	f000 b906 	b.w	800e3cc <__kernel_sinf>
 800e1c0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e1c4:	db04      	blt.n	800e1d0 <sinf+0x30>
 800e1c6:	ee30 0a40 	vsub.f32	s0, s0, s0
 800e1ca:	b003      	add	sp, #12
 800e1cc:	f85d fb04 	ldr.w	pc, [sp], #4
 800e1d0:	4668      	mov	r0, sp
 800e1d2:	f000 fa11 	bl	800e5f8 <__ieee754_rem_pio2f>
 800e1d6:	f000 0003 	and.w	r0, r0, #3
 800e1da:	2801      	cmp	r0, #1
 800e1dc:	d00a      	beq.n	800e1f4 <sinf+0x54>
 800e1de:	2802      	cmp	r0, #2
 800e1e0:	d00f      	beq.n	800e202 <sinf+0x62>
 800e1e2:	b9c0      	cbnz	r0, 800e216 <sinf+0x76>
 800e1e4:	eddd 0a01 	vldr	s1, [sp, #4]
 800e1e8:	ed9d 0a00 	vldr	s0, [sp]
 800e1ec:	2001      	movs	r0, #1
 800e1ee:	f000 f8ed 	bl	800e3cc <__kernel_sinf>
 800e1f2:	e7ea      	b.n	800e1ca <sinf+0x2a>
 800e1f4:	eddd 0a01 	vldr	s1, [sp, #4]
 800e1f8:	ed9d 0a00 	vldr	s0, [sp]
 800e1fc:	f000 f888 	bl	800e310 <__kernel_cosf>
 800e200:	e7e3      	b.n	800e1ca <sinf+0x2a>
 800e202:	eddd 0a01 	vldr	s1, [sp, #4]
 800e206:	ed9d 0a00 	vldr	s0, [sp]
 800e20a:	2001      	movs	r0, #1
 800e20c:	f000 f8de 	bl	800e3cc <__kernel_sinf>
 800e210:	eeb1 0a40 	vneg.f32	s0, s0
 800e214:	e7d9      	b.n	800e1ca <sinf+0x2a>
 800e216:	eddd 0a01 	vldr	s1, [sp, #4]
 800e21a:	ed9d 0a00 	vldr	s0, [sp]
 800e21e:	f000 f877 	bl	800e310 <__kernel_cosf>
 800e222:	e7f5      	b.n	800e210 <sinf+0x70>
 800e224:	3f490fd8 	.word	0x3f490fd8
 800e228:	00000000 	.word	0x00000000

0800e22c <finitef>:
 800e22c:	b082      	sub	sp, #8
 800e22e:	ed8d 0a01 	vstr	s0, [sp, #4]
 800e232:	9801      	ldr	r0, [sp, #4]
 800e234:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800e238:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 800e23c:	bfac      	ite	ge
 800e23e:	2000      	movge	r0, #0
 800e240:	2001      	movlt	r0, #1
 800e242:	b002      	add	sp, #8
 800e244:	4770      	bx	lr

0800e246 <with_errnof>:
 800e246:	b513      	push	{r0, r1, r4, lr}
 800e248:	4604      	mov	r4, r0
 800e24a:	ed8d 0a01 	vstr	s0, [sp, #4]
 800e24e:	f7ff fa97 	bl	800d780 <__errno>
 800e252:	ed9d 0a01 	vldr	s0, [sp, #4]
 800e256:	6004      	str	r4, [r0, #0]
 800e258:	b002      	add	sp, #8
 800e25a:	bd10      	pop	{r4, pc}

0800e25c <xflowf>:
 800e25c:	b130      	cbz	r0, 800e26c <xflowf+0x10>
 800e25e:	eef1 7a40 	vneg.f32	s15, s0
 800e262:	ee27 0a80 	vmul.f32	s0, s15, s0
 800e266:	2022      	movs	r0, #34	; 0x22
 800e268:	f7ff bfed 	b.w	800e246 <with_errnof>
 800e26c:	eef0 7a40 	vmov.f32	s15, s0
 800e270:	e7f7      	b.n	800e262 <xflowf+0x6>
	...

0800e274 <__math_uflowf>:
 800e274:	ed9f 0a01 	vldr	s0, [pc, #4]	; 800e27c <__math_uflowf+0x8>
 800e278:	f7ff bff0 	b.w	800e25c <xflowf>
 800e27c:	10000000 	.word	0x10000000

0800e280 <__math_oflowf>:
 800e280:	ed9f 0a01 	vldr	s0, [pc, #4]	; 800e288 <__math_oflowf+0x8>
 800e284:	f7ff bfea 	b.w	800e25c <xflowf>
 800e288:	70000000 	.word	0x70000000

0800e28c <floorf>:
 800e28c:	ee10 3a10 	vmov	r3, s0
 800e290:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 800e294:	3a7f      	subs	r2, #127	; 0x7f
 800e296:	2a16      	cmp	r2, #22
 800e298:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 800e29c:	dc2a      	bgt.n	800e2f4 <floorf+0x68>
 800e29e:	2a00      	cmp	r2, #0
 800e2a0:	da11      	bge.n	800e2c6 <floorf+0x3a>
 800e2a2:	eddf 7a18 	vldr	s15, [pc, #96]	; 800e304 <floorf+0x78>
 800e2a6:	ee30 0a27 	vadd.f32	s0, s0, s15
 800e2aa:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800e2ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e2b2:	dd05      	ble.n	800e2c0 <floorf+0x34>
 800e2b4:	2b00      	cmp	r3, #0
 800e2b6:	da23      	bge.n	800e300 <floorf+0x74>
 800e2b8:	4a13      	ldr	r2, [pc, #76]	; (800e308 <floorf+0x7c>)
 800e2ba:	2900      	cmp	r1, #0
 800e2bc:	bf18      	it	ne
 800e2be:	4613      	movne	r3, r2
 800e2c0:	ee00 3a10 	vmov	s0, r3
 800e2c4:	4770      	bx	lr
 800e2c6:	4911      	ldr	r1, [pc, #68]	; (800e30c <floorf+0x80>)
 800e2c8:	4111      	asrs	r1, r2
 800e2ca:	420b      	tst	r3, r1
 800e2cc:	d0fa      	beq.n	800e2c4 <floorf+0x38>
 800e2ce:	eddf 7a0d 	vldr	s15, [pc, #52]	; 800e304 <floorf+0x78>
 800e2d2:	ee30 0a27 	vadd.f32	s0, s0, s15
 800e2d6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800e2da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e2de:	ddef      	ble.n	800e2c0 <floorf+0x34>
 800e2e0:	2b00      	cmp	r3, #0
 800e2e2:	bfbe      	ittt	lt
 800e2e4:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 800e2e8:	fa40 f202 	asrlt.w	r2, r0, r2
 800e2ec:	189b      	addlt	r3, r3, r2
 800e2ee:	ea23 0301 	bic.w	r3, r3, r1
 800e2f2:	e7e5      	b.n	800e2c0 <floorf+0x34>
 800e2f4:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 800e2f8:	d3e4      	bcc.n	800e2c4 <floorf+0x38>
 800e2fa:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e2fe:	4770      	bx	lr
 800e300:	2300      	movs	r3, #0
 800e302:	e7dd      	b.n	800e2c0 <floorf+0x34>
 800e304:	7149f2ca 	.word	0x7149f2ca
 800e308:	bf800000 	.word	0xbf800000
 800e30c:	007fffff 	.word	0x007fffff

0800e310 <__kernel_cosf>:
 800e310:	ee10 3a10 	vmov	r3, s0
 800e314:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e318:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800e31c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800e320:	da05      	bge.n	800e32e <__kernel_cosf+0x1e>
 800e322:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 800e326:	ee17 2a90 	vmov	r2, s15
 800e32a:	2a00      	cmp	r2, #0
 800e32c:	d03b      	beq.n	800e3a6 <__kernel_cosf+0x96>
 800e32e:	ee20 7a00 	vmul.f32	s14, s0, s0
 800e332:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800e3ac <__kernel_cosf+0x9c>
 800e336:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 800e3b0 <__kernel_cosf+0xa0>
 800e33a:	4a1e      	ldr	r2, [pc, #120]	; (800e3b4 <__kernel_cosf+0xa4>)
 800e33c:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e340:	4293      	cmp	r3, r2
 800e342:	eddf 7a1d 	vldr	s15, [pc, #116]	; 800e3b8 <__kernel_cosf+0xa8>
 800e346:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e34a:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 800e3bc <__kernel_cosf+0xac>
 800e34e:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e352:	eddf 7a1b 	vldr	s15, [pc, #108]	; 800e3c0 <__kernel_cosf+0xb0>
 800e356:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e35a:	ed9f 6a1a 	vldr	s12, [pc, #104]	; 800e3c4 <__kernel_cosf+0xb4>
 800e35e:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e362:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 800e366:	ee26 6a07 	vmul.f32	s12, s12, s14
 800e36a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800e36e:	eee7 0a06 	vfma.f32	s1, s14, s12
 800e372:	ee67 7a27 	vmul.f32	s15, s14, s15
 800e376:	dc04      	bgt.n	800e382 <__kernel_cosf+0x72>
 800e378:	ee77 7ae0 	vsub.f32	s15, s15, s1
 800e37c:	ee36 0ae7 	vsub.f32	s0, s13, s15
 800e380:	4770      	bx	lr
 800e382:	4a11      	ldr	r2, [pc, #68]	; (800e3c8 <__kernel_cosf+0xb8>)
 800e384:	4293      	cmp	r3, r2
 800e386:	bfda      	itte	le
 800e388:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 800e38c:	ee07 3a10 	vmovle	s14, r3
 800e390:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 800e394:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e398:	ee36 0ac7 	vsub.f32	s0, s13, s14
 800e39c:	ee77 7ae0 	vsub.f32	s15, s15, s1
 800e3a0:	ee30 0a67 	vsub.f32	s0, s0, s15
 800e3a4:	4770      	bx	lr
 800e3a6:	eeb0 0a66 	vmov.f32	s0, s13
 800e3aa:	4770      	bx	lr
 800e3ac:	ad47d74e 	.word	0xad47d74e
 800e3b0:	310f74f6 	.word	0x310f74f6
 800e3b4:	3e999999 	.word	0x3e999999
 800e3b8:	b493f27c 	.word	0xb493f27c
 800e3bc:	37d00d01 	.word	0x37d00d01
 800e3c0:	bab60b61 	.word	0xbab60b61
 800e3c4:	3d2aaaab 	.word	0x3d2aaaab
 800e3c8:	3f480000 	.word	0x3f480000

0800e3cc <__kernel_sinf>:
 800e3cc:	ee10 3a10 	vmov	r3, s0
 800e3d0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e3d4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800e3d8:	da04      	bge.n	800e3e4 <__kernel_sinf+0x18>
 800e3da:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 800e3de:	ee17 3a90 	vmov	r3, s15
 800e3e2:	b35b      	cbz	r3, 800e43c <__kernel_sinf+0x70>
 800e3e4:	ee20 7a00 	vmul.f32	s14, s0, s0
 800e3e8:	eddf 7a15 	vldr	s15, [pc, #84]	; 800e440 <__kernel_sinf+0x74>
 800e3ec:	ed9f 6a15 	vldr	s12, [pc, #84]	; 800e444 <__kernel_sinf+0x78>
 800e3f0:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e3f4:	eddf 7a14 	vldr	s15, [pc, #80]	; 800e448 <__kernel_sinf+0x7c>
 800e3f8:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e3fc:	ed9f 6a13 	vldr	s12, [pc, #76]	; 800e44c <__kernel_sinf+0x80>
 800e400:	eea7 6a87 	vfma.f32	s12, s15, s14
 800e404:	eddf 7a12 	vldr	s15, [pc, #72]	; 800e450 <__kernel_sinf+0x84>
 800e408:	ee60 6a07 	vmul.f32	s13, s0, s14
 800e40c:	eee6 7a07 	vfma.f32	s15, s12, s14
 800e410:	b930      	cbnz	r0, 800e420 <__kernel_sinf+0x54>
 800e412:	ed9f 6a10 	vldr	s12, [pc, #64]	; 800e454 <__kernel_sinf+0x88>
 800e416:	eea7 6a27 	vfma.f32	s12, s14, s15
 800e41a:	eea6 0a26 	vfma.f32	s0, s12, s13
 800e41e:	4770      	bx	lr
 800e420:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 800e424:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 800e428:	eee0 7a86 	vfma.f32	s15, s1, s12
 800e42c:	eed7 0a87 	vfnms.f32	s1, s15, s14
 800e430:	eddf 7a09 	vldr	s15, [pc, #36]	; 800e458 <__kernel_sinf+0x8c>
 800e434:	eee6 0aa7 	vfma.f32	s1, s13, s15
 800e438:	ee30 0a60 	vsub.f32	s0, s0, s1
 800e43c:	4770      	bx	lr
 800e43e:	bf00      	nop
 800e440:	2f2ec9d3 	.word	0x2f2ec9d3
 800e444:	b2d72f34 	.word	0xb2d72f34
 800e448:	3638ef1b 	.word	0x3638ef1b
 800e44c:	b9500d01 	.word	0xb9500d01
 800e450:	3c088889 	.word	0x3c088889
 800e454:	be2aaaab 	.word	0xbe2aaaab
 800e458:	3e2aaaab 	.word	0x3e2aaaab

0800e45c <__ieee754_expf>:
 800e45c:	ee10 2a10 	vmov	r2, s0
 800e460:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 800e464:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800e468:	d902      	bls.n	800e470 <__ieee754_expf+0x14>
 800e46a:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e46e:	4770      	bx	lr
 800e470:	ea4f 71d2 	mov.w	r1, r2, lsr #31
 800e474:	d106      	bne.n	800e484 <__ieee754_expf+0x28>
 800e476:	eddf 7a4e 	vldr	s15, [pc, #312]	; 800e5b0 <__ieee754_expf+0x154>
 800e47a:	2900      	cmp	r1, #0
 800e47c:	bf18      	it	ne
 800e47e:	eeb0 0a67 	vmovne.f32	s0, s15
 800e482:	4770      	bx	lr
 800e484:	484b      	ldr	r0, [pc, #300]	; (800e5b4 <__ieee754_expf+0x158>)
 800e486:	4282      	cmp	r2, r0
 800e488:	dd02      	ble.n	800e490 <__ieee754_expf+0x34>
 800e48a:	2000      	movs	r0, #0
 800e48c:	f7ff bef8 	b.w	800e280 <__math_oflowf>
 800e490:	2a00      	cmp	r2, #0
 800e492:	da05      	bge.n	800e4a0 <__ieee754_expf+0x44>
 800e494:	4a48      	ldr	r2, [pc, #288]	; (800e5b8 <__ieee754_expf+0x15c>)
 800e496:	4293      	cmp	r3, r2
 800e498:	d902      	bls.n	800e4a0 <__ieee754_expf+0x44>
 800e49a:	2000      	movs	r0, #0
 800e49c:	f7ff beea 	b.w	800e274 <__math_uflowf>
 800e4a0:	4a46      	ldr	r2, [pc, #280]	; (800e5bc <__ieee754_expf+0x160>)
 800e4a2:	4293      	cmp	r3, r2
 800e4a4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 800e4a8:	d952      	bls.n	800e550 <__ieee754_expf+0xf4>
 800e4aa:	4a45      	ldr	r2, [pc, #276]	; (800e5c0 <__ieee754_expf+0x164>)
 800e4ac:	4293      	cmp	r3, r2
 800e4ae:	ea4f 0281 	mov.w	r2, r1, lsl #2
 800e4b2:	d834      	bhi.n	800e51e <__ieee754_expf+0xc2>
 800e4b4:	4b43      	ldr	r3, [pc, #268]	; (800e5c4 <__ieee754_expf+0x168>)
 800e4b6:	4413      	add	r3, r2
 800e4b8:	ed93 7a00 	vldr	s14, [r3]
 800e4bc:	4b42      	ldr	r3, [pc, #264]	; (800e5c8 <__ieee754_expf+0x16c>)
 800e4be:	4413      	add	r3, r2
 800e4c0:	ee30 7a47 	vsub.f32	s14, s0, s14
 800e4c4:	f1c1 0201 	rsb	r2, r1, #1
 800e4c8:	edd3 7a00 	vldr	s15, [r3]
 800e4cc:	1a52      	subs	r2, r2, r1
 800e4ce:	ee37 0a67 	vsub.f32	s0, s14, s15
 800e4d2:	ee20 6a00 	vmul.f32	s12, s0, s0
 800e4d6:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 800e5cc <__ieee754_expf+0x170>
 800e4da:	eddf 6a3d 	vldr	s13, [pc, #244]	; 800e5d0 <__ieee754_expf+0x174>
 800e4de:	eee6 6a05 	vfma.f32	s13, s12, s10
 800e4e2:	ed9f 5a3c 	vldr	s10, [pc, #240]	; 800e5d4 <__ieee754_expf+0x178>
 800e4e6:	eea6 5a86 	vfma.f32	s10, s13, s12
 800e4ea:	eddf 6a3b 	vldr	s13, [pc, #236]	; 800e5d8 <__ieee754_expf+0x17c>
 800e4ee:	eee5 6a06 	vfma.f32	s13, s10, s12
 800e4f2:	ed9f 5a3a 	vldr	s10, [pc, #232]	; 800e5dc <__ieee754_expf+0x180>
 800e4f6:	eea6 5a86 	vfma.f32	s10, s13, s12
 800e4fa:	eef0 6a40 	vmov.f32	s13, s0
 800e4fe:	eee5 6a46 	vfms.f32	s13, s10, s12
 800e502:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 800e506:	ee20 5a26 	vmul.f32	s10, s0, s13
 800e50a:	bb92      	cbnz	r2, 800e572 <__ieee754_expf+0x116>
 800e50c:	ee76 6ac6 	vsub.f32	s13, s13, s12
 800e510:	eec5 7a26 	vdiv.f32	s15, s10, s13
 800e514:	ee37 0ac0 	vsub.f32	s0, s15, s0
 800e518:	ee35 0ac0 	vsub.f32	s0, s11, s0
 800e51c:	4770      	bx	lr
 800e51e:	4b30      	ldr	r3, [pc, #192]	; (800e5e0 <__ieee754_expf+0x184>)
 800e520:	ed9f 7a30 	vldr	s14, [pc, #192]	; 800e5e4 <__ieee754_expf+0x188>
 800e524:	eddf 6a30 	vldr	s13, [pc, #192]	; 800e5e8 <__ieee754_expf+0x18c>
 800e528:	4413      	add	r3, r2
 800e52a:	edd3 7a00 	vldr	s15, [r3]
 800e52e:	eee0 7a07 	vfma.f32	s15, s0, s14
 800e532:	eeb0 7a40 	vmov.f32	s14, s0
 800e536:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800e53a:	ee17 2a90 	vmov	r2, s15
 800e53e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e542:	eea7 7ae6 	vfms.f32	s14, s15, s13
 800e546:	eddf 6a29 	vldr	s13, [pc, #164]	; 800e5ec <__ieee754_expf+0x190>
 800e54a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e54e:	e7be      	b.n	800e4ce <__ieee754_expf+0x72>
 800e550:	f1b3 5f50 	cmp.w	r3, #872415232	; 0x34000000
 800e554:	d20b      	bcs.n	800e56e <__ieee754_expf+0x112>
 800e556:	eddf 6a26 	vldr	s13, [pc, #152]	; 800e5f0 <__ieee754_expf+0x194>
 800e55a:	ee70 6a26 	vadd.f32	s13, s0, s13
 800e55e:	eef4 6ae5 	vcmpe.f32	s13, s11
 800e562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e566:	dd02      	ble.n	800e56e <__ieee754_expf+0x112>
 800e568:	ee30 0a25 	vadd.f32	s0, s0, s11
 800e56c:	4770      	bx	lr
 800e56e:	2200      	movs	r2, #0
 800e570:	e7af      	b.n	800e4d2 <__ieee754_expf+0x76>
 800e572:	ee36 6a66 	vsub.f32	s12, s12, s13
 800e576:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
 800e57a:	eec5 6a06 	vdiv.f32	s13, s10, s12
 800e57e:	bfb8      	it	lt
 800e580:	3264      	addlt	r2, #100	; 0x64
 800e582:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e586:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e58a:	ee75 7ae7 	vsub.f32	s15, s11, s15
 800e58e:	ee17 3a90 	vmov	r3, s15
 800e592:	bfab      	itete	ge
 800e594:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 800e598:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 800e59c:	ee00 3a10 	vmovge	s0, r3
 800e5a0:	eddf 7a14 	vldrlt	s15, [pc, #80]	; 800e5f4 <__ieee754_expf+0x198>
 800e5a4:	bfbc      	itt	lt
 800e5a6:	ee00 3a10 	vmovlt	s0, r3
 800e5aa:	ee20 0a27 	vmullt.f32	s0, s0, s15
 800e5ae:	4770      	bx	lr
 800e5b0:	00000000 	.word	0x00000000
 800e5b4:	42b17217 	.word	0x42b17217
 800e5b8:	42cff1b5 	.word	0x42cff1b5
 800e5bc:	3eb17218 	.word	0x3eb17218
 800e5c0:	3f851591 	.word	0x3f851591
 800e5c4:	0801a214 	.word	0x0801a214
 800e5c8:	0801a21c 	.word	0x0801a21c
 800e5cc:	3331bb4c 	.word	0x3331bb4c
 800e5d0:	b5ddea0e 	.word	0xb5ddea0e
 800e5d4:	388ab355 	.word	0x388ab355
 800e5d8:	bb360b61 	.word	0xbb360b61
 800e5dc:	3e2aaaab 	.word	0x3e2aaaab
 800e5e0:	0801a20c 	.word	0x0801a20c
 800e5e4:	3fb8aa3b 	.word	0x3fb8aa3b
 800e5e8:	3f317180 	.word	0x3f317180
 800e5ec:	3717f7d1 	.word	0x3717f7d1
 800e5f0:	7149f2ca 	.word	0x7149f2ca
 800e5f4:	0d800000 	.word	0x0d800000

0800e5f8 <__ieee754_rem_pio2f>:
 800e5f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e5fa:	ee10 6a10 	vmov	r6, s0
 800e5fe:	4b86      	ldr	r3, [pc, #536]	; (800e818 <__ieee754_rem_pio2f+0x220>)
 800e600:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 800e604:	429d      	cmp	r5, r3
 800e606:	b087      	sub	sp, #28
 800e608:	4604      	mov	r4, r0
 800e60a:	dc05      	bgt.n	800e618 <__ieee754_rem_pio2f+0x20>
 800e60c:	2300      	movs	r3, #0
 800e60e:	ed80 0a00 	vstr	s0, [r0]
 800e612:	6043      	str	r3, [r0, #4]
 800e614:	2000      	movs	r0, #0
 800e616:	e020      	b.n	800e65a <__ieee754_rem_pio2f+0x62>
 800e618:	4b80      	ldr	r3, [pc, #512]	; (800e81c <__ieee754_rem_pio2f+0x224>)
 800e61a:	429d      	cmp	r5, r3
 800e61c:	dc38      	bgt.n	800e690 <__ieee754_rem_pio2f+0x98>
 800e61e:	2e00      	cmp	r6, #0
 800e620:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 800e820 <__ieee754_rem_pio2f+0x228>
 800e624:	4b7f      	ldr	r3, [pc, #508]	; (800e824 <__ieee754_rem_pio2f+0x22c>)
 800e626:	f025 050f 	bic.w	r5, r5, #15
 800e62a:	dd18      	ble.n	800e65e <__ieee754_rem_pio2f+0x66>
 800e62c:	429d      	cmp	r5, r3
 800e62e:	ee70 7a47 	vsub.f32	s15, s0, s14
 800e632:	bf09      	itett	eq
 800e634:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 800e828 <__ieee754_rem_pio2f+0x230>
 800e638:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 800e82c <__ieee754_rem_pio2f+0x234>
 800e63c:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 800e640:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 800e830 <__ieee754_rem_pio2f+0x238>
 800e644:	ee77 6ac7 	vsub.f32	s13, s15, s14
 800e648:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e64c:	edc0 6a00 	vstr	s13, [r0]
 800e650:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e654:	edc0 7a01 	vstr	s15, [r0, #4]
 800e658:	2001      	movs	r0, #1
 800e65a:	b007      	add	sp, #28
 800e65c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e65e:	429d      	cmp	r5, r3
 800e660:	ee70 7a07 	vadd.f32	s15, s0, s14
 800e664:	bf09      	itett	eq
 800e666:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 800e828 <__ieee754_rem_pio2f+0x230>
 800e66a:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 800e82c <__ieee754_rem_pio2f+0x234>
 800e66e:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 800e672:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 800e830 <__ieee754_rem_pio2f+0x238>
 800e676:	ee77 6a87 	vadd.f32	s13, s15, s14
 800e67a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800e67e:	edc0 6a00 	vstr	s13, [r0]
 800e682:	ee77 7a87 	vadd.f32	s15, s15, s14
 800e686:	edc0 7a01 	vstr	s15, [r0, #4]
 800e68a:	f04f 30ff 	mov.w	r0, #4294967295
 800e68e:	e7e4      	b.n	800e65a <__ieee754_rem_pio2f+0x62>
 800e690:	4b68      	ldr	r3, [pc, #416]	; (800e834 <__ieee754_rem_pio2f+0x23c>)
 800e692:	429d      	cmp	r5, r3
 800e694:	dc71      	bgt.n	800e77a <__ieee754_rem_pio2f+0x182>
 800e696:	f7ff fd7b 	bl	800e190 <fabsf>
 800e69a:	ed9f 7a67 	vldr	s14, [pc, #412]	; 800e838 <__ieee754_rem_pio2f+0x240>
 800e69e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800e6a2:	eee0 7a07 	vfma.f32	s15, s0, s14
 800e6a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800e6aa:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800e6ae:	ee17 0a90 	vmov	r0, s15
 800e6b2:	eddf 7a5b 	vldr	s15, [pc, #364]	; 800e820 <__ieee754_rem_pio2f+0x228>
 800e6b6:	eea7 0a67 	vfms.f32	s0, s14, s15
 800e6ba:	281f      	cmp	r0, #31
 800e6bc:	eddf 7a5b 	vldr	s15, [pc, #364]	; 800e82c <__ieee754_rem_pio2f+0x234>
 800e6c0:	ee67 7a27 	vmul.f32	s15, s14, s15
 800e6c4:	eeb1 6a47 	vneg.f32	s12, s14
 800e6c8:	ee70 6a67 	vsub.f32	s13, s0, s15
 800e6cc:	ee16 2a90 	vmov	r2, s13
 800e6d0:	dc1c      	bgt.n	800e70c <__ieee754_rem_pio2f+0x114>
 800e6d2:	495a      	ldr	r1, [pc, #360]	; (800e83c <__ieee754_rem_pio2f+0x244>)
 800e6d4:	1e47      	subs	r7, r0, #1
 800e6d6:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 800e6da:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 800e6de:	428b      	cmp	r3, r1
 800e6e0:	d014      	beq.n	800e70c <__ieee754_rem_pio2f+0x114>
 800e6e2:	6022      	str	r2, [r4, #0]
 800e6e4:	ed94 7a00 	vldr	s14, [r4]
 800e6e8:	ee30 0a47 	vsub.f32	s0, s0, s14
 800e6ec:	2e00      	cmp	r6, #0
 800e6ee:	ee30 0a67 	vsub.f32	s0, s0, s15
 800e6f2:	ed84 0a01 	vstr	s0, [r4, #4]
 800e6f6:	dab0      	bge.n	800e65a <__ieee754_rem_pio2f+0x62>
 800e6f8:	eeb1 7a47 	vneg.f32	s14, s14
 800e6fc:	eeb1 0a40 	vneg.f32	s0, s0
 800e700:	ed84 7a00 	vstr	s14, [r4]
 800e704:	ed84 0a01 	vstr	s0, [r4, #4]
 800e708:	4240      	negs	r0, r0
 800e70a:	e7a6      	b.n	800e65a <__ieee754_rem_pio2f+0x62>
 800e70c:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 800e710:	ebc1 51d5 	rsb	r1, r1, r5, lsr #23
 800e714:	2908      	cmp	r1, #8
 800e716:	ea4f 53e5 	mov.w	r3, r5, asr #23
 800e71a:	dde2      	ble.n	800e6e2 <__ieee754_rem_pio2f+0xea>
 800e71c:	eddf 5a42 	vldr	s11, [pc, #264]	; 800e828 <__ieee754_rem_pio2f+0x230>
 800e720:	eef0 6a40 	vmov.f32	s13, s0
 800e724:	eee6 6a25 	vfma.f32	s13, s12, s11
 800e728:	ee70 7a66 	vsub.f32	s15, s0, s13
 800e72c:	eee6 7a25 	vfma.f32	s15, s12, s11
 800e730:	eddf 5a3f 	vldr	s11, [pc, #252]	; 800e830 <__ieee754_rem_pio2f+0x238>
 800e734:	eed7 7a25 	vfnms.f32	s15, s14, s11
 800e738:	ee76 5ae7 	vsub.f32	s11, s13, s15
 800e73c:	ee15 2a90 	vmov	r2, s11
 800e740:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 800e744:	1a5b      	subs	r3, r3, r1
 800e746:	2b19      	cmp	r3, #25
 800e748:	dc04      	bgt.n	800e754 <__ieee754_rem_pio2f+0x15c>
 800e74a:	edc4 5a00 	vstr	s11, [r4]
 800e74e:	eeb0 0a66 	vmov.f32	s0, s13
 800e752:	e7c7      	b.n	800e6e4 <__ieee754_rem_pio2f+0xec>
 800e754:	eddf 5a3a 	vldr	s11, [pc, #232]	; 800e840 <__ieee754_rem_pio2f+0x248>
 800e758:	eeb0 0a66 	vmov.f32	s0, s13
 800e75c:	eea6 0a25 	vfma.f32	s0, s12, s11
 800e760:	ee76 7ac0 	vsub.f32	s15, s13, s0
 800e764:	eddf 6a37 	vldr	s13, [pc, #220]	; 800e844 <__ieee754_rem_pio2f+0x24c>
 800e768:	eee6 7a25 	vfma.f32	s15, s12, s11
 800e76c:	eed7 7a26 	vfnms.f32	s15, s14, s13
 800e770:	ee30 7a67 	vsub.f32	s14, s0, s15
 800e774:	ed84 7a00 	vstr	s14, [r4]
 800e778:	e7b4      	b.n	800e6e4 <__ieee754_rem_pio2f+0xec>
 800e77a:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 800e77e:	db06      	blt.n	800e78e <__ieee754_rem_pio2f+0x196>
 800e780:	ee70 7a40 	vsub.f32	s15, s0, s0
 800e784:	edc0 7a01 	vstr	s15, [r0, #4]
 800e788:	edc0 7a00 	vstr	s15, [r0]
 800e78c:	e742      	b.n	800e614 <__ieee754_rem_pio2f+0x1c>
 800e78e:	15ea      	asrs	r2, r5, #23
 800e790:	3a86      	subs	r2, #134	; 0x86
 800e792:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 800e796:	ee07 3a90 	vmov	s15, r3
 800e79a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 800e79e:	eddf 6a2a 	vldr	s13, [pc, #168]	; 800e848 <__ieee754_rem_pio2f+0x250>
 800e7a2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800e7a6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e7aa:	ed8d 7a03 	vstr	s14, [sp, #12]
 800e7ae:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e7b2:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 800e7b6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800e7ba:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e7be:	ed8d 7a04 	vstr	s14, [sp, #16]
 800e7c2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800e7c6:	eef5 7a40 	vcmp.f32	s15, #0.0
 800e7ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7ce:	edcd 7a05 	vstr	s15, [sp, #20]
 800e7d2:	d11e      	bne.n	800e812 <__ieee754_rem_pio2f+0x21a>
 800e7d4:	eeb5 7a40 	vcmp.f32	s14, #0.0
 800e7d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7dc:	bf14      	ite	ne
 800e7de:	2302      	movne	r3, #2
 800e7e0:	2301      	moveq	r3, #1
 800e7e2:	491a      	ldr	r1, [pc, #104]	; (800e84c <__ieee754_rem_pio2f+0x254>)
 800e7e4:	9101      	str	r1, [sp, #4]
 800e7e6:	2102      	movs	r1, #2
 800e7e8:	9100      	str	r1, [sp, #0]
 800e7ea:	a803      	add	r0, sp, #12
 800e7ec:	4621      	mov	r1, r4
 800e7ee:	f000 f895 	bl	800e91c <__kernel_rem_pio2f>
 800e7f2:	2e00      	cmp	r6, #0
 800e7f4:	f6bf af31 	bge.w	800e65a <__ieee754_rem_pio2f+0x62>
 800e7f8:	edd4 7a00 	vldr	s15, [r4]
 800e7fc:	eef1 7a67 	vneg.f32	s15, s15
 800e800:	edc4 7a00 	vstr	s15, [r4]
 800e804:	edd4 7a01 	vldr	s15, [r4, #4]
 800e808:	eef1 7a67 	vneg.f32	s15, s15
 800e80c:	edc4 7a01 	vstr	s15, [r4, #4]
 800e810:	e77a      	b.n	800e708 <__ieee754_rem_pio2f+0x110>
 800e812:	2303      	movs	r3, #3
 800e814:	e7e5      	b.n	800e7e2 <__ieee754_rem_pio2f+0x1ea>
 800e816:	bf00      	nop
 800e818:	3f490fd8 	.word	0x3f490fd8
 800e81c:	4016cbe3 	.word	0x4016cbe3
 800e820:	3fc90f80 	.word	0x3fc90f80
 800e824:	3fc90fd0 	.word	0x3fc90fd0
 800e828:	37354400 	.word	0x37354400
 800e82c:	37354443 	.word	0x37354443
 800e830:	2e85a308 	.word	0x2e85a308
 800e834:	43490f80 	.word	0x43490f80
 800e838:	3f22f984 	.word	0x3f22f984
 800e83c:	0801a224 	.word	0x0801a224
 800e840:	2e85a300 	.word	0x2e85a300
 800e844:	248d3132 	.word	0x248d3132
 800e848:	43800000 	.word	0x43800000
 800e84c:	0801a2a4 	.word	0x0801a2a4

0800e850 <scalbnf>:
 800e850:	ee10 3a10 	vmov	r3, s0
 800e854:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 800e858:	d02b      	beq.n	800e8b2 <scalbnf+0x62>
 800e85a:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 800e85e:	d302      	bcc.n	800e866 <scalbnf+0x16>
 800e860:	ee30 0a00 	vadd.f32	s0, s0, s0
 800e864:	4770      	bx	lr
 800e866:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 800e86a:	d123      	bne.n	800e8b4 <scalbnf+0x64>
 800e86c:	4b24      	ldr	r3, [pc, #144]	; (800e900 <scalbnf+0xb0>)
 800e86e:	eddf 7a25 	vldr	s15, [pc, #148]	; 800e904 <scalbnf+0xb4>
 800e872:	4298      	cmp	r0, r3
 800e874:	ee20 0a27 	vmul.f32	s0, s0, s15
 800e878:	db17      	blt.n	800e8aa <scalbnf+0x5a>
 800e87a:	ee10 3a10 	vmov	r3, s0
 800e87e:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 800e882:	3a19      	subs	r2, #25
 800e884:	f24c 3150 	movw	r1, #50000	; 0xc350
 800e888:	4288      	cmp	r0, r1
 800e88a:	dd15      	ble.n	800e8b8 <scalbnf+0x68>
 800e88c:	eddf 7a1e 	vldr	s15, [pc, #120]	; 800e908 <scalbnf+0xb8>
 800e890:	eddf 6a1e 	vldr	s13, [pc, #120]	; 800e90c <scalbnf+0xbc>
 800e894:	ee10 3a10 	vmov	r3, s0
 800e898:	eeb0 7a67 	vmov.f32	s14, s15
 800e89c:	2b00      	cmp	r3, #0
 800e89e:	bfb8      	it	lt
 800e8a0:	eef0 7a66 	vmovlt.f32	s15, s13
 800e8a4:	ee27 0a87 	vmul.f32	s0, s15, s14
 800e8a8:	4770      	bx	lr
 800e8aa:	eddf 7a19 	vldr	s15, [pc, #100]	; 800e910 <scalbnf+0xc0>
 800e8ae:	ee27 0a80 	vmul.f32	s0, s15, s0
 800e8b2:	4770      	bx	lr
 800e8b4:	0dd2      	lsrs	r2, r2, #23
 800e8b6:	e7e5      	b.n	800e884 <scalbnf+0x34>
 800e8b8:	4410      	add	r0, r2
 800e8ba:	28fe      	cmp	r0, #254	; 0xfe
 800e8bc:	dce6      	bgt.n	800e88c <scalbnf+0x3c>
 800e8be:	2800      	cmp	r0, #0
 800e8c0:	dd06      	ble.n	800e8d0 <scalbnf+0x80>
 800e8c2:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 800e8c6:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 800e8ca:	ee00 3a10 	vmov	s0, r3
 800e8ce:	4770      	bx	lr
 800e8d0:	f110 0f16 	cmn.w	r0, #22
 800e8d4:	da09      	bge.n	800e8ea <scalbnf+0x9a>
 800e8d6:	eddf 7a0e 	vldr	s15, [pc, #56]	; 800e910 <scalbnf+0xc0>
 800e8da:	eddf 6a0e 	vldr	s13, [pc, #56]	; 800e914 <scalbnf+0xc4>
 800e8de:	ee10 3a10 	vmov	r3, s0
 800e8e2:	eeb0 7a67 	vmov.f32	s14, s15
 800e8e6:	2b00      	cmp	r3, #0
 800e8e8:	e7d9      	b.n	800e89e <scalbnf+0x4e>
 800e8ea:	3019      	adds	r0, #25
 800e8ec:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 800e8f0:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 800e8f4:	ed9f 0a08 	vldr	s0, [pc, #32]	; 800e918 <scalbnf+0xc8>
 800e8f8:	ee07 3a90 	vmov	s15, r3
 800e8fc:	e7d7      	b.n	800e8ae <scalbnf+0x5e>
 800e8fe:	bf00      	nop
 800e900:	ffff3cb0 	.word	0xffff3cb0
 800e904:	4c000000 	.word	0x4c000000
 800e908:	7149f2ca 	.word	0x7149f2ca
 800e90c:	f149f2ca 	.word	0xf149f2ca
 800e910:	0da24260 	.word	0x0da24260
 800e914:	8da24260 	.word	0x8da24260
 800e918:	33000000 	.word	0x33000000

0800e91c <__kernel_rem_pio2f>:
 800e91c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e920:	ed2d 8b04 	vpush	{d8-d9}
 800e924:	b0d9      	sub	sp, #356	; 0x164
 800e926:	4688      	mov	r8, r1
 800e928:	9002      	str	r0, [sp, #8]
 800e92a:	49b8      	ldr	r1, [pc, #736]	; (800ec0c <__kernel_rem_pio2f+0x2f0>)
 800e92c:	9866      	ldr	r0, [sp, #408]	; 0x198
 800e92e:	9301      	str	r3, [sp, #4]
 800e930:	f851 a020 	ldr.w	sl, [r1, r0, lsl #2]
 800e934:	9901      	ldr	r1, [sp, #4]
 800e936:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 800e938:	f101 3bff 	add.w	fp, r1, #4294967295
 800e93c:	1d11      	adds	r1, r2, #4
 800e93e:	db25      	blt.n	800e98c <__kernel_rem_pio2f+0x70>
 800e940:	1ed0      	subs	r0, r2, #3
 800e942:	bf48      	it	mi
 800e944:	1d10      	addmi	r0, r2, #4
 800e946:	10c0      	asrs	r0, r0, #3
 800e948:	1c45      	adds	r5, r0, #1
 800e94a:	00e9      	lsls	r1, r5, #3
 800e94c:	eba0 070b 	sub.w	r7, r0, fp
 800e950:	ed9f 7ab2 	vldr	s14, [pc, #712]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800e954:	9103      	str	r1, [sp, #12]
 800e956:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 800e95a:	eb0a 0c0b 	add.w	ip, sl, fp
 800e95e:	ae1c      	add	r6, sp, #112	; 0x70
 800e960:	eb03 0e87 	add.w	lr, r3, r7, lsl #2
 800e964:	2400      	movs	r4, #0
 800e966:	4564      	cmp	r4, ip
 800e968:	dd12      	ble.n	800e990 <__kernel_rem_pio2f+0x74>
 800e96a:	9901      	ldr	r1, [sp, #4]
 800e96c:	ac1c      	add	r4, sp, #112	; 0x70
 800e96e:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 800e972:	f50d 7988 	add.w	r9, sp, #272	; 0x110
 800e976:	f04f 0c00 	mov.w	ip, #0
 800e97a:	45d4      	cmp	ip, sl
 800e97c:	dc27      	bgt.n	800e9ce <__kernel_rem_pio2f+0xb2>
 800e97e:	f8dd e008 	ldr.w	lr, [sp, #8]
 800e982:	eddf 7aa6 	vldr	s15, [pc, #664]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800e986:	4627      	mov	r7, r4
 800e988:	2600      	movs	r6, #0
 800e98a:	e016      	b.n	800e9ba <__kernel_rem_pio2f+0x9e>
 800e98c:	2000      	movs	r0, #0
 800e98e:	e7db      	b.n	800e948 <__kernel_rem_pio2f+0x2c>
 800e990:	42e7      	cmn	r7, r4
 800e992:	bf5d      	ittte	pl
 800e994:	f85e 1024 	ldrpl.w	r1, [lr, r4, lsl #2]
 800e998:	ee07 1a90 	vmovpl	s15, r1
 800e99c:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 800e9a0:	eef0 7a47 	vmovmi.f32	s15, s14
 800e9a4:	ece6 7a01 	vstmia	r6!, {s15}
 800e9a8:	3401      	adds	r4, #1
 800e9aa:	e7dc      	b.n	800e966 <__kernel_rem_pio2f+0x4a>
 800e9ac:	ecfe 6a01 	vldmia	lr!, {s13}
 800e9b0:	ed97 7a00 	vldr	s14, [r7]
 800e9b4:	eee6 7a87 	vfma.f32	s15, s13, s14
 800e9b8:	3601      	adds	r6, #1
 800e9ba:	455e      	cmp	r6, fp
 800e9bc:	f1a7 0704 	sub.w	r7, r7, #4
 800e9c0:	ddf4      	ble.n	800e9ac <__kernel_rem_pio2f+0x90>
 800e9c2:	ece9 7a01 	vstmia	r9!, {s15}
 800e9c6:	f10c 0c01 	add.w	ip, ip, #1
 800e9ca:	3404      	adds	r4, #4
 800e9cc:	e7d5      	b.n	800e97a <__kernel_rem_pio2f+0x5e>
 800e9ce:	a908      	add	r1, sp, #32
 800e9d0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 800e9d4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800e9d8:	eddf 8a8f 	vldr	s17, [pc, #572]	; 800ec18 <__kernel_rem_pio2f+0x2fc>
 800e9dc:	ed9f 9a8d 	vldr	s18, [pc, #564]	; 800ec14 <__kernel_rem_pio2f+0x2f8>
 800e9e0:	9105      	str	r1, [sp, #20]
 800e9e2:	9304      	str	r3, [sp, #16]
 800e9e4:	4656      	mov	r6, sl
 800e9e6:	00b3      	lsls	r3, r6, #2
 800e9e8:	9306      	str	r3, [sp, #24]
 800e9ea:	ab58      	add	r3, sp, #352	; 0x160
 800e9ec:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 800e9f0:	ac08      	add	r4, sp, #32
 800e9f2:	ab44      	add	r3, sp, #272	; 0x110
 800e9f4:	ed10 0a14 	vldr	s0, [r0, #-80]	; 0xffffffb0
 800e9f8:	46a4      	mov	ip, r4
 800e9fa:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 800e9fe:	4637      	mov	r7, r6
 800ea00:	2f00      	cmp	r7, #0
 800ea02:	f1a0 0004 	sub.w	r0, r0, #4
 800ea06:	dc4a      	bgt.n	800ea9e <__kernel_rem_pio2f+0x182>
 800ea08:	4628      	mov	r0, r5
 800ea0a:	9207      	str	r2, [sp, #28]
 800ea0c:	f7ff ff20 	bl	800e850 <scalbnf>
 800ea10:	eeb0 8a40 	vmov.f32	s16, s0
 800ea14:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 800ea18:	ee28 0a00 	vmul.f32	s0, s16, s0
 800ea1c:	f7ff fc36 	bl	800e28c <floorf>
 800ea20:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 800ea24:	eea0 8a67 	vfms.f32	s16, s0, s15
 800ea28:	2d00      	cmp	r5, #0
 800ea2a:	9a07      	ldr	r2, [sp, #28]
 800ea2c:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 800ea30:	ee17 9a90 	vmov	r9, s15
 800ea34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ea38:	ee38 8a67 	vsub.f32	s16, s16, s15
 800ea3c:	dd41      	ble.n	800eac2 <__kernel_rem_pio2f+0x1a6>
 800ea3e:	f106 3cff 	add.w	ip, r6, #4294967295
 800ea42:	ab08      	add	r3, sp, #32
 800ea44:	f1c5 0e08 	rsb	lr, r5, #8
 800ea48:	f853 702c 	ldr.w	r7, [r3, ip, lsl #2]
 800ea4c:	fa47 f00e 	asr.w	r0, r7, lr
 800ea50:	4481      	add	r9, r0
 800ea52:	fa00 f00e 	lsl.w	r0, r0, lr
 800ea56:	1a3f      	subs	r7, r7, r0
 800ea58:	f1c5 0007 	rsb	r0, r5, #7
 800ea5c:	f843 702c 	str.w	r7, [r3, ip, lsl #2]
 800ea60:	4107      	asrs	r7, r0
 800ea62:	2f00      	cmp	r7, #0
 800ea64:	dd3c      	ble.n	800eae0 <__kernel_rem_pio2f+0x1c4>
 800ea66:	f04f 0e00 	mov.w	lr, #0
 800ea6a:	f109 0901 	add.w	r9, r9, #1
 800ea6e:	4671      	mov	r1, lr
 800ea70:	4576      	cmp	r6, lr
 800ea72:	dc67      	bgt.n	800eb44 <__kernel_rem_pio2f+0x228>
 800ea74:	2d00      	cmp	r5, #0
 800ea76:	dd03      	ble.n	800ea80 <__kernel_rem_pio2f+0x164>
 800ea78:	2d01      	cmp	r5, #1
 800ea7a:	d074      	beq.n	800eb66 <__kernel_rem_pio2f+0x24a>
 800ea7c:	2d02      	cmp	r5, #2
 800ea7e:	d07b      	beq.n	800eb78 <__kernel_rem_pio2f+0x25c>
 800ea80:	2f02      	cmp	r7, #2
 800ea82:	d12d      	bne.n	800eae0 <__kernel_rem_pio2f+0x1c4>
 800ea84:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800ea88:	ee30 8a48 	vsub.f32	s16, s0, s16
 800ea8c:	b341      	cbz	r1, 800eae0 <__kernel_rem_pio2f+0x1c4>
 800ea8e:	4628      	mov	r0, r5
 800ea90:	9207      	str	r2, [sp, #28]
 800ea92:	f7ff fedd 	bl	800e850 <scalbnf>
 800ea96:	9a07      	ldr	r2, [sp, #28]
 800ea98:	ee38 8a40 	vsub.f32	s16, s16, s0
 800ea9c:	e020      	b.n	800eae0 <__kernel_rem_pio2f+0x1c4>
 800ea9e:	ee60 7a28 	vmul.f32	s15, s0, s17
 800eaa2:	3f01      	subs	r7, #1
 800eaa4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800eaa8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800eaac:	eea7 0ac9 	vfms.f32	s0, s15, s18
 800eab0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800eab4:	ecac 0a01 	vstmia	ip!, {s0}
 800eab8:	ed90 0a00 	vldr	s0, [r0]
 800eabc:	ee37 0a80 	vadd.f32	s0, s15, s0
 800eac0:	e79e      	b.n	800ea00 <__kernel_rem_pio2f+0xe4>
 800eac2:	d105      	bne.n	800ead0 <__kernel_rem_pio2f+0x1b4>
 800eac4:	1e70      	subs	r0, r6, #1
 800eac6:	ab08      	add	r3, sp, #32
 800eac8:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 800eacc:	11ff      	asrs	r7, r7, #7
 800eace:	e7c8      	b.n	800ea62 <__kernel_rem_pio2f+0x146>
 800ead0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 800ead4:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800ead8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eadc:	da30      	bge.n	800eb40 <__kernel_rem_pio2f+0x224>
 800eade:	2700      	movs	r7, #0
 800eae0:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800eae4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800eae8:	f040 809a 	bne.w	800ec20 <__kernel_rem_pio2f+0x304>
 800eaec:	1e74      	subs	r4, r6, #1
 800eaee:	46a4      	mov	ip, r4
 800eaf0:	2100      	movs	r1, #0
 800eaf2:	45d4      	cmp	ip, sl
 800eaf4:	da47      	bge.n	800eb86 <__kernel_rem_pio2f+0x26a>
 800eaf6:	2900      	cmp	r1, #0
 800eaf8:	d063      	beq.n	800ebc2 <__kernel_rem_pio2f+0x2a6>
 800eafa:	ab08      	add	r3, sp, #32
 800eafc:	3d08      	subs	r5, #8
 800eafe:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800eb02:	2b00      	cmp	r3, #0
 800eb04:	d07f      	beq.n	800ec06 <__kernel_rem_pio2f+0x2ea>
 800eb06:	4628      	mov	r0, r5
 800eb08:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800eb0c:	f7ff fea0 	bl	800e850 <scalbnf>
 800eb10:	1c63      	adds	r3, r4, #1
 800eb12:	aa44      	add	r2, sp, #272	; 0x110
 800eb14:	ed9f 7a40 	vldr	s14, [pc, #256]	; 800ec18 <__kernel_rem_pio2f+0x2fc>
 800eb18:	0099      	lsls	r1, r3, #2
 800eb1a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800eb1e:	4623      	mov	r3, r4
 800eb20:	2b00      	cmp	r3, #0
 800eb22:	f280 80ad 	bge.w	800ec80 <__kernel_rem_pio2f+0x364>
 800eb26:	4623      	mov	r3, r4
 800eb28:	2b00      	cmp	r3, #0
 800eb2a:	f2c0 80cb 	blt.w	800ecc4 <__kernel_rem_pio2f+0x3a8>
 800eb2e:	aa44      	add	r2, sp, #272	; 0x110
 800eb30:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 800eb34:	4e36      	ldr	r6, [pc, #216]	; (800ec10 <__kernel_rem_pio2f+0x2f4>)
 800eb36:	eddf 7a39 	vldr	s15, [pc, #228]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800eb3a:	2000      	movs	r0, #0
 800eb3c:	1ae2      	subs	r2, r4, r3
 800eb3e:	e0b6      	b.n	800ecae <__kernel_rem_pio2f+0x392>
 800eb40:	2702      	movs	r7, #2
 800eb42:	e790      	b.n	800ea66 <__kernel_rem_pio2f+0x14a>
 800eb44:	6820      	ldr	r0, [r4, #0]
 800eb46:	b949      	cbnz	r1, 800eb5c <__kernel_rem_pio2f+0x240>
 800eb48:	b118      	cbz	r0, 800eb52 <__kernel_rem_pio2f+0x236>
 800eb4a:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
 800eb4e:	6020      	str	r0, [r4, #0]
 800eb50:	2001      	movs	r0, #1
 800eb52:	f10e 0e01 	add.w	lr, lr, #1
 800eb56:	3404      	adds	r4, #4
 800eb58:	4601      	mov	r1, r0
 800eb5a:	e789      	b.n	800ea70 <__kernel_rem_pio2f+0x154>
 800eb5c:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
 800eb60:	6020      	str	r0, [r4, #0]
 800eb62:	4608      	mov	r0, r1
 800eb64:	e7f5      	b.n	800eb52 <__kernel_rem_pio2f+0x236>
 800eb66:	1e74      	subs	r4, r6, #1
 800eb68:	ab08      	add	r3, sp, #32
 800eb6a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800eb6e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800eb72:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 800eb76:	e783      	b.n	800ea80 <__kernel_rem_pio2f+0x164>
 800eb78:	1e74      	subs	r4, r6, #1
 800eb7a:	ab08      	add	r3, sp, #32
 800eb7c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800eb80:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 800eb84:	e7f5      	b.n	800eb72 <__kernel_rem_pio2f+0x256>
 800eb86:	ab08      	add	r3, sp, #32
 800eb88:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 800eb8c:	f10c 3cff 	add.w	ip, ip, #4294967295
 800eb90:	4301      	orrs	r1, r0
 800eb92:	e7ae      	b.n	800eaf2 <__kernel_rem_pio2f+0x1d6>
 800eb94:	3001      	adds	r0, #1
 800eb96:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 800eb9a:	2f00      	cmp	r7, #0
 800eb9c:	d0fa      	beq.n	800eb94 <__kernel_rem_pio2f+0x278>
 800eb9e:	9b06      	ldr	r3, [sp, #24]
 800eba0:	f503 73b0 	add.w	r3, r3, #352	; 0x160
 800eba4:	eb0d 0403 	add.w	r4, sp, r3
 800eba8:	9b01      	ldr	r3, [sp, #4]
 800ebaa:	18f7      	adds	r7, r6, r3
 800ebac:	ab1c      	add	r3, sp, #112	; 0x70
 800ebae:	f106 0c01 	add.w	ip, r6, #1
 800ebb2:	3c4c      	subs	r4, #76	; 0x4c
 800ebb4:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800ebb8:	4430      	add	r0, r6
 800ebba:	4560      	cmp	r0, ip
 800ebbc:	da04      	bge.n	800ebc8 <__kernel_rem_pio2f+0x2ac>
 800ebbe:	4606      	mov	r6, r0
 800ebc0:	e711      	b.n	800e9e6 <__kernel_rem_pio2f+0xca>
 800ebc2:	9c05      	ldr	r4, [sp, #20]
 800ebc4:	2001      	movs	r0, #1
 800ebc6:	e7e6      	b.n	800eb96 <__kernel_rem_pio2f+0x27a>
 800ebc8:	9b04      	ldr	r3, [sp, #16]
 800ebca:	f8dd e008 	ldr.w	lr, [sp, #8]
 800ebce:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 800ebd2:	9306      	str	r3, [sp, #24]
 800ebd4:	ee07 3a90 	vmov	s15, r3
 800ebd8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ebdc:	2600      	movs	r6, #0
 800ebde:	ece7 7a01 	vstmia	r7!, {s15}
 800ebe2:	eddf 7a0e 	vldr	s15, [pc, #56]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800ebe6:	46b9      	mov	r9, r7
 800ebe8:	455e      	cmp	r6, fp
 800ebea:	dd04      	ble.n	800ebf6 <__kernel_rem_pio2f+0x2da>
 800ebec:	ece4 7a01 	vstmia	r4!, {s15}
 800ebf0:	f10c 0c01 	add.w	ip, ip, #1
 800ebf4:	e7e1      	b.n	800ebba <__kernel_rem_pio2f+0x29e>
 800ebf6:	ecfe 6a01 	vldmia	lr!, {s13}
 800ebfa:	ed39 7a01 	vldmdb	r9!, {s14}
 800ebfe:	3601      	adds	r6, #1
 800ec00:	eee6 7a87 	vfma.f32	s15, s13, s14
 800ec04:	e7f0      	b.n	800ebe8 <__kernel_rem_pio2f+0x2cc>
 800ec06:	3c01      	subs	r4, #1
 800ec08:	e777      	b.n	800eafa <__kernel_rem_pio2f+0x1de>
 800ec0a:	bf00      	nop
 800ec0c:	0801a5e8 	.word	0x0801a5e8
 800ec10:	0801a5bc 	.word	0x0801a5bc
 800ec14:	43800000 	.word	0x43800000
 800ec18:	3b800000 	.word	0x3b800000
 800ec1c:	00000000 	.word	0x00000000
 800ec20:	9b03      	ldr	r3, [sp, #12]
 800ec22:	eeb0 0a48 	vmov.f32	s0, s16
 800ec26:	1a98      	subs	r0, r3, r2
 800ec28:	f7ff fe12 	bl	800e850 <scalbnf>
 800ec2c:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 800ec14 <__kernel_rem_pio2f+0x2f8>
 800ec30:	eeb4 0ac7 	vcmpe.f32	s0, s14
 800ec34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ec38:	db19      	blt.n	800ec6e <__kernel_rem_pio2f+0x352>
 800ec3a:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 800ec18 <__kernel_rem_pio2f+0x2fc>
 800ec3e:	ee60 7a27 	vmul.f32	s15, s0, s15
 800ec42:	aa08      	add	r2, sp, #32
 800ec44:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ec48:	1c74      	adds	r4, r6, #1
 800ec4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ec4e:	3508      	adds	r5, #8
 800ec50:	eea7 0ac7 	vfms.f32	s0, s15, s14
 800ec54:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ec58:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800ec5c:	ee10 3a10 	vmov	r3, s0
 800ec60:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 800ec64:	ee17 3a90 	vmov	r3, s15
 800ec68:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 800ec6c:	e74b      	b.n	800eb06 <__kernel_rem_pio2f+0x1ea>
 800ec6e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 800ec72:	aa08      	add	r2, sp, #32
 800ec74:	ee10 3a10 	vmov	r3, s0
 800ec78:	4634      	mov	r4, r6
 800ec7a:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
 800ec7e:	e742      	b.n	800eb06 <__kernel_rem_pio2f+0x1ea>
 800ec80:	a808      	add	r0, sp, #32
 800ec82:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 800ec86:	9001      	str	r0, [sp, #4]
 800ec88:	ee07 0a90 	vmov	s15, r0
 800ec8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ec90:	3b01      	subs	r3, #1
 800ec92:	ee67 7a80 	vmul.f32	s15, s15, s0
 800ec96:	ee20 0a07 	vmul.f32	s0, s0, s14
 800ec9a:	ed62 7a01 	vstmdb	r2!, {s15}
 800ec9e:	e73f      	b.n	800eb20 <__kernel_rem_pio2f+0x204>
 800eca0:	ecf6 6a01 	vldmia	r6!, {s13}
 800eca4:	ecb5 7a01 	vldmia	r5!, {s14}
 800eca8:	eee6 7a87 	vfma.f32	s15, s13, s14
 800ecac:	3001      	adds	r0, #1
 800ecae:	4550      	cmp	r0, sl
 800ecb0:	dc01      	bgt.n	800ecb6 <__kernel_rem_pio2f+0x39a>
 800ecb2:	4290      	cmp	r0, r2
 800ecb4:	ddf4      	ble.n	800eca0 <__kernel_rem_pio2f+0x384>
 800ecb6:	a858      	add	r0, sp, #352	; 0x160
 800ecb8:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800ecbc:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 800ecc0:	3b01      	subs	r3, #1
 800ecc2:	e731      	b.n	800eb28 <__kernel_rem_pio2f+0x20c>
 800ecc4:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ecc6:	2b02      	cmp	r3, #2
 800ecc8:	dc09      	bgt.n	800ecde <__kernel_rem_pio2f+0x3c2>
 800ecca:	2b00      	cmp	r3, #0
 800eccc:	dc2b      	bgt.n	800ed26 <__kernel_rem_pio2f+0x40a>
 800ecce:	d044      	beq.n	800ed5a <__kernel_rem_pio2f+0x43e>
 800ecd0:	f009 0007 	and.w	r0, r9, #7
 800ecd4:	b059      	add	sp, #356	; 0x164
 800ecd6:	ecbd 8b04 	vpop	{d8-d9}
 800ecda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ecde:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ece0:	2b03      	cmp	r3, #3
 800ece2:	d1f5      	bne.n	800ecd0 <__kernel_rem_pio2f+0x3b4>
 800ece4:	aa30      	add	r2, sp, #192	; 0xc0
 800ece6:	1f0b      	subs	r3, r1, #4
 800ece8:	4413      	add	r3, r2
 800ecea:	461a      	mov	r2, r3
 800ecec:	4620      	mov	r0, r4
 800ecee:	2800      	cmp	r0, #0
 800ecf0:	f1a2 0204 	sub.w	r2, r2, #4
 800ecf4:	dc52      	bgt.n	800ed9c <__kernel_rem_pio2f+0x480>
 800ecf6:	4622      	mov	r2, r4
 800ecf8:	2a01      	cmp	r2, #1
 800ecfa:	f1a3 0304 	sub.w	r3, r3, #4
 800ecfe:	dc5d      	bgt.n	800edbc <__kernel_rem_pio2f+0x4a0>
 800ed00:	ab30      	add	r3, sp, #192	; 0xc0
 800ed02:	ed5f 7a3a 	vldr	s15, [pc, #-232]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800ed06:	440b      	add	r3, r1
 800ed08:	2c01      	cmp	r4, #1
 800ed0a:	dc67      	bgt.n	800eddc <__kernel_rem_pio2f+0x4c0>
 800ed0c:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
 800ed10:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
 800ed14:	2f00      	cmp	r7, #0
 800ed16:	d167      	bne.n	800ede8 <__kernel_rem_pio2f+0x4cc>
 800ed18:	edc8 6a00 	vstr	s13, [r8]
 800ed1c:	ed88 7a01 	vstr	s14, [r8, #4]
 800ed20:	edc8 7a02 	vstr	s15, [r8, #8]
 800ed24:	e7d4      	b.n	800ecd0 <__kernel_rem_pio2f+0x3b4>
 800ed26:	ab30      	add	r3, sp, #192	; 0xc0
 800ed28:	ed1f 7a44 	vldr	s14, [pc, #-272]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800ed2c:	440b      	add	r3, r1
 800ed2e:	4622      	mov	r2, r4
 800ed30:	2a00      	cmp	r2, #0
 800ed32:	da24      	bge.n	800ed7e <__kernel_rem_pio2f+0x462>
 800ed34:	b34f      	cbz	r7, 800ed8a <__kernel_rem_pio2f+0x46e>
 800ed36:	eef1 7a47 	vneg.f32	s15, s14
 800ed3a:	edc8 7a00 	vstr	s15, [r8]
 800ed3e:	eddd 7a30 	vldr	s15, [sp, #192]	; 0xc0
 800ed42:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ed46:	aa31      	add	r2, sp, #196	; 0xc4
 800ed48:	2301      	movs	r3, #1
 800ed4a:	429c      	cmp	r4, r3
 800ed4c:	da20      	bge.n	800ed90 <__kernel_rem_pio2f+0x474>
 800ed4e:	b10f      	cbz	r7, 800ed54 <__kernel_rem_pio2f+0x438>
 800ed50:	eef1 7a67 	vneg.f32	s15, s15
 800ed54:	edc8 7a01 	vstr	s15, [r8, #4]
 800ed58:	e7ba      	b.n	800ecd0 <__kernel_rem_pio2f+0x3b4>
 800ed5a:	ab30      	add	r3, sp, #192	; 0xc0
 800ed5c:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 800ec1c <__kernel_rem_pio2f+0x300>
 800ed60:	440b      	add	r3, r1
 800ed62:	2c00      	cmp	r4, #0
 800ed64:	da05      	bge.n	800ed72 <__kernel_rem_pio2f+0x456>
 800ed66:	b10f      	cbz	r7, 800ed6c <__kernel_rem_pio2f+0x450>
 800ed68:	eef1 7a67 	vneg.f32	s15, s15
 800ed6c:	edc8 7a00 	vstr	s15, [r8]
 800ed70:	e7ae      	b.n	800ecd0 <__kernel_rem_pio2f+0x3b4>
 800ed72:	ed33 7a01 	vldmdb	r3!, {s14}
 800ed76:	3c01      	subs	r4, #1
 800ed78:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ed7c:	e7f1      	b.n	800ed62 <__kernel_rem_pio2f+0x446>
 800ed7e:	ed73 7a01 	vldmdb	r3!, {s15}
 800ed82:	3a01      	subs	r2, #1
 800ed84:	ee37 7a27 	vadd.f32	s14, s14, s15
 800ed88:	e7d2      	b.n	800ed30 <__kernel_rem_pio2f+0x414>
 800ed8a:	eef0 7a47 	vmov.f32	s15, s14
 800ed8e:	e7d4      	b.n	800ed3a <__kernel_rem_pio2f+0x41e>
 800ed90:	ecb2 7a01 	vldmia	r2!, {s14}
 800ed94:	3301      	adds	r3, #1
 800ed96:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ed9a:	e7d6      	b.n	800ed4a <__kernel_rem_pio2f+0x42e>
 800ed9c:	edd2 7a00 	vldr	s15, [r2]
 800eda0:	edd2 6a01 	vldr	s13, [r2, #4]
 800eda4:	ee37 7aa6 	vadd.f32	s14, s15, s13
 800eda8:	3801      	subs	r0, #1
 800edaa:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800edae:	ed82 7a00 	vstr	s14, [r2]
 800edb2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800edb6:	edc2 7a01 	vstr	s15, [r2, #4]
 800edba:	e798      	b.n	800ecee <__kernel_rem_pio2f+0x3d2>
 800edbc:	edd3 7a00 	vldr	s15, [r3]
 800edc0:	edd3 6a01 	vldr	s13, [r3, #4]
 800edc4:	ee37 7aa6 	vadd.f32	s14, s15, s13
 800edc8:	3a01      	subs	r2, #1
 800edca:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800edce:	ed83 7a00 	vstr	s14, [r3]
 800edd2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800edd6:	edc3 7a01 	vstr	s15, [r3, #4]
 800edda:	e78d      	b.n	800ecf8 <__kernel_rem_pio2f+0x3dc>
 800eddc:	ed33 7a01 	vldmdb	r3!, {s14}
 800ede0:	3c01      	subs	r4, #1
 800ede2:	ee77 7a87 	vadd.f32	s15, s15, s14
 800ede6:	e78f      	b.n	800ed08 <__kernel_rem_pio2f+0x3ec>
 800ede8:	eef1 6a66 	vneg.f32	s13, s13
 800edec:	eeb1 7a47 	vneg.f32	s14, s14
 800edf0:	edc8 6a00 	vstr	s13, [r8]
 800edf4:	ed88 7a01 	vstr	s14, [r8, #4]
 800edf8:	eef1 7a67 	vneg.f32	s15, s15
 800edfc:	e790      	b.n	800ed20 <__kernel_rem_pio2f+0x404>
 800edfe:	bf00      	nop

0800ee00 <_close>:
 800ee00:	4b02      	ldr	r3, [pc, #8]	; (800ee0c <_close+0xc>)
 800ee02:	2258      	movs	r2, #88	; 0x58
 800ee04:	601a      	str	r2, [r3, #0]
 800ee06:	f04f 30ff 	mov.w	r0, #4294967295
 800ee0a:	4770      	bx	lr
 800ee0c:	200031f0 	.word	0x200031f0

0800ee10 <_fstat>:
 800ee10:	4b02      	ldr	r3, [pc, #8]	; (800ee1c <_fstat+0xc>)
 800ee12:	2258      	movs	r2, #88	; 0x58
 800ee14:	601a      	str	r2, [r3, #0]
 800ee16:	f04f 30ff 	mov.w	r0, #4294967295
 800ee1a:	4770      	bx	lr
 800ee1c:	200031f0 	.word	0x200031f0

0800ee20 <_isatty>:
 800ee20:	4b02      	ldr	r3, [pc, #8]	; (800ee2c <_isatty+0xc>)
 800ee22:	2258      	movs	r2, #88	; 0x58
 800ee24:	601a      	str	r2, [r3, #0]
 800ee26:	2000      	movs	r0, #0
 800ee28:	4770      	bx	lr
 800ee2a:	bf00      	nop
 800ee2c:	200031f0 	.word	0x200031f0

0800ee30 <_lseek>:
 800ee30:	4b02      	ldr	r3, [pc, #8]	; (800ee3c <_lseek+0xc>)
 800ee32:	2258      	movs	r2, #88	; 0x58
 800ee34:	601a      	str	r2, [r3, #0]
 800ee36:	f04f 30ff 	mov.w	r0, #4294967295
 800ee3a:	4770      	bx	lr
 800ee3c:	200031f0 	.word	0x200031f0

0800ee40 <_read>:
 800ee40:	4b02      	ldr	r3, [pc, #8]	; (800ee4c <_read+0xc>)
 800ee42:	2258      	movs	r2, #88	; 0x58
 800ee44:	601a      	str	r2, [r3, #0]
 800ee46:	f04f 30ff 	mov.w	r0, #4294967295
 800ee4a:	4770      	bx	lr
 800ee4c:	200031f0 	.word	0x200031f0

0800ee50 <_write>:
 800ee50:	4b02      	ldr	r3, [pc, #8]	; (800ee5c <_write+0xc>)
 800ee52:	2258      	movs	r2, #88	; 0x58
 800ee54:	601a      	str	r2, [r3, #0]
 800ee56:	f04f 30ff 	mov.w	r0, #4294967295
 800ee5a:	4770      	bx	lr
 800ee5c:	200031f0 	.word	0x200031f0

0800ee60 <_init>:
 800ee60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ee62:	bf00      	nop
 800ee64:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800ee66:	bc08      	pop	{r3}
 800ee68:	469e      	mov	lr, r3
 800ee6a:	4770      	bx	lr

0800ee6c <_fini>:
 800ee6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ee6e:	bf00      	nop
 800ee70:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800ee72:	bc08      	pop	{r3}
 800ee74:	469e      	mov	lr, r3
 800ee76:	4770      	bx	lr
